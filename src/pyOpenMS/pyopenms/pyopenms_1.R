 

# R implementation of _AAIndex
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AAIndex.html
AAIndex <- R6Class(classname = "AAIndex",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: double aliphatic(char aa)
    aliphatic = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$aliphatic(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double acidic(char aa)
    acidic = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$acidic(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double basic(char aa)
    basic = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$basic(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double polar(char aa)
    polar = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$polar(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getKHAG800101(char aa)
    getKHAG800101 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getKHAG800101(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getVASM830103(char aa)
    getVASM830103 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getVASM830103(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getNADH010106(char aa)
    getNADH010106 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getNADH010106(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getNADH010107(char aa)
    getNADH010107 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getNADH010107(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getWILM950102(char aa)
    getWILM950102 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getWILM950102(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getROBB760107(char aa)
    getROBB760107 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getROBB760107(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getOOBM850104(char aa)
    getOOBM850104 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getOOBM850104(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getFAUJ880111(char aa)
    getFAUJ880111 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getFAUJ880111(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getFINA770101(char aa)
    getFINA770101 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getFINA770101(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getARGP820102(char aa)
    getARGP820102 = function(aa){
    
        if(!(is_scalar_character(aa))){ stop("arg aa wrong type") }
    py_run_string("aa = bytes(aa)")
        py_ans = private$py_obj$getARGP820102(py$aa)
        py_run_string("del aa")
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calculateGB(AASequence & seq, double T)
    calculateGB = function(seq, T){
    
        if(!(is.R6(seq) && class(seq)[1] == "AASequence")){ stop("arg seq wrong type") }
        if(!(is_scalar_double(T))){ stop("arg T wrong type") }
    
    
        py_ans = private$py_obj$calculateGB(seq, T)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AASeqWithMass
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AASeqWithMass.html
AASeqWithMass <- R6Class(classname = "AASeqWithMass",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        peptide_mass = function(peptide_mass){
    
        if(!missing(peptide_mass)){
            if(!(is_scalar_double(peptide_mass))){ stop("arg peptide_mass wrong type") }
        
        
            private$py_obj$peptide_mass <- peptide_mass
            } else {
        
                py_ans = private$py_obj$peptide_mass
                r_result = py_ans
                return(r_result)
                }
        },
        peptide_seq = function(peptide_seq){
    
        if(!missing(peptide_seq)){
            if(!(is.R6(peptide_seq) && class(peptide_seq)[1] == "AASequence")){ stop("arg peptide_seq wrong type") }
        
        
            private$py_obj$peptide_seq <- peptide_seq
            } else {
        
                py_ans = private$py_obj$peptide_seq
            r_result = AASequence$new(py_ans)
                return(r_result)
                }
        },
        position = function(position){
    
        if(!missing(position)){
            if(!(position %in% c(0, 1, 2))){ stop("arg position wrong type") }
        
        
            private$py_obj$position <- as.integer(position)
            } else {
        
                py_ans = private$py_obj$position
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void AASeqWithMass(AASeqWithMass)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AASeqWithMass")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AASeqWithMass(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AASeqWithMass()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$AASeqWithMass()
        invisible()
    
    
    },
    
    # C++ signature: void AASeqWithMass(AASeqWithMass)
    # C++ signature: void AASeqWithMass()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASeqWithMass")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AASeqWithMass" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _AASequence
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AASequence.html

# Representation of a peptide/protein sequence
# This class represents amino acid sequences in OpenMS. An AASequence
# instance primarily contains a sequence of residues.
AASequence <- R6Class(classname = "AASequence",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AASequence()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AASequence) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AASequence()
        invisible()
    }
    
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toUnmodifiedString()
    toUnmodifiedString = function(){
    
        py_ans = private$py_obj$toUnmodifiedString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toUniModString()
    toUniModString = function(){
    
        py_ans = private$py_obj$toUniModString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toBracketString()
# create a TPP compatible string of the modified sequence using bracket notation. Uses integer mass by default.
    toBracketString_0 = function(){
    
        py_ans = private$py_obj$`_toBracketString_0`()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toBracketString(bool integer_mass)
# create a TPP compatible string of the modified sequence using bracket notation.
    toBracketString_1 = function(integer_mass){
    
        if(!( (is_scalar_integer(integer_mass) || is_scalar_double(integer_mass)) && integer_mass == as.integer(integer_mass))){ stop("arg integer_mass wrong type") }
    
        py_ans = private$py_obj$`_toBracketString_1`(as.integer(integer_mass))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toBracketString(bool integer_mass, bool mass_delta)
# create a TPP compatible string of the modified sequence using bracket notation.
    toBracketString_2 = function(integer_mass, mass_delta){
    
        if(!( (is_scalar_integer(integer_mass) || is_scalar_double(integer_mass)) && integer_mass == as.integer(integer_mass))){ stop("arg integer_mass wrong type") }
        if(!( (is_scalar_integer(mass_delta) || is_scalar_double(mass_delta)) && mass_delta == as.integer(mass_delta))){ stop("arg mass_delta wrong type") }
    
    
        py_ans = private$py_obj$`_toBracketString_2`(as.integer(integer_mass), as.integer(mass_delta))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toBracketString(bool integer_mass, bool mass_delta, libcpp_vector[String] fixed_modifications)
# create a TPP compatible string of the modified sequence using bracket notation.
    toBracketString_3 = function(integer_mass, mass_delta, fixed_modifications){
    
        if(!( (is_scalar_integer(integer_mass) || is_scalar_double(integer_mass)) && integer_mass == as.integer(integer_mass))){ stop("arg integer_mass wrong type") }
        if(!( (is_scalar_integer(mass_delta) || is_scalar_double(mass_delta)) && mass_delta == as.integer(mass_delta))){ stop("arg mass_delta wrong type") }
        if(!(is_list(fixed_modifications) && all(sapply(fixed_modifications),is_scalar_character))){ stop("arg fixed_modifications wrong type") }
    
    
        v2 = r_to_py(modify_depth(fixed_modifications,1,py_builtin$bytes(fixed_modifications,'utf-8')))
        py_ans = private$py_obj$`_toBracketString_3`(as.integer(integer_mass), as.integer(mass_delta), v2)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toBracketString()
        # create a TPP compatible string of the modified sequence using bracket notation. Uses integer mass by default.

    # C++ signature: String toBracketString(bool integer_mass)
        # create a TPP compatible string of the modified sequence using bracket notation.

    # C++ signature: String toBracketString(bool integer_mass, bool mass_delta)
        # create a TPP compatible string of the modified sequence using bracket notation.

    # C++ signature: String toBracketString(bool integer_mass, bool mass_delta, libcpp_vector[String] fixed_modifications)
        # create a TPP compatible string of the modified sequence using bracket notation.
    toBracketString = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$toBracketString_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$toBracketString_1(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$toBracketString_2(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]]),is_scalar_character))) { self$toBracketString_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setModification(size_t index, String modification)
    setModification = function(index, modification){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
    
        private$py_obj$setModification(as.integer(index), modification)
        invisible()
    },
    
    # C++ signature: void setNTerminalModification(String modification)
    setNTerminalModification = function(modification){
    
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
        private$py_obj$setNTerminalModification(modification)
        invisible()
    },
    
    # C++ signature: String getNTerminalModificationName()
    getNTerminalModificationName = function(){
    
        py_ans = private$py_obj$getNTerminalModificationName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCTerminalModification(String modification)
    setCTerminalModification = function(modification){
    
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
        private$py_obj$setCTerminalModification(modification)
        invisible()
    },
    
    # C++ signature: const ResidueModification * getNTerminalModification()
    getNTerminalModification = function(){
    
        py_ans = private$py_obj$getNTerminalModification() ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getCTerminalModificationName()
    getCTerminalModificationName = function(){
    
        py_ans = private$py_obj$getCTerminalModificationName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getCTerminalModification()
    getCTerminalModification = function(){
    
        py_ans = private$py_obj$getCTerminalModification() ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Residue getResidue(size_t index)
    getResidue = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getResidue(as.integer(index))
        r_ans = Residue$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula()
# convenience function with ResidueType=Full and charge = 0 by default
    getFormula_0 = function(){
    
        py_ans = private$py_obj$`_getFormula_0`()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula(ResidueType type_, int charge)
    getFormula_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getFormula_1`(as.integer(type_), as.integer(charge))
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula()
        # convenience function with ResidueType=Full and charge = 0 by default

    # C++ signature: EmpiricalFormula getFormula(ResidueType type_, int charge)
    getFormula = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getFormula_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getFormula_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getAverageWeight()
    getAverageWeight_0 = function(){
    
        py_ans = private$py_obj$`_getAverageWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight(ResidueType type_, int charge)
    getAverageWeight_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getAverageWeight_1`(as.integer(type_), as.integer(charge))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight()
    # C++ signature: double getAverageWeight(ResidueType type_, int charge)
    getAverageWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getAverageWeight_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getAverageWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getMonoWeight()
    getMonoWeight_0 = function(){
    
        py_ans = private$py_obj$`_getMonoWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight(ResidueType type_, int charge)
    getMonoWeight_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getMonoWeight_1`(as.integer(type_), as.integer(charge))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight()
    # C++ signature: double getMonoWeight(ResidueType type_, int charge)
    getMonoWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getMonoWeight_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getMonoWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: AASequence getPrefix(size_t index)
    getPrefix = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getPrefix(as.integer(index))
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: AASequence getSuffix(size_t index)
    getSuffix = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getSuffix(as.integer(index))
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: AASequence getSubsequence(size_t index, unsigned int number)
    getSubsequence = function(index, number){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!( (is_scalar_integer(number) || is_scalar_double(number)) && number == as.integer(number))){ stop("arg number wrong type") }
    
    
        py_ans = private$py_obj$getSubsequence(as.integer(index), as.integer(number))
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool has(Residue residue)
    has = function(residue){
    
        if(!(is.R6(residue) && class(residue)[1] == "Residue")){ stop("arg residue wrong type") }
    
        py_ans = private$py_obj$has(residue)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasSubsequence(AASequence peptide)
    hasSubsequence = function(peptide){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
    
        py_ans = private$py_obj$hasSubsequence(peptide)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasPrefix(AASequence peptide)
    hasPrefix = function(peptide){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
    
        py_ans = private$py_obj$hasPrefix(peptide)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasSuffix(AASequence peptide)
    hasSuffix = function(peptide){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
    
        py_ans = private$py_obj$hasSuffix(peptide)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasNTerminalModification()
    hasNTerminalModification = function(){
    
        py_ans = private$py_obj$hasNTerminalModification()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasCTerminalModification()
    hasCTerminalModification = function(){
    
        py_ans = private$py_obj$hasCTerminalModification()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isModified()
    isModified = function(){
    
        py_ans = private$py_obj$isModified()
        r_ans = py_ans
        return(r_ans)
    }
)
)
    #' @export
    `+.AASequence` <- function(e1, e2){
       added <- e1$.__enclos_env__$private$py_obj + e2$.__enclos_env__$private$py_obj
       result <- AASequence$new(added)
       return(result)
    }
    
    # C++ signature: AASequence fromString(String s)
    AASequence$fromString = function(s){
    
        if(!((is.R6(s) && class(s)[1]=="String") || is_scalar_character(s))){ stop("arg s wrong type") }
    
        py_ans = Pymod$AASequence$fromString(s)
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    }
    
    # C++ signature: AASequence fromStringPermissive(String s, bool permissive)
    AASequence$fromStringPermissive = function(s, permissive){
    
        if(!((is.R6(s) && class(s)[1]=="String") || is_scalar_character(s))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(permissive) || is_scalar_double(permissive)) && permissive == as.integer(permissive))){ stop("arg permissive wrong type") }
    
    
        py_ans = Pymod$AASequence$fromStringPermissive(s, as.integer(permissive))
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    } 

# R implementation of _AMSE_AdductInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AMSE_AdductInfo.html
AMSE_AdductInfo <- R6Class(classname = "AMSE_AdductInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AMSE_AdductInfo(const String & name, EmpiricalFormula & adduct, int charge, unsigned int mol_multiplier)
    initialize = function(name, adduct, charge, mol_multiplier){
    
    if(missing(adduct) && missing(charge) && missing(mol_multiplier)){
         if( "python.builtin.object" %in% class(name) && class_to_wrap(name) == AMSE_AdductInfo ) { private$py_obj <- name }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(adduct) && class(adduct)[1] == "EmpiricalFormula")){ stop("arg adduct wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!( (is_scalar_integer(mol_multiplier) || is_scalar_double(mol_multiplier)) && mol_multiplier == as.integer(mol_multiplier))){ stop("arg mol_multiplier wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$AMSE_AdductInfo(name, adduct, as.integer(charge), as.integer(mol_multiplier))
        invisible()
    }
    
    },
    
    # C++ signature: double getNeutralMass(double observed_mz)
    getNeutralMass = function(observed_mz){
    
        if(!(is_scalar_double(observed_mz))){ stop("arg observed_mz wrong type") }
    
        py_ans = private$py_obj$getNeutralMass(observed_mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ(double neutral_mass)
    getMZ = function(neutral_mass){
    
        if(!(is_scalar_double(neutral_mass))){ stop("arg neutral_mass wrong type") }
    
        py_ans = private$py_obj$getMZ(neutral_mass)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isCompatible(EmpiricalFormula db_entry)
    isCompatible = function(db_entry){
    
        if(!(is.R6(db_entry) && class(db_entry)[1] == "EmpiricalFormula")){ stop("arg db_entry wrong type") }
    
        py_ans = private$py_obj$isCompatible(db_entry)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AQS_featureConcentration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AQS_featureConcentration.html
AQS_featureConcentration <- R6Class(classname = "AQS_featureConcentration",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        feature = function(feature){
    
        if(!missing(feature)){
            if(!(is.R6(feature) && class(feature)[1] == "Feature")){ stop("arg feature wrong type") }
        
        
            private$py_obj$feature <- feature
            } else {
        
                py_ans = private$py_obj$feature
            r_result = Feature$new(py_ans)
                return(r_result)
                }
        },
        IS_feature = function(IS_feature){
    
        if(!missing(IS_feature)){
            if(!(is.R6(IS_feature) && class(IS_feature)[1] == "Feature")){ stop("arg IS_feature wrong type") }
        
        
            private$py_obj$IS_feature <- IS_feature
            } else {
        
                py_ans = private$py_obj$IS_feature
            r_result = Feature$new(py_ans)
                return(r_result)
                }
        },
        actual_concentration = function(actual_concentration){
    
        if(!missing(actual_concentration)){
            if(!(is_scalar_double(actual_concentration))){ stop("arg actual_concentration wrong type") }
        
        
            private$py_obj$actual_concentration <- actual_concentration
            } else {
        
                py_ans = private$py_obj$actual_concentration
                r_result = py_ans
                return(r_result)
                }
        },
        IS_actual_concentration = function(IS_actual_concentration){
    
        if(!missing(IS_actual_concentration)){
            if(!(is_scalar_double(IS_actual_concentration))){ stop("arg IS_actual_concentration wrong type") }
        
        
            private$py_obj$IS_actual_concentration <- IS_actual_concentration
            } else {
        
                py_ans = private$py_obj$IS_actual_concentration
                r_result = py_ans
                return(r_result)
                }
        },
        concentration_units = function(concentration_units){
    
        if(!missing(concentration_units)){
            if(!((is.R6(concentration_units) && class(concentration_units)[1]=="String") || is_scalar_character(concentration_units))){ stop("arg concentration_units wrong type") }
        
        
            private$py_obj$concentration_units <- concentration_units
            } else {
        
                py_ans = private$py_obj$concentration_units
            r_result = py_ans
                return(r_result)
                }
        },
        dilution_factor = function(dilution_factor){
    
        if(!missing(dilution_factor)){
            if(!(is_scalar_double(dilution_factor))){ stop("arg dilution_factor wrong type") }
        
        
            private$py_obj$dilution_factor <- dilution_factor
            } else {
        
                py_ans = private$py_obj$dilution_factor
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void AQS_featureConcentration()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AQS_featureConcentration()
        invisible()
    
    
    },
    
    # C++ signature: void AQS_featureConcentration(AQS_featureConcentration)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AQS_featureConcentration")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AQS_featureConcentration(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AQS_featureConcentration()
    # C++ signature: void AQS_featureConcentration(AQS_featureConcentration)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AQS_featureConcentration")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AQS_featureConcentration" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _AQS_runConcentration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AQS_runConcentration.html
AQS_runConcentration <- R6Class(classname = "AQS_runConcentration",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        sample_name = function(sample_name){
    
        if(!missing(sample_name)){
            if(!((is.R6(sample_name) && class(sample_name)[1]=="String") || is_scalar_character(sample_name))){ stop("arg sample_name wrong type") }
        
        
            private$py_obj$sample_name <- sample_name
            } else {
        
                py_ans = private$py_obj$sample_name
            r_result = py_ans
                return(r_result)
                }
        },
        component_name = function(component_name){
    
        if(!missing(component_name)){
            if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
        
        
            private$py_obj$component_name <- component_name
            } else {
        
                py_ans = private$py_obj$component_name
            r_result = py_ans
                return(r_result)
                }
        },
        IS_component_name = function(IS_component_name){
    
        if(!missing(IS_component_name)){
            if(!((is.R6(IS_component_name) && class(IS_component_name)[1]=="String") || is_scalar_character(IS_component_name))){ stop("arg IS_component_name wrong type") }
        
        
            private$py_obj$IS_component_name <- IS_component_name
            } else {
        
                py_ans = private$py_obj$IS_component_name
            r_result = py_ans
                return(r_result)
                }
        },
        actual_concentration = function(actual_concentration){
    
        if(!missing(actual_concentration)){
            if(!(is_scalar_double(actual_concentration))){ stop("arg actual_concentration wrong type") }
        
        
            private$py_obj$actual_concentration <- actual_concentration
            } else {
        
                py_ans = private$py_obj$actual_concentration
                r_result = py_ans
                return(r_result)
                }
        },
        IS_actual_concentration = function(IS_actual_concentration){
    
        if(!missing(IS_actual_concentration)){
            if(!(is_scalar_double(IS_actual_concentration))){ stop("arg IS_actual_concentration wrong type") }
        
        
            private$py_obj$IS_actual_concentration <- IS_actual_concentration
            } else {
        
                py_ans = private$py_obj$IS_actual_concentration
                r_result = py_ans
                return(r_result)
                }
        },
        concentration_units = function(concentration_units){
    
        if(!missing(concentration_units)){
            if(!((is.R6(concentration_units) && class(concentration_units)[1]=="String") || is_scalar_character(concentration_units))){ stop("arg concentration_units wrong type") }
        
        
            private$py_obj$concentration_units <- concentration_units
            } else {
        
                py_ans = private$py_obj$concentration_units
            r_result = py_ans
                return(r_result)
                }
        },
        dilution_factor = function(dilution_factor){
    
        if(!missing(dilution_factor)){
            if(!(is_scalar_double(dilution_factor))){ stop("arg dilution_factor wrong type") }
        
        
            private$py_obj$dilution_factor <- dilution_factor
            } else {
        
                py_ans = private$py_obj$dilution_factor
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void AQS_runConcentration()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AQS_runConcentration()
        invisible()
    
    
    },
    
    # C++ signature: void AQS_runConcentration(AQS_runConcentration)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AQS_runConcentration")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AQS_runConcentration(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AQS_runConcentration()
    # C++ signature: void AQS_runConcentration(AQS_runConcentration)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AQS_runConcentration")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AQS_runConcentration" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _AScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AScore.html
AScore <- R6Class(classname = "AScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AScore()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AScore) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AScore()
        invisible()
    }
    
    },
    
    # C++ signature: PeptideHit compute(PeptideHit & hit, MSSpectrum & real_spectrum)
    compute = function(hit, real_spectrum){
    
        if(!(is.R6(hit) && class(hit)[1] == "PeptideHit")){ stop("arg hit wrong type") }
        if(!(is.R6(real_spectrum) && class(real_spectrum)[1] == "MSSpectrum")){ stop("arg real_spectrum wrong type") }
    
    
        py_ans = private$py_obj$compute(hit, real_spectrum)
        r_ans = PeptideHit$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _AbsoluteQuantitation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AbsoluteQuantitation.html
AbsoluteQuantitation <- R6Class(classname = "AbsoluteQuantitation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AbsoluteQuantitation()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AbsoluteQuantitation) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AbsoluteQuantitation()
        invisible()
    }
    
    },
    
    # C++ signature: void setQuantMethods(libcpp_vector[AbsoluteQuantitationMethod] & quant_methods)
    setQuantMethods = function(quant_methods){
    
        if(!(is_list(quant_methods) && all(sapply(quant_methods,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AbsoluteQuantitationMethod")))){ stop("arg quant_methods wrong type") }
        v0 <- r_to_py(quant_methods)
        private$py_obj$setQuantMethods(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(quant_methods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[AbsoluteQuantitationMethod] getQuantMethods()
    getQuantMethods = function(){
    
        py_ans = private$py_obj$getQuantMethods()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: double calculateRatio(Feature & component_1, Feature & component_2, const String & feature_name)
    calculateRatio = function(component_1, component_2, feature_name){
    
        if(!(is.R6(component_1) && class(component_1)[1] == "Feature")){ stop("arg component_1 wrong type") }
        if(!(is.R6(component_2) && class(component_2)[1] == "Feature")){ stop("arg component_2 wrong type") }
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
    
    
    
        py_ans = private$py_obj$calculateRatio(component_1, component_2, feature_name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double applyCalibration(const Feature & component, const Feature & IS_component, const String & feature_name, const String & transformation_model, const Param & transformation_model_params)
    applyCalibration = function(component, IS_component, feature_name, transformation_model, transformation_model_params){
    
        if(!(is.R6(component) && class(component)[1] == "Feature")){ stop("arg component wrong type") }
        if(!(is.R6(IS_component) && class(IS_component)[1] == "Feature")){ stop("arg IS_component wrong type") }
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
        if(!((is.R6(transformation_model) && class(transformation_model)[1]=="String") || is_scalar_character(transformation_model))){ stop("arg transformation_model wrong type") }
        if(!(is.R6(transformation_model_params) && class(transformation_model_params)[1] == "Param")){ stop("arg transformation_model_params wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$applyCalibration(component, IS_component, feature_name, transformation_model, transformation_model_params)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void quantifyComponents(FeatureMap & unknowns)
    quantifyComponents = function(unknowns){
    
        if(!(is.R6(unknowns) && class(unknowns)[1] == "FeatureMap")){ stop("arg unknowns wrong type") }
    
        private$py_obj$quantifyComponents(unknowns)
        invisible()
    },
    
    # C++ signature: bool optimizeCalibrationCurveIterative(libcpp_vector[AQS_featureConcentration] & component_concentrations, const String & feature_name, const String & transformation_model, const Param & transformation_model_params, Param & optimized_params)
    optimizeCalibrationCurveIterative = function(component_concentrations, feature_name, transformation_model, transformation_model_params, optimized_params){
    
        if(!(is_list(component_concentrations) && all(sapply(component_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_featureConcentration")))){ stop("arg component_concentrations wrong type") }
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
        if(!((is.R6(transformation_model) && class(transformation_model)[1]=="String") || is_scalar_character(transformation_model))){ stop("arg transformation_model wrong type") }
        if(!(is.R6(transformation_model_params) && class(transformation_model_params)[1] == "Param")){ stop("arg transformation_model_params wrong type") }
        if(!(is.R6(optimized_params) && class(optimized_params)[1] == "Param")){ stop("arg optimized_params wrong type") }
        v0 <- r_to_py(component_concentrations)
    
    
    
    
        py_ans = private$py_obj$optimizeCalibrationCurveIterative(v0, feature_name, transformation_model, transformation_model_params, optimized_params)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(component_concentrations <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void optimizeSingleCalibrationCurve(const String & component_name, libcpp_vector[AQS_featureConcentration] & component_concentrations)
    optimizeSingleCalibrationCurve = function(component_name, component_concentrations){
    
        if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
        if(!(is_list(component_concentrations) && all(sapply(component_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_featureConcentration")))){ stop("arg component_concentrations wrong type") }
    
        v1 <- r_to_py(component_concentrations)
        private$py_obj$optimizeSingleCalibrationCurve(component_name, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(component_concentrations <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double calculateBias(double actual_concentration, double calculated_concentration)
    calculateBias = function(actual_concentration, calculated_concentration){
    
        if(!(is_scalar_double(actual_concentration))){ stop("arg actual_concentration wrong type") }
        if(!(is_scalar_double(calculated_concentration))){ stop("arg calculated_concentration wrong type") }
    
    
        py_ans = private$py_obj$calculateBias(actual_concentration, calculated_concentration)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param fitCalibration(libcpp_vector[AQS_featureConcentration] & component_concentrations, const String & feature_name, const String & transformation_model, Param transformation_model_params)
    fitCalibration = function(component_concentrations, feature_name, transformation_model, transformation_model_params){
    
        if(!(is_list(component_concentrations) && all(sapply(component_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_featureConcentration")))){ stop("arg component_concentrations wrong type") }
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
        if(!((is.R6(transformation_model) && class(transformation_model)[1]=="String") || is_scalar_character(transformation_model))){ stop("arg transformation_model wrong type") }
        if(!(is.R6(transformation_model_params) && class(transformation_model_params)[1] == "Param")){ stop("arg transformation_model_params wrong type") }
        v0 <- r_to_py(component_concentrations)
    
    
    
        py_ans = private$py_obj$fitCalibration(v0, feature_name, transformation_model, transformation_model_params)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = Param$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(component_concentrations <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void calculateBiasAndR(libcpp_vector[AQS_featureConcentration] & component_concentrations, const String & feature_name, const String & transformation_model, Param & transformation_model_params, libcpp_vector[double] & biases, double & correlation_coefficient)
    calculateBiasAndR = function(component_concentrations, feature_name, transformation_model, transformation_model_params, biases, correlation_coefficient){
    
        if(!(is_list(component_concentrations) && all(sapply(component_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_featureConcentration")))){ stop("arg component_concentrations wrong type") }
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
        if(!((is.R6(transformation_model) && class(transformation_model)[1]=="String") || is_scalar_character(transformation_model))){ stop("arg transformation_model wrong type") }
        if(!(is.R6(transformation_model_params) && class(transformation_model_params)[1] == "Param")){ stop("arg transformation_model_params wrong type") }
        if(!(is_list(biases) && all(sapply(biases,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg biases wrong type") }
        if(!(is_scalar_double(correlation_coefficient))){ stop("arg correlation_coefficient wrong type") }
        v0 <- r_to_py(component_concentrations)
    
    
    
        v4 <- r_to_py(biases)
    
        private$py_obj$calculateBiasAndR(v0, feature_name, transformation_model, transformation_model_params, v4, correlation_coefficient)
        byref_4 <- map_depth(py_to_r(v4),0,as.list)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(component_concentrations <- byref_0))
        eval.parent(substitute(biases <- byref_4))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _AbsoluteQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AbsoluteQuantitationMethod.html
AbsoluteQuantitationMethod <- R6Class(classname = "AbsoluteQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AbsoluteQuantitationMethod()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AbsoluteQuantitationMethod) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AbsoluteQuantitationMethod()
        invisible()
    }
    
    },
    
    # C++ signature: void setLLOD(double llod)
    setLLOD = function(llod){
    
        if(!(is_scalar_double(llod))){ stop("arg llod wrong type") }
    
        private$py_obj$setLLOD(llod)
        invisible()
    },
    
    # C++ signature: void setULOD(double ulod)
    setULOD = function(ulod){
    
        if(!(is_scalar_double(ulod))){ stop("arg ulod wrong type") }
    
        private$py_obj$setULOD(ulod)
        invisible()
    },
    
    # C++ signature: double getLLOD()
    getLLOD = function(){
    
        py_ans = private$py_obj$getLLOD()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getULOD()
    getULOD = function(){
    
        py_ans = private$py_obj$getULOD()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLLOQ(double lloq)
    setLLOQ = function(lloq){
    
        if(!(is_scalar_double(lloq))){ stop("arg lloq wrong type") }
    
        private$py_obj$setLLOQ(lloq)
        invisible()
    },
    
    # C++ signature: void setULOQ(double uloq)
    setULOQ = function(uloq){
    
        if(!(is_scalar_double(uloq))){ stop("arg uloq wrong type") }
    
        private$py_obj$setULOQ(uloq)
        invisible()
    },
    
    # C++ signature: double getLLOQ()
    getLLOQ = function(){
    
        py_ans = private$py_obj$getLLOQ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getULOQ()
    getULOQ = function(){
    
        py_ans = private$py_obj$getULOQ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool checkLOD(double value)
    checkLOD = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$checkLOD(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool checkLOQ(double value)
    checkLOQ = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$checkLOQ(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComponentName(const String & component_name)
    setComponentName = function(component_name){
    
        if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
    
        private$py_obj$setComponentName(component_name)
        invisible()
    },
    
    # C++ signature: void setISName(const String & IS_name)
    setISName = function(IS_name){
    
        if(!((is.R6(IS_name) && class(IS_name)[1]=="String") || is_scalar_character(IS_name))){ stop("arg IS_name wrong type") }
    
        private$py_obj$setISName(IS_name)
        invisible()
    },
    
    # C++ signature: void setFeatureName(const String & feature_name)
    setFeatureName = function(feature_name){
    
        if(!((is.R6(feature_name) && class(feature_name)[1]=="String") || is_scalar_character(feature_name))){ stop("arg feature_name wrong type") }
    
        private$py_obj$setFeatureName(feature_name)
        invisible()
    },
    
    # C++ signature: String getComponentName()
    getComponentName = function(){
    
        py_ans = private$py_obj$getComponentName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getISName()
    getISName = function(){
    
        py_ans = private$py_obj$getISName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getFeatureName()
    getFeatureName = function(){
    
        py_ans = private$py_obj$getFeatureName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setConcentrationUnits(const String & concentration_units)
    setConcentrationUnits = function(concentration_units){
    
        if(!((is.R6(concentration_units) && class(concentration_units)[1]=="String") || is_scalar_character(concentration_units))){ stop("arg concentration_units wrong type") }
    
        private$py_obj$setConcentrationUnits(concentration_units)
        invisible()
    },
    
    # C++ signature: String getConcentrationUnits()
    getConcentrationUnits = function(){
    
        py_ans = private$py_obj$getConcentrationUnits()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTransformationModel(const String & transformation_model)
    setTransformationModel = function(transformation_model){
    
        if(!((is.R6(transformation_model) && class(transformation_model)[1]=="String") || is_scalar_character(transformation_model))){ stop("arg transformation_model wrong type") }
    
        private$py_obj$setTransformationModel(transformation_model)
        invisible()
    },
    
    # C++ signature: void setTransformationModelParams(Param transformation_model_param)
    setTransformationModelParams = function(transformation_model_param){
    
        if(!(is.R6(transformation_model_param) && class(transformation_model_param)[1] == "Param")){ stop("arg transformation_model_param wrong type") }
    
        private$py_obj$setTransformationModelParams(transformation_model_param)
        invisible()
    },
    
    # C++ signature: String getTransformationModel()
    getTransformationModel = function(){
    
        py_ans = private$py_obj$getTransformationModel()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param getTransformationModelParams()
    getTransformationModelParams = function(){
    
        py_ans = private$py_obj$getTransformationModelParams()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setNPoints(int n_points)
    setNPoints = function(n_points){
    
        if(!( (is_scalar_integer(n_points) || is_scalar_double(n_points)) && n_points == as.integer(n_points))){ stop("arg n_points wrong type") }
    
        private$py_obj$setNPoints(as.integer(n_points))
        invisible()
    },
    
    # C++ signature: void setCorrelationCoefficient(double correlation_coefficient)
    setCorrelationCoefficient = function(correlation_coefficient){
    
        if(!(is_scalar_double(correlation_coefficient))){ stop("arg correlation_coefficient wrong type") }
    
        private$py_obj$setCorrelationCoefficient(correlation_coefficient)
        invisible()
    },
    
    # C++ signature: int getNPoints()
    getNPoints = function(){
    
        py_ans = private$py_obj$getNPoints()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCorrelationCoefficient()
    getCorrelationCoefficient = function(){
    
        py_ans = private$py_obj$getCorrelationCoefficient()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AbsoluteQuantitationMethodFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AbsoluteQuantitationMethodFile.html
AbsoluteQuantitationMethodFile <- R6Class(classname = "AbsoluteQuantitationMethodFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AbsoluteQuantitationMethodFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AbsoluteQuantitationMethodFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AbsoluteQuantitationMethodFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, libcpp_vector[AbsoluteQuantitationMethod] & aqm_list)
    load = function(filename, aqm_list){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(aqm_list) && all(sapply(aqm_list,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AbsoluteQuantitationMethod")))){ stop("arg aqm_list wrong type") }
    
        v1 <- r_to_py(aqm_list)
        private$py_obj$load(filename, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(aqm_list <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(const String & filename, libcpp_vector[AbsoluteQuantitationMethod] & aqm_list)
    store = function(filename, aqm_list){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(aqm_list) && all(sapply(aqm_list,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AbsoluteQuantitationMethod")))){ stop("arg aqm_list wrong type") }
    
        v1 <- r_to_py(aqm_list)
        private$py_obj$store(filename, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(aqm_list <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _AbsoluteQuantitationStandards
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AbsoluteQuantitationStandards.html
AbsoluteQuantitationStandards <- R6Class(classname = "AbsoluteQuantitationStandards",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AbsoluteQuantitationStandards()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AbsoluteQuantitationStandards()
        invisible()
    
    
    },
    
    # C++ signature: void AbsoluteQuantitationStandards(AbsoluteQuantitationStandards)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AbsoluteQuantitationStandards")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AbsoluteQuantitationStandards(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AbsoluteQuantitationStandards()
    # C++ signature: void AbsoluteQuantitationStandards(AbsoluteQuantitationStandards)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AbsoluteQuantitationStandards")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AbsoluteQuantitationStandards" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getComponentFeatureConcentrations(libcpp_vector[AQS_runConcentration] & run_concentrations, libcpp_vector[FeatureMap] & feature_maps, const String & component_name, libcpp_vector[AQS_featureConcentration] & feature_concentrations)
    getComponentFeatureConcentrations = function(run_concentrations, feature_maps, component_name, feature_concentrations){
    
        if(!(is_list(run_concentrations) && all(sapply(run_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_runConcentration")))){ stop("arg run_concentrations wrong type") }
        if(!(is_list(feature_maps) && all(sapply(feature_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg feature_maps wrong type") }
        if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
        if(!(is_list(feature_concentrations) && all(sapply(feature_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_featureConcentration")))){ stop("arg feature_concentrations wrong type") }
        v0 <- r_to_py(run_concentrations)
        v1 <- r_to_py(feature_maps)
    
        v3 <- r_to_py(feature_concentrations)
        private$py_obj$getComponentFeatureConcentrations(v0, v1, component_name, v3)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(run_concentrations <- byref_0))
        eval.parent(substitute(feature_maps <- byref_1))
        eval.parent(substitute(feature_concentrations <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _AbsoluteQuantitationStandardsFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AbsoluteQuantitationStandardsFile.html
AbsoluteQuantitationStandardsFile <- R6Class(classname = "AbsoluteQuantitationStandardsFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AbsoluteQuantitationStandardsFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AbsoluteQuantitationStandardsFile()
        invisible()
    
    
    },
    
    # C++ signature: void AbsoluteQuantitationStandardsFile(AbsoluteQuantitationStandardsFile &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AbsoluteQuantitationStandardsFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AbsoluteQuantitationStandardsFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AbsoluteQuantitationStandardsFile()
    # C++ signature: void AbsoluteQuantitationStandardsFile(AbsoluteQuantitationStandardsFile &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AbsoluteQuantitationStandardsFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AbsoluteQuantitationStandardsFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, libcpp_vector[AQS_runConcentration] & run_concentrations)
    load = function(filename, run_concentrations){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(run_concentrations) && all(sapply(run_concentrations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AQS_runConcentration")))){ stop("arg run_concentrations wrong type") }
    
        v1 <- r_to_py(run_concentrations)
        private$py_obj$load(filename, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(run_concentrations <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _AccurateMassSearchEngine
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AccurateMassSearchEngine.html
AccurateMassSearchEngine <- R6Class(classname = "AccurateMassSearchEngine",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AccurateMassSearchEngine()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == AccurateMassSearchEngine) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$AccurateMassSearchEngine()
        invisible()
    }
    
    },
    
    # C++ signature: void queryByMZ(double observed_mz, int observed_charge, String ion_mode, libcpp_vector[AccurateMassSearchResult] &, EmpiricalFormula & observed_adduct)
    queryByMZ = function(observed_mz, observed_charge, ion_mode, in_3, observed_adduct){
    
        if(!(is_scalar_double(observed_mz))){ stop("arg observed_mz wrong type") }
        if(!( (is_scalar_integer(observed_charge) || is_scalar_double(observed_charge)) && observed_charge == as.integer(observed_charge))){ stop("arg observed_charge wrong type") }
        if(!((is.R6(ion_mode) && class(ion_mode)[1]=="String") || is_scalar_character(ion_mode))){ stop("arg ion_mode wrong type") }
        if(!(is_list(in_3) && all(sapply(in_3,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AccurateMassSearchResult")))){ stop("arg in_3 wrong type") }
        if(!(is.R6(observed_adduct) && class(observed_adduct)[1] == "EmpiricalFormula")){ stop("arg observed_adduct wrong type") }
    
    
    
        v3 <- r_to_py(in_3)
    
        private$py_obj$queryByMZ(observed_mz, as.integer(observed_charge), ion_mode, v3, observed_adduct)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_3 <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void queryByFeature(Feature feature, size_t feature_index, String ion_mode, libcpp_vector[AccurateMassSearchResult] &)
    queryByFeature = function(feature, feature_index, ion_mode, in_3){
    
        if(!(is.R6(feature) && class(feature)[1] == "Feature")){ stop("arg feature wrong type") }
        if(!( (is_scalar_integer(feature_index) || is_scalar_double(feature_index)) && feature_index == as.integer(feature_index))){ stop("arg feature_index wrong type") }
        if(!((is.R6(ion_mode) && class(ion_mode)[1]=="String") || is_scalar_character(ion_mode))){ stop("arg ion_mode wrong type") }
        if(!(is_list(in_3) && all(sapply(in_3,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AccurateMassSearchResult")))){ stop("arg in_3 wrong type") }
    
    
    
        v3 <- r_to_py(in_3)
        private$py_obj$queryByFeature(feature, as.integer(feature_index), ion_mode, v3)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_3 <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void queryByConsensusFeature(ConsensusFeature cfeat, size_t cf_index, size_t number_of_maps, String ion_mode, libcpp_vector[AccurateMassSearchResult] & results)
    queryByConsensusFeature = function(cfeat, cf_index, number_of_maps, ion_mode, results){
    
        if(!(is.R6(cfeat) && class(cfeat)[1] == "ConsensusFeature")){ stop("arg cfeat wrong type") }
        if(!( (is_scalar_integer(cf_index) || is_scalar_double(cf_index)) && cf_index == as.integer(cf_index))){ stop("arg cf_index wrong type") }
        if(!( (is_scalar_integer(number_of_maps) || is_scalar_double(number_of_maps)) && number_of_maps == as.integer(number_of_maps))){ stop("arg number_of_maps wrong type") }
        if(!((is.R6(ion_mode) && class(ion_mode)[1]=="String") || is_scalar_character(ion_mode))){ stop("arg ion_mode wrong type") }
        if(!(is_list(results) && all(sapply(results,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AccurateMassSearchResult")))){ stop("arg results wrong type") }
    
    
    
    
        v4 <- r_to_py(results)
        private$py_obj$queryByConsensusFeature(cfeat, as.integer(cf_index), as.integer(number_of_maps), ion_mode, v4)
        byref_4 <- map(py_to_r(v4),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(results <- byref_4))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void run(FeatureMap &, MzTab &)
    run_0 = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MzTab")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_run_0`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void run(ConsensusMap &, MzTab &)
    run_1 = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MzTab")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_run_1`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void run(FeatureMap &, MzTab &)
    # C++ signature: void run(ConsensusMap &, MzTab &)
    run = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MzTab")) { self$run_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MzTab")) { self$run_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void init()
    init = function(){
    
        private$py_obj$init()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _AccurateMassSearchResult
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AccurateMassSearchResult.html
AccurateMassSearchResult <- R6Class(classname = "AccurateMassSearchResult",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AccurateMassSearchResult()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AccurateMassSearchResult()
        invisible()
    
    
    },
    
    # C++ signature: void AccurateMassSearchResult(AccurateMassSearchResult)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AccurateMassSearchResult")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AccurateMassSearchResult(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AccurateMassSearchResult()
    # C++ signature: void AccurateMassSearchResult(AccurateMassSearchResult)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AccurateMassSearchResult")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AccurateMassSearchResult" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getObservedMZ()
    getObservedMZ = function(){
    
        py_ans = private$py_obj$getObservedMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedMZ(double & m)
    setObservedMZ = function(m){
    
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
    
        private$py_obj$setObservedMZ(m)
        invisible()
    },
    
    # C++ signature: double getCalculatedMZ()
    getCalculatedMZ = function(){
    
        py_ans = private$py_obj$getCalculatedMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCalculatedMZ(double & m)
    setCalculatedMZ = function(m){
    
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
    
        private$py_obj$setCalculatedMZ(m)
        invisible()
    },
    
    # C++ signature: double getQueryMass()
    getQueryMass = function(){
    
        py_ans = private$py_obj$getQueryMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQueryMass(double & m)
    setQueryMass = function(m){
    
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
    
        private$py_obj$setQueryMass(m)
        invisible()
    },
    
    # C++ signature: double getFoundMass()
    getFoundMass = function(){
    
        py_ans = private$py_obj$getFoundMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFoundMass(double & m)
    setFoundMass = function(m){
    
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
    
        private$py_obj$setFoundMass(m)
        invisible()
    },
    
    # C++ signature: double getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(double & ch)
    setCharge = function(ch){
    
        if(!(is_scalar_double(ch))){ stop("arg ch wrong type") }
    
        private$py_obj$setCharge(ch)
        invisible()
    },
    
    # C++ signature: double getMZErrorPPM()
    getMZErrorPPM = function(){
    
        py_ans = private$py_obj$getMZErrorPPM()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZErrorPPM(double & ppm)
    setMZErrorPPM = function(ppm){
    
        if(!(is_scalar_double(ppm))){ stop("arg ppm wrong type") }
    
        private$py_obj$setMZErrorPPM(ppm)
        invisible()
    },
    
    # C++ signature: double getObservedRT()
    getObservedRT = function(){
    
        py_ans = private$py_obj$getObservedRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedRT(double & rt)
    setObservedRT = function(rt){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
    
        private$py_obj$setObservedRT(rt)
        invisible()
    },
    
    # C++ signature: double getObservedIntensity()
    getObservedIntensity = function(){
    
        py_ans = private$py_obj$getObservedIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedIntensity(double & intensity)
    setObservedIntensity = function(intensity){
    
        if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
    
        private$py_obj$setObservedIntensity(intensity)
        invisible()
    },
    
    # C++ signature: double getMatchingIndex()
    getMatchingIndex = function(){
    
        py_ans = private$py_obj$getMatchingIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchingIndex(double & idx)
    setMatchingIndex = function(idx){
    
        if(!(is_scalar_double(idx))){ stop("arg idx wrong type") }
    
        private$py_obj$setMatchingIndex(idx)
        invisible()
    },
    
    # C++ signature: String getFoundAdduct()
    getFoundAdduct = function(){
    
        py_ans = private$py_obj$getFoundAdduct()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFoundAdduct(const String & add)
    setFoundAdduct = function(add){
    
        if(!((is.R6(add) && class(add)[1]=="String") || is_scalar_character(add))){ stop("arg add wrong type") }
    
        private$py_obj$setFoundAdduct(add)
        invisible()
    },
    
    # C++ signature: String getFormulaString()
    getFormulaString = function(){
    
        py_ans = private$py_obj$getFormulaString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEmpiricalFormula(const String & ep)
    setEmpiricalFormula = function(ep){
    
        if(!((is.R6(ep) && class(ep)[1]=="String") || is_scalar_character(ep))){ stop("arg ep wrong type") }
    
        private$py_obj$setEmpiricalFormula(ep)
        invisible()
    },
    
    # C++ signature: libcpp_vector[String] getMatchingHMDBids()
    getMatchingHMDBids = function(){
    
        py_ans = private$py_obj$getMatchingHMDBids()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setMatchingHMDBids(libcpp_vector[String] & match_ids)
    setMatchingHMDBids = function(match_ids){
    
        if(!(is_list(match_ids) && all(sapply(match_ids),is_scalar_character))){ stop("arg match_ids wrong type") }
        v0 = r_to_py(modify_depth(match_ids,1,py_builtin$bytes(match_ids,'utf-8')))
        private$py_obj$setMatchingHMDBids(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(match_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getIsotopesSimScore()
    getIsotopesSimScore = function(){
    
        py_ans = private$py_obj$getIsotopesSimScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsotopesSimScore(double & sim_score)
    setIsotopesSimScore = function(sim_score){
    
        if(!(is_scalar_double(sim_score))){ stop("arg sim_score wrong type") }
    
        private$py_obj$setIsotopesSimScore(sim_score)
        invisible()
    },
    
    # C++ signature: libcpp_vector[double] getIndividualIntensities()
    getIndividualIntensities = function(){
    
        py_ans = private$py_obj$getIndividualIntensities()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setIndividualIntensities(libcpp_vector[double])
    setIndividualIntensities = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setIndividualIntensities(v0)
        
        invisible()
    },
    
    # C++ signature: size_t getSourceFeatureIndex()
    getSourceFeatureIndex = function(){
    
        py_ans = private$py_obj$getSourceFeatureIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSourceFeatureIndex(size_t)
    setSourceFeatureIndex = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSourceFeatureIndex(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: libcpp_vector[double] getMasstraceIntensities()
    getMasstraceIntensities = function(){
    
        py_ans = private$py_obj$getMasstraceIntensities()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setMasstraceIntensities(libcpp_vector[double] &)
    setMasstraceIntensities = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setMasstraceIntensities(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _Acquisition
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Acquisition.html
Acquisition <- R6Class(classname = "Acquisition",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Acquisition()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Acquisition()
        invisible()
    
    
    },
    
    # C++ signature: void Acquisition(Acquisition)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Acquisition")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Acquisition(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Acquisition()
    # C++ signature: void Acquisition(Acquisition)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Acquisition")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Acquisition" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(const String & identifier)
    setIdentifier = function(identifier){
    
        if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
    
        private$py_obj$setIdentifier(identifier)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _AcquisitionInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AcquisitionInfo.html
AcquisitionInfo <- R6Class(classname = "AcquisitionInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AcquisitionInfo()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AcquisitionInfo()
        invisible()
    
    
    },
    
    # C++ signature: void AcquisitionInfo(AcquisitionInfo)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AcquisitionInfo")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AcquisitionInfo(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AcquisitionInfo()
    # C++ signature: void AcquisitionInfo(AcquisitionInfo)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AcquisitionInfo")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AcquisitionInfo" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getMethodOfCombination()
    getMethodOfCombination = function(){
    
        py_ans = private$py_obj$getMethodOfCombination()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMethodOfCombination(String method)
    setMethodOfCombination = function(method){
    
        if(!((is.R6(method) && class(method)[1]=="String") || is_scalar_character(method))){ stop("arg method wrong type") }
    
        private$py_obj$setMethodOfCombination(method)
        invisible()
    },
    
    # C++ signature: size_t size()
# Number a Acquisition objects
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void push_back(Acquisition)
# Append a Acquisition object
    push_back = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Acquisition")){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(in_0)
        invisible()
    },
    
    # C++ signature: void resize(size_t n)
    resize = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$resize(as.integer(n))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _Adduct
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Adduct.html
Adduct <- R6Class(classname = "Adduct",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Adduct()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Adduct()
        invisible()
    
    
    },
    
    # C++ signature: void Adduct(Adduct)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Adduct")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Adduct(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Adduct(int charge)
    init_2 = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        private$py_obj <- Pymod$Adduct(as.integer(charge))
        invisible()
    
    
    },
    
    # C++ signature: void Adduct(int charge, int amount, double singleMass, String formula, double log_prob, double rt_shift, String label)
    init_3 = function(charge, amount, singleMass, formula, log_prob, rt_shift, label){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!( (is_scalar_integer(amount) || is_scalar_double(amount)) && amount == as.integer(amount))){ stop("arg amount wrong type") }
        if(!(is_scalar_double(singleMass))){ stop("arg singleMass wrong type") }
        if(!((is.R6(formula) && class(formula)[1]=="String") || is_scalar_character(formula))){ stop("arg formula wrong type") }
        if(!(is_scalar_double(log_prob))){ stop("arg log_prob wrong type") }
        if(!(is_scalar_double(rt_shift))){ stop("arg rt_shift wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
    
    
    
    
    
        private$py_obj <- Pymod$Adduct(as.integer(charge), as.integer(amount), singleMass, formula, log_prob, rt_shift, label)
        invisible()
    
    
    },
    
    # C++ signature: void Adduct()
    # C++ signature: void Adduct(Adduct)
    # C++ signature: void Adduct(int charge)
    # C++ signature: void Adduct(int charge, int amount, double singleMass, String formula, double log_prob, double rt_shift, String label)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Adduct")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_2(...) }
        else if ((length(arg_list)==7) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]])) && (is_scalar_double(arg_list[[5]])) && (is_scalar_double(arg_list[[6]])) && ((is.R6(arg_list[[7]]) && class(arg_list[[7]])[1]=="String") || is_scalar_character(arg_list[[7]]))) { self$init_3(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Adduct" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getAmount()
    getAmount = function(){
    
        py_ans = private$py_obj$getAmount()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAmount(int amount)
    setAmount = function(amount){
    
        if(!( (is_scalar_integer(amount) || is_scalar_double(amount)) && amount == as.integer(amount))){ stop("arg amount wrong type") }
    
        private$py_obj$setAmount(as.integer(amount))
        invisible()
    },
    
    # C++ signature: double getSingleMass()
    getSingleMass = function(){
    
        py_ans = private$py_obj$getSingleMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSingleMass(double singleMass)
    setSingleMass = function(singleMass){
    
        if(!(is_scalar_double(singleMass))){ stop("arg singleMass wrong type") }
    
        private$py_obj$setSingleMass(singleMass)
        invisible()
    },
    
    # C++ signature: double getLogProb()
    getLogProb = function(){
    
        py_ans = private$py_obj$getLogProb()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLogProb(double log_prob)
    setLogProb = function(log_prob){
    
        if(!(is_scalar_double(log_prob))){ stop("arg log_prob wrong type") }
    
        private$py_obj$setLogProb(log_prob)
        invisible()
    },
    
    # C++ signature: String getFormula()
    getFormula = function(){
    
        py_ans = private$py_obj$getFormula()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFormula(String formula)
    setFormula = function(formula){
    
        if(!((is.R6(formula) && class(formula)[1]=="String") || is_scalar_character(formula))){ stop("arg formula wrong type") }
    
        private$py_obj$setFormula(formula)
        invisible()
    },
    
    # C++ signature: double getRTShift()
    getRTShift = function(){
    
        py_ans = private$py_obj$getRTShift()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getLabel()
    getLabel = function(){
    
        py_ans = private$py_obj$getLabel()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AhoCorasickAmbiguous
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AhoCorasickAmbiguous.html
AhoCorasickAmbiguous <- R6Class(classname = "AhoCorasickAmbiguous",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AhoCorasickAmbiguous()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AhoCorasickAmbiguous()
        invisible()
    
    
    },
    
    # C++ signature: void AhoCorasickAmbiguous(const String & protein_sequence)
    init_1 = function(protein_sequence){
    
        if(!((is.R6(protein_sequence) && class(protein_sequence)[1]=="String") || is_scalar_character(protein_sequence))){ stop("arg protein_sequence wrong type") }
    
    
        private$py_obj <- Pymod$AhoCorasickAmbiguous(protein_sequence)
        invisible()
    
    
    },
    
    # C++ signature: void AhoCorasickAmbiguous()
    # C++ signature: void AhoCorasickAmbiguous(const String & protein_sequence)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AhoCorasickAmbiguous" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setProtein(const String & protein_sequence)
    setProtein = function(protein_sequence){
    
        if(!((is.R6(protein_sequence) && class(protein_sequence)[1]=="String") || is_scalar_character(protein_sequence))){ stop("arg protein_sequence wrong type") }
    
        private$py_obj$setProtein(protein_sequence)
        invisible()
    },
    
    # C++ signature: size_t getHitDBIndex()
    getHitDBIndex = function(){
    
        py_ans = private$py_obj$getHitDBIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getHitProteinPosition()
    getHitProteinPosition = function(){
    
        py_ans = private$py_obj$getHitProteinPosition()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AnalysisSummary
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AnalysisSummary.html
AnalysisSummary <- R6Class(classname = "AnalysisSummary",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        user_params_ = function(user_params_){
    
        if(!missing(user_params_)){
            if(!(is.R6(user_params_) && class(user_params_)[1] == "MetaInfo")){ stop("arg user_params_ wrong type") }
        
        
            private$py_obj$user_params_ <- user_params_
            } else {
        
                py_ans = private$py_obj$user_params_
            r_result = MetaInfo$new(py_ans)
                return(r_result)
                }
        },
        cv_params_ = function(cv_params_){
    
        if(!missing(cv_params_)){
            if(!(is.R6(cv_params_) && class(cv_params_)[1] == "CVTermList")){ stop("arg cv_params_ wrong type") }
        
        
            private$py_obj$cv_params_ <- cv_params_
            } else {
        
                py_ans = private$py_obj$cv_params_
            r_result = CVTermList$new(py_ans)
                return(r_result)
                }
        },
        quant_type_ = function(quant_type_){
    
        if(!missing(quant_type_)){
            if(!(quant_type_ %in% c(0, 1, 2, 3))){ stop("arg quant_type_ wrong type") }
        
        
            private$py_obj$quant_type_ <- as.integer(quant_type_)
            } else {
        
                py_ans = private$py_obj$quant_type_
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void AnalysisSummary()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AnalysisSummary()
        invisible()
    
    
    },
    
    # C++ signature: void AnalysisSummary(AnalysisSummary)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AnalysisSummary")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AnalysisSummary(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AnalysisSummary()
    # C++ signature: void AnalysisSummary(AnalysisSummary)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AnalysisSummary")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AnalysisSummary" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _AnnotationStatistics
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AnnotationStatistics.html
AnnotationStatistics <- R6Class(classname = "AnnotationStatistics",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        states = function(states){
    
        if(!missing(states)){
            if(!(is_list(states) && all(sapply(states,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg states wrong type") }
        
            v0 <- r_to_py(states)
            private$py_obj$states <- v0
            } else {
            
                py_ans = private$py_obj$states
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void AnnotationStatistics()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AnnotationStatistics()
        invisible()
    
    
    },
    
    # C++ signature: void AnnotationStatistics(AnnotationStatistics)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AnnotationStatistics")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AnnotationStatistics(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AnnotationStatistics()
    # C++ signature: void AnnotationStatistics(AnnotationStatistics)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AnnotationStatistics")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AnnotationStatistics" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _Assay
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Assay.html
Assay <- R6Class(classname = "Assay",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        uid_ = function(uid_){
    
        if(!missing(uid_)){
            if(!((is.R6(uid_) && class(uid_)[1]=="String") || is_scalar_character(uid_))){ stop("arg uid_ wrong type") }
        
        
            private$py_obj$uid_ <- uid_
            } else {
        
                py_ans = private$py_obj$uid_
            r_result = py_ans
                return(r_result)
                }
        },
        raw_files_ = function(raw_files_){
    
        if(!missing(raw_files_)){
            if(!(is_list(raw_files_) && all(sapply(raw_files_,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExperimentalSettings")))){ stop("arg raw_files_ wrong type") }
        
            v0 <- r_to_py(raw_files_)
            private$py_obj$raw_files_ <- v0
            } else {
            
                py_ans = private$py_obj$raw_files_
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        feature_maps_ = function(feature_maps_){
    
        if(!missing(feature_maps_)){
            if(!(
          is.environment(feature_maps_) && identical(parent.env(feature_maps_), asNamespace("collections")) && identical(strsplit(capture.output(feature_maps_$print())," ")[[1]][1], "dict")
          && all(sapply(feature_maps_$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(feature_maps_$values(),function(v) is.R6(v) && class(v)[1] == "FeatureMap"))
          )){ stop("arg feature_maps_ wrong type") }
        
            v0 <- py_dict(as.integer(feature_maps_$keys()),feature_maps_$values())
            private$py_obj$feature_maps_ <- v0
            } else {
        
                py_ans = private$py_obj$feature_maps_
            r_result <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())), function(i) FeatureMap$new(i)), py_to_r(py_builtin$list(py_ans$keys())))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Assay()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Assay()
        invisible()
    
    
    },
    
    # C++ signature: void Assay(Assay)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Assay")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Assay(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Assay()
    # C++ signature: void Assay(Assay)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Assay")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Assay" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _Attachment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::QcMLFile_1_1Attachment.html
Attachment <- R6Class(classname = "Attachment",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        value = function(value){
    
        if(!missing(value)){
            if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
        
        
            private$py_obj$value <- value
            } else {
        
                py_ans = private$py_obj$value
            r_result = py_ans
                return(r_result)
                }
        },
        cvRef = function(cvRef){
    
        if(!missing(cvRef)){
            if(!((is.R6(cvRef) && class(cvRef)[1]=="String") || is_scalar_character(cvRef))){ stop("arg cvRef wrong type") }
        
        
            private$py_obj$cvRef <- cvRef
            } else {
        
                py_ans = private$py_obj$cvRef
            r_result = py_ans
                return(r_result)
                }
        },
        cvAcc = function(cvAcc){
    
        if(!missing(cvAcc)){
            if(!((is.R6(cvAcc) && class(cvAcc)[1]=="String") || is_scalar_character(cvAcc))){ stop("arg cvAcc wrong type") }
        
        
            private$py_obj$cvAcc <- cvAcc
            } else {
        
                py_ans = private$py_obj$cvAcc
            r_result = py_ans
                return(r_result)
                }
        },
        unitRef = function(unitRef){
    
        if(!missing(unitRef)){
            if(!((is.R6(unitRef) && class(unitRef)[1]=="String") || is_scalar_character(unitRef))){ stop("arg unitRef wrong type") }
        
        
            private$py_obj$unitRef <- unitRef
            } else {
        
                py_ans = private$py_obj$unitRef
            r_result = py_ans
                return(r_result)
                }
        },
        unitAcc = function(unitAcc){
    
        if(!missing(unitAcc)){
            if(!((is.R6(unitAcc) && class(unitAcc)[1]=="String") || is_scalar_character(unitAcc))){ stop("arg unitAcc wrong type") }
        
        
            private$py_obj$unitAcc <- unitAcc
            } else {
        
                py_ans = private$py_obj$unitAcc
            r_result = py_ans
                return(r_result)
                }
        },
        binary = function(binary){
    
        if(!missing(binary)){
            if(!((is.R6(binary) && class(binary)[1]=="String") || is_scalar_character(binary))){ stop("arg binary wrong type") }
        
        
            private$py_obj$binary <- binary
            } else {
        
                py_ans = private$py_obj$binary
            r_result = py_ans
                return(r_result)
                }
        },
        qualityRef = function(qualityRef){
    
        if(!missing(qualityRef)){
            if(!((is.R6(qualityRef) && class(qualityRef)[1]=="String") || is_scalar_character(qualityRef))){ stop("arg qualityRef wrong type") }
        
        
            private$py_obj$qualityRef <- qualityRef
            } else {
        
                py_ans = private$py_obj$qualityRef
            r_result = py_ans
                return(r_result)
                }
        },
        colTypes = function(colTypes){
    
        if(!missing(colTypes)){
            if(!(is_list(colTypes) && all(sapply(colTypes),is_scalar_character))){ stop("arg colTypes wrong type") }
        
            v0 = r_to_py(modify_depth(colTypes,1,py_builtin$bytes(colTypes,'utf-8')))
            private$py_obj$colTypes <- v0
            } else {
        
                py_ans = private$py_obj$colTypes
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Attachment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Attachment()
        invisible()
    
    
    },
    
    # C++ signature: void Attachment(Attachment)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Attachment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Attachment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Attachment()
    # C++ signature: void Attachment(Attachment)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Attachment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Attachment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String toXMLString(unsigned int indentation_level)
    toXMLString = function(indentation_level){
    
        if(!( (is_scalar_integer(indentation_level) || is_scalar_double(indentation_level)) && indentation_level == as.integer(indentation_level))){ stop("arg indentation_level wrong type") }
    
        py_ans = private$py_obj$toXMLString(as.integer(indentation_level))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toCSVString(String separator)
    toCSVString = function(separator){
    
        if(!((is.R6(separator) && class(separator)[1]=="String") || is_scalar_character(separator))){ stop("arg separator wrong type") }
    
        py_ans = private$py_obj$toCSVString(separator)
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _AverageLinkage
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1AverageLinkage.html
AverageLinkage <- R6Class(classname = "AverageLinkage",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void AverageLinkage()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$AverageLinkage()
        invisible()
    
    
    },
    
    # C++ signature: void AverageLinkage(AverageLinkage)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AverageLinkage")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$AverageLinkage(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void AverageLinkage()
    # C++ signature: void AverageLinkage(AverageLinkage)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AverageLinkage")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "AverageLinkage" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _BSpline2d
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BSpline2d.html
BSpline2d <- R6Class(classname = "BSpline2d",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BSpline2d(libcpp_vector[double] x, libcpp_vector[double] y, double wave_length, BoundaryCondition boundary_condition, size_t num_nodes)
    initialize = function(x, y, wave_length, boundary_condition, num_nodes){
    
    if(missing(y) && missing(wave_length) && missing(boundary_condition) && missing(num_nodes)){
         if( "python.builtin.object" %in% class(x) && class_to_wrap(x) == BSpline2d ) { private$py_obj <- x }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(x) && all(sapply(x,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x wrong type") }
        if(!(is_list(y) && all(sapply(y,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg y wrong type") }
        if(!(is_scalar_double(wave_length))){ stop("arg wave_length wrong type") }
        if(!(boundary_condition %in% c(0, 1, 2))){ stop("arg boundary_condition wrong type") }
        if(!( (is_scalar_integer(num_nodes) || is_scalar_double(num_nodes)) && num_nodes == as.integer(num_nodes))){ stop("arg num_nodes wrong type") }
        v0 <- r_to_py(x)
        v1 <- r_to_py(y)
    
    
    
    
        private$py_obj <- Pymod$BSpline2d(v0, v1, wave_length, as.integer(boundary_condition), as.integer(num_nodes))
        invisible()
    }
        
        
    
    },
    
    # C++ signature: bool solve(libcpp_vector[double] y)
    solve = function(y){
    
        if(!(is_list(y) && all(sapply(y,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg y wrong type") }
        v0 <- r_to_py(y)
        py_ans = private$py_obj$solve(v0)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double eval(double x)
    eval = function(x){
    
        if(!(is_scalar_double(x))){ stop("arg x wrong type") }
    
        py_ans = private$py_obj$eval(x)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double derivative(double x)
    derivative = function(x){
    
        if(!(is_scalar_double(x))){ stop("arg x wrong type") }
    
        py_ans = private$py_obj$derivative(x)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool ok()
    ok = function(){
    
        py_ans = private$py_obj$ok()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void debug(bool enable)
    debug = function(enable){
    
        if(!( (is_scalar_integer(enable) || is_scalar_double(enable)) && enable == as.integer(enable))){ stop("arg enable wrong type") }
    
        private$py_obj$debug(as.integer(enable))
        invisible()
    },
    
    # C++ signature: double derivatives(double x, unsigned int order)
    derivatives = function(x, order){
    
        if(!(is_scalar_double(x))){ stop("arg x wrong type") }
        if(!( (is_scalar_integer(order) || is_scalar_double(order)) && order == as.integer(order))){ stop("arg order wrong type") }
    
    
        py_ans = private$py_obj$derivatives(x, as.integer(order))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _Base64
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Base64.html
Base64 <- R6Class(classname = "Base64",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Base64()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Base64) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Base64()
        invisible()
    }
    
    },
    
    # C++ signature: void encodeIntegers(libcpp_vector[int] & in_, ByteOrder to_byte_order, String & out, bool zlib_compression)
    encodeIntegers = function(in_, to_byte_order, out, zlib_compression){
    
        if(!(is_list(in_) && all(sapply(in_,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg in_ wrong type") }
        if(!(to_byte_order %in% c(0, 1))){ stop("arg to_byte_order wrong type") }
        if(!((is.R6(out) && class(out)[1]=="String") || is_scalar_character(out))){ stop("arg out wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
        v0 <- r_to_py(modify_depth(in_,1,as.integer))
    
    
    
        private$py_obj$encodeIntegers(v0, as.integer(to_byte_order), out, as.integer(zlib_compression))
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(in_ <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void decodeIntegers(const String & in_, ByteOrder from_byte_order, libcpp_vector[int] & out, bool zlib_compression)
    decodeIntegers = function(in_, from_byte_order, out, zlib_compression){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(from_byte_order %in% c(0, 1))){ stop("arg from_byte_order wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg out wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
    
    
        v2 <- r_to_py(modify_depth(out,1,as.integer))
    
        private$py_obj$decodeIntegers(in_, as.integer(from_byte_order), v2, as.integer(zlib_compression))
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
    
        tryCatch({
        eval.parent(substitute(out <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void encodeStrings(libcpp_vector[String] & in_, String & out, bool zlib_compression)
    encodeStrings = function(in_, out, zlib_compression){
    
        if(!(is_list(in_) && all(sapply(in_),is_scalar_character))){ stop("arg in_ wrong type") }
        if(!((is.R6(out) && class(out)[1]=="String") || is_scalar_character(out))){ stop("arg out wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
        v0 = r_to_py(modify_depth(in_,1,py_builtin$bytes(in_,'utf-8')))
    
    
        private$py_obj$encodeStrings(v0, out, as.integer(zlib_compression))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(in_ <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void decodeStrings(const String & in_, libcpp_vector[String] & out, bool zlib_compression)
    decodeStrings = function(in_, out, zlib_compression){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out),is_scalar_character))){ stop("arg out wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
    
        v1 = r_to_py(modify_depth(out,1,py_builtin$bytes(out,'utf-8')))
    
        private$py_obj$decodeStrings(in_, v1, as.integer(zlib_compression))
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
    
        tryCatch({
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _BaseFeature
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BaseFeature.html
BaseFeature <- R6Class(classname = "BaseFeature",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BaseFeature()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$BaseFeature()
        invisible()
    
    
    },
    
    # C++ signature: void BaseFeature(BaseFeature &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "BaseFeature")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$BaseFeature(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void BaseFeature()
    # C++ signature: void BaseFeature(BaseFeature &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "BaseFeature")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "BaseFeature" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getQuality()
    getQuality = function(){
    
        py_ans = private$py_obj$getQuality()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuality(float q)
    setQuality = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setQuality(q)
        invisible()
    },
    
    # C++ signature: float getWidth()
    getWidth = function(){
    
        py_ans = private$py_obj$getWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWidth(float q)
    setWidth = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setWidth(q)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int q)
    setCharge = function(q){
    
        if(!( (is_scalar_integer(q) || is_scalar_double(q)) && q == as.integer(q))){ stop("arg q wrong type") }
    
        private$py_obj$setCharge(as.integer(q))
        invisible()
    },
    
    # C++ signature: AnnotationState getAnnotationState()
    getAnnotationState = function(){
    
        py_ans = private$py_obj$getAnnotationState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification] & peptides)
    setPeptideIdentifications = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$setPeptideIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _BernNorm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BernNorm.html
BernNorm <- R6Class(classname = "BernNorm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BernNorm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == BernNorm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$BernNorm()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _BiGaussFitter1D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BiGaussFitter1D.html
BiGaussFitter1D <- R6Class(classname = "BiGaussFitter1D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BiGaussFitter1D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$BiGaussFitter1D()
        invisible()
    
    
    },
    
    # C++ signature: void BiGaussFitter1D(BiGaussFitter1D)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "BiGaussFitter1D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$BiGaussFitter1D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void BiGaussFitter1D()
    # C++ signature: void BiGaussFitter1D(BiGaussFitter1D)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "BiGaussFitter1D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "BiGaussFitter1D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _BiGaussModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BiGaussModel.html
BiGaussModel <- R6Class(classname = "BiGaussModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BiGaussModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$BiGaussModel()
        invisible()
    
    
    },
    
    # C++ signature: void BiGaussModel(BiGaussModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "BiGaussModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$BiGaussModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void BiGaussModel()
    # C++ signature: void BiGaussModel(BiGaussModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "BiGaussModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "BiGaussModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setOffset(double offset)
    setOffset = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset(offset)
        invisible()
    },
    
    # C++ signature: void setSamples()
    setSamples = function(){
    
        private$py_obj$setSamples()
        invisible()
    },
    
    # C++ signature: double getCenter()
    getCenter = function(){
    
        py_ans = private$py_obj$getCenter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _BilinearInterpolation[double,double]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1BilinearInterpolation[double,double].html
BilinearInterpolation <- R6Class(classname = "BilinearInterpolation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BilinearInterpolation()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$BilinearInterpolation()
        invisible()
    
    
    },
    
    # C++ signature: void BilinearInterpolation(BilinearInterpolation)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "BilinearInterpolation")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$BilinearInterpolation(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void BilinearInterpolation()
    # C++ signature: void BilinearInterpolation(BilinearInterpolation)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "BilinearInterpolation")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "BilinearInterpolation" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double value(double arg_pos_0, double arg_pos_1)
    value = function(arg_pos_0, arg_pos_1){
    
        if(!(is_scalar_double(arg_pos_0))){ stop("arg arg_pos_0 wrong type") }
        if(!(is_scalar_double(arg_pos_1))){ stop("arg arg_pos_1 wrong type") }
    
    
        py_ans = private$py_obj$value(arg_pos_0, arg_pos_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addValue(double arg_pos_0, double arg_pos_1, double arg_value)
    addValue = function(arg_pos_0, arg_pos_1, arg_value){
    
        if(!(is_scalar_double(arg_pos_0))){ stop("arg arg_pos_0 wrong type") }
        if(!(is_scalar_double(arg_pos_1))){ stop("arg arg_pos_1 wrong type") }
        if(!(is_scalar_double(arg_value))){ stop("arg arg_value wrong type") }
    
    
    
        private$py_obj$addValue(arg_pos_0, arg_pos_1, arg_value)
        invisible()
    },
    
    # C++ signature: MatrixDouble getData()
    getData = function(){
    
        py_ans = private$py_obj$getData()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setData(MatrixDouble & data)
    setData = function(data){
    
        if(!(is.R6(data) && class(data)[1] == "MatrixDouble")){ stop("arg data wrong type") }
    
        private$py_obj$setData(data)
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double key2index_0(double pos)
    key2index_0 = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$key2index_0(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double index2key_0(double pos)
    index2key_0 = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$index2key_0(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double key2index_1(double pos)
    key2index_1 = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$key2index_1(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double index2key_1(double pos)
    index2key_1 = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$index2key_1(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getScale_0()
    getScale_0 = function(){
    
        py_ans = private$py_obj$getScale_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScale_0(double & scale)
    setScale_0 = function(scale){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
    
        private$py_obj$setScale_0(scale)
        invisible()
    },
    
    # C++ signature: double getScale_1()
    getScale_1 = function(){
    
        py_ans = private$py_obj$getScale_1()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScale_1(double & scale)
    setScale_1 = function(scale){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
    
        private$py_obj$setScale_1(scale)
        invisible()
    },
    
    # C++ signature: double getOffset_0()
    getOffset_0 = function(){
    
        py_ans = private$py_obj$getOffset_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset_0(double & offset)
    setOffset_0 = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset_0(offset)
        invisible()
    },
    
    # C++ signature: double getOffset_1()
    getOffset_1 = function(){
    
        py_ans = private$py_obj$getOffset_1()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset_1(double & offset)
    setOffset_1 = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset_1(offset)
        invisible()
    },
    
    # C++ signature: void setMapping_0(double & scale, double & inside, double & outside)
    setMapping_0_0 = function(scale, inside, outside){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(inside))){ stop("arg inside wrong type") }
        if(!(is_scalar_double(outside))){ stop("arg outside wrong type") }
    
    
    
        private$py_obj$`_setMapping_0_0`(scale, inside, outside)
        invisible()
    },
    
    # C++ signature: void setMapping_0(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping_0_1 = function(inside_low, outside_low, inside_high, outside_high){
    
        if(!(is_scalar_double(inside_low))){ stop("arg inside_low wrong type") }
        if(!(is_scalar_double(outside_low))){ stop("arg outside_low wrong type") }
        if(!(is_scalar_double(inside_high))){ stop("arg inside_high wrong type") }
        if(!(is_scalar_double(outside_high))){ stop("arg outside_high wrong type") }
    
    
    
    
        private$py_obj$`_setMapping_0_1`(inside_low, outside_low, inside_high, outside_high)
        invisible()
    },
    
    # C++ signature: void setMapping_0(double & scale, double & inside, double & outside)
    # C++ signature: void setMapping_0(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping_0 = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$setMapping_0_0(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$setMapping_0_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setMapping_1(double & scale, double & inside, double & outside)
    setMapping_1_0 = function(scale, inside, outside){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(inside))){ stop("arg inside wrong type") }
        if(!(is_scalar_double(outside))){ stop("arg outside wrong type") }
    
    
    
        private$py_obj$`_setMapping_1_0`(scale, inside, outside)
        invisible()
    },
    
    # C++ signature: void setMapping_1(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping_1_1 = function(inside_low, outside_low, inside_high, outside_high){
    
        if(!(is_scalar_double(inside_low))){ stop("arg inside_low wrong type") }
        if(!(is_scalar_double(outside_low))){ stop("arg outside_low wrong type") }
        if(!(is_scalar_double(inside_high))){ stop("arg inside_high wrong type") }
        if(!(is_scalar_double(outside_high))){ stop("arg outside_high wrong type") }
    
    
    
    
        private$py_obj$`_setMapping_1_1`(inside_low, outside_low, inside_high, outside_high)
        invisible()
    },
    
    # C++ signature: void setMapping_1(double & scale, double & inside, double & outside)
    # C++ signature: void setMapping_1(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping_1 = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$setMapping_1_0(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$setMapping_1_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getInsideReferencePoint_0()
    getInsideReferencePoint_0 = function(){
    
        py_ans = private$py_obj$getInsideReferencePoint_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getInsideReferencePoint_1()
    getInsideReferencePoint_1 = function(){
    
        py_ans = private$py_obj$getInsideReferencePoint_1()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getOutsideReferencePoint_0()
    getOutsideReferencePoint_0 = function(){
    
        py_ans = private$py_obj$getOutsideReferencePoint_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getOutsideReferencePoint_1()
    getOutsideReferencePoint_1 = function(){
    
        py_ans = private$py_obj$getOutsideReferencePoint_1()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMin_0()
    supportMin_0 = function(){
    
        py_ans = private$py_obj$supportMin_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMin_1()
    supportMin_1 = function(){
    
        py_ans = private$py_obj$supportMin_1()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMax_0()
    supportMax_0 = function(){
    
        py_ans = private$py_obj$supportMax_0()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMax_1()
    supportMax_1 = function(){
    
        py_ans = private$py_obj$supportMax_1()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _BinnedSpectrum
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BinnedSpectrum.html
BinnedSpectrum <- R6Class(classname = "BinnedSpectrum",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void BinnedSpectrum(MSSpectrum, float size, bool unit_ppm, unsigned int spread, float offset)
    initialize = function(in_0, size, unit_ppm, spread, offset){
    
    if(missing(size) && missing(unit_ppm) && missing(spread) && missing(offset)){
         if( "python.builtin.object" %in% class(in_0) && class_to_wrap(in_0) == BinnedSpectrum ) { private$py_obj <- in_0 }
         else { stop("arg wrong type") }
      } else {
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(size))){ stop("arg size wrong type") }
        if(!( (is_scalar_integer(unit_ppm) || is_scalar_double(unit_ppm)) && unit_ppm == as.integer(unit_ppm))){ stop("arg unit_ppm wrong type") }
        if(!( (is_scalar_integer(spread) || is_scalar_double(spread)) && spread == as.integer(spread))){ stop("arg spread wrong type") }
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
    
    
    
    
    
        private$py_obj <- Pymod$BinnedSpectrum(in_0, size, as.integer(unit_ppm), as.integer(spread), offset)
        invisible()
    }
    
    },
    
    # C++ signature: float getBinSize()
    getBinSize = function(){
    
        py_ans = private$py_obj$getBinSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getBinSpread()
    getBinSpread = function(){
    
        py_ans = private$py_obj$getBinSpread()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getBinIndex(float mz)
    getBinIndex = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$getBinIndex(mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getBinLowerMZ(size_t i)
    getBinLowerMZ = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getBinLowerMZ(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getBinIntensity(double mz)
    getBinIntensity = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$getBinIntensity(mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[Precursor] getPrecursors()
    getPrecursors = function(){
    
        py_ans = private$py_obj$getPrecursors()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: bool isCompatible(BinnedSpectrum & a, BinnedSpectrum & b)
    isCompatible = function(a, b){
    
        if(!(is.R6(a) && class(a)[1] == "BinnedSpectrum")){ stop("arg a wrong type") }
        if(!(is.R6(b) && class(b)[1] == "BinnedSpectrum")){ stop("arg b wrong type") }
    
    
        py_ans = private$py_obj$isCompatible(a, b)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getOffset()
    getOffset = function(){
    
        py_ans = private$py_obj$getOffset()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _BoxElement
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1BoxElement.html
BoxElement <- R6Class(classname = "BoxElement",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mz = function(mz){
    
        if(!missing(mz)){
            if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        
        
            private$py_obj$mz <- mz
            } else {
        
                py_ans = private$py_obj$mz
                r_result = py_ans
                return(r_result)
                }
        },
        c = function(c){
    
        if(!missing(c)){
            if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
        
        
            private$py_obj$c <- as.integer(c)
            } else {
        
                py_ans = private$py_obj$c
                r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        intens = function(intens){
    
        if(!missing(intens)){
            if(!(is_scalar_double(intens))){ stop("arg intens wrong type") }
        
        
            private$py_obj$intens <- intens
            } else {
        
                py_ans = private$py_obj$intens
                r_result = py_ans
                return(r_result)
                }
        },
        ref_intens = function(ref_intens){
    
        if(!missing(ref_intens)){
            if(!(is_scalar_double(ref_intens))){ stop("arg ref_intens wrong type") }
        
        
            private$py_obj$ref_intens <- ref_intens
            } else {
        
                py_ans = private$py_obj$ref_intens
                r_result = py_ans
                return(r_result)
                }
        },
        RT = function(RT){
    
        if(!missing(RT)){
            if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        
        
            private$py_obj$RT <- RT
            } else {
        
                py_ans = private$py_obj$RT
                r_result = py_ans
                return(r_result)
                }
        },
        RT_index = function(RT_index){
    
        if(!missing(RT_index)){
            if(!( (is_scalar_integer(RT_index) || is_scalar_double(RT_index)) && RT_index == as.integer(RT_index))){ stop("arg RT_index wrong type") }
        
        
            private$py_obj$RT_index <- as.integer(RT_index)
            } else {
        
                py_ans = private$py_obj$RT_index
                r_result = py_ans
                return(r_result)
                }
        },
        MZ_begin = function(MZ_begin){
    
        if(!missing(MZ_begin)){
            if(!( (is_scalar_integer(MZ_begin) || is_scalar_double(MZ_begin)) && MZ_begin == as.integer(MZ_begin))){ stop("arg MZ_begin wrong type") }
        
        
            private$py_obj$MZ_begin <- as.integer(MZ_begin)
            } else {
        
                py_ans = private$py_obj$MZ_begin
                r_result = py_ans
                return(r_result)
                }
        },
        MZ_end = function(MZ_end){
    
        if(!missing(MZ_end)){
            if(!( (is_scalar_integer(MZ_end) || is_scalar_double(MZ_end)) && MZ_end == as.integer(MZ_end))){ stop("arg MZ_end wrong type") }
        
        
            private$py_obj$MZ_end <- as.integer(MZ_end)
            } else {
        
                py_ans = private$py_obj$MZ_end
                r_result = py_ans
                return(r_result)
                }
        }

    )
) 

# R implementation of _CV
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1CV.html
CV <- R6Class(classname = "CV",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        fullname = function(fullname){
    
        if(!missing(fullname)){
            if(!((is.R6(fullname) && class(fullname)[1]=="String") || is_scalar_character(fullname))){ stop("arg fullname wrong type") }
        
        
            private$py_obj$fullname <- fullname
            } else {
        
                py_ans = private$py_obj$fullname
            r_result = py_ans
                return(r_result)
                }
        },
        version = function(version){
    
        if(!missing(version)){
            if(!((is.R6(version) && class(version)[1]=="String") || is_scalar_character(version))){ stop("arg version wrong type") }
        
        
            private$py_obj$version <- version
            } else {
        
                py_ans = private$py_obj$version
            r_result = py_ans
                return(r_result)
                }
        },
        URI = function(URI){
    
        if(!missing(URI)){
            if(!((is.R6(URI) && class(URI)[1]=="String") || is_scalar_character(URI))){ stop("arg URI wrong type") }
        
        
            private$py_obj$URI <- URI
            } else {
        
                py_ans = private$py_obj$URI
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CV(CV)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CV")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CV(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CV(String new_id, String new_fullname, String new_version, String new_URI)
    init_1 = function(new_id, new_fullname, new_version, new_URI){
    
        if(!((is.R6(new_id) && class(new_id)[1]=="String") || is_scalar_character(new_id))){ stop("arg new_id wrong type") }
        if(!((is.R6(new_fullname) && class(new_fullname)[1]=="String") || is_scalar_character(new_fullname))){ stop("arg new_fullname wrong type") }
        if(!((is.R6(new_version) && class(new_version)[1]=="String") || is_scalar_character(new_version))){ stop("arg new_version wrong type") }
        if(!((is.R6(new_URI) && class(new_URI)[1]=="String") || is_scalar_character(new_URI))){ stop("arg new_URI wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$CV(new_id, new_fullname, new_version, new_URI)
        invisible()
    
    
    },
    
    # C++ signature: void CV(CV)
    # C++ signature: void CV(String new_id, String new_fullname, String new_version, String new_URI)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CV")) { self$init_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CV" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _CVMappingFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVMappingFile.html
CVMappingFile <- R6Class(classname = "CVMappingFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVMappingFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == CVMappingFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$CVMappingFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, CVMappings & cv_mappings, bool strip_namespaces)
    load = function(filename, cv_mappings, strip_namespaces){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(cv_mappings) && class(cv_mappings)[1] == "CVMappings")){ stop("arg cv_mappings wrong type") }
        if(!( (is_scalar_integer(strip_namespaces) || is_scalar_double(strip_namespaces)) && strip_namespaces == as.integer(strip_namespaces))){ stop("arg strip_namespaces wrong type") }
    
    
    
        private$py_obj$load(filename, cv_mappings, as.integer(strip_namespaces))
        invisible()
    }
)
) 

# R implementation of _CVMappingRule
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVMappingRule.html
CVMappingRule <- R6Class(classname = "CVMappingRule",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVMappingRule()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVMappingRule()
        invisible()
    
    
    },
    
    # C++ signature: void CVMappingRule(CVMappingRule)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVMappingRule")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVMappingRule(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVMappingRule()
    # C++ signature: void CVMappingRule(CVMappingRule)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVMappingRule")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVMappingRule" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setIdentifier(String identifier)
    setIdentifier = function(identifier){
    
        if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
    
        private$py_obj$setIdentifier(identifier)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setElementPath(String element_path)
    setElementPath = function(element_path){
    
        if(!((is.R6(element_path) && class(element_path)[1]=="String") || is_scalar_character(element_path))){ stop("arg element_path wrong type") }
    
        private$py_obj$setElementPath(element_path)
        invisible()
    },
    
    # C++ signature: String getElementPath()
    getElementPath = function(){
    
        py_ans = private$py_obj$getElementPath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRequirementLevel(RequirementLevel level)
    setRequirementLevel = function(level){
    
        if(!(level %in% c(0, 1, 2))){ stop("arg level wrong type") }
    
        private$py_obj$setRequirementLevel(as.integer(level))
        invisible()
    },
    
    # C++ signature: RequirementLevel getRequirementLevel()
    getRequirementLevel = function(){
    
        py_ans = private$py_obj$getRequirementLevel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCombinationsLogic(CombinationsLogic combinations_logic)
    setCombinationsLogic = function(combinations_logic){
    
        if(!(combinations_logic %in% c(0, 1, 2))){ stop("arg combinations_logic wrong type") }
    
        private$py_obj$setCombinationsLogic(as.integer(combinations_logic))
        invisible()
    },
    
    # C++ signature: CombinationsLogic getCombinationsLogic()
    getCombinationsLogic = function(){
    
        py_ans = private$py_obj$getCombinationsLogic()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScopePath(String path)
    setScopePath = function(path){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
    
        private$py_obj$setScopePath(path)
        invisible()
    },
    
    # C++ signature: String getScopePath()
    getScopePath = function(){
    
        py_ans = private$py_obj$getScopePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVMappingTerm] cv_terms)
    setCVTerms = function(cv_terms){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVMappingTerm")))){ stop("arg cv_terms wrong type") }
        v0 <- r_to_py(cv_terms)
        private$py_obj$setCVTerms(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[CVMappingTerm] getCVTerms()
    getCVTerms = function(){
    
        py_ans = private$py_obj$getCVTerms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVMappingTerm cv_terms)
    addCVTerm = function(cv_terms){
    
        if(!(is.R6(cv_terms) && class(cv_terms)[1] == "CVMappingTerm")){ stop("arg cv_terms wrong type") }
    
        private$py_obj$addCVTerm(cv_terms)
        invisible()
    }
)
) 

# R implementation of _CVMappingTerm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVMappingTerm.html
CVMappingTerm <- R6Class(classname = "CVMappingTerm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVMappingTerm()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVMappingTerm()
        invisible()
    
    
    },
    
    # C++ signature: void CVMappingTerm(CVMappingTerm)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVMappingTerm")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVMappingTerm(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVMappingTerm()
    # C++ signature: void CVMappingTerm(CVMappingTerm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVMappingTerm")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVMappingTerm" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setAccession(String accession)
    setAccession = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        private$py_obj$setAccession(accession)
        invisible()
    },
    
    # C++ signature: String getAccession()
    getAccession = function(){
    
        py_ans = private$py_obj$getAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUseTermName(bool use_term_name)
    setUseTermName = function(use_term_name){
    
        if(!( (is_scalar_integer(use_term_name) || is_scalar_double(use_term_name)) && use_term_name == as.integer(use_term_name))){ stop("arg use_term_name wrong type") }
    
        private$py_obj$setUseTermName(as.integer(use_term_name))
        invisible()
    },
    
    # C++ signature: bool getUseTermName()
    getUseTermName = function(){
    
        py_ans = private$py_obj$getUseTermName()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUseTerm(bool use_term)
    setUseTerm = function(use_term){
    
        if(!( (is_scalar_integer(use_term) || is_scalar_double(use_term)) && use_term == as.integer(use_term))){ stop("arg use_term wrong type") }
    
        private$py_obj$setUseTerm(as.integer(use_term))
        invisible()
    },
    
    # C++ signature: bool getUseTerm()
    getUseTerm = function(){
    
        py_ans = private$py_obj$getUseTerm()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTermName(String term_name)
    setTermName = function(term_name){
    
        if(!((is.R6(term_name) && class(term_name)[1]=="String") || is_scalar_character(term_name))){ stop("arg term_name wrong type") }
    
        private$py_obj$setTermName(term_name)
        invisible()
    },
    
    # C++ signature: String getTermName()
    getTermName = function(){
    
        py_ans = private$py_obj$getTermName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsRepeatable(bool is_repeatable)
    setIsRepeatable = function(is_repeatable){
    
        if(!( (is_scalar_integer(is_repeatable) || is_scalar_double(is_repeatable)) && is_repeatable == as.integer(is_repeatable))){ stop("arg is_repeatable wrong type") }
    
        private$py_obj$setIsRepeatable(as.integer(is_repeatable))
        invisible()
    },
    
    # C++ signature: bool getIsRepeatable()
    getIsRepeatable = function(){
    
        py_ans = private$py_obj$getIsRepeatable()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAllowChildren(bool allow_children)
    setAllowChildren = function(allow_children){
    
        if(!( (is_scalar_integer(allow_children) || is_scalar_double(allow_children)) && allow_children == as.integer(allow_children))){ stop("arg allow_children wrong type") }
    
        private$py_obj$setAllowChildren(as.integer(allow_children))
        invisible()
    },
    
    # C++ signature: bool getAllowChildren()
    getAllowChildren = function(){
    
        py_ans = private$py_obj$getAllowChildren()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVIdentifierRef(String cv_identifier_ref)
    setCVIdentifierRef = function(cv_identifier_ref){
    
        if(!((is.R6(cv_identifier_ref) && class(cv_identifier_ref)[1]=="String") || is_scalar_character(cv_identifier_ref))){ stop("arg cv_identifier_ref wrong type") }
    
        private$py_obj$setCVIdentifierRef(cv_identifier_ref)
        invisible()
    },
    
    # C++ signature: String getCVIdentifierRef()
    getCVIdentifierRef = function(){
    
        py_ans = private$py_obj$getCVIdentifierRef()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CVMappings
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVMappings.html
CVMappings <- R6Class(classname = "CVMappings",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVMappings()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVMappings()
        invisible()
    
    
    },
    
    # C++ signature: void CVMappings(CVMappings)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVMappings")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVMappings(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVMappings()
    # C++ signature: void CVMappings(CVMappings)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVMappings")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVMappings" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setMappingRules(libcpp_vector[CVMappingRule] & cv_mapping_rules)
    setMappingRules = function(cv_mapping_rules){
    
        if(!(is_list(cv_mapping_rules) && all(sapply(cv_mapping_rules,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVMappingRule")))){ stop("arg cv_mapping_rules wrong type") }
        v0 <- r_to_py(cv_mapping_rules)
        private$py_obj$setMappingRules(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(cv_mapping_rules <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[CVMappingRule] getMappingRules()
    getMappingRules = function(){
    
        py_ans = private$py_obj$getMappingRules()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addMappingRule(CVMappingRule & cv_mapping_rule)
    addMappingRule = function(cv_mapping_rule){
    
        if(!(is.R6(cv_mapping_rule) && class(cv_mapping_rule)[1] == "CVMappingRule")){ stop("arg cv_mapping_rule wrong type") }
    
        private$py_obj$addMappingRule(cv_mapping_rule)
        invisible()
    },
    
    # C++ signature: void setCVReferences(libcpp_vector[CVReference] & cv_references)
    setCVReferences = function(cv_references){
    
        if(!(is_list(cv_references) && all(sapply(cv_references,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVReference")))){ stop("arg cv_references wrong type") }
        v0 <- r_to_py(cv_references)
        private$py_obj$setCVReferences(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(cv_references <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[CVReference] getCVReferences()
    getCVReferences = function(){
    
        py_ans = private$py_obj$getCVReferences()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addCVReference(CVReference & cv_reference)
    addCVReference = function(cv_reference){
    
        if(!(is.R6(cv_reference) && class(cv_reference)[1] == "CVReference")){ stop("arg cv_reference wrong type") }
    
        private$py_obj$addCVReference(cv_reference)
        invisible()
    },
    
    # C++ signature: bool hasCVReference(const String & identifier)
    hasCVReference = function(identifier){
    
        if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
    
        py_ans = private$py_obj$hasCVReference(identifier)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CVReference
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVReference.html
CVReference <- R6Class(classname = "CVReference",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVReference()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVReference()
        invisible()
    
    
    },
    
    # C++ signature: void CVReference(CVReference)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVReference")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVReference(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVReference()
    # C++ signature: void CVReference(CVReference)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVReference")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVReference" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setName(const String & name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(const String & identifier)
    setIdentifier = function(identifier){
    
        if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
    
        private$py_obj$setIdentifier(identifier)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CVTerm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVTerm.html
CVTerm <- R6Class(classname = "CVTerm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVTerm()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVTerm()
        invisible()
    
    
    },
    
    # C++ signature: void CVTerm(CVTerm)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVTerm")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVTerm(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVTerm()
    # C++ signature: void CVTerm(CVTerm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVTerm")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVTerm" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setAccession(String accession)
    setAccession = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        private$py_obj$setAccession(accession)
        invisible()
    },
    
    # C++ signature: String getAccession()
    getAccession = function(){
    
        py_ans = private$py_obj$getAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVIdentifierRef(String cv_id_ref)
    setCVIdentifierRef = function(cv_id_ref){
    
        if(!((is.R6(cv_id_ref) && class(cv_id_ref)[1]=="String") || is_scalar_character(cv_id_ref))){ stop("arg cv_id_ref wrong type") }
    
        private$py_obj$setCVIdentifierRef(cv_id_ref)
        invisible()
    },
    
    # C++ signature: String getCVIdentifierRef()
    getCVIdentifierRef = function(){
    
        py_ans = private$py_obj$getCVIdentifierRef()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DataValue getValue()
    getValue = function(){
    
        py_ans = private$py_obj$getValue()
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setValue(DataValue value)
    setValue = function(value){
    
        if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
    
        private$py_obj$setValue(value)
        invisible()
    },
    
    # C++ signature: void setUnit(Unit & unit)
    setUnit = function(unit){
    
        if(!(is.R6(unit) && class(unit)[1] == "Unit")){ stop("arg unit wrong type") }
    
        private$py_obj$setUnit(unit)
        invisible()
    },
    
    # C++ signature: Unit getUnit()
    getUnit = function(){
    
        py_ans = private$py_obj$getUnit()
        r_ans = Unit$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasValue()
    hasValue = function(){
    
        py_ans = private$py_obj$hasValue()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasUnit()
    hasUnit = function(){
    
        py_ans = private$py_obj$hasUnit()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CVTermList
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVTermList.html
CVTermList <- R6Class(classname = "CVTermList",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVTermList()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVTermList()
        invisible()
    
    
    },
    
    # C++ signature: void CVTermList(CVTermList)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVTermList")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVTermList(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVTermList()
    # C++ signature: void CVTermList(CVTermList)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVTermList")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVTermList" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _CVTermListInterface
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVTermListInterface.html
CVTermListInterface <- R6Class(classname = "CVTermListInterface",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CVTermListInterface()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVTermListInterface()
        invisible()
    
    
    },
    
    # C++ signature: void CVTermListInterface(CVTermListInterface)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CVTermListInterface")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CVTermListInterface(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CVTermListInterface()
    # C++ signature: void CVTermListInterface(CVTermListInterface)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVTermListInterface")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVTermListInterface" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] & cv_terms)
    replaceCVTerms_0 = function(cv_terms){
    
        if(!(
          is.environment(cv_terms) && identical(parent.env(cv_terms), asNamespace("collections")) && identical(strsplit(capture.output(cv_terms$print())," ")[[1]][1], "dict")
          && all(sapply(cv_terms$keys(),is_scalar_character))
          && all(sapply(cv_terms$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_terms wrong type") }
        map_0 <- py_dict(cv_terms$values(),modify_depth(cv_terms$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$`_replaceCVTerms_0`(map_0)
        byref_0 <- collections::dict(lapply(py_to_r(py_builtin$list(map_0$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(map_0$keys())),as.character))
    
        tryCatch({
        eval.parent(substitute(cv_terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] & cv_terms, const String & accession)
    replaceCVTerms_1 = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$`_replaceCVTerms_1`(v0, accession)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(cv_terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] & cv_terms)
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] & cv_terms, const String & accession)
    replaceCVTerms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (
          is.environment(arg_list[[1]]) && identical(parent.env(arg_list[[1]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[1]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[1]]$keys(),is_scalar_character))
          && all(sapply(arg_list[[1]]$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )) { self$replaceCVTerms_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$replaceCVTerms_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & cv_term)
    replaceCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$replaceCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] & cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        byref_0 <- collections::dict(lapply(py_to_r(py_builtin$list(map_0$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(map_0$keys())),as.character))
    
        tryCatch({
        eval.parent(substitute(cv_term_map <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(const String & accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _CVTerm_ControlledVocabulary
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CVTerm_ControlledVocabulary.html
CVTerm_ControlledVocabulary <- R6Class(classname = "CVTerm_ControlledVocabulary",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        parents = function(parents){
    
        if(!missing(parents)){
            if(!(is_list(parents) && all(sapply(parents),is_scalar_character) && !any(duplicated(parents) == T))){ stop("arg parents wrong type") }
        
            v0 = py_builtin$set(modify_depth(parents,1,py_builtin$bytes(parents,'utf-8')))
            private$py_obj$parents <- v0
            } else {
        
                py_ans = private$py_obj$parents
            r_result = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
                return(r_result)
                }
        },
        children = function(children){
    
        if(!missing(children)){
            if(!(is_list(children) && all(sapply(children),is_scalar_character) && !any(duplicated(children) == T))){ stop("arg children wrong type") }
        
            v0 = py_builtin$set(modify_depth(children,1,py_builtin$bytes(children,'utf-8')))
            private$py_obj$children <- v0
            } else {
        
                py_ans = private$py_obj$children
            r_result = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
                return(r_result)
                }
        },
        obsolete = function(obsolete){
    
        if(!missing(obsolete)){
            if(!( (is_scalar_integer(obsolete) || is_scalar_double(obsolete)) && obsolete == as.integer(obsolete))){ stop("arg obsolete wrong type") }
        
        
            private$py_obj$obsolete <- as.integer(obsolete)
            } else {
        
                py_ans = private$py_obj$obsolete
                r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        synonyms = function(synonyms){
    
        if(!missing(synonyms)){
            if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character))){ stop("arg synonyms wrong type") }
        
            v0 = r_to_py(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
            private$py_obj$synonyms <- v0
            } else {
        
                py_ans = private$py_obj$synonyms
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        unparsed = function(unparsed){
    
        if(!missing(unparsed)){
            if(!(is_list(unparsed) && all(sapply(unparsed),is_scalar_character))){ stop("arg unparsed wrong type") }
        
            v0 = r_to_py(modify_depth(unparsed,1,py_builtin$bytes(unparsed,'utf-8')))
            private$py_obj$unparsed <- v0
            } else {
        
                py_ans = private$py_obj$unparsed
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        xref_type = function(xref_type){
    
        if(!missing(xref_type)){
            if(!(xref_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))){ stop("arg xref_type wrong type") }
        
        
            private$py_obj$xref_type <- as.integer(xref_type)
            } else {
        
                py_ans = private$py_obj$xref_type
                r_result = py_ans
                return(r_result)
                }
        },
        xref_binary = function(xref_binary){
    
        if(!missing(xref_binary)){
            if(!(is_list(xref_binary) && all(sapply(xref_binary),is_scalar_character))){ stop("arg xref_binary wrong type") }
        
            v0 = r_to_py(modify_depth(xref_binary,1,py_builtin$bytes(xref_binary,'utf-8')))
            private$py_obj$xref_binary <- v0
            } else {
        
                py_ans = private$py_obj$xref_binary
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        units = function(units){
    
        if(!missing(units)){
            if(!(is_list(units) && all(sapply(units),is_scalar_character) && !any(duplicated(units) == T))){ stop("arg units wrong type") }
        
            v0 = py_builtin$set(modify_depth(units,1,py_builtin$bytes(units,'utf-8')))
            private$py_obj$units <- v0
            } else {
        
                py_ans = private$py_obj$units
            r_result = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CVTerm_ControlledVocabulary()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CVTerm_ControlledVocabulary()
        invisible()
    
    
    },
    
    # C++ signature: void CVTerm_ControlledVocabulary(CVTerm_ControlledVocabulary rhs)
    init_1 = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "CVTerm_ControlledVocabulary")){ stop("arg rhs wrong type") }
    
    
        private$py_obj <- Pymod$CVTerm_ControlledVocabulary(rhs)
        invisible()
    
    
    },
    
    # C++ signature: void CVTerm_ControlledVocabulary()
    # C++ signature: void CVTerm_ControlledVocabulary(CVTerm_ControlledVocabulary rhs)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CVTerm_ControlledVocabulary")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CVTerm_ControlledVocabulary" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String toXMLString(String ref, String value)
    toXMLString_0 = function(ref, value){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
    
        py_ans = private$py_obj$`_toXMLString_0`(ref, value)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toXMLString(String ref, DataValue value)
    toXMLString_1 = function(ref, value){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
        if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
    
    
        py_ans = private$py_obj$`_toXMLString_1`(ref, value)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toXMLString(String ref, String value)
    # C++ signature: String toXMLString(String ref, DataValue value)
    toXMLString = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$toXMLString_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$toXMLString_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getXRefTypeName(XRefType_CVTerm_ControlledVocabulary type)
    getXRefTypeName = function(type){
    
        if(!(type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))){ stop("arg type wrong type") }
    
        py_ans = private$py_obj$getXRefTypeName(as.integer(type))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isHigherBetterScore(CVTerm_ControlledVocabulary term)
    isHigherBetterScore = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm_ControlledVocabulary")){ stop("arg term wrong type") }
    
        py_ans = private$py_obj$isHigherBetterScore(term)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CachedMzMLHandler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1CachedMzMLHandler.html
CachedMzMLHandler <- R6Class(classname = "CachedMzMLHandler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CachedMzMLHandler()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CachedMzMLHandler()
        invisible()
    
    
    },
    
    # C++ signature: void CachedMzMLHandler(CachedMzMLHandler)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CachedMzMLHandler")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CachedMzMLHandler(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CachedMzMLHandler()
    # C++ signature: void CachedMzMLHandler(CachedMzMLHandler)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CachedMzMLHandler")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CachedMzMLHandler" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void writeMemdump(MSExperiment exp, String out)
    writeMemdump = function(exp, out){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!((is.R6(out) && class(out)[1]=="String") || is_scalar_character(out))){ stop("arg out wrong type") }
    
    
        private$py_obj$writeMemdump(exp, out)
        invisible()
    },
    
    # C++ signature: void writeMetadata(MSExperiment exp, String out_meta)
    writeMetadata = function(exp, out_meta){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!((is.R6(out_meta) && class(out_meta)[1]=="String") || is_scalar_character(out_meta))){ stop("arg out_meta wrong type") }
    
    
        private$py_obj$writeMetadata(exp, out_meta)
        invisible()
    },
    
    # C++ signature: void readMemdump(MSExperiment exp, String filename)
    readMemdump = function(exp, filename){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj$readMemdump(exp, filename)
        invisible()
    },
    
    # C++ signature: libcpp_vector[streampos] getSpectraIndex()
    getSpectraIndex = function(){
    
        py_ans = private$py_obj$getSpectraIndex()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[streampos] getChromatogramIndex()
    getChromatogramIndex = function(){
    
        py_ans = private$py_obj$getChromatogramIndex()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void createMemdumpIndex(String filename)
    createMemdumpIndex = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$createMemdumpIndex(filename)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _CachedSwathFileConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CachedSwathFileConsumer.html
CachedSwathFileConsumer <- R6Class(classname = "CachedSwathFileConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CachedSwathFileConsumer(String cachedir, String basename, size_t nr_ms1_spectra, libcpp_vector[int] nr_ms2_spectra)
    initialize = function(cachedir, basename, nr_ms1_spectra, nr_ms2_spectra){
    
    if(missing(basename) && missing(nr_ms1_spectra) && missing(nr_ms2_spectra)){
         if( "python.builtin.object" %in% class(cachedir) && class_to_wrap(cachedir) == CachedSwathFileConsumer ) { private$py_obj <- cachedir }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(cachedir) && class(cachedir)[1]=="String") || is_scalar_character(cachedir))){ stop("arg cachedir wrong type") }
        if(!((is.R6(basename) && class(basename)[1]=="String") || is_scalar_character(basename))){ stop("arg basename wrong type") }
        if(!( (is_scalar_integer(nr_ms1_spectra) || is_scalar_double(nr_ms1_spectra)) && nr_ms1_spectra == as.integer(nr_ms1_spectra))){ stop("arg nr_ms1_spectra wrong type") }
        if(!(is_list(nr_ms2_spectra) && all(sapply(nr_ms2_spectra,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg nr_ms2_spectra wrong type") }
    
    
    
        v3 <- r_to_py(modify_depth(nr_ms2_spectra,1,as.integer))
    
        private$py_obj <- Pymod$CachedSwathFileConsumer(cachedir, basename, as.integer(nr_ms1_spectra), v3)
        invisible()
    }
        
    
    },
    
    # C++ signature: void setExpectedSize(size_t s, size_t c)
    setExpectedSize = function(s, c){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(s), as.integer(c))
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void retrieveSwathMaps(libcpp_vector[SwathMap] & maps)
    retrieveSwathMaps = function(maps){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg maps wrong type") }
        v0 <- r_to_py(maps)
        private$py_obj$retrieveSwathMaps(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    }
)
) 

# R implementation of _CachedmzML
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CachedmzML.html
CachedmzML <- R6Class(classname = "CachedmzML",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CachedmzML()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CachedmzML()
        invisible()
    
    
    },
    
    # C++ signature: void CachedmzML(CachedmzML)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CachedmzML")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CachedmzML(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CachedmzML(String filename)
    init_2 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$CachedmzML(filename)
        invisible()
    
    
    },
    
    # C++ signature: void CachedmzML()
    # C++ signature: void CachedmzML(CachedmzML)
    # C++ signature: void CachedmzML(String filename)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CachedmzML")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CachedmzML" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum getSpectrum(size_t idx)
    getSpectrum = function(idx){
    
        if(!( (is_scalar_integer(idx) || is_scalar_double(idx)) && idx == as.integer(idx))){ stop("arg idx wrong type") }
    
        py_ans = private$py_obj$getSpectrum(as.integer(idx))
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSChromatogram getChromatogram(size_t idx)
    getChromatogram = function(idx){
    
        if(!( (is_scalar_integer(idx) || is_scalar_double(idx)) && idx == as.integer(idx))){ stop("arg idx wrong type") }
    
        py_ans = private$py_obj$getChromatogram(as.integer(idx))
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSExperiment getMetaData()
    getMetaData = function(){
    
        py_ans = private$py_obj$getMetaData()
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    }
)
)
    
    # C++ signature: void load(const String & filename, CachedmzML & exp)
    CachedmzML$load = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "CachedmzML")){ stop("arg exp wrong type") }
    
    
        Pymod$CachedmzML$load(filename, exp)
    }
    
    # C++ signature: void store(const String & filename, MSExperiment exp)
    CachedmzML$store = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        Pymod$CachedmzML$store(filename, exp)
    } 

# R implementation of _CalibrationData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CalibrationData.html
CalibrationData <- R6Class(classname = "CalibrationData",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CalibrationData()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CalibrationData()
        invisible()
    
    
    },
    
    # C++ signature: void CalibrationData(CalibrationData &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CalibrationData")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CalibrationData(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CalibrationData()
    # C++ signature: void CalibrationData(CalibrationData &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CalibrationData")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CalibrationData" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMZ(size_t)
    getMZ = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMZ(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT(size_t)
    getRT = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getRT(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getIntensity(size_t)
    getIntensity = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getIntensity(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void setUsePPM(bool)
    setUsePPM = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setUsePPM(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool usePPM()
    usePPM = function(){
    
        py_ans = private$py_obj$usePPM()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void insertCalibrationPoint(double rt, double mz_obs, float intensity, double mz_ref, double weight, int group)
    insertCalibrationPoint = function(rt, mz_obs, intensity, mz_ref, weight, group){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        if(!(is_scalar_double(mz_obs))){ stop("arg mz_obs wrong type") }
        if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        if(!(is_scalar_double(mz_ref))){ stop("arg mz_ref wrong type") }
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
        if(!( (is_scalar_integer(group) || is_scalar_double(group)) && group == as.integer(group))){ stop("arg group wrong type") }
    
    
    
    
    
    
        private$py_obj$insertCalibrationPoint(rt, mz_obs, intensity, mz_ref, weight, as.integer(group))
        invisible()
    },
    
    # C++ signature: size_t getNrOfGroups()
    getNrOfGroups = function(){
    
        py_ans = private$py_obj$getNrOfGroups()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getError(size_t)
    getError = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getError(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRefMZ(size_t)
    getRefMZ = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getRefMZ(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getWeight(size_t)
    getWeight = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getWeight(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getGroup(size_t i)
    getGroup = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getGroup(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: CalibrationData median(double, double)
    median = function(in_0, in_1){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$median(in_0, in_1)
        r_ans = CalibrationData$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void sortByRT()
    sortByRT = function(){
    
        private$py_obj$sortByRT()
        invisible()
    }
)
)
    
    # C++ signature: StringList getMetaValues()
    CalibrationData$getMetaValues = function(){
    
        py_ans = Pymod$CalibrationData$getMetaValues()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    } 

# R implementation of _ChannelInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChannelInfo.html
ChannelInfo <- R6Class(classname = "ChannelInfo",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        description = function(description){
    
        if(!missing(description)){
            if(!(is_scalar_character(description))){ stop("arg description wrong type") }
        
        description_0 = py_builtin$bytes(description,'utf-8')
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        name = function(name){
    
        if(!missing(name)){
            if(!( (is_scalar_integer(name) || is_scalar_double(name)) && name == as.integer(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- as.integer(name)
            } else {
        
                py_ans = private$py_obj$name
                r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- as.integer(id)
            } else {
        
                py_ans = private$py_obj$id
                r_result = py_ans
                return(r_result)
                }
        },
        center = function(center){
    
        if(!missing(center)){
            if(!(is_scalar_double(center))){ stop("arg center wrong type") }
        
        
            private$py_obj$center <- center
            } else {
        
                py_ans = private$py_obj$center
                r_result = py_ans
                return(r_result)
                }
        },
        active = function(active){
    
        if(!missing(active)){
            if(!( (is_scalar_integer(active) || is_scalar_double(active)) && active == as.integer(active))){ stop("arg active wrong type") }
        
        
            private$py_obj$active <- as.integer(active)
            } else {
        
                py_ans = private$py_obj$active
                r_result = py_ans
                return(r_result)
                }
        }

    )
) 

# R implementation of _ChargePair
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChargePair.html
ChargePair <- R6Class(classname = "ChargePair",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChargePair()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChargePair()
        invisible()
    
    
    },
    
    # C++ signature: void ChargePair(ChargePair)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChargePair")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChargePair(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChargePair(size_t index0, size_t index1, int charge0, int charge1, Compomer compomer, double mass_diff, bool active)
    init_2 = function(index0, index1, charge0, charge1, compomer, mass_diff, active){
    
        if(!( (is_scalar_integer(index0) || is_scalar_double(index0)) && index0 == as.integer(index0))){ stop("arg index0 wrong type") }
        if(!( (is_scalar_integer(index1) || is_scalar_double(index1)) && index1 == as.integer(index1))){ stop("arg index1 wrong type") }
        if(!( (is_scalar_integer(charge0) || is_scalar_double(charge0)) && charge0 == as.integer(charge0))){ stop("arg charge0 wrong type") }
        if(!( (is_scalar_integer(charge1) || is_scalar_double(charge1)) && charge1 == as.integer(charge1))){ stop("arg charge1 wrong type") }
        if(!(is.R6(compomer) && class(compomer)[1] == "Compomer")){ stop("arg compomer wrong type") }
        if(!(is_scalar_double(mass_diff))){ stop("arg mass_diff wrong type") }
        if(!( (is_scalar_integer(active) || is_scalar_double(active)) && active == as.integer(active))){ stop("arg active wrong type") }
    
    
    
    
    
    
    
    
        private$py_obj <- Pymod$ChargePair(as.integer(index0), as.integer(index1), as.integer(charge0), as.integer(charge1), compomer, mass_diff, as.integer(active))
        invisible()
    
    
    },
    
    # C++ signature: void ChargePair()
    # C++ signature: void ChargePair(ChargePair)
    # C++ signature: void ChargePair(size_t index0, size_t index1, int charge0, int charge1, Compomer compomer, double mass_diff, bool active)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChargePair")) { self$init_1(...) }
        else if ((length(arg_list)==7) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && (is.R6(arg_list[[5]]) && class(arg_list[[5]])[1] == "Compomer") && (is_scalar_double(arg_list[[6]])) && ( (is_scalar_integer(arg_list[[7]]) || is_scalar_double(arg_list[[7]])) && arg_list[[7]] == as.integer(arg_list[[7]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChargePair" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int getCharge(unsigned int pairID)
    getCharge = function(pairID){
    
        if(!( (is_scalar_integer(pairID) || is_scalar_double(pairID)) && pairID == as.integer(pairID))){ stop("arg pairID wrong type") }
    
        py_ans = private$py_obj$getCharge(as.integer(pairID))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(unsigned int pairID, int e)
    setCharge = function(pairID, e){
    
        if(!( (is_scalar_integer(pairID) || is_scalar_double(pairID)) && pairID == as.integer(pairID))){ stop("arg pairID wrong type") }
        if(!( (is_scalar_integer(e) || is_scalar_double(e)) && e == as.integer(e))){ stop("arg e wrong type") }
    
    
        private$py_obj$setCharge(as.integer(pairID), as.integer(e))
        invisible()
    },
    
    # C++ signature: size_t getElementIndex(unsigned int pairID)
    getElementIndex = function(pairID){
    
        if(!( (is_scalar_integer(pairID) || is_scalar_double(pairID)) && pairID == as.integer(pairID))){ stop("arg pairID wrong type") }
    
        py_ans = private$py_obj$getElementIndex(as.integer(pairID))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setElementIndex(unsigned int pairID, size_t e)
    setElementIndex = function(pairID, e){
    
        if(!( (is_scalar_integer(pairID) || is_scalar_double(pairID)) && pairID == as.integer(pairID))){ stop("arg pairID wrong type") }
        if(!( (is_scalar_integer(e) || is_scalar_double(e)) && e == as.integer(e))){ stop("arg e wrong type") }
    
    
        private$py_obj$setElementIndex(as.integer(pairID), as.integer(e))
        invisible()
    },
    
    # C++ signature: Compomer getCompomer()
    getCompomer = function(){
    
        py_ans = private$py_obj$getCompomer()
        r_ans = Compomer$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setCompomer(Compomer & compomer)
    setCompomer = function(compomer){
    
        if(!(is.R6(compomer) && class(compomer)[1] == "Compomer")){ stop("arg compomer wrong type") }
    
        private$py_obj$setCompomer(compomer)
        invisible()
    },
    
    # C++ signature: double getMassDiff()
    getMassDiff = function(){
    
        py_ans = private$py_obj$getMassDiff()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMassDiff(double mass_diff)
    setMassDiff = function(mass_diff){
    
        if(!(is_scalar_double(mass_diff))){ stop("arg mass_diff wrong type") }
    
        private$py_obj$setMassDiff(mass_diff)
        invisible()
    },
    
    # C++ signature: double getEdgeScore()
    getEdgeScore = function(){
    
        py_ans = private$py_obj$getEdgeScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEdgeScore(double score)
    setEdgeScore = function(score){
    
        if(!(is_scalar_double(score))){ stop("arg score wrong type") }
    
        private$py_obj$setEdgeScore(score)
        invisible()
    },
    
    # C++ signature: bool isActive()
    isActive = function(){
    
        py_ans = private$py_obj$isActive()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setActive(bool active)
    setActive = function(active){
    
        if(!( (is_scalar_integer(active) || is_scalar_double(active)) && active == as.integer(active))){ stop("arg active wrong type") }
    
        private$py_obj$setActive(as.integer(active))
        invisible()
    }
)
) 

# R implementation of _ChargedIndexSet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChargedIndexSet.html
ChargedIndexSet <- R6Class(classname = "ChargedIndexSet",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ChargedIndexSet()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ChargedIndexSet) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ChargedIndexSet()
        invisible()
    }
    
    }
)
) 

# R implementation of _ChromatogramExtractor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChromatogramExtractor.html
ChromatogramExtractor <- R6Class(classname = "ChromatogramExtractor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromatogramExtractor()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChromatogramExtractor()
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramExtractor(ChromatogramExtractor)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromatogramExtractor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChromatogramExtractor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramExtractor()
    # C++ signature: void ChromatogramExtractor(ChromatogramExtractor)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChromatogramExtractor")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChromatogramExtractor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void extractChromatograms(MSExperiment & input, MSExperiment & output, TargetedExperiment & transition_exp, double extract_window, bool ppm, TransformationDescription trafo, double rt_extraction_window, String filter)
    extractChromatograms = function(input, output, transition_exp, extract_window, ppm, trafo, rt_extraction_window, filter){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
        if(!(is.R6(transition_exp) && class(transition_exp)[1] == "TargetedExperiment")){ stop("arg transition_exp wrong type") }
        if(!(is_scalar_double(extract_window))){ stop("arg extract_window wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "TransformationDescription")){ stop("arg trafo wrong type") }
        if(!(is_scalar_double(rt_extraction_window))){ stop("arg rt_extraction_window wrong type") }
        if(!((is.R6(filter) && class(filter)[1]=="String") || is_scalar_character(filter))){ stop("arg filter wrong type") }
    
    
    
    
    
    
    
    
        private$py_obj$extractChromatograms(input, output, transition_exp, extract_window, as.integer(ppm), trafo, rt_extraction_window, filter)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _ChromatogramExtractorAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChromatogramExtractorAlgorithm.html
ChromatogramExtractorAlgorithm <- R6Class(classname = "ChromatogramExtractorAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromatogramExtractorAlgorithm()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChromatogramExtractorAlgorithm()
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramExtractorAlgorithm(ChromatogramExtractorAlgorithm)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromatogramExtractorAlgorithm")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChromatogramExtractorAlgorithm(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramExtractorAlgorithm()
    # C++ signature: void ChromatogramExtractorAlgorithm(ChromatogramExtractorAlgorithm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChromatogramExtractorAlgorithm")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChromatogramExtractorAlgorithm" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMS] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    extractChromatograms_0 = function(input, output, extraction_coordinates, mz_extraction_window, ppm, im_extraction_window, filter){
    
        if(!(all(class(input) == c('SpectrumAccessOpenMS','R6')))){ stop("arg input wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6')))))){ stop("arg output wrong type") }
        if(!(is_list(extraction_coordinates) && all(sapply(extraction_coordinates,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates")))){ stop("arg extraction_coordinates wrong type") }
        if(!(is_scalar_double(mz_extraction_window))){ stop("arg mz_extraction_window wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_scalar_double(im_extraction_window))){ stop("arg im_extraction_window wrong type") }
        if(!((is.R6(filter) && class(filter)[1]=="String") || is_scalar_character(filter))){ stop("arg filter wrong type") }
        input_input <- r_to_py(input)
        v1 <- r_to_py(output)
        v2 <- r_to_py(extraction_coordinates)
    
    
    
    
        private$py_obj$`_extractChromatograms_0`(input_input, v1, v2, mz_extraction_window, as.integer(ppm), im_extraction_window, filter)
        
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(OSChromatogram,"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMSCached] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    extractChromatograms_1 = function(input, output, extraction_coordinates, mz_extraction_window, ppm, im_extraction_window, filter){
    
        if(!(all(class(input) == c('SpectrumAccessOpenMSCached','R6')))){ stop("arg input wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6')))))){ stop("arg output wrong type") }
        if(!(is_list(extraction_coordinates) && all(sapply(extraction_coordinates,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates")))){ stop("arg extraction_coordinates wrong type") }
        if(!(is_scalar_double(mz_extraction_window))){ stop("arg mz_extraction_window wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_scalar_double(im_extraction_window))){ stop("arg im_extraction_window wrong type") }
        if(!((is.R6(filter) && class(filter)[1]=="String") || is_scalar_character(filter))){ stop("arg filter wrong type") }
        input_input <- r_to_py(input)
        v1 <- r_to_py(output)
        v2 <- r_to_py(extraction_coordinates)
    
    
    
    
        private$py_obj$`_extractChromatograms_1`(input_input, v1, v2, mz_extraction_window, as.integer(ppm), im_extraction_window, filter)
        
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(OSChromatogram,"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMSInMemory] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    extractChromatograms_2 = function(input, output, extraction_coordinates, mz_extraction_window, ppm, im_extraction_window, filter){
    
        if(!(all(class(input) == c('SpectrumAccessOpenMSInMemory','R6')))){ stop("arg input wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6')))))){ stop("arg output wrong type") }
        if(!(is_list(extraction_coordinates) && all(sapply(extraction_coordinates,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates")))){ stop("arg extraction_coordinates wrong type") }
        if(!(is_scalar_double(mz_extraction_window))){ stop("arg mz_extraction_window wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_scalar_double(im_extraction_window))){ stop("arg im_extraction_window wrong type") }
        if(!((is.R6(filter) && class(filter)[1]=="String") || is_scalar_character(filter))){ stop("arg filter wrong type") }
        input_input <- r_to_py(input)
        v1 <- r_to_py(output)
        v2 <- r_to_py(extraction_coordinates)
    
    
    
    
        private$py_obj$`_extractChromatograms_2`(input_input, v1, v2, mz_extraction_window, as.integer(ppm), im_extraction_window, filter)
        
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(OSChromatogram,"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessQuadMZTransforming] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    extractChromatograms_3 = function(input, output, extraction_coordinates, mz_extraction_window, ppm, im_extraction_window, filter){
    
        if(!(all(class(input) == c('SpectrumAccessQuadMZTransforming','R6')))){ stop("arg input wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6')))))){ stop("arg output wrong type") }
        if(!(is_list(extraction_coordinates) && all(sapply(extraction_coordinates,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates")))){ stop("arg extraction_coordinates wrong type") }
        if(!(is_scalar_double(mz_extraction_window))){ stop("arg mz_extraction_window wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_scalar_double(im_extraction_window))){ stop("arg im_extraction_window wrong type") }
        if(!((is.R6(filter) && class(filter)[1]=="String") || is_scalar_character(filter))){ stop("arg filter wrong type") }
        input_input <- r_to_py(input)
        v1 <- r_to_py(output)
        v2 <- r_to_py(extraction_coordinates)
    
    
    
    
        private$py_obj$`_extractChromatograms_3`(input_input, v1, v2, mz_extraction_window, as.integer(ppm), im_extraction_window, filter)
        
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(OSChromatogram,"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMS] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMSCached] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessOpenMSInMemory] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    # C++ signature: void extractChromatograms(shared_ptr[SpectrumAccessQuadMZTransforming] input, libcpp_vector[shared_ptr[OSChromatogram]] & output, libcpp_vector[ExtractionCoordinates] extraction_coordinates, double mz_extraction_window, bool ppm, double im_extraction_window, String filter)
    extractChromatograms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==7) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMS','R6'))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6'))))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates"))) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is_scalar_double(arg_list[[6]])) && ((is.R6(arg_list[[7]]) && class(arg_list[[7]])[1]=="String") || is_scalar_character(arg_list[[7]]))) { self$extractChromatograms_0(...) }
        else if ((length(arg_list)==7) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMSCached','R6'))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6'))))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates"))) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is_scalar_double(arg_list[[6]])) && ((is.R6(arg_list[[7]]) && class(arg_list[[7]])[1]=="String") || is_scalar_character(arg_list[[7]]))) { self$extractChromatograms_1(...) }
        else if ((length(arg_list)==7) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMSInMemory','R6'))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6'))))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates"))) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is_scalar_double(arg_list[[6]])) && ((is.R6(arg_list[[7]]) && class(arg_list[[7]])[1]=="String") || is_scalar_character(arg_list[[7]]))) { self$extractChromatograms_2(...) }
        else if ((length(arg_list)==7) && (all(class(arg_list[[1]]) == c('SpectrumAccessQuadMZTransforming','R6'))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) all(class(elemt_rec) == c('OSChromatogram','R6'))))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExtractionCoordinates"))) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is_scalar_double(arg_list[[6]])) && ((is.R6(arg_list[[7]]) && class(arg_list[[7]])[1]=="String") || is_scalar_character(arg_list[[7]]))) { self$extractChromatograms_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _ChromatogramPeak
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ChromatogramPeak_1_1ChromatogramPeak.html
ChromatogramPeak <- R6Class(classname = "ChromatogramPeak",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromatogramPeak()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChromatogramPeak()
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramPeak(ChromatogramPeak &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromatogramPeak")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChromatogramPeak(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramPeak(DPosition1 retention_time, double intensity)
    init_2 = function(retention_time, intensity){
    
        if(!(is.R6(retention_time) && class(retention_time)[1] == "DPosition1")){ stop("arg retention_time wrong type") }
        if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
    
    
    
        private$py_obj <- Pymod$ChromatogramPeak(retention_time, intensity)
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramPeak()
    # C++ signature: void ChromatogramPeak(ChromatogramPeak &)
    # C++ signature: void ChromatogramPeak(DPosition1 retention_time, double intensity)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChromatogramPeak")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DPosition1") && (is_scalar_double(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChromatogramPeak" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIntensity(double)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: DPosition1 getPosition()
    getPosition = function(){
    
        py_ans = private$py_obj$getPosition()
        r_ans = DPosition1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPosition(DPosition1)
    setPosition = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DPosition1")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPosition(in_0)
        invisible()
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: double getPos()
    getPos = function(){
    
        py_ans = private$py_obj$getPos()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPos(double)
    setPos = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPos(in_0)
        invisible()
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    }
)
) 

# R implementation of _ChromatogramSettings
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChromatogramSettings.html

# Description of the chromatogram settings, provides meta-information
# about a single chromatogram.
ChromatogramSettings <- R6Class(classname = "ChromatogramSettings",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromatogramSettings()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChromatogramSettings()
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramSettings(ChromatogramSettings)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromatogramSettings")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChromatogramSettings(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChromatogramSettings()
    # C++ signature: void ChromatogramSettings(ChromatogramSettings)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChromatogramSettings")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChromatogramSettings" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: Product getProduct()
# Access to the product ion
    getProduct = function(){
    
        py_ans = private$py_obj$getProduct()
        r_ans = Product$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setProduct(Product p)
# Set the product ion
    setProduct = function(p){
    
        if(!(is.R6(p) && class(p)[1] == "Product")){ stop("arg p wrong type") }
    
        private$py_obj$setProduct(p)
        invisible()
    },
    
    # C++ signature: String getNativeID()
# returns the native identifier for the spectrum, used by the acquisition software.
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeID(String native_id)
# sets the native identifier for the spectrum, used by the acquisition software.
    setNativeID = function(native_id){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
    
        private$py_obj$setNativeID(native_id)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: InstrumentSettings getInstrumentSettings()
    getInstrumentSettings = function(){
    
        py_ans = private$py_obj$getInstrumentSettings()
        r_ans = InstrumentSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrumentSettings(InstrumentSettings instrument_settings)
    setInstrumentSettings = function(instrument_settings){
    
        if(!(is.R6(instrument_settings) && class(instrument_settings)[1] == "InstrumentSettings")){ stop("arg instrument_settings wrong type") }
    
        private$py_obj$setInstrumentSettings(instrument_settings)
        invisible()
    },
    
    # C++ signature: AcquisitionInfo getAcquisitionInfo()
    getAcquisitionInfo = function(){
    
        py_ans = private$py_obj$getAcquisitionInfo()
        r_ans = AcquisitionInfo$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAcquisitionInfo(AcquisitionInfo acquisition_info)
    setAcquisitionInfo = function(acquisition_info){
    
        if(!(is.R6(acquisition_info) && class(acquisition_info)[1] == "AcquisitionInfo")){ stop("arg acquisition_info wrong type") }
    
        private$py_obj$setAcquisitionInfo(acquisition_info)
        invisible()
    },
    
    # C++ signature: SourceFile getSourceFile()
    getSourceFile = function(){
    
        py_ans = private$py_obj$getSourceFile()
        r_ans = SourceFile$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSourceFile(SourceFile source_file)
    setSourceFile = function(source_file){
    
        if(!(is.R6(source_file) && class(source_file)[1] == "SourceFile")){ stop("arg source_file wrong type") }
    
        private$py_obj$setSourceFile(source_file)
        invisible()
    },
    
    # C++ signature: Precursor getPrecursor()
    getPrecursor = function(){
    
        py_ans = private$py_obj$getPrecursor()
        r_ans = Precursor$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPrecursor(Precursor precursor)
    setPrecursor = function(precursor){
    
        if(!(is.R6(precursor) && class(precursor)[1] == "Precursor")){ stop("arg precursor wrong type") }
    
        private$py_obj$setPrecursor(precursor)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: void setChromatogramType(ChromatogramType type)
    setChromatogramType = function(type){
    
        if(!(type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type wrong type") }
    
        private$py_obj$setChromatogramType(as.integer(type))
        invisible()
    },
    
    # C++ signature: ChromatogramType getChromatogramType()
    getChromatogramType = function(){
    
        py_ans = private$py_obj$getChromatogramType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ChromatogramTools
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChromatogramTools.html
ChromatogramTools <- R6Class(classname = "ChromatogramTools",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromatogramTools()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ChromatogramTools) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ChromatogramTools()
        invisible()
    }
    
    },
    
    # C++ signature: void convertChromatogramsToSpectra(MSExperiment & epx)
    convertChromatogramsToSpectra = function(epx){
    
        if(!(is.R6(epx) && class(epx)[1] == "MSExperiment")){ stop("arg epx wrong type") }
    
        private$py_obj$convertChromatogramsToSpectra(epx)
        invisible()
    },
    
    # C++ signature: void convertSpectraToChromatograms(MSExperiment & epx, bool remove_spectra, bool force_conversion)
    convertSpectraToChromatograms = function(epx, remove_spectra, force_conversion){
    
        if(!(is.R6(epx) && class(epx)[1] == "MSExperiment")){ stop("arg epx wrong type") }
        if(!( (is_scalar_integer(remove_spectra) || is_scalar_double(remove_spectra)) && remove_spectra == as.integer(remove_spectra))){ stop("arg remove_spectra wrong type") }
        if(!( (is_scalar_integer(force_conversion) || is_scalar_double(force_conversion)) && force_conversion == as.integer(force_conversion))){ stop("arg force_conversion wrong type") }
    
    
    
        private$py_obj$convertSpectraToChromatograms(epx, as.integer(remove_spectra), as.integer(force_conversion))
        invisible()
    }
)
) 

# R implementation of _ChromeleonFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ChromeleonFile.html
ChromeleonFile <- R6Class(classname = "ChromeleonFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ChromeleonFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ChromeleonFile()
        invisible()
    
    
    },
    
    # C++ signature: void ChromeleonFile(ChromeleonFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromeleonFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ChromeleonFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ChromeleonFile()
    # C++ signature: void ChromeleonFile(ChromeleonFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ChromeleonFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ChromeleonFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & experiment)
    load = function(filename, experiment){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
    
    
        private$py_obj$load(filename, experiment)
        invisible()
    }
)
) 

# R implementation of _ClusterProxyKD
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ClusterProxyKD.html
ClusterProxyKD <- R6Class(classname = "ClusterProxyKD",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ClusterProxyKD()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ClusterProxyKD()
        invisible()
    
    
    },
    
    # C++ signature: void ClusterProxyKD(ClusterProxyKD)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ClusterProxyKD")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ClusterProxyKD(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ClusterProxyKD(size_t size, double avg_distance, size_t center_index)
    init_2 = function(size, avg_distance, center_index){
    
        if(!( (is_scalar_integer(size) || is_scalar_double(size)) && size == as.integer(size))){ stop("arg size wrong type") }
        if(!(is_scalar_double(avg_distance))){ stop("arg avg_distance wrong type") }
        if(!( (is_scalar_integer(center_index) || is_scalar_double(center_index)) && center_index == as.integer(center_index))){ stop("arg center_index wrong type") }
    
    
    
    
        private$py_obj <- Pymod$ClusterProxyKD(as.integer(size), avg_distance, as.integer(center_index))
        invisible()
    
    
    },
    
    # C++ signature: void ClusterProxyKD()
    # C++ signature: void ClusterProxyKD(ClusterProxyKD)
    # C++ signature: void ClusterProxyKD(size_t size, double avg_distance, size_t center_index)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ClusterProxyKD")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ClusterProxyKD" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t getSize()
    getSize = function(){
    
        py_ans = private$py_obj$getSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid()
    isValid = function(){
    
        py_ans = private$py_obj$isValid()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAvgDistance()
    getAvgDistance = function(){
    
        py_ans = private$py_obj$getAvgDistance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getCenterIndex()
    getCenterIndex = function(){
    
        py_ans = private$py_obj$getCenterIndex()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ClusteringGrid
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ClusteringGrid.html
ClusteringGrid <- R6Class(classname = "ClusteringGrid",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ClusteringGrid(libcpp_vector[double] & grid_spacing_x, libcpp_vector[double] & grid_spacing_y)
    initialize = function(grid_spacing_x, grid_spacing_y){
    
    if(missing(grid_spacing_y)){
         if( "python.builtin.object" %in% class(grid_spacing_x) && class_to_wrap(grid_spacing_x) == ClusteringGrid ) { private$py_obj <- grid_spacing_x }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(grid_spacing_x) && all(sapply(grid_spacing_x,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg grid_spacing_x wrong type") }
        if(!(is_list(grid_spacing_y) && all(sapply(grid_spacing_y,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg grid_spacing_y wrong type") }
        v0 <- r_to_py(grid_spacing_x)
        v1 <- r_to_py(grid_spacing_y)
    
        private$py_obj <- Pymod$ClusteringGrid(v0, v1)
        invisible()
    }
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
    },
    
    # C++ signature: libcpp_vector[double] getGridSpacingX()
    getGridSpacingX = function(){
    
        py_ans = private$py_obj$getGridSpacingX()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getGridSpacingY()
    getGridSpacingY = function(){
    
        py_ans = private$py_obj$getGridSpacingY()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void addCluster(libcpp_pair[int,int] cell_index, int & cluster_index)
    addCluster = function(cell_index, cluster_index){
    
        if(!(is_list(cell_index) && length(cell_index) == 2 &&  (is_scalar_integer(cell_index[[1]]) || is_scalar_double(cell_index[[1]])) && cell_index[[1]] == as.integer(cell_index[[1]]) &&  (is_scalar_integer(cell_index[[2]]) || is_scalar_double(cell_index[[2]])) && cell_index[[2]] == as.integer(cell_index[[2]]))){ stop("arg cell_index wrong type") }
        if(!( (is_scalar_integer(cluster_index) || is_scalar_double(cluster_index)) && cluster_index == as.integer(cluster_index))){ stop("arg cluster_index wrong type") }
        v0 = r_to_py(list(as.integer(cell_index[[1]]),as.integer(cell_index[[2]])))
    
        private$py_obj$addCluster(v0, as.integer(cluster_index))
        invisible()
    },
    
    # C++ signature: void removeCluster(libcpp_pair[int,int] cell_index, int & cluster_index)
    removeCluster = function(cell_index, cluster_index){
    
        if(!(is_list(cell_index) && length(cell_index) == 2 &&  (is_scalar_integer(cell_index[[1]]) || is_scalar_double(cell_index[[1]])) && cell_index[[1]] == as.integer(cell_index[[1]]) &&  (is_scalar_integer(cell_index[[2]]) || is_scalar_double(cell_index[[2]])) && cell_index[[2]] == as.integer(cell_index[[2]]))){ stop("arg cell_index wrong type") }
        if(!( (is_scalar_integer(cluster_index) || is_scalar_double(cluster_index)) && cluster_index == as.integer(cluster_index))){ stop("arg cluster_index wrong type") }
        v0 = r_to_py(list(as.integer(cell_index[[1]]),as.integer(cell_index[[2]])))
    
        private$py_obj$removeCluster(v0, as.integer(cluster_index))
        invisible()
    },
    
    # C++ signature: void removeAllClusters()
    removeAllClusters = function(){
    
        private$py_obj$removeAllClusters()
        invisible()
    },
    
    # C++ signature: libcpp_pair[int,int] getIndex(DPosition2 position)
    getIndex = function(position){
    
        if(!(is_list(position) && length(position) == 2 && (is_scalar_integer(position[[1]]) || is_scalar_double(position[[1]])) && (is_scalar_integer(position[[2]]) || is_scalar_double(position[[2]])))){ stop("arg position wrong type") }
        dp_0 <- r_to_py(position)
        py_ans = private$py_obj$getIndex(dp_0)
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    },
    
    # C++ signature: bool isNonEmptyCell(libcpp_pair[int,int] cell_index)
    isNonEmptyCell = function(cell_index){
    
        if(!(is_list(cell_index) && length(cell_index) == 2 &&  (is_scalar_integer(cell_index[[1]]) || is_scalar_double(cell_index[[1]])) && cell_index[[1]] == as.integer(cell_index[[1]]) &&  (is_scalar_integer(cell_index[[2]]) || is_scalar_double(cell_index[[2]])) && cell_index[[2]] == as.integer(cell_index[[2]]))){ stop("arg cell_index wrong type") }
        v0 = r_to_py(list(as.integer(cell_index[[1]]),as.integer(cell_index[[2]])))
        py_ans = private$py_obj$isNonEmptyCell(v0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getCellCount()
    getCellCount = function(){
    
        py_ans = private$py_obj$getCellCount()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CoarseIsotopePatternGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CoarseIsotopePatternGenerator.html
CoarseIsotopePatternGenerator <- R6Class(classname = "CoarseIsotopePatternGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CoarseIsotopePatternGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CoarseIsotopePatternGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void CoarseIsotopePatternGenerator(size_t max_isotope)
    init_1 = function(max_isotope){
    
        if(!( (is_scalar_integer(max_isotope) || is_scalar_double(max_isotope)) && max_isotope == as.integer(max_isotope))){ stop("arg max_isotope wrong type") }
    
    
        private$py_obj <- Pymod$CoarseIsotopePatternGenerator(as.integer(max_isotope))
        invisible()
    
    
    },
    
    # C++ signature: void CoarseIsotopePatternGenerator(size_t max_isotope, bool round_masses)
    init_2 = function(max_isotope, round_masses){
    
        if(!( (is_scalar_integer(max_isotope) || is_scalar_double(max_isotope)) && max_isotope == as.integer(max_isotope))){ stop("arg max_isotope wrong type") }
        if(!( (is_scalar_integer(round_masses) || is_scalar_double(round_masses)) && round_masses == as.integer(round_masses))){ stop("arg round_masses wrong type") }
    
    
    
        private$py_obj <- Pymod$CoarseIsotopePatternGenerator(as.integer(max_isotope), as.integer(round_masses))
        invisible()
    
    
    },
    
    # C++ signature: void CoarseIsotopePatternGenerator()
    # C++ signature: void CoarseIsotopePatternGenerator(size_t max_isotope)
    # C++ signature: void CoarseIsotopePatternGenerator(size_t max_isotope, bool round_masses)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CoarseIsotopePatternGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: IsotopeDistribution run(EmpiricalFormula)
    run = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmpiricalFormula")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$run(in_0)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool getRoundMasses()
    getRoundMasses = function(){
    
        py_ans = private$py_obj$getRoundMasses()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRoundMasses(bool round_masses_)
    setRoundMasses = function(round_masses_){
    
        if(!( (is_scalar_integer(round_masses_) || is_scalar_double(round_masses_)) && round_masses_ == as.integer(round_masses_))){ stop("arg round_masses_ wrong type") }
    
        private$py_obj$setRoundMasses(as.integer(round_masses_))
        invisible()
    },
    
    # C++ signature: size_t getMaxIsotope()
    getMaxIsotope = function(){
    
        py_ans = private$py_obj$getMaxIsotope()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxIsotope(size_t max_isotope)
    setMaxIsotope = function(max_isotope){
    
        if(!( (is_scalar_integer(max_isotope) || is_scalar_double(max_isotope)) && max_isotope == as.integer(max_isotope))){ stop("arg max_isotope wrong type") }
    
        private$py_obj$setMaxIsotope(as.integer(max_isotope))
        invisible()
    },
    
    # C++ signature: IsotopeDistribution estimateFromPeptideWeight(double average_weight)
    estimateFromPeptideWeight = function(average_weight){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
    
        py_ans = private$py_obj$estimateFromPeptideWeight(average_weight)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateFromPeptideWeightAndS(double average_weight, unsigned int S)
    estimateFromPeptideWeightAndS = function(average_weight, S){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!( (is_scalar_integer(S) || is_scalar_double(S)) && S == as.integer(S))){ stop("arg S wrong type") }
    
    
        py_ans = private$py_obj$estimateFromPeptideWeightAndS(average_weight, as.integer(S))
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateFromRNAWeight(double average_weight)
    estimateFromRNAWeight = function(average_weight){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
    
        py_ans = private$py_obj$estimateFromRNAWeight(average_weight)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateFromDNAWeight(double average_weight)
    estimateFromDNAWeight = function(average_weight){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
    
        py_ans = private$py_obj$estimateFromDNAWeight(average_weight)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateFromWeightAndComp(double average_weight, double C, double H, double N, double O, double S, double P)
    estimateFromWeightAndComp = function(average_weight, C, H, N, O, S, P){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!(is_scalar_double(C))){ stop("arg C wrong type") }
        if(!(is_scalar_double(H))){ stop("arg H wrong type") }
        if(!(is_scalar_double(N))){ stop("arg N wrong type") }
        if(!(is_scalar_double(O))){ stop("arg O wrong type") }
        if(!(is_scalar_double(S))){ stop("arg S wrong type") }
        if(!(is_scalar_double(P))){ stop("arg P wrong type") }
    
    
    
    
    
    
    
        py_ans = private$py_obj$estimateFromWeightAndComp(average_weight, C, H, N, O, S, P)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateFromWeightAndCompAndS(double average_weight, unsigned int S, double C, double H, double N, double O, double P)
    estimateFromWeightAndCompAndS = function(average_weight, S, C, H, N, O, P){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!( (is_scalar_integer(S) || is_scalar_double(S)) && S == as.integer(S))){ stop("arg S wrong type") }
        if(!(is_scalar_double(C))){ stop("arg C wrong type") }
        if(!(is_scalar_double(H))){ stop("arg H wrong type") }
        if(!(is_scalar_double(N))){ stop("arg N wrong type") }
        if(!(is_scalar_double(O))){ stop("arg O wrong type") }
        if(!(is_scalar_double(P))){ stop("arg P wrong type") }
    
    
    
    
    
    
    
        py_ans = private$py_obj$estimateFromWeightAndCompAndS(average_weight, as.integer(S), C, H, N, O, P)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution estimateForFragmentFromPeptideWeight(double average_weight_precursor, double average_weight_fragment, libcpp_set[unsigned int] & precursor_isotopes)
    estimateForFragmentFromPeptideWeight = function(average_weight_precursor, average_weight_fragment, precursor_isotopes){
    
        if(!(is_scalar_double(average_weight_precursor))){ stop("arg average_weight_precursor wrong type") }
        if(!(is_scalar_double(average_weight_fragment))){ stop("arg average_weight_fragment wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
    
    
        py$v2 <- precursor_isotopes
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
        py_ans = private$py_obj$estimateForFragmentFromPeptideWeight(average_weight_precursor, average_weight_fragment, py$v2)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: IsotopeDistribution estimateForFragmentFromPeptideWeightAndS(double average_weight_precursor, unsigned int S_precursor, double average_weight_fragment, unsigned int S_fragment, libcpp_set[unsigned int] & precursor_isotopes)
    estimateForFragmentFromPeptideWeightAndS = function(average_weight_precursor, S_precursor, average_weight_fragment, S_fragment, precursor_isotopes){
    
        if(!(is_scalar_double(average_weight_precursor))){ stop("arg average_weight_precursor wrong type") }
        if(!( (is_scalar_integer(S_precursor) || is_scalar_double(S_precursor)) && S_precursor == as.integer(S_precursor))){ stop("arg S_precursor wrong type") }
        if(!(is_scalar_double(average_weight_fragment))){ stop("arg average_weight_fragment wrong type") }
        if(!( (is_scalar_integer(S_fragment) || is_scalar_double(S_fragment)) && S_fragment == as.integer(S_fragment))){ stop("arg S_fragment wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
    
    
    
    
        py$v4 <- precursor_isotopes
        py_run_string("v4 = [int(t) for t in v4];v4 = set(v4)")
        py_ans = private$py_obj$estimateForFragmentFromPeptideWeightAndS(average_weight_precursor, as.integer(S_precursor), average_weight_fragment, as.integer(S_fragment), py$v4)
        byref_4 <- as.list(py_eval("list(v4)"))
        py_run_string("del v4; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_4))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: IsotopeDistribution estimateForFragmentFromRNAWeight(double average_weight_precursor, double average_weight_fragment, libcpp_set[unsigned int] & precursor_isotopes)
    estimateForFragmentFromRNAWeight = function(average_weight_precursor, average_weight_fragment, precursor_isotopes){
    
        if(!(is_scalar_double(average_weight_precursor))){ stop("arg average_weight_precursor wrong type") }
        if(!(is_scalar_double(average_weight_fragment))){ stop("arg average_weight_fragment wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
    
    
        py$v2 <- precursor_isotopes
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
        py_ans = private$py_obj$estimateForFragmentFromRNAWeight(average_weight_precursor, average_weight_fragment, py$v2)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: IsotopeDistribution estimateForFragmentFromDNAWeight(double average_weight_precursor, double average_weight_fragment, libcpp_set[unsigned int] & precursor_isotopes)
    estimateForFragmentFromDNAWeight = function(average_weight_precursor, average_weight_fragment, precursor_isotopes){
    
        if(!(is_scalar_double(average_weight_precursor))){ stop("arg average_weight_precursor wrong type") }
        if(!(is_scalar_double(average_weight_fragment))){ stop("arg average_weight_fragment wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
    
    
        py$v2 <- precursor_isotopes
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
        py_ans = private$py_obj$estimateForFragmentFromDNAWeight(average_weight_precursor, average_weight_fragment, py$v2)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: IsotopeDistribution estimateForFragmentFromWeightAndComp(double average_weight_precursor, double average_weight_fragment, libcpp_set[unsigned int] & precursor_isotopes, double C, double H, double N, double O, double S, double P)
    estimateForFragmentFromWeightAndComp = function(average_weight_precursor, average_weight_fragment, precursor_isotopes, C, H, N, O, S, P){
    
        if(!(is_scalar_double(average_weight_precursor))){ stop("arg average_weight_precursor wrong type") }
        if(!(is_scalar_double(average_weight_fragment))){ stop("arg average_weight_fragment wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
        if(!(is_scalar_double(C))){ stop("arg C wrong type") }
        if(!(is_scalar_double(H))){ stop("arg H wrong type") }
        if(!(is_scalar_double(N))){ stop("arg N wrong type") }
        if(!(is_scalar_double(O))){ stop("arg O wrong type") }
        if(!(is_scalar_double(S))){ stop("arg S wrong type") }
        if(!(is_scalar_double(P))){ stop("arg P wrong type") }
    
    
        py$v2 <- precursor_isotopes
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
    
    
    
    
    
    
        py_ans = private$py_obj$estimateForFragmentFromWeightAndComp(average_weight_precursor, average_weight_fragment, py$v2, C, H, N, O, S, P)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: IsotopeDistribution calcFragmentIsotopeDist(IsotopeDistribution & fragment_isotope_dist, IsotopeDistribution & comp_fragment_isotope_dist, libcpp_set[unsigned int] & precursor_isotopes, double fragment_mono_mass)
    calcFragmentIsotopeDist = function(fragment_isotope_dist, comp_fragment_isotope_dist, precursor_isotopes, fragment_mono_mass){
    
        if(!(is.R6(fragment_isotope_dist) && class(fragment_isotope_dist)[1] == "IsotopeDistribution")){ stop("arg fragment_isotope_dist wrong type") }
        if(!(is.R6(comp_fragment_isotope_dist) && class(comp_fragment_isotope_dist)[1] == "IsotopeDistribution")){ stop("arg comp_fragment_isotope_dist wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
        if(!(is_scalar_double(fragment_mono_mass))){ stop("arg fragment_mono_mass wrong type") }
    
    
        py$v2 <- precursor_isotopes
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
    
        py_ans = private$py_obj$calcFragmentIsotopeDist(fragment_isotope_dist, comp_fragment_isotope_dist, py$v2, fragment_mono_mass)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _ColumnHeader
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ConsensusMap_1_1ColumnHeader.html
ColumnHeader <- R6Class(classname = "ColumnHeader",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        filename = function(filename){
    
        if(!missing(filename)){
            if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        
        
            private$py_obj$filename <- filename
            } else {
        
                py_ans = private$py_obj$filename
            r_result = py_ans
                return(r_result)
                }
        },
        label = function(label){
    
        if(!missing(label)){
            if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
        
        
            private$py_obj$label <- label
            } else {
        
                py_ans = private$py_obj$label
            r_result = py_ans
                return(r_result)
                }
        },
        size = function(size){
    
        if(!missing(size)){
            if(!( (is_scalar_integer(size) || is_scalar_double(size)) && size == as.integer(size))){ stop("arg size wrong type") }
        
        
            private$py_obj$size <- as.integer(size)
            } else {
        
                py_ans = private$py_obj$size
                r_result = py_ans
                return(r_result)
                }
        },
        unique_id = function(unique_id){
    
        if(!missing(unique_id)){
            if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
        
        
            private$py_obj$unique_id <- as.integer(unique_id)
            } else {
        
                py_ans = private$py_obj$unique_id
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ColumnHeader()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ColumnHeader()
        invisible()
    
    
    },
    
    # C++ signature: void ColumnHeader(ColumnHeader &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ColumnHeader")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ColumnHeader(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ColumnHeader()
    # C++ signature: void ColumnHeader(ColumnHeader &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ColumnHeader")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ColumnHeader" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _CompNovoIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CompNovoIdentification.html
CompNovoIdentification <- R6Class(classname = "CompNovoIdentification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CompNovoIdentification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CompNovoIdentification()
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIdentification(CompNovoIdentification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CompNovoIdentification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CompNovoIdentification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIdentification()
    # C++ signature: void CompNovoIdentification(CompNovoIdentification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CompNovoIdentification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CompNovoIdentification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getIdentifications(libcpp_vector[PeptideIdentification] & ids, MSExperiment)
    getIdentifications = function(ids, in_1){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$getIdentifications(v0, in_1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getIdentification(PeptideIdentification & id, MSSpectrum cid_spec, MSSpectrum etd_spec)
    getIdentification = function(id, cid_spec, etd_spec){
    
        if(!(is.R6(id) && class(id)[1] == "PeptideIdentification")){ stop("arg id wrong type") }
        if(!(is.R6(cid_spec) && class(cid_spec)[1] == "MSSpectrum")){ stop("arg cid_spec wrong type") }
        if(!(is.R6(etd_spec) && class(etd_spec)[1] == "MSSpectrum")){ stop("arg etd_spec wrong type") }
    
    
    
        private$py_obj$getIdentification(id, cid_spec, etd_spec)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _CompNovoIdentificationCID
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CompNovoIdentificationCID.html
CompNovoIdentificationCID <- R6Class(classname = "CompNovoIdentificationCID",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CompNovoIdentificationCID()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CompNovoIdentificationCID()
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIdentificationCID(CompNovoIdentificationCID)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CompNovoIdentificationCID")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CompNovoIdentificationCID(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIdentificationCID()
    # C++ signature: void CompNovoIdentificationCID(CompNovoIdentificationCID)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CompNovoIdentificationCID")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CompNovoIdentificationCID" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getIdentifications(libcpp_vector[PeptideIdentification] & ids, MSExperiment)
    getIdentifications = function(ids, in_1){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$getIdentifications(v0, in_1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getIdentification(PeptideIdentification & id, MSSpectrum cid_spec)
    getIdentification = function(id, cid_spec){
    
        if(!(is.R6(id) && class(id)[1] == "PeptideIdentification")){ stop("arg id wrong type") }
        if(!(is.R6(cid_spec) && class(cid_spec)[1] == "MSSpectrum")){ stop("arg cid_spec wrong type") }
    
    
        private$py_obj$getIdentification(id, cid_spec)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _CompNovoIonScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CompNovoIonScoring.html
CompNovoIonScoring <- R6Class(classname = "CompNovoIonScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CompNovoIonScoring()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CompNovoIonScoring()
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIonScoring(CompNovoIonScoring)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CompNovoIonScoring")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CompNovoIonScoring(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIonScoring()
    # C++ signature: void CompNovoIonScoring(CompNovoIonScoring)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CompNovoIonScoring")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CompNovoIonScoring" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _CompNovoIonScoringCID
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CompNovoIonScoringCID.html
CompNovoIonScoringCID <- R6Class(classname = "CompNovoIonScoringCID",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CompNovoIonScoringCID()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$CompNovoIonScoringCID()
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIonScoringCID(CompNovoIonScoringCID)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CompNovoIonScoringCID")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CompNovoIonScoringCID(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CompNovoIonScoringCID()
    # C++ signature: void CompNovoIonScoringCID(CompNovoIonScoringCID)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CompNovoIonScoringCID")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CompNovoIonScoringCID" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _ComplementFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ComplementFilter.html
ComplementFilter <- R6Class(classname = "ComplementFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ComplementFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ComplementFilter()
        invisible()
    
    
    },
    
    # C++ signature: void ComplementFilter(ComplementFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ComplementFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ComplementFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ComplementFilter()
    # C++ signature: void ComplementFilter(ComplementFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ComplementFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ComplementFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ComplementMarker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ComplementMarker.html
ComplementMarker <- R6Class(classname = "ComplementMarker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ComplementMarker()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ComplementMarker()
        invisible()
    
    
    },
    
    # C++ signature: void ComplementMarker(ComplementMarker)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ComplementMarker")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ComplementMarker(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ComplementMarker()
    # C++ signature: void ComplementMarker(ComplementMarker)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ComplementMarker")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ComplementMarker" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void apply(libcpp_map[double,bool] &, MSSpectrum &)
    apply = function(in_0, in_1){
    
        if(!(
          is.environment(in_0) && identical(parent.env(in_0), asNamespace("collections")) && identical(strsplit(capture.output(in_0$print())," ")[[1]][1], "dict")
          && all(sapply(in_0$keys(),function(k) is_scalar_double(k)))
          && all(sapply(in_0$values(),function(v)  (is_scalar_integer(v) || is_scalar_double(v)) && v == as.integer(v)))
          )){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSSpectrum")){ stop("arg in_1 wrong type") }
        v0 <- py_dict(in_0$keys(),as.integer(in_0$values()))
    
        private$py_obj$apply(v0, in_1)
        byref_0 <- collections::dict(py_to_r(py_builtin$list(v0$values())),py_to_r(py_builtin$list(v0$keys())))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Compomer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Compomer.html
Compomer <- R6Class(classname = "Compomer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Compomer()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Compomer()
        invisible()
    
    
    },
    
    # C++ signature: void Compomer(Compomer)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Compomer")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Compomer(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Compomer()
    # C++ signature: void Compomer(Compomer)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Compomer")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Compomer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void add(Adduct & a, unsigned int side)
    add = function(a, side){
    
        if(!(is.R6(a) && class(a)[1] == "Adduct")){ stop("arg a wrong type") }
        if(!( (is_scalar_integer(side) || is_scalar_double(side)) && side == as.integer(side))){ stop("arg side wrong type") }
    
    
        private$py_obj$add(a, as.integer(side))
        invisible()
    },
    
    # C++ signature: bool isConflicting(Compomer & cmp, unsigned int side_this, unsigned int side_other)
    isConflicting = function(cmp, side_this, side_other){
    
        if(!(is.R6(cmp) && class(cmp)[1] == "Compomer")){ stop("arg cmp wrong type") }
        if(!( (is_scalar_integer(side_this) || is_scalar_double(side_this)) && side_this == as.integer(side_this))){ stop("arg side_this wrong type") }
        if(!( (is_scalar_integer(side_other) || is_scalar_double(side_other)) && side_other == as.integer(side_other))){ stop("arg side_other wrong type") }
    
    
    
        py_ans = private$py_obj$isConflicting(cmp, as.integer(side_this), as.integer(side_other))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setID(size_t id)
    setID = function(id){
    
        if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
    
        private$py_obj$setID(as.integer(id))
        invisible()
    },
    
    # C++ signature: size_t getID()
    getID = function(){
    
        py_ans = private$py_obj$getID()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNetCharge()
    getNetCharge = function(){
    
        py_ans = private$py_obj$getNetCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMass()
    getMass = function(){
    
        py_ans = private$py_obj$getMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getPositiveCharges()
    getPositiveCharges = function(){
    
        py_ans = private$py_obj$getPositiveCharges()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNegativeCharges()
    getNegativeCharges = function(){
    
        py_ans = private$py_obj$getNegativeCharges()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getLogP()
    getLogP = function(){
    
        py_ans = private$py_obj$getLogP()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRTShift()
    getRTShift = function(){
    
        py_ans = private$py_obj$getRTShift()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getAdductsAsString()
    getAdductsAsString_0 = function(){
    
        py_ans = private$py_obj$`_getAdductsAsString_0`()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getAdductsAsString(unsigned int side)
    getAdductsAsString_1 = function(side){
    
        if(!( (is_scalar_integer(side) || is_scalar_double(side)) && side == as.integer(side))){ stop("arg side wrong type") }
    
        py_ans = private$py_obj$`_getAdductsAsString_1`(as.integer(side))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getAdductsAsString()
    # C++ signature: String getAdductsAsString(unsigned int side)
    getAdductsAsString = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getAdductsAsString_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getAdductsAsString_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool isSingleAdduct(Adduct & a, unsigned int side)
    isSingleAdduct = function(a, side){
    
        if(!(is.R6(a) && class(a)[1] == "Adduct")){ stop("arg a wrong type") }
        if(!( (is_scalar_integer(side) || is_scalar_double(side)) && side == as.integer(side))){ stop("arg side wrong type") }
    
    
        py_ans = private$py_obj$isSingleAdduct(a, as.integer(side))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Compomer removeAdduct(Adduct & a)
    removeAdduct_0 = function(a){
    
        if(!(is.R6(a) && class(a)[1] == "Adduct")){ stop("arg a wrong type") }
    
        py_ans = private$py_obj$`_removeAdduct_0`(a)
        r_ans = Compomer$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Compomer removeAdduct(Adduct & a, unsigned int side)
    removeAdduct_1 = function(a, side){
    
        if(!(is.R6(a) && class(a)[1] == "Adduct")){ stop("arg a wrong type") }
        if(!( (is_scalar_integer(side) || is_scalar_double(side)) && side == as.integer(side))){ stop("arg side wrong type") }
    
    
        py_ans = private$py_obj$`_removeAdduct_1`(a, as.integer(side))
        r_ans = Compomer$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Compomer removeAdduct(Adduct & a)
    # C++ signature: Compomer removeAdduct(Adduct & a, unsigned int side)
    removeAdduct = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Adduct")) { self$removeAdduct_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Adduct") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$removeAdduct_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: StringList getLabels(unsigned int side)
    getLabels = function(side){
    
        if(!( (is_scalar_integer(side) || is_scalar_double(side)) && side == as.integer(side))){ stop("arg side wrong type") }
    
        py_ans = private$py_obj$getLabels(as.integer(side))
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    }
)
) 

# R implementation of _Compound
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Compound.html
Compound <- R6Class(classname = "Compound",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        molecular_formula = function(molecular_formula){
    
        if(!missing(molecular_formula)){
            if(!((is.R6(molecular_formula) && class(molecular_formula)[1]=="String") || is_scalar_character(molecular_formula))){ stop("arg molecular_formula wrong type") }
        
        
            private$py_obj$molecular_formula <- molecular_formula
            } else {
        
                py_ans = private$py_obj$molecular_formula
            r_result = py_ans
                return(r_result)
                }
        },
        smiles_string = function(smiles_string){
    
        if(!missing(smiles_string)){
            if(!((is.R6(smiles_string) && class(smiles_string)[1]=="String") || is_scalar_character(smiles_string))){ stop("arg smiles_string wrong type") }
        
        
            private$py_obj$smiles_string <- smiles_string
            } else {
        
                py_ans = private$py_obj$smiles_string
            r_result = py_ans
                return(r_result)
                }
        },
        theoretical_mass = function(theoretical_mass){
    
        if(!missing(theoretical_mass)){
            if(!(is_scalar_double(theoretical_mass))){ stop("arg theoretical_mass wrong type") }
        
        
            private$py_obj$theoretical_mass <- theoretical_mass
            } else {
        
                py_ans = private$py_obj$theoretical_mass
                r_result = py_ans
                return(r_result)
                }
        },
        rts = function(rts){
    
        if(!missing(rts)){
            if(!(is_list(rts) && all(sapply(rts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "RetentionTime")))){ stop("arg rts wrong type") }
        
            v0 <- r_to_py(rts)
            private$py_obj$rts <- v0
            } else {
            
                py_ans = private$py_obj$rts
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Compound()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Compound()
        invisible()
    
    
    },
    
    # C++ signature: void Compound(Compound)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Compound")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Compound(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Compound()
    # C++ signature: void Compound(Compound)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Compound")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Compound" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setChargeState(int charge)
    setChargeState = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setChargeState(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getChargeState()
    getChargeState = function(){
    
        py_ans = private$py_obj$getChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasCharge()
    hasCharge = function(){
    
        py_ans = private$py_obj$hasCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRetentionTime()
    getRetentionTime = function(){
    
        py_ans = private$py_obj$getRetentionTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasRetentionTime()
    hasRetentionTime = function(){
    
        py_ans = private$py_obj$hasRetentionTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: RTType getRetentionTimeType()
    getRetentionTimeType = function(){
    
        py_ans = private$py_obj$getRetentionTimeType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: RTUnit getRetentionTimeUnit()
    getRetentionTimeUnit = function(){
    
        py_ans = private$py_obj$getRetentionTimeUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ConfidenceScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConfidenceScoring.html
ConfidenceScoring <- R6Class(classname = "ConfidenceScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConfidenceScoring()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ConfidenceScoring()
        invisible()
    
    
    },
    
    # C++ signature: void ConfidenceScoring(ConfidenceScoring)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConfidenceScoring")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ConfidenceScoring(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ConfidenceScoring()
    # C++ signature: void ConfidenceScoring(ConfidenceScoring)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConfidenceScoring")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ConfidenceScoring" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void initialize(TargetedExperiment & targeted, size_t n_decoys, size_t n_transitions, TransformationDescription trafo)
    initialise = function(targeted, n_decoys, n_transitions, trafo){
    
        if(!(is.R6(targeted) && class(targeted)[1] == "TargetedExperiment")){ stop("arg targeted wrong type") }
        if(!( (is_scalar_integer(n_decoys) || is_scalar_double(n_decoys)) && n_decoys == as.integer(n_decoys))){ stop("arg n_decoys wrong type") }
        if(!( (is_scalar_integer(n_transitions) || is_scalar_double(n_transitions)) && n_transitions == as.integer(n_transitions))){ stop("arg n_transitions wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "TransformationDescription")){ stop("arg trafo wrong type") }
    
    
    
    
        private$py_obj$initialize(targeted, as.integer(n_decoys), as.integer(n_transitions), trafo)
        invisible()
    },
    
    # C++ signature: void initializeGlm(double intercept, double rt_coef, double int_coef)
    initializeGlm = function(intercept, rt_coef, int_coef){
    
        if(!(is_scalar_double(intercept))){ stop("arg intercept wrong type") }
        if(!(is_scalar_double(rt_coef))){ stop("arg rt_coef wrong type") }
        if(!(is_scalar_double(int_coef))){ stop("arg int_coef wrong type") }
    
    
    
        private$py_obj$initializeGlm(intercept, rt_coef, int_coef)
        invisible()
    },
    
    # C++ signature: void scoreMap(FeatureMap & map)
    scoreMap = function(map){
    
        if(!(is.R6(map) && class(map)[1] == "FeatureMap")){ stop("arg map wrong type") }
    
        private$py_obj$scoreMap(map)
        invisible()
    }
)
) 

# R implementation of _Configuration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Configuration.html
Configuration <- R6Class(classname = "Configuration",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        contact_ref = function(contact_ref){
    
        if(!missing(contact_ref)){
            if(!((is.R6(contact_ref) && class(contact_ref)[1]=="String") || is_scalar_character(contact_ref))){ stop("arg contact_ref wrong type") }
        
        
            private$py_obj$contact_ref <- contact_ref
            } else {
        
                py_ans = private$py_obj$contact_ref
            r_result = py_ans
                return(r_result)
                }
        },
        instrument_ref = function(instrument_ref){
    
        if(!missing(instrument_ref)){
            if(!((is.R6(instrument_ref) && class(instrument_ref)[1]=="String") || is_scalar_character(instrument_ref))){ stop("arg instrument_ref wrong type") }
        
        
            private$py_obj$instrument_ref <- instrument_ref
            } else {
        
                py_ans = private$py_obj$instrument_ref
            r_result = py_ans
                return(r_result)
                }
        },
        validations = function(validations){
    
        if(!missing(validations)){
            if(!(is_list(validations) && all(sapply(validations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTermList")))){ stop("arg validations wrong type") }
        
            v0 <- r_to_py(validations)
            private$py_obj$validations <- v0
            } else {
            
                py_ans = private$py_obj$validations
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusFeature
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusFeature.html

# A consensus feature spanning multiple LC-MS/MS experiments.
# -----
# A ConsensusFeature represents analytes that have been
# quantified across multiple LC-MS/MS experiments. Each analyte in a
# ConsensusFeature is linked to its original LC-MS/MS run through a
# unique identifier.
# -----
# Get access to the underlying features through getFeatureList()
ConsensusFeature <- R6Class(classname = "ConsensusFeature",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusFeature()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ConsensusFeature()
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusFeature(ConsensusFeature &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusFeature")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ConsensusFeature(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusFeature(unsigned long int, Peak2D, unsigned long int)
    init_2 = function(in_0, in_1, in_2){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "Peak2D")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
    
    
    
    
        private$py_obj <- Pymod$ConsensusFeature(as.integer(in_0), in_1, as.integer(in_2))
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusFeature(unsigned long int, BaseFeature)
    init_3 = function(in_0, in_1){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "BaseFeature")){ stop("arg in_1 wrong type") }
    
    
    
        private$py_obj <- Pymod$ConsensusFeature(as.integer(in_0), in_1)
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusFeature(unsigned long int, ConsensusFeature)
    init_4 = function(in_0, in_1){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "ConsensusFeature")){ stop("arg in_1 wrong type") }
    
    
    
        private$py_obj <- Pymod$ConsensusFeature(as.integer(in_0), in_1)
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusFeature()
    # C++ signature: void ConsensusFeature(ConsensusFeature &)
    # C++ signature: void ConsensusFeature(unsigned long int, Peak2D, unsigned long int)
    # C++ signature: void ConsensusFeature(unsigned long int, BaseFeature)
    # C++ signature: void ConsensusFeature(unsigned long int, ConsensusFeature)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusFeature")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Peak2D") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "BaseFeature")) { self$init_3(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusFeature")) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ConsensusFeature" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void computeConsensus()
    computeConsensus = function(){
    
        private$py_obj$computeConsensus()
        invisible()
    },
    
    # C++ signature: void computeMonoisotopicConsensus()
    computeMonoisotopicConsensus = function(){
    
        private$py_obj$computeMonoisotopicConsensus()
        invisible()
    },
    
    # C++ signature: void computeDechargeConsensus(FeatureMap, bool)
    computeDechargeConsensus = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
        if(!( (is_scalar_integer(in_1) || is_scalar_double(in_1)) && in_1 == as.integer(in_1))){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$computeDechargeConsensus(in_0, as.integer(in_1))
        invisible()
    },
    
    # C++ signature: void insert(unsigned long int map_idx, Peak2D, unsigned long int element_idx)
    insert_0 = function(map_idx, in_1, element_idx){
    
        if(!( (is_scalar_integer(map_idx) || is_scalar_double(map_idx)) && map_idx == as.integer(map_idx))){ stop("arg map_idx wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "Peak2D")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(element_idx) || is_scalar_double(element_idx)) && element_idx == as.integer(element_idx))){ stop("arg element_idx wrong type") }
    
    
    
        private$py_obj$`_insert_0`(as.integer(map_idx), in_1, as.integer(element_idx))
        invisible()
    },
    
    # C++ signature: void insert(unsigned long int map_idx, BaseFeature)
    insert_1 = function(map_idx, in_1){
    
        if(!( (is_scalar_integer(map_idx) || is_scalar_double(map_idx)) && map_idx == as.integer(map_idx))){ stop("arg map_idx wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "BaseFeature")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_insert_1`(as.integer(map_idx), in_1)
        invisible()
    },
    
    # C++ signature: void insert(unsigned long int map_idx, ConsensusFeature)
    insert_2 = function(map_idx, in_1){
    
        if(!( (is_scalar_integer(map_idx) || is_scalar_double(map_idx)) && map_idx == as.integer(map_idx))){ stop("arg map_idx wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "ConsensusFeature")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_insert_2`(as.integer(map_idx), in_1)
        invisible()
    },
    
    # C++ signature: void insert(unsigned long int map_idx, Peak2D, unsigned long int element_idx)
    # C++ signature: void insert(unsigned long int map_idx, BaseFeature)
    # C++ signature: void insert(unsigned long int map_idx, ConsensusFeature)
    insert = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Peak2D") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$insert_0(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "BaseFeature")) { self$insert_1(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusFeature")) { self$insert_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_vector[FeatureHandle] getFeatureList()
    getFeatureList = function(){
    
        py_ans = private$py_obj$getFeatureList()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addRatio(Ratio r)
    addRatio = function(r){
    
        if(!(is.R6(r) && class(r)[1] == "Ratio")){ stop("arg r wrong type") }
    
        private$py_obj$addRatio(r)
        invisible()
    },
    
    # C++ signature: void setRatios(libcpp_vector[Ratio] rs)
    setRatios = function(rs){
    
        if(!(is_list(rs) && all(sapply(rs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Ratio")))){ stop("arg rs wrong type") }
        v0 <- r_to_py(rs)
        private$py_obj$setRatios(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Ratio] getRatios()
    getRatios = function(){
    
        py_ans = private$py_obj$getRatios()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getQuality()
    getQuality = function(){
    
        py_ans = private$py_obj$getQuality()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuality(float q)
    setQuality = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setQuality(q)
        invisible()
    },
    
    # C++ signature: float getWidth()
    getWidth = function(){
    
        py_ans = private$py_obj$getWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWidth(float q)
    setWidth = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setWidth(q)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int q)
    setCharge = function(q){
    
        if(!( (is_scalar_integer(q) || is_scalar_double(q)) && q == as.integer(q))){ stop("arg q wrong type") }
    
        private$py_obj$setCharge(as.integer(q))
        invisible()
    },
    
    # C++ signature: AnnotationState getAnnotationState()
    getAnnotationState = function(){
    
        py_ans = private$py_obj$getAnnotationState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification] & peptides)
    setPeptideIdentifications = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$setPeptideIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithm.html
ConsensusIDAlgorithm <- R6Class(classname = "ConsensusIDAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmAverage
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmAverage.html
ConsensusIDAlgorithmAverage <- R6Class(classname = "ConsensusIDAlgorithmAverage",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmAverage()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmAverage) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmAverage()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmBest
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmBest.html
ConsensusIDAlgorithmBest <- R6Class(classname = "ConsensusIDAlgorithmBest",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmBest()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmBest) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmBest()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmIdentity
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmIdentity.html
ConsensusIDAlgorithmIdentity <- R6Class(classname = "ConsensusIDAlgorithmIdentity",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmPEPIons
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmPEPIons.html
ConsensusIDAlgorithmPEPIons <- R6Class(classname = "ConsensusIDAlgorithmPEPIons",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmPEPIons()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmPEPIons) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmPEPIons()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmPEPMatrix
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmPEPMatrix.html
ConsensusIDAlgorithmPEPMatrix <- R6Class(classname = "ConsensusIDAlgorithmPEPMatrix",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmPEPMatrix()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmPEPMatrix) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmPEPMatrix()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmRanks
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmRanks.html
ConsensusIDAlgorithmRanks <- R6Class(classname = "ConsensusIDAlgorithmRanks",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmRanks()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmRanks) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmRanks()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmSimilarity
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmSimilarity.html
ConsensusIDAlgorithmSimilarity <- R6Class(classname = "ConsensusIDAlgorithmSimilarity",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusIDAlgorithmWorst
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusIDAlgorithmWorst.html
ConsensusIDAlgorithmWorst <- R6Class(classname = "ConsensusIDAlgorithmWorst",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusIDAlgorithmWorst()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusIDAlgorithmWorst) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusIDAlgorithmWorst()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids, size_t number_of_runs)
    apply = function(ids, number_of_runs){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$apply(v0, as.integer(number_of_runs))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusMap
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ConsensusMap_1_1ConsensusMap.html

# A container for consensus elements.
# -----
# A ConsensusMap is a container holding 2-dimensional consensus elements
# (ConsensusFeature) which in turn represent analytes that have been
# quantified across multiple LC-MS/MS experiments. Each analyte in a
# ConsensusFeature is linked to its original LC-MS/MS run, the links are
# maintained by the ConsensusMap class.
# The map is implemented as a vector of elements of type ConsensusFeature.
# -----
# To be consistent, all maps who are referenced by ConsensusFeature objects
# (through a unique id) need to be registered in this class.
# -----
# This class supports direct iteration in Python.
ConsensusMap <- R6Class(classname = "ConsensusMap",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusMap()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ConsensusMap()
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusMap(ConsensusMap &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ConsensusMap(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ConsensusMap()
    # C++ signature: void ConsensusMap(ConsensusMap &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ConsensusMap" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void reserve(size_t s)
    reserve = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$reserve(as.integer(s))
        invisible()
    },
    
    # C++ signature: void push_back(ConsensusFeature spec)
    push_back = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "ConsensusFeature")){ stop("arg spec wrong type") }
    
        private$py_obj$push_back(spec)
        invisible()
    },
    
    # C++ signature: ConsensusMap appendRows(ConsensusMap)
    appendRows = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$appendRows(in_0)
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: ConsensusMap appendColumns(ConsensusMap)
    appendColumns = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$appendColumns(in_0)
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void clear(bool clear_meta_data)
    clear_0 = function(clear_meta_data){
    
        if(!( (is_scalar_integer(clear_meta_data) || is_scalar_double(clear_meta_data)) && clear_meta_data == as.integer(clear_meta_data))){ stop("arg clear_meta_data wrong type") }
    
        private$py_obj$`_clear_0`(as.integer(clear_meta_data))
        invisible()
    },
    
    # C++ signature: void clear()
    clear_1 = function(){
    
        private$py_obj$`_clear_1`()
        invisible()
    },
    
    # C++ signature: void clear(bool clear_meta_data)
    # C++ signature: void clear()
    clear = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$clear_0(...) }
        else if (length(arg_list)==0) { self$clear_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void updateRanges()
    updateRanges = function(){
    
        private$py_obj$updateRanges()
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinIdentification] getProteinIdentifications()
    getProteinIdentifications = function(){
    
        py_ans = private$py_obj$getProteinIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProteinIdentifications(libcpp_vector[ProteinIdentification])
    setProteinIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setProteinIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getUnassignedPeptideIdentifications()
    getUnassignedPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getUnassignedPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setUnassignedPeptideIdentifications(libcpp_vector[PeptideIdentification])
    setUnassignedPeptideIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setUnassignedPeptideIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[DataProcessing] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[DataProcessing])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "DataProcessing")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    setPrimaryMSRunPath_0 = function(s){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
        private$py_obj$`_setPrimaryMSRunPath_0`(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s, MSExperiment & e)
    setPrimaryMSRunPath_1 = function(s, e){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        if(!(is.R6(e) && class(e)[1] == "MSExperiment")){ stop("arg e wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
    
        private$py_obj$`_setPrimaryMSRunPath_1`(v0, e)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    # C++ signature: void setPrimaryMSRunPath(StringList & s, MSExperiment & e)
    setPrimaryMSRunPath = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$setPrimaryMSRunPath_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment")) { self$setPrimaryMSRunPath_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & toFill)
    getPrimaryMSRunPath = function(toFill){
    
        if(!(is_list(toFill) && all(sapply(toFill),is_scalar_character))){ stop("arg toFill wrong type") }
        v0 = r_to_py(modify_depth(toFill,1,py_builtin$bytes(toFill,'utf-8')))
        private$py_obj$getPrimaryMSRunPath(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(toFill <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void sortByIntensity(bool reverse)
    sortByIntensity_0 = function(reverse){
    
        if(!( (is_scalar_integer(reverse) || is_scalar_double(reverse)) && reverse == as.integer(reverse))){ stop("arg reverse wrong type") }
    
        private$py_obj$`_sortByIntensity_0`(as.integer(reverse))
        invisible()
    },
    
    # C++ signature: void sortByIntensity()
    sortByIntensity_1 = function(){
    
        private$py_obj$`_sortByIntensity_1`()
        invisible()
    },
    
    # C++ signature: void sortByIntensity(bool reverse)
    # C++ signature: void sortByIntensity()
    sortByIntensity = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$sortByIntensity_0(...) }
        else if (length(arg_list)==0) { self$sortByIntensity_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void sortByRT()
    sortByRT = function(){
    
        private$py_obj$sortByRT()
        invisible()
    },
    
    # C++ signature: void sortByMZ()
    sortByMZ = function(){
    
        private$py_obj$sortByMZ()
        invisible()
    },
    
    # C++ signature: void sortByPosition()
    sortByPosition = function(){
    
        private$py_obj$sortByPosition()
        invisible()
    },
    
    # C++ signature: void sortByQuality(bool reverse)
    sortByQuality_0 = function(reverse){
    
        if(!( (is_scalar_integer(reverse) || is_scalar_double(reverse)) && reverse == as.integer(reverse))){ stop("arg reverse wrong type") }
    
        private$py_obj$`_sortByQuality_0`(as.integer(reverse))
        invisible()
    },
    
    # C++ signature: void sortByQuality()
    sortByQuality_1 = function(){
    
        private$py_obj$`_sortByQuality_1`()
        invisible()
    },
    
    # C++ signature: void sortByQuality(bool reverse)
    # C++ signature: void sortByQuality()
    sortByQuality = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$sortByQuality_0(...) }
        else if (length(arg_list)==0) { self$sortByQuality_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void sortBySize()
    sortBySize = function(){
    
        private$py_obj$sortBySize()
        invisible()
    },
    
    # C++ signature: void sortByMaps()
    sortByMaps = function(){
    
        private$py_obj$sortByMaps()
        invisible()
    },
    
    # C++ signature: String getExperimentType()
    getExperimentType = function(){
    
        py_ans = private$py_obj$getExperimentType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setExperimentType(String experiment_type)
    setExperimentType = function(experiment_type){
    
        if(!((is.R6(experiment_type) && class(experiment_type)[1]=="String") || is_scalar_character(experiment_type))){ stop("arg experiment_type wrong type") }
    
        private$py_obj$setExperimentType(experiment_type)
        invisible()
    },
    
    # C++ signature: void sortPeptideIdentificationsByMapIndex()
    sortPeptideIdentificationsByMapIndex = function(){
    
        private$py_obj$sortPeptideIdentificationsByMapIndex()
        invisible()
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DPosition2 getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition2 getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMinInt()
    getMinInt = function(){
    
        py_ans = private$py_obj$getMinInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxInt()
    getMaxInt = function(){
    
        py_ans = private$py_obj$getMaxInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearRanges()
    clearRanges = function(){
    
        private$py_obj$clearRanges()
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ConsensusMapNormalizerAlgorithmMedian
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ConsensusMapNormalizerAlgorithmMedian_1_1ConsensusMapNormalizerAlgorithmMedian.html
ConsensusMapNormalizerAlgorithmMedian <- R6Class(classname = "ConsensusMapNormalizerAlgorithmMedian",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusMapNormalizerAlgorithmMedian()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusMapNormalizerAlgorithmMedian) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusMapNormalizerAlgorithmMedian()
        invisible()
    }
    
    },
    
    # C++ signature: size_t computeMedians(ConsensusMap & input_map, libcpp_vector[double] & medians, const String & acc_filter, const String & desc_filter)
    computeMedians = function(input_map, medians, acc_filter, desc_filter){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
        if(!(is_list(medians) && all(sapply(medians,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg medians wrong type") }
        if(!((is.R6(acc_filter) && class(acc_filter)[1]=="String") || is_scalar_character(acc_filter))){ stop("arg acc_filter wrong type") }
        if(!((is.R6(desc_filter) && class(desc_filter)[1]=="String") || is_scalar_character(desc_filter))){ stop("arg desc_filter wrong type") }
    
        v1 <- r_to_py(medians)
    
    
        py_ans = private$py_obj$computeMedians(input_map, v1, acc_filter, desc_filter)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(medians <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void normalizeMaps(ConsensusMap & input_map, NormalizationMethod method, const String & acc_filter, const String & desc_filter)
    normalizeMaps = function(input_map, method, acc_filter, desc_filter){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
        if(!(method %in% c(0, 1))){ stop("arg method wrong type") }
        if(!((is.R6(acc_filter) && class(acc_filter)[1]=="String") || is_scalar_character(acc_filter))){ stop("arg acc_filter wrong type") }
        if(!((is.R6(desc_filter) && class(desc_filter)[1]=="String") || is_scalar_character(desc_filter))){ stop("arg desc_filter wrong type") }
    
    
    
    
        private$py_obj$normalizeMaps(input_map, as.integer(method), acc_filter, desc_filter)
        invisible()
    }
)
) 

# R implementation of _ConsensusMapNormalizerAlgorithmQuantile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusMapNormalizerAlgorithmQuantile.html
ConsensusMapNormalizerAlgorithmQuantile <- R6Class(classname = "ConsensusMapNormalizerAlgorithmQuantile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusMapNormalizerAlgorithmQuantile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusMapNormalizerAlgorithmQuantile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusMapNormalizerAlgorithmQuantile()
        invisible()
    }
    
    },
    
    # C++ signature: void normalizeMaps(ConsensusMap & input_map)
    normalizeMaps = function(input_map){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
    
        private$py_obj$normalizeMaps(input_map)
        invisible()
    },
    
    # C++ signature: void resample(libcpp_vector[double] & data_in, libcpp_vector[double] & data_out, unsigned int n_resampling_points)
    resample = function(data_in, data_out, n_resampling_points){
    
        if(!(is_list(data_in) && all(sapply(data_in,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg data_in wrong type") }
        if(!(is_list(data_out) && all(sapply(data_out,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg data_out wrong type") }
        if(!( (is_scalar_integer(n_resampling_points) || is_scalar_double(n_resampling_points)) && n_resampling_points == as.integer(n_resampling_points))){ stop("arg n_resampling_points wrong type") }
        v0 <- r_to_py(data_in)
        v1 <- r_to_py(data_out)
    
        private$py_obj$resample(v0, v1, as.integer(n_resampling_points))
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(data_in <- byref_0))
        eval.parent(substitute(data_out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractIntensityVectors(ConsensusMap & map_, libcpp_vector[libcpp_vector[double]] & out_intensities)
    extractIntensityVectors = function(map_, out_intensities){
    
        if(!(is.R6(map_) && class(map_)[1] == "ConsensusMap")){ stop("arg map_ wrong type") }
        if(!(is_list(out_intensities) && all(sapply(out_intensities,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is_scalar_double(elemt_rec_rec))))))){ stop("arg out_intensities wrong type") }
    
        v1 <- r_to_py(out_intensities)
        private$py_obj$extractIntensityVectors(map_, v1)
        byref_1 <- map_depth(py_to_r(v1),1,as.list)
    
        tryCatch({
        eval.parent(substitute(out_intensities <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setNormalizedIntensityValues(libcpp_vector[libcpp_vector[double]] & feature_ints, ConsensusMap & map_)
    setNormalizedIntensityValues = function(feature_ints, map_){
    
        if(!(is_list(feature_ints) && all(sapply(feature_ints,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is_scalar_double(elemt_rec_rec))))))){ stop("arg feature_ints wrong type") }
        if(!(is.R6(map_) && class(map_)[1] == "ConsensusMap")){ stop("arg map_ wrong type") }
        v0 <- r_to_py(feature_ints)
    
        private$py_obj$setNormalizedIntensityValues(v0, map_)
        byref_0 <- map_depth(py_to_r(v0),1,as.list)
    
        tryCatch({
        eval.parent(substitute(feature_ints <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _ConsensusMapNormalizerAlgorithmThreshold
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusMapNormalizerAlgorithmThreshold.html
ConsensusMapNormalizerAlgorithmThreshold <- R6Class(classname = "ConsensusMapNormalizerAlgorithmThreshold",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusMapNormalizerAlgorithmThreshold()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusMapNormalizerAlgorithmThreshold) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusMapNormalizerAlgorithmThreshold()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[double] computeCorrelation(ConsensusMap & input_map, double ratio_threshold, const String & acc_filter, const String & desc_filter)
    computeCorrelation = function(input_map, ratio_threshold, acc_filter, desc_filter){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
        if(!(is_scalar_double(ratio_threshold))){ stop("arg ratio_threshold wrong type") }
        if(!((is.R6(acc_filter) && class(acc_filter)[1]=="String") || is_scalar_character(acc_filter))){ stop("arg acc_filter wrong type") }
        if(!((is.R6(desc_filter) && class(desc_filter)[1]=="String") || is_scalar_character(desc_filter))){ stop("arg desc_filter wrong type") }
    
    
    
    
        py_ans = private$py_obj$computeCorrelation(input_map, ratio_threshold, acc_filter, desc_filter)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void normalizeMaps(ConsensusMap & input_map, libcpp_vector[double] & ratios)
    normalizeMaps = function(input_map, ratios){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
        if(!(is_list(ratios) && all(sapply(ratios,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg ratios wrong type") }
    
        v1 <- r_to_py(ratios)
        private$py_obj$normalizeMaps(input_map, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(ratios <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _ConsensusXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConsensusXMLFile.html
ConsensusXMLFile <- R6Class(classname = "ConsensusXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConsensusXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConsensusXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConsensusXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, ConsensusMap &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "ConsensusMap")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, ConsensusMap &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "ConsensusMap")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _Contact
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Contact.html
Contact <- R6Class(classname = "Contact",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Contact()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Contact) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Contact()
        invisible()
    }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ContactPerson
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ContactPerson.html
ContactPerson <- R6Class(classname = "ContactPerson",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ContactPerson()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ContactPerson) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ContactPerson()
        invisible()
    }
    
    },
    
    # C++ signature: String getFirstName()
    getFirstName = function(){
    
        py_ans = private$py_obj$getFirstName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFirstName(String name)
    setFirstName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setFirstName(name)
        invisible()
    },
    
    # C++ signature: String getLastName()
    getLastName = function(){
    
        py_ans = private$py_obj$getLastName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLastName(String name)
    setLastName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setLastName(name)
        invisible()
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getInstitution()
    getInstitution = function(){
    
        py_ans = private$py_obj$getInstitution()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInstitution(String institution)
    setInstitution = function(institution){
    
        if(!((is.R6(institution) && class(institution)[1]=="String") || is_scalar_character(institution))){ stop("arg institution wrong type") }
    
        private$py_obj$setInstitution(institution)
        invisible()
    },
    
    # C++ signature: String getEmail()
    getEmail = function(){
    
        py_ans = private$py_obj$getEmail()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEmail(String email)
    setEmail = function(email){
    
        if(!((is.R6(email) && class(email)[1]=="String") || is_scalar_character(email))){ stop("arg email wrong type") }
    
        private$py_obj$setEmail(email)
        invisible()
    },
    
    # C++ signature: String getURL()
    getURL = function(){
    
        py_ans = private$py_obj$getURL()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setURL(String email)
    setURL = function(email){
    
        if(!((is.R6(email) && class(email)[1]=="String") || is_scalar_character(email))){ stop("arg email wrong type") }
    
        private$py_obj$setURL(email)
        invisible()
    },
    
    # C++ signature: String getAddress()
    getAddress = function(){
    
        py_ans = private$py_obj$getAddress()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAddress(String email)
    setAddress = function(email){
    
        if(!((is.R6(email) && class(email)[1]=="String") || is_scalar_character(email))){ stop("arg email wrong type") }
    
        private$py_obj$setAddress(email)
        invisible()
    },
    
    # C++ signature: String getContactInfo()
    getContactInfo = function(){
    
        py_ans = private$py_obj$getContactInfo()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setContactInfo(String contact_info)
    setContactInfo = function(contact_info){
    
        if(!((is.R6(contact_info) && class(contact_info)[1]=="String") || is_scalar_character(contact_info))){ stop("arg contact_info wrong type") }
    
        private$py_obj$setContactInfo(contact_info)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ContinuousWaveletTransform
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ContinuousWaveletTransform.html
ContinuousWaveletTransform <- R6Class(classname = "ContinuousWaveletTransform",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ContinuousWaveletTransform()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ContinuousWaveletTransform) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ContinuousWaveletTransform()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[Peak1D] getSignal()
    getSignal = function(){
    
        py_ans = private$py_obj$getSignal()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSignal(libcpp_vector[Peak1D] & signal)
    setSignal = function(signal){
    
        if(!(is_list(signal) && all(sapply(signal,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Peak1D")))){ stop("arg signal wrong type") }
        v0 <- r_to_py(signal)
        private$py_obj$setSignal(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(signal <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] getWavelet()
    getWavelet = function(){
    
        py_ans = private$py_obj$getWavelet()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setWavelet(libcpp_vector[double] & wavelet)
    setWavelet = function(wavelet){
    
        if(!(is_list(wavelet) && all(sapply(wavelet,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg wavelet wrong type") }
        v0 <- r_to_py(wavelet)
        private$py_obj$setWavelet(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(wavelet <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getScale()
    getScale = function(){
    
        py_ans = private$py_obj$getScale()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScale(double scale)
    setScale = function(scale){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
    
        private$py_obj$setScale(scale)
        invisible()
    },
    
    # C++ signature: double getSpacing()
    getSpacing = function(){
    
        py_ans = private$py_obj$getSpacing()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpacing(double spacing)
    setSpacing = function(spacing){
    
        if(!(is_scalar_double(spacing))){ stop("arg spacing wrong type") }
    
        private$py_obj$setSpacing(spacing)
        invisible()
    },
    
    # C++ signature: ptrdiff_t getLeftPaddingIndex()
    getLeftPaddingIndex = function(){
    
        py_ans = private$py_obj$getLeftPaddingIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLeftPaddingIndex(ptrdiff_t end_left_padding)
    setLeftPaddingIndex = function(end_left_padding){
    
        if(!( (is_scalar_integer(end_left_padding) || is_scalar_double(end_left_padding)) && end_left_padding == as.integer(end_left_padding))){ stop("arg end_left_padding wrong type") }
    
        private$py_obj$setLeftPaddingIndex(as.integer(end_left_padding))
        invisible()
    },
    
    # C++ signature: ptrdiff_t getRightPaddingIndex()
    getRightPaddingIndex = function(){
    
        py_ans = private$py_obj$getRightPaddingIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRightPaddingIndex(ptrdiff_t begin_right_padding)
    setRightPaddingIndex = function(begin_right_padding){
    
        if(!( (is_scalar_integer(begin_right_padding) || is_scalar_double(begin_right_padding)) && begin_right_padding == as.integer(begin_right_padding))){ stop("arg begin_right_padding wrong type") }
    
        private$py_obj$setRightPaddingIndex(as.integer(begin_right_padding))
        invisible()
    },
    
    # C++ signature: ptrdiff_t getSignalLength()
    getSignalLength = function(){
    
        py_ans = private$py_obj$getSignalLength()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSignalLength(ptrdiff_t signal_length)
    setSignalLength = function(signal_length){
    
        if(!( (is_scalar_integer(signal_length) || is_scalar_double(signal_length)) && signal_length == as.integer(signal_length))){ stop("arg signal_length wrong type") }
    
        private$py_obj$setSignalLength(as.integer(signal_length))
        invisible()
    },
    
    # C++ signature: int getSize()
    getSize = function(){
    
        py_ans = private$py_obj$getSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void init(double scale, double spacing)
    init = function(scale, spacing){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(spacing))){ stop("arg spacing wrong type") }
    
    
        private$py_obj$init(scale, spacing)
        invisible()
    }
)
) 

# R implementation of _ContinuousWaveletTransformNumIntegration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ContinuousWaveletTransformNumIntegration.html
ContinuousWaveletTransformNumIntegration <- R6Class(classname = "ContinuousWaveletTransformNumIntegration",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ContinuousWaveletTransformNumIntegration()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ContinuousWaveletTransformNumIntegration) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ContinuousWaveletTransformNumIntegration()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[Peak1D] getSignal()
    getSignal = function(){
    
        py_ans = private$py_obj$getSignal()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSignal(libcpp_vector[Peak1D] & signal)
    setSignal = function(signal){
    
        if(!(is_list(signal) && all(sapply(signal,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Peak1D")))){ stop("arg signal wrong type") }
        v0 <- r_to_py(signal)
        private$py_obj$setSignal(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(signal <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] getWavelet()
    getWavelet = function(){
    
        py_ans = private$py_obj$getWavelet()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setWavelet(libcpp_vector[double] & wavelet)
    setWavelet = function(wavelet){
    
        if(!(is_list(wavelet) && all(sapply(wavelet,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg wavelet wrong type") }
        v0 <- r_to_py(wavelet)
        private$py_obj$setWavelet(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(wavelet <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getScale()
    getScale = function(){
    
        py_ans = private$py_obj$getScale()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScale(double scale)
    setScale = function(scale){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
    
        private$py_obj$setScale(scale)
        invisible()
    },
    
    # C++ signature: double getSpacing()
    getSpacing = function(){
    
        py_ans = private$py_obj$getSpacing()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpacing(double spacing)
    setSpacing = function(spacing){
    
        if(!(is_scalar_double(spacing))){ stop("arg spacing wrong type") }
    
        private$py_obj$setSpacing(spacing)
        invisible()
    },
    
    # C++ signature: ptrdiff_t getLeftPaddingIndex()
    getLeftPaddingIndex = function(){
    
        py_ans = private$py_obj$getLeftPaddingIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLeftPaddingIndex(ptrdiff_t end_left_padding)
    setLeftPaddingIndex = function(end_left_padding){
    
        if(!( (is_scalar_integer(end_left_padding) || is_scalar_double(end_left_padding)) && end_left_padding == as.integer(end_left_padding))){ stop("arg end_left_padding wrong type") }
    
        private$py_obj$setLeftPaddingIndex(as.integer(end_left_padding))
        invisible()
    },
    
    # C++ signature: ptrdiff_t getRightPaddingIndex()
    getRightPaddingIndex = function(){
    
        py_ans = private$py_obj$getRightPaddingIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRightPaddingIndex(ptrdiff_t begin_right_padding)
    setRightPaddingIndex = function(begin_right_padding){
    
        if(!( (is_scalar_integer(begin_right_padding) || is_scalar_double(begin_right_padding)) && begin_right_padding == as.integer(begin_right_padding))){ stop("arg begin_right_padding wrong type") }
    
        private$py_obj$setRightPaddingIndex(as.integer(begin_right_padding))
        invisible()
    },
    
    # C++ signature: ptrdiff_t getSignalLength()
    getSignalLength = function(){
    
        py_ans = private$py_obj$getSignalLength()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSignalLength(ptrdiff_t signal_length)
    setSignalLength = function(signal_length){
    
        if(!( (is_scalar_integer(signal_length) || is_scalar_double(signal_length)) && signal_length == as.integer(signal_length))){ stop("arg signal_length wrong type") }
    
        private$py_obj$setSignalLength(as.integer(signal_length))
        invisible()
    },
    
    # C++ signature: int getSize()
    getSize = function(){
    
        py_ans = private$py_obj$getSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void init(double scale, double spacing)
    init = function(scale, spacing){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(spacing))){ stop("arg spacing wrong type") }
    
    
        private$py_obj$init(scale, spacing)
        invisible()
    }
)
) 

# R implementation of _ControlledVocabulary
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ControlledVocabulary.html
ControlledVocabulary <- R6Class(classname = "ControlledVocabulary",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ControlledVocabulary()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ControlledVocabulary()
        invisible()
    
    
    },
    
    # C++ signature: void ControlledVocabulary(ControlledVocabulary & voc)
    init_1 = function(voc){
    
        if(!(is.R6(voc) && class(voc)[1] == "ControlledVocabulary")){ stop("arg voc wrong type") }
    
    
        private$py_obj <- Pymod$ControlledVocabulary(voc)
        invisible()
    
    
    },
    
    # C++ signature: void ControlledVocabulary()
    # C++ signature: void ControlledVocabulary(ControlledVocabulary & voc)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ControlledVocabulary")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ControlledVocabulary" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String name()
    name = function(){
    
        py_ans = private$py_obj$name()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void loadFromOBO(String name, String filename)
    loadFromOBO = function(name, filename){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj$loadFromOBO(name, filename)
        invisible()
    },
    
    # C++ signature: bool exists(String id)
    exists = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$exists(id)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasTermWithName(String name)
    hasTermWithName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$hasTermWithName(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: CVTerm_ControlledVocabulary getTerm(String id)
    getTerm = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getTerm(id)
        r_ans = CVTerm_ControlledVocabulary$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: CVTerm_ControlledVocabulary getTermByName(String name, String desc)
    getTermByName = function(name, desc){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(desc) && class(desc)[1]=="String") || is_scalar_character(desc))){ stop("arg desc wrong type") }
    
    
        py_ans = private$py_obj$getTermByName(name, desc)
        r_ans = CVTerm_ControlledVocabulary$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getAllChildTerms(libcpp_set[String] terms, String parent)
    getAllChildTerms = function(terms, parent){
    
        if(!(is_list(terms) && all(sapply(terms),is_scalar_character) && !any(duplicated(terms) == T))){ stop("arg terms wrong type") }
        if(!((is.R6(parent) && class(parent)[1]=="String") || is_scalar_character(parent))){ stop("arg parent wrong type") }
        v0 = py_builtin$set(modify_depth(terms,1,py_builtin$bytes(terms,'utf-8')))
    
        private$py_obj$getAllChildTerms(v0, parent)
        invisible()
    },
    
    # C++ signature: bool isChildOf(String child, String parent)
    isChildOf = function(child, parent){
    
        if(!((is.R6(child) && class(child)[1]=="String") || is_scalar_character(child))){ stop("arg child wrong type") }
        if(!((is.R6(parent) && class(parent)[1]=="String") || is_scalar_character(parent))){ stop("arg parent wrong type") }
    
    
        py_ans = private$py_obj$isChildOf(child, parent)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ConvexHull2D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ConvexHull2D.html
ConvexHull2D <- R6Class(classname = "ConvexHull2D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ConvexHull2D()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ConvexHull2D) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ConvexHull2D()
        invisible()
    }
    
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: size_t compress()
    compress = function(){
    
        py_ans = private$py_obj$compress()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void expandToBoundingBox()
    expandToBoundingBox = function(){
    
        private$py_obj$expandToBoundingBox()
        invisible()
    },
    
    # C++ signature: bool addPoint(DPosition2 point)
    addPoint = function(point){
    
        if(!(is_list(point) && length(point) == 2 && (is_scalar_integer(point[[1]]) || is_scalar_double(point[[1]])) && (is_scalar_integer(point[[2]]) || is_scalar_double(point[[2]])))){ stop("arg point wrong type") }
        dp_0 <- r_to_py(point)
        py_ans = private$py_obj$addPoint(dp_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addPoints(libcpp_vector[DPosition2] points)
    addPoints = function(points){
    
        if(!(is.matrix(points) && NROW(points) == 2 && is_double(points[1,]) && is_double(points[2,]))){ stop("arg points wrong type") }
        dp_0 <- r_to_py(points)
        private$py_obj$addPoints(dp_0)
        invisible()
    },
    
    # C++ signature: bool encloses(DPosition2)
    encloses = function(in_0){
    
        if(!(is_list(in_0) && length(in_0) == 2 && (is_scalar_integer(in_0[[1]]) || is_scalar_double(in_0[[1]])) && (is_scalar_integer(in_0[[2]]) || is_scalar_double(in_0[[2]])))){ stop("arg in_0 wrong type") }
        dp_0 <- r_to_py(in_0)
        py_ans = private$py_obj$encloses(dp_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[DPosition2] getHullPoints()
    getHullPoints = function(){
    
        py_ans = private$py_obj$getHullPoints()
        r_ans <- py_ans
        return(r_ans)
    },
    
    # C++ signature: void setHullPoints(libcpp_vector[DPosition2])
    setHullPoints = function(in_0){
    
        if(!(is.matrix(in_0) && NROW(in_0) == 2 && is_double(in_0[1,]) && is_double(in_0[2,]))){ stop("arg in_0 wrong type") }
        dp_0 <- r_to_py(in_0)
        private$py_obj$setHullPoints(dp_0)
        invisible()
    },
    
    # C++ signature: DBoundingBox2 getBoundingBox()
    getBoundingBox = function(){
    
        py_ans = private$py_obj$getBoundingBox()
        r_ans = DBoundingBox2$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _CrossLinkSpectrumMatch
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::OPXLDataStructs_1_1CrossLinkSpectrumMatch.html
CrossLinkSpectrumMatch <- R6Class(classname = "CrossLinkSpectrumMatch",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        cross_link = function(cross_link){
    
        if(!missing(cross_link)){
            if(!(is.R6(cross_link) && class(cross_link)[1] == "ProteinProteinCrossLink")){ stop("arg cross_link wrong type") }
        
        
            private$py_obj$cross_link <- cross_link
            } else {
        
                py_ans = private$py_obj$cross_link
            r_result = ProteinProteinCrossLink$new(py_ans)
                return(r_result)
                }
        },
        scan_index_light = function(scan_index_light){
    
        if(!missing(scan_index_light)){
            if(!( (is_scalar_integer(scan_index_light) || is_scalar_double(scan_index_light)) && scan_index_light == as.integer(scan_index_light))){ stop("arg scan_index_light wrong type") }
        
        
            private$py_obj$scan_index_light <- as.integer(scan_index_light)
            } else {
        
                py_ans = private$py_obj$scan_index_light
                r_result = py_ans
                return(r_result)
                }
        },
        scan_index_heavy = function(scan_index_heavy){
    
        if(!missing(scan_index_heavy)){
            if(!( (is_scalar_integer(scan_index_heavy) || is_scalar_double(scan_index_heavy)) && scan_index_heavy == as.integer(scan_index_heavy))){ stop("arg scan_index_heavy wrong type") }
        
        
            private$py_obj$scan_index_heavy <- as.integer(scan_index_heavy)
            } else {
        
                py_ans = private$py_obj$scan_index_heavy
                r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        rank = function(rank){
    
        if(!missing(rank)){
            if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        
        
            private$py_obj$rank <- as.integer(rank)
            } else {
        
                py_ans = private$py_obj$rank
                r_result = py_ans
                return(r_result)
                }
        },
        xquest_score = function(xquest_score){
    
        if(!missing(xquest_score)){
            if(!(is_scalar_double(xquest_score))){ stop("arg xquest_score wrong type") }
        
        
            private$py_obj$xquest_score <- xquest_score
            } else {
        
                py_ans = private$py_obj$xquest_score
                r_result = py_ans
                return(r_result)
                }
        },
        pre_score = function(pre_score){
    
        if(!missing(pre_score)){
            if(!(is_scalar_double(pre_score))){ stop("arg pre_score wrong type") }
        
        
            private$py_obj$pre_score <- pre_score
            } else {
        
                py_ans = private$py_obj$pre_score
                r_result = py_ans
                return(r_result)
                }
        },
        percTIC = function(percTIC){
    
        if(!missing(percTIC)){
            if(!(is_scalar_double(percTIC))){ stop("arg percTIC wrong type") }
        
        
            private$py_obj$percTIC <- percTIC
            } else {
        
                py_ans = private$py_obj$percTIC
                r_result = py_ans
                return(r_result)
                }
        },
        wTIC = function(wTIC){
    
        if(!missing(wTIC)){
            if(!(is_scalar_double(wTIC))){ stop("arg wTIC wrong type") }
        
        
            private$py_obj$wTIC <- wTIC
            } else {
        
                py_ans = private$py_obj$wTIC
                r_result = py_ans
                return(r_result)
                }
        },
        wTICold = function(wTICold){
    
        if(!missing(wTICold)){
            if(!(is_scalar_double(wTICold))){ stop("arg wTICold wrong type") }
        
        
            private$py_obj$wTICold <- wTICold
            } else {
        
                py_ans = private$py_obj$wTICold
                r_result = py_ans
                return(r_result)
                }
        },
        int_sum = function(int_sum){
    
        if(!missing(int_sum)){
            if(!(is_scalar_double(int_sum))){ stop("arg int_sum wrong type") }
        
        
            private$py_obj$int_sum <- int_sum
            } else {
        
                py_ans = private$py_obj$int_sum
                r_result = py_ans
                return(r_result)
                }
        },
        intsum_alpha = function(intsum_alpha){
    
        if(!missing(intsum_alpha)){
            if(!(is_scalar_double(intsum_alpha))){ stop("arg intsum_alpha wrong type") }
        
        
            private$py_obj$intsum_alpha <- intsum_alpha
            } else {
        
                py_ans = private$py_obj$intsum_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        intsum_beta = function(intsum_beta){
    
        if(!missing(intsum_beta)){
            if(!(is_scalar_double(intsum_beta))){ stop("arg intsum_beta wrong type") }
        
        
            private$py_obj$intsum_beta <- intsum_beta
            } else {
        
                py_ans = private$py_obj$intsum_beta
                r_result = py_ans
                return(r_result)
                }
        },
        total_current = function(total_current){
    
        if(!missing(total_current)){
            if(!(is_scalar_double(total_current))){ stop("arg total_current wrong type") }
        
        
            private$py_obj$total_current <- total_current
            } else {
        
                py_ans = private$py_obj$total_current
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_error_ppm = function(precursor_error_ppm){
    
        if(!missing(precursor_error_ppm)){
            if(!(is_scalar_double(precursor_error_ppm))){ stop("arg precursor_error_ppm wrong type") }
        
        
            private$py_obj$precursor_error_ppm <- precursor_error_ppm
            } else {
        
                py_ans = private$py_obj$precursor_error_ppm
                r_result = py_ans
                return(r_result)
                }
        },
        match_odds = function(match_odds){
    
        if(!missing(match_odds)){
            if(!(is_scalar_double(match_odds))){ stop("arg match_odds wrong type") }
        
        
            private$py_obj$match_odds <- match_odds
            } else {
        
                py_ans = private$py_obj$match_odds
                r_result = py_ans
                return(r_result)
                }
        },
        match_odds_alpha = function(match_odds_alpha){
    
        if(!missing(match_odds_alpha)){
            if(!(is_scalar_double(match_odds_alpha))){ stop("arg match_odds_alpha wrong type") }
        
        
            private$py_obj$match_odds_alpha <- match_odds_alpha
            } else {
        
                py_ans = private$py_obj$match_odds_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        match_odds_beta = function(match_odds_beta){
    
        if(!missing(match_odds_beta)){
            if(!(is_scalar_double(match_odds_beta))){ stop("arg match_odds_beta wrong type") }
        
        
            private$py_obj$match_odds_beta <- match_odds_beta
            } else {
        
                py_ans = private$py_obj$match_odds_beta
                r_result = py_ans
                return(r_result)
                }
        },
        log_occupancy = function(log_occupancy){
    
        if(!missing(log_occupancy)){
            if(!(is_scalar_double(log_occupancy))){ stop("arg log_occupancy wrong type") }
        
        
            private$py_obj$log_occupancy <- log_occupancy
            } else {
        
                py_ans = private$py_obj$log_occupancy
                r_result = py_ans
                return(r_result)
                }
        },
        log_occupancy_alpha = function(log_occupancy_alpha){
    
        if(!missing(log_occupancy_alpha)){
            if(!(is_scalar_double(log_occupancy_alpha))){ stop("arg log_occupancy_alpha wrong type") }
        
        
            private$py_obj$log_occupancy_alpha <- log_occupancy_alpha
            } else {
        
                py_ans = private$py_obj$log_occupancy_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        log_occupancy_beta = function(log_occupancy_beta){
    
        if(!missing(log_occupancy_beta)){
            if(!(is_scalar_double(log_occupancy_beta))){ stop("arg log_occupancy_beta wrong type") }
        
        
            private$py_obj$log_occupancy_beta <- log_occupancy_beta
            } else {
        
                py_ans = private$py_obj$log_occupancy_beta
                r_result = py_ans
                return(r_result)
                }
        },
        xcorrx_max = function(xcorrx_max){
    
        if(!missing(xcorrx_max)){
            if(!(is_scalar_double(xcorrx_max))){ stop("arg xcorrx_max wrong type") }
        
        
            private$py_obj$xcorrx_max <- xcorrx_max
            } else {
        
                py_ans = private$py_obj$xcorrx_max
                r_result = py_ans
                return(r_result)
                }
        },
        xcorrc_max = function(xcorrc_max){
    
        if(!missing(xcorrc_max)){
            if(!(is_scalar_double(xcorrc_max))){ stop("arg xcorrc_max wrong type") }
        
        
            private$py_obj$xcorrc_max <- xcorrc_max
            } else {
        
                py_ans = private$py_obj$xcorrc_max
                r_result = py_ans
                return(r_result)
                }
        },
        matched_linear_alpha = function(matched_linear_alpha){
    
        if(!missing(matched_linear_alpha)){
            if(!( (is_scalar_integer(matched_linear_alpha) || is_scalar_double(matched_linear_alpha)) && matched_linear_alpha == as.integer(matched_linear_alpha))){ stop("arg matched_linear_alpha wrong type") }
        
        
            private$py_obj$matched_linear_alpha <- as.integer(matched_linear_alpha)
            } else {
        
                py_ans = private$py_obj$matched_linear_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        matched_linear_beta = function(matched_linear_beta){
    
        if(!missing(matched_linear_beta)){
            if(!( (is_scalar_integer(matched_linear_beta) || is_scalar_double(matched_linear_beta)) && matched_linear_beta == as.integer(matched_linear_beta))){ stop("arg matched_linear_beta wrong type") }
        
        
            private$py_obj$matched_linear_beta <- as.integer(matched_linear_beta)
            } else {
        
                py_ans = private$py_obj$matched_linear_beta
                r_result = py_ans
                return(r_result)
                }
        },
        matched_xlink_alpha = function(matched_xlink_alpha){
    
        if(!missing(matched_xlink_alpha)){
            if(!( (is_scalar_integer(matched_xlink_alpha) || is_scalar_double(matched_xlink_alpha)) && matched_xlink_alpha == as.integer(matched_xlink_alpha))){ stop("arg matched_xlink_alpha wrong type") }
        
        
            private$py_obj$matched_xlink_alpha <- as.integer(matched_xlink_alpha)
            } else {
        
                py_ans = private$py_obj$matched_xlink_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        matched_xlink_beta = function(matched_xlink_beta){
    
        if(!missing(matched_xlink_beta)){
            if(!( (is_scalar_integer(matched_xlink_beta) || is_scalar_double(matched_xlink_beta)) && matched_xlink_beta == as.integer(matched_xlink_beta))){ stop("arg matched_xlink_beta wrong type") }
        
        
            private$py_obj$matched_xlink_beta <- as.integer(matched_xlink_beta)
            } else {
        
                py_ans = private$py_obj$matched_xlink_beta
                r_result = py_ans
                return(r_result)
                }
        },
        num_iso_peaks_mean = function(num_iso_peaks_mean){
    
        if(!missing(num_iso_peaks_mean)){
            if(!(is_scalar_double(num_iso_peaks_mean))){ stop("arg num_iso_peaks_mean wrong type") }
        
        
            private$py_obj$num_iso_peaks_mean <- num_iso_peaks_mean
            } else {
        
                py_ans = private$py_obj$num_iso_peaks_mean
                r_result = py_ans
                return(r_result)
                }
        },
        num_iso_peaks_mean_linear_alpha = function(num_iso_peaks_mean_linear_alpha){
    
        if(!missing(num_iso_peaks_mean_linear_alpha)){
            if(!(is_scalar_double(num_iso_peaks_mean_linear_alpha))){ stop("arg num_iso_peaks_mean_linear_alpha wrong type") }
        
        
            private$py_obj$num_iso_peaks_mean_linear_alpha <- num_iso_peaks_mean_linear_alpha
            } else {
        
                py_ans = private$py_obj$num_iso_peaks_mean_linear_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        num_iso_peaks_mean_linear_beta = function(num_iso_peaks_mean_linear_beta){
    
        if(!missing(num_iso_peaks_mean_linear_beta)){
            if(!(is_scalar_double(num_iso_peaks_mean_linear_beta))){ stop("arg num_iso_peaks_mean_linear_beta wrong type") }
        
        
            private$py_obj$num_iso_peaks_mean_linear_beta <- num_iso_peaks_mean_linear_beta
            } else {
        
                py_ans = private$py_obj$num_iso_peaks_mean_linear_beta
                r_result = py_ans
                return(r_result)
                }
        },
        num_iso_peaks_mean_xlinks_alpha = function(num_iso_peaks_mean_xlinks_alpha){
    
        if(!missing(num_iso_peaks_mean_xlinks_alpha)){
            if(!(is_scalar_double(num_iso_peaks_mean_xlinks_alpha))){ stop("arg num_iso_peaks_mean_xlinks_alpha wrong type") }
        
        
            private$py_obj$num_iso_peaks_mean_xlinks_alpha <- num_iso_peaks_mean_xlinks_alpha
            } else {
        
                py_ans = private$py_obj$num_iso_peaks_mean_xlinks_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        num_iso_peaks_mean_xlinks_beta = function(num_iso_peaks_mean_xlinks_beta){
    
        if(!missing(num_iso_peaks_mean_xlinks_beta)){
            if(!(is_scalar_double(num_iso_peaks_mean_xlinks_beta))){ stop("arg num_iso_peaks_mean_xlinks_beta wrong type") }
        
        
            private$py_obj$num_iso_peaks_mean_xlinks_beta <- num_iso_peaks_mean_xlinks_beta
            } else {
        
                py_ans = private$py_obj$num_iso_peaks_mean_xlinks_beta
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_linear_alpha = function(ppm_error_abs_sum_linear_alpha){
    
        if(!missing(ppm_error_abs_sum_linear_alpha)){
            if(!(is_scalar_double(ppm_error_abs_sum_linear_alpha))){ stop("arg ppm_error_abs_sum_linear_alpha wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_linear_alpha <- ppm_error_abs_sum_linear_alpha
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_linear_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_linear_beta = function(ppm_error_abs_sum_linear_beta){
    
        if(!missing(ppm_error_abs_sum_linear_beta)){
            if(!(is_scalar_double(ppm_error_abs_sum_linear_beta))){ stop("arg ppm_error_abs_sum_linear_beta wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_linear_beta <- ppm_error_abs_sum_linear_beta
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_linear_beta
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_xlinks_alpha = function(ppm_error_abs_sum_xlinks_alpha){
    
        if(!missing(ppm_error_abs_sum_xlinks_alpha)){
            if(!(is_scalar_double(ppm_error_abs_sum_xlinks_alpha))){ stop("arg ppm_error_abs_sum_xlinks_alpha wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_xlinks_alpha <- ppm_error_abs_sum_xlinks_alpha
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_xlinks_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_xlinks_beta = function(ppm_error_abs_sum_xlinks_beta){
    
        if(!missing(ppm_error_abs_sum_xlinks_beta)){
            if(!(is_scalar_double(ppm_error_abs_sum_xlinks_beta))){ stop("arg ppm_error_abs_sum_xlinks_beta wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_xlinks_beta <- ppm_error_abs_sum_xlinks_beta
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_xlinks_beta
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_linear = function(ppm_error_abs_sum_linear){
    
        if(!missing(ppm_error_abs_sum_linear)){
            if(!(is_scalar_double(ppm_error_abs_sum_linear))){ stop("arg ppm_error_abs_sum_linear wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_linear <- ppm_error_abs_sum_linear
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_linear
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_xlinks = function(ppm_error_abs_sum_xlinks){
    
        if(!missing(ppm_error_abs_sum_xlinks)){
            if(!(is_scalar_double(ppm_error_abs_sum_xlinks))){ stop("arg ppm_error_abs_sum_xlinks wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_xlinks <- ppm_error_abs_sum_xlinks
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_xlinks
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_alpha = function(ppm_error_abs_sum_alpha){
    
        if(!missing(ppm_error_abs_sum_alpha)){
            if(!(is_scalar_double(ppm_error_abs_sum_alpha))){ stop("arg ppm_error_abs_sum_alpha wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_alpha <- ppm_error_abs_sum_alpha
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum_beta = function(ppm_error_abs_sum_beta){
    
        if(!missing(ppm_error_abs_sum_beta)){
            if(!(is_scalar_double(ppm_error_abs_sum_beta))){ stop("arg ppm_error_abs_sum_beta wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum_beta <- ppm_error_abs_sum_beta
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum_beta
                r_result = py_ans
                return(r_result)
                }
        },
        ppm_error_abs_sum = function(ppm_error_abs_sum){
    
        if(!missing(ppm_error_abs_sum)){
            if(!(is_scalar_double(ppm_error_abs_sum))){ stop("arg ppm_error_abs_sum wrong type") }
        
        
            private$py_obj$ppm_error_abs_sum <- ppm_error_abs_sum
            } else {
        
                py_ans = private$py_obj$ppm_error_abs_sum
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_correction = function(precursor_correction){
    
        if(!missing(precursor_correction)){
            if(!( (is_scalar_integer(precursor_correction) || is_scalar_double(precursor_correction)) && precursor_correction == as.integer(precursor_correction))){ stop("arg precursor_correction wrong type") }
        
        
            private$py_obj$precursor_correction <- as.integer(precursor_correction)
            } else {
        
                py_ans = private$py_obj$precursor_correction
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_total_intensity = function(precursor_total_intensity){
    
        if(!missing(precursor_total_intensity)){
            if(!(is_scalar_double(precursor_total_intensity))){ stop("arg precursor_total_intensity wrong type") }
        
        
            private$py_obj$precursor_total_intensity <- precursor_total_intensity
            } else {
        
                py_ans = private$py_obj$precursor_total_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_target_intensity = function(precursor_target_intensity){
    
        if(!missing(precursor_target_intensity)){
            if(!(is_scalar_double(precursor_target_intensity))){ stop("arg precursor_target_intensity wrong type") }
        
        
            private$py_obj$precursor_target_intensity <- precursor_target_intensity
            } else {
        
                py_ans = private$py_obj$precursor_target_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_signal_proportion = function(precursor_signal_proportion){
    
        if(!missing(precursor_signal_proportion)){
            if(!(is_scalar_double(precursor_signal_proportion))){ stop("arg precursor_signal_proportion wrong type") }
        
        
            private$py_obj$precursor_signal_proportion <- precursor_signal_proportion
            } else {
        
                py_ans = private$py_obj$precursor_signal_proportion
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_target_peak_count = function(precursor_target_peak_count){
    
        if(!missing(precursor_target_peak_count)){
            if(!( (is_scalar_integer(precursor_target_peak_count) || is_scalar_double(precursor_target_peak_count)) && precursor_target_peak_count == as.integer(precursor_target_peak_count))){ stop("arg precursor_target_peak_count wrong type") }
        
        
            private$py_obj$precursor_target_peak_count <- as.integer(precursor_target_peak_count)
            } else {
        
                py_ans = private$py_obj$precursor_target_peak_count
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_residual_peak_count = function(precursor_residual_peak_count){
    
        if(!missing(precursor_residual_peak_count)){
            if(!( (is_scalar_integer(precursor_residual_peak_count) || is_scalar_double(precursor_residual_peak_count)) && precursor_residual_peak_count == as.integer(precursor_residual_peak_count))){ stop("arg precursor_residual_peak_count wrong type") }
        
        
            private$py_obj$precursor_residual_peak_count <- as.integer(precursor_residual_peak_count)
            } else {
        
                py_ans = private$py_obj$precursor_residual_peak_count
                r_result = py_ans
                return(r_result)
                }
        },
        frag_annotations = function(frag_annotations){
    
        if(!missing(frag_annotations)){
            if(!(is_list(frag_annotations) && all(sapply(frag_annotations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_PeakAnnotation")))){ stop("arg frag_annotations wrong type") }
        
            v0 <- r_to_py(frag_annotations)
            private$py_obj$frag_annotations <- v0
            } else {
            
                py_ans = private$py_obj$frag_annotations
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        peptide_id_index = function(peptide_id_index){
    
        if(!missing(peptide_id_index)){
            if(!( (is_scalar_integer(peptide_id_index) || is_scalar_double(peptide_id_index)) && peptide_id_index == as.integer(peptide_id_index))){ stop("arg peptide_id_index wrong type") }
        
        
            private$py_obj$peptide_id_index <- as.integer(peptide_id_index)
            } else {
        
                py_ans = private$py_obj$peptide_id_index
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CrossLinkSpectrumMatch(CrossLinkSpectrumMatch)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CrossLinkSpectrumMatch")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$CrossLinkSpectrumMatch(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void CrossLinkSpectrumMatch()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$CrossLinkSpectrumMatch()
        invisible()
    
    
    },
    
    # C++ signature: void CrossLinkSpectrumMatch(CrossLinkSpectrumMatch)
    # C++ signature: void CrossLinkSpectrumMatch()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CrossLinkSpectrumMatch")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CrossLinkSpectrumMatch" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _CrossLinksDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CrossLinksDB.html
CrossLinksDB <- R6Class(classname = "CrossLinksDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: size_t getNumberOfModifications()
    getNumberOfModifications = function(){
    
        py_ans = private$py_obj$getNumberOfModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void searchModifications(libcpp_set[const ResidueModification *] & mods, const String & mod_name, const String & residue, TermSpecificity term_spec)
    searchModifications = function(mods, mod_name, residue, term_spec){
    
        if(!(
              is_list(mods) && all(sapply(mods,function(el) is.R6(el) && class(el)[1] == "ResidueModification")) && length(mods) == py_to_r(py_builtin$len(py_builtin$set(mods)))
              )){ stop("arg mods wrong type") }
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
        py$v0 <- lapply(mods,function(item0) item0$.__enclos_env__$private$py_obj)
        py_run_string("v0 = set(v0)")
    
    
    
        private$py_obj$searchModifications(py$v0, mod_name, residue, as.integer(term_spec))
        byref_0 <- py_eval("list(v0)")
        byref_0 <- lapply(byref_0,function(x) ResidueModification$new(x))
        py_run_string("del v0; gc.collect()")
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: const ResidueModification * getModification(size_t index)
    getModification_0 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getModification_0`(as.integer(index)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(const String & mod_name)
    getModification_1 = function(mod_name){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
    
        py_ans = private$py_obj$`_getModification_1`(mod_name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(const String & mod_name, const String & residue, TermSpecificity term_spec)
    getModification_2 = function(mod_name, residue, term_spec){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
    
    
    
        py_ans = private$py_obj$`_getModification_2`(mod_name, residue, as.integer(term_spec)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(size_t index)
    # C++ signature: const ResidueModification * getModification(const String & mod_name)
    # C++ signature: const ResidueModification * getModification(const String & mod_name, const String & residue, TermSpecificity term_spec)
    getModification = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getModification_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getModification_1(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (arg_list[[3]] %in% c(0, 1, 2, 3, 4, 5))) { self$getModification_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool has(String modification)
    has = function(modification){
    
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
        py_ans = private$py_obj$has(modification)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addModification(ResidueModification * new_mod)
    addModification = function(new_mod){
    
        if(!(is.R6(new_mod) && class(new_mod)[1] == "ResidueModification")){ stop("arg new_mod wrong type") }
    
        private$py_obj$addModification(new_mod)
        invisible()
    },
    
    # C++ signature: size_t findModificationIndex(const String & mod_name)
    findModificationIndex = function(mod_name){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
    
        py_ans = private$py_obj$findModificationIndex(mod_name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void searchModificationsByDiffMonoMass(libcpp_vector[String] & mods, double mass, double max_error, const String & residue, TermSpecificity term_spec)
    searchModificationsByDiffMonoMass = function(mods, mass, max_error, residue, term_spec){
    
        if(!(is_list(mods) && all(sapply(mods),is_scalar_character))){ stop("arg mods wrong type") }
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(max_error))){ stop("arg max_error wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
        v0 = r_to_py(modify_depth(mods,1,py_builtin$bytes(mods,'utf-8')))
    
    
    
    
        private$py_obj$searchModificationsByDiffMonoMass(v0, mass, max_error, residue, as.integer(term_spec))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: const ResidueModification * getBestModificationByDiffMonoMass(double mass, double max_error, const String residue, TermSpecificity term_spec)
    getBestModificationByDiffMonoMass = function(mass, max_error, residue, term_spec){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(max_error))){ stop("arg max_error wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
    
    
    
    
        py_ans = private$py_obj$getBestModificationByDiffMonoMass(mass, max_error, residue, as.integer(term_spec)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getAllSearchModifications(libcpp_vector[String] & modifications)
    getAllSearchModifications = function(modifications){
    
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character))){ stop("arg modifications wrong type") }
        v0 = r_to_py(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$getAllSearchModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(modifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void readFromOBOFile(const String & filename)
    readFromOBOFile = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$readFromOBOFile(filename)
        invisible()
    },
    
    # C++ signature: bool isInstantiated()
    isInstantiated = function(){
    
        py_ans = private$py_obj$isInstantiated()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _CsiAdapterHit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::CsiFingerIdMzTabWriter_1_1CsiAdapterHit.html
CsiAdapterHit <- R6Class(classname = "CsiAdapterHit",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        inchikey2D = function(inchikey2D){
    
        if(!missing(inchikey2D)){
            if(!((is.R6(inchikey2D) && class(inchikey2D)[1]=="String") || is_scalar_character(inchikey2D))){ stop("arg inchikey2D wrong type") }
        
        
            private$py_obj$inchikey2D <- inchikey2D
            } else {
        
                py_ans = private$py_obj$inchikey2D
            r_result = py_ans
                return(r_result)
                }
        },
        inchi = function(inchi){
    
        if(!missing(inchi)){
            if(!((is.R6(inchi) && class(inchi)[1]=="String") || is_scalar_character(inchi))){ stop("arg inchi wrong type") }
        
        
            private$py_obj$inchi <- inchi
            } else {
        
                py_ans = private$py_obj$inchi
            r_result = py_ans
                return(r_result)
                }
        },
        rank = function(rank){
    
        if(!missing(rank)){
            if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        
        
            private$py_obj$rank <- as.integer(rank)
            } else {
        
                py_ans = private$py_obj$rank
                r_result = py_ans
                return(r_result)
                }
        },
        molecular_formula = function(molecular_formula){
    
        if(!missing(molecular_formula)){
            if(!((is.R6(molecular_formula) && class(molecular_formula)[1]=="String") || is_scalar_character(molecular_formula))){ stop("arg molecular_formula wrong type") }
        
        
            private$py_obj$molecular_formula <- molecular_formula
            } else {
        
                py_ans = private$py_obj$molecular_formula
            r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        smiles = function(smiles){
    
        if(!missing(smiles)){
            if(!((is.R6(smiles) && class(smiles)[1]=="String") || is_scalar_character(smiles))){ stop("arg smiles wrong type") }
        
        
            private$py_obj$smiles <- smiles
            } else {
        
                py_ans = private$py_obj$smiles
            r_result = py_ans
                return(r_result)
                }
        },
        pubchemids = function(pubchemids){
    
        if(!missing(pubchemids)){
            if(!(is_list(pubchemids) && all(sapply(pubchemids),is_scalar_character))){ stop("arg pubchemids wrong type") }
        
            v0 = r_to_py(modify_depth(pubchemids,1,py_builtin$bytes(pubchemids,'utf-8')))
            private$py_obj$pubchemids <- v0
            } else {
        
                py_ans = private$py_obj$pubchemids
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        links = function(links){
    
        if(!missing(links)){
            if(!(is_list(links) && all(sapply(links),is_scalar_character))){ stop("arg links wrong type") }
        
            v0 = r_to_py(modify_depth(links,1,py_builtin$bytes(links,'utf-8')))
            private$py_obj$links <- v0
            } else {
        
                py_ans = private$py_obj$links
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CsiAdapterHit()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == CsiAdapterHit) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$CsiAdapterHit()
        invisible()
    }
    
    }
)
) 

# R implementation of _CsiAdapterIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::CsiFingerIdMzTabWriter_1_1CsiAdapterIdentification.html
CsiAdapterIdentification <- R6Class(classname = "CsiAdapterIdentification",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        scan_index = function(scan_index){
    
        if(!missing(scan_index)){
            if(!( (is_scalar_integer(scan_index) || is_scalar_double(scan_index)) && scan_index == as.integer(scan_index))){ stop("arg scan_index wrong type") }
        
        
            private$py_obj$scan_index <- as.integer(scan_index)
            } else {
        
                py_ans = private$py_obj$scan_index
                r_result = py_ans
                return(r_result)
                }
        },
        scan_number = function(scan_number){
    
        if(!missing(scan_number)){
            if(!( (is_scalar_integer(scan_number) || is_scalar_double(scan_number)) && scan_number == as.integer(scan_number))){ stop("arg scan_number wrong type") }
        
        
            private$py_obj$scan_number <- as.integer(scan_number)
            } else {
        
                py_ans = private$py_obj$scan_number
                r_result = py_ans
                return(r_result)
                }
        },
        feature_id = function(feature_id){
    
        if(!missing(feature_id)){
            if(!((is.R6(feature_id) && class(feature_id)[1]=="String") || is_scalar_character(feature_id))){ stop("arg feature_id wrong type") }
        
        
            private$py_obj$feature_id <- feature_id
            } else {
        
                py_ans = private$py_obj$feature_id
            r_result = py_ans
                return(r_result)
                }
        },
        hits = function(hits){
    
        if(!missing(hits)){
            if(!(is_list(hits) && all(sapply(hits,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CsiAdapterHit")))){ stop("arg hits wrong type") }
        
            v0 <- r_to_py(hits)
            private$py_obj$hits <- v0
            } else {
            
                py_ans = private$py_obj$hits
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CsiAdapterIdentification()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == CsiAdapterIdentification) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$CsiAdapterIdentification()
        invisible()
    }
    
    }
)
) 

# R implementation of _CsiAdapterRun
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::CsiFingerIdMzTabWriter_1_1CsiAdapterRun.html
CsiAdapterRun <- R6Class(classname = "CsiAdapterRun",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        identifications = function(identifications){
    
        if(!missing(identifications)){
            if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CsiAdapterIdentification")))){ stop("arg identifications wrong type") }
        
            v0 <- r_to_py(identifications)
            private$py_obj$identifications <- v0
            } else {
            
                py_ans = private$py_obj$identifications
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void CsiAdapterRun()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == CsiAdapterRun) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$CsiAdapterRun()
        invisible()
    }
    
    }
)
) 

# R implementation of _CsiFingerIdMzTabWriter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CsiFingerIdMzTabWriter.html
CsiFingerIdMzTabWriter <- R6Class(classname = "CsiFingerIdMzTabWriter",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: void read(libcpp_vector[String] sirius_output_paths, String original_input_mzml, size_t top_n_hits, MzTab & result)
    CsiFingerIdMzTabWriter$read = function(sirius_output_paths, original_input_mzml, top_n_hits, result){
    
        if(!(is_list(sirius_output_paths) && all(sapply(sirius_output_paths),is_scalar_character))){ stop("arg sirius_output_paths wrong type") }
        if(!((is.R6(original_input_mzml) && class(original_input_mzml)[1]=="String") || is_scalar_character(original_input_mzml))){ stop("arg original_input_mzml wrong type") }
        if(!( (is_scalar_integer(top_n_hits) || is_scalar_double(top_n_hits)) && top_n_hits == as.integer(top_n_hits))){ stop("arg top_n_hits wrong type") }
        if(!(is.R6(result) && class(result)[1] == "MzTab")){ stop("arg result wrong type") }
        v0 = r_to_py(modify_depth(sirius_output_paths,1,py_builtin$bytes(sirius_output_paths,'utf-8')))
    
    
    
        Pymod$CsiFingerIdMzTabWriter$read(v0, original_input_mzml, as.integer(top_n_hits), result)
    } 

# R implementation of _CubicSpline2d
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1CubicSpline2d.html
CubicSpline2d <- R6Class(classname = "CubicSpline2d",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void CubicSpline2d(libcpp_vector[double] x, libcpp_vector[double] y)
    init_0 = function(x, y){
    
        if(!(is_list(x) && all(sapply(x,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x wrong type") }
        if(!(is_list(y) && all(sapply(y,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg y wrong type") }
        v0 <- r_to_py(x)
        v1 <- r_to_py(y)
    
        private$py_obj <- Pymod$CubicSpline2d(v0, v1)
        invisible()
    
        
        
    
    },
    
    # C++ signature: void CubicSpline2d(libcpp_map[double,double] m)
    init_1 = function(m){
    
        if(!(
          is.environment(m) && identical(parent.env(m), asNamespace("collections")) && identical(strsplit(capture.output(m$print())," ")[[1]][1], "dict")
          && all(sapply(m$keys(),function(k) is_scalar_double(k)))
          && all(sapply(m$values(),function(v) is_scalar_double(v)))
          )){ stop("arg m wrong type") }
        v0 <- py_dict(m$keys(),m$values())
    
        private$py_obj <- Pymod$CubicSpline2d(v0)
        invisible()
    
    
    },
    
    # C++ signature: void CubicSpline2d(libcpp_vector[double] x, libcpp_vector[double] y)
    # C++ signature: void CubicSpline2d(libcpp_map[double,double] m)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec))))) { self$init_0(...) }
        else if ((length(arg_list)==1) && (
          is.environment(arg_list[[1]]) && identical(parent.env(arg_list[[1]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[1]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[1]]$keys(),function(k) is_scalar_double(k)))
          && all(sapply(arg_list[[1]]$values(),function(v) is_scalar_double(v)))
          )) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "CubicSpline2d" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double eval(double x)
    eval = function(x){
    
        if(!(is_scalar_double(x))){ stop("arg x wrong type") }
    
        py_ans = private$py_obj$eval(x)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double derivatives(double x, unsigned int order)
    derivatives = function(x, order){
    
        if(!(is_scalar_double(x))){ stop("arg x wrong type") }
        if(!( (is_scalar_integer(order) || is_scalar_double(order)) && order == as.integer(order))){ stop("arg order wrong type") }
    
    
        py_ans = private$py_obj$derivatives(x, as.integer(order))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DBoundingBox2
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DBoundingBox2.html
DBoundingBox2 <- R6Class(classname = "DBoundingBox2",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DBoundingBox2()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DBoundingBox2()
        invisible()
    
    
    },
    
    # C++ signature: void DBoundingBox2(DBoundingBox2)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DBoundingBox2")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DBoundingBox2(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DBoundingBox2()
    # C++ signature: void DBoundingBox2(DBoundingBox2)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DBoundingBox2")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DBoundingBox2" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: DPosition2 minPosition()
    minPosition = function(){
    
        py_ans = private$py_obj$minPosition()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition2 maxPosition()
    maxPosition = function(){
    
        py_ans = private$py_obj$maxPosition()
        r_ans = as.list(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _DIAScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DIAScoring.html
DIAScoring <- R6Class(classname = "DIAScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DIAScoring()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DIAScoring) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DIAScoring()
        invisible()
    }
    
    },
    
    # C++ signature: bool dia_ms1_massdiff_score(double precursor_mz, shared_ptr[OSSpectrum] spectrum, double & ppm_score)
    dia_ms1_massdiff_score = function(precursor_mz, spectrum, ppm_score){
    
        if(!(is_scalar_double(precursor_mz))){ stop("arg precursor_mz wrong type") }
        if(!(all(class(spectrum) == c('OSSpectrum','R6')))){ stop("arg spectrum wrong type") }
        if(!(is_scalar_double(ppm_score))){ stop("arg ppm_score wrong type") }
    
        input_spectrum <- r_to_py(spectrum)
    
        py_ans = private$py_obj$dia_ms1_massdiff_score(precursor_mz, input_spectrum, ppm_score)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void dia_ms1_isotope_scores(double precursor_mz, shared_ptr[OSSpectrum] spectrum, size_t charge_state, double & isotope_corr, double & isotope_overlap, String sum_formula)
    dia_ms1_isotope_scores = function(precursor_mz, spectrum, charge_state, isotope_corr, isotope_overlap, sum_formula){
    
        if(!(is_scalar_double(precursor_mz))){ stop("arg precursor_mz wrong type") }
        if(!(all(class(spectrum) == c('OSSpectrum','R6')))){ stop("arg spectrum wrong type") }
        if(!( (is_scalar_integer(charge_state) || is_scalar_double(charge_state)) && charge_state == as.integer(charge_state))){ stop("arg charge_state wrong type") }
        if(!(is_scalar_double(isotope_corr))){ stop("arg isotope_corr wrong type") }
        if(!(is_scalar_double(isotope_overlap))){ stop("arg isotope_overlap wrong type") }
        if(!((is.R6(sum_formula) && class(sum_formula)[1]=="String") || is_scalar_character(sum_formula))){ stop("arg sum_formula wrong type") }
    
        input_spectrum <- r_to_py(spectrum)
    
    
    
    
        private$py_obj$dia_ms1_isotope_scores(precursor_mz, input_spectrum, as.integer(charge_state), isotope_corr, isotope_overlap, sum_formula)
        invisible()
    },
    
    # C++ signature: void score_with_isotopes(shared_ptr[OSSpectrum] spectrum, libcpp_vector[LightTransition] transitions, double & dotprod, double & manhattan)
    score_with_isotopes = function(spectrum, transitions, dotprod, manhattan){
    
        if(!(all(class(spectrum) == c('OSSpectrum','R6')))){ stop("arg spectrum wrong type") }
        if(!(is_list(transitions) && all(sapply(transitions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightTransition")))){ stop("arg transitions wrong type") }
        if(!(is_scalar_double(dotprod))){ stop("arg dotprod wrong type") }
        if(!(is_scalar_double(manhattan))){ stop("arg manhattan wrong type") }
        input_spectrum <- r_to_py(spectrum)
        v1 <- r_to_py(transitions)
    
    
        private$py_obj$score_with_isotopes(input_spectrum, v1, dotprod, manhattan)
        
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _DRange1
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DRange1.html
DRange1 <- R6Class(classname = "DRange1",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DRange1()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DRange1()
        invisible()
    
    
    },
    
    # C++ signature: void DRange1(DRange1)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DRange1")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DRange1(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DRange1(DPosition1 lower, DPosition1 upper)
    init_2 = function(lower, upper){
    
        if(!(is.R6(lower) && class(lower)[1] == "DPosition1")){ stop("arg lower wrong type") }
        if(!(is.R6(upper) && class(upper)[1] == "DPosition1")){ stop("arg upper wrong type") }
    
    
    
        private$py_obj <- Pymod$DRange1(lower, upper)
        invisible()
    
    
    },
    
    # C++ signature: void DRange1()
    # C++ signature: void DRange1(DRange1)
    # C++ signature: void DRange1(DPosition1 lower, DPosition1 upper)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DRange1")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DPosition1") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DPosition1")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DRange1" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool encloses(DPosition1 & position)
    encloses = function(position){
    
        if(!(is.R6(position) && class(position)[1] == "DPosition1")){ stop("arg position wrong type") }
    
        py_ans = private$py_obj$encloses(position)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 united(DRange1 other_range)
    united = function(other_range){
    
        if(!(is.R6(other_range) && class(other_range)[1] == "DRange1")){ stop("arg other_range wrong type") }
    
        py_ans = private$py_obj$united(other_range)
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool isIntersected(DRange1 & range_)
    isIntersected = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        py_ans = private$py_obj$isIntersected(range_)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isEmpty()
    isEmpty = function(){
    
        py_ans = private$py_obj$isEmpty()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DRange2
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DRange2.html
DRange2 <- R6Class(classname = "DRange2",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DRange2()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DRange2()
        invisible()
    
    
    },
    
    # C++ signature: void DRange2(DRange2)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DRange2")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DRange2(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DRange2(DPosition2 lower, DPosition2 upper)
    init_2 = function(lower, upper){
    
        if(!(is_list(lower) && length(lower) == 2 && (is_scalar_integer(lower[[1]]) || is_scalar_double(lower[[1]])) && (is_scalar_integer(lower[[2]]) || is_scalar_double(lower[[2]])))){ stop("arg lower wrong type") }
        if(!(is_list(upper) && length(upper) == 2 && (is_scalar_integer(upper[[1]]) || is_scalar_double(upper[[1]])) && (is_scalar_integer(upper[[2]]) || is_scalar_double(upper[[2]])))){ stop("arg upper wrong type") }
        dp_0 <- r_to_py(lower)
        dp_1 <- r_to_py(upper)
    
        private$py_obj <- Pymod$DRange2(dp_0, dp_1)
        invisible()
    
    
    },
    
    # C++ signature: void DRange2(double minx, double miny, double maxx, double maxy)
    init_3 = function(minx, miny, maxx, maxy){
    
        if(!(is_scalar_double(minx))){ stop("arg minx wrong type") }
        if(!(is_scalar_double(miny))){ stop("arg miny wrong type") }
        if(!(is_scalar_double(maxx))){ stop("arg maxx wrong type") }
        if(!(is_scalar_double(maxy))){ stop("arg maxy wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$DRange2(minx, miny, maxx, maxy)
        invisible()
    
    
    },
    
    # C++ signature: void DRange2()
    # C++ signature: void DRange2(DRange2)
    # C++ signature: void DRange2(DPosition2 lower, DPosition2 upper)
    # C++ signature: void DRange2(double minx, double miny, double maxx, double maxy)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DRange2")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && length(arg_list[[1]]) == 2 && (is_scalar_integer(arg_list[[1]][[1]]) || is_scalar_double(arg_list[[1]][[1]])) && (is_scalar_integer(arg_list[[1]][[2]]) || is_scalar_double(arg_list[[1]][[2]]))) && (is_list(arg_list[[2]]) && length(arg_list[[2]]) == 2 && (is_scalar_integer(arg_list[[2]][[1]]) || is_scalar_double(arg_list[[2]][[1]])) && (is_scalar_integer(arg_list[[2]][[2]]) || is_scalar_double(arg_list[[2]][[2]])))) { self$init_2(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$init_3(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DRange2" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: DRange2 united(DRange2 other_range)
    united = function(other_range){
    
        if(!(is.R6(other_range) && class(other_range)[1] == "DRange2")){ stop("arg other_range wrong type") }
    
        py_ans = private$py_obj$united(other_range)
        r_ans = DRange2$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool isIntersected(DRange2 & range_)
    isIntersected = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange2")){ stop("arg range_ wrong type") }
    
        py_ans = private$py_obj$isIntersected(range_)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isEmpty()
    isEmpty = function(){
    
        py_ans = private$py_obj$isEmpty()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DTA2DFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DTA2DFile.html
DTA2DFile <- R6Class(classname = "DTA2DFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DTA2DFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DTA2DFile()
        invisible()
    
    
    },
    
    # C++ signature: void DTA2DFile(DTA2DFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DTA2DFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DTA2DFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DTA2DFile()
    # C++ signature: void DTA2DFile(DTA2DFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DTA2DFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DTA2DFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void storeTIC(String filename, MSExperiment & peakmap)
    storeTIC = function(filename, peakmap){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(peakmap) && class(peakmap)[1] == "MSExperiment")){ stop("arg peakmap wrong type") }
    
    
        private$py_obj$storeTIC(filename, peakmap)
        invisible()
    },
    
    # C++ signature: void store(String filename, MSExperiment & peakmap)
    store = function(filename, peakmap){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(peakmap) && class(peakmap)[1] == "MSExperiment")){ stop("arg peakmap wrong type") }
    
    
        private$py_obj$store(filename, peakmap)
        invisible()
    },
    
    # C++ signature: void load(String filename, MSExperiment & peakmap)
    load = function(filename, peakmap){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(peakmap) && class(peakmap)[1] == "MSExperiment")){ stop("arg peakmap wrong type") }
    
    
        private$py_obj$load(filename, peakmap)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _DTAFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DTAFile.html
DTAFile <- R6Class(classname = "DTAFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DTAFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DTAFile()
        invisible()
    
    
    },
    
    # C++ signature: void DTAFile(DTAFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DTAFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DTAFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DTAFile()
    # C++ signature: void DTAFile(DTAFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DTAFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DTAFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(String filename, MSSpectrum & spectrum)
    load = function(filename, spectrum){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
    
        private$py_obj$load(filename, spectrum)
        invisible()
    },
    
    # C++ signature: void store(String filename, MSSpectrum & spectrum)
    store = function(filename, spectrum){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
    
        private$py_obj$store(filename, spectrum)
        invisible()
    }
)
) 

# R implementation of _DataFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DataFilter.html
DataFilter <- R6Class(classname = "DataFilter",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        field = function(field){
    
        if(!missing(field)){
            if(!(field %in% c(0, 1, 2, 3, 4))){ stop("arg field wrong type") }
        
        
            private$py_obj$field <- as.integer(field)
            } else {
        
                py_ans = private$py_obj$field
                r_result = py_ans
                return(r_result)
                }
        },
        op = function(op){
    
        if(!missing(op)){
            if(!(op %in% c(0, 1, 2, 3))){ stop("arg op wrong type") }
        
        
            private$py_obj$op <- as.integer(op)
            } else {
        
                py_ans = private$py_obj$op
                r_result = py_ans
                return(r_result)
                }
        },
        value = function(value){
    
        if(!missing(value)){
            if(!(is_scalar_double(value))){ stop("arg value wrong type") }
        
        
            private$py_obj$value <- value
            } else {
        
                py_ans = private$py_obj$value
                r_result = py_ans
                return(r_result)
                }
        },
        value_string = function(value_string){
    
        if(!missing(value_string)){
            if(!((is.R6(value_string) && class(value_string)[1]=="String") || is_scalar_character(value_string))){ stop("arg value_string wrong type") }
        
        
            private$py_obj$value_string <- value_string
            } else {
        
                py_ans = private$py_obj$value_string
            r_result = py_ans
                return(r_result)
                }
        },
        meta_name = function(meta_name){
    
        if(!missing(meta_name)){
            if(!((is.R6(meta_name) && class(meta_name)[1]=="String") || is_scalar_character(meta_name))){ stop("arg meta_name wrong type") }
        
        
            private$py_obj$meta_name <- meta_name
            } else {
        
                py_ans = private$py_obj$meta_name
            r_result = py_ans
                return(r_result)
                }
        },
        value_is_numerical = function(value_is_numerical){
    
        if(!missing(value_is_numerical)){
            if(!( (is_scalar_integer(value_is_numerical) || is_scalar_double(value_is_numerical)) && value_is_numerical == as.integer(value_is_numerical))){ stop("arg value_is_numerical wrong type") }
        
        
            private$py_obj$value_is_numerical <- as.integer(value_is_numerical)
            } else {
        
                py_ans = private$py_obj$value_is_numerical
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void DataFilter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DataFilter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DataFilter()
        invisible()
    }
    
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void fromString(const String & filter_)
    fromString = function(filter_){
    
        if(!((is.R6(filter_) && class(filter_)[1]=="String") || is_scalar_character(filter_))){ stop("arg filter_ wrong type") }
    
        private$py_obj$fromString(filter_)
        invisible()
    }
)
) 

# R implementation of _DataFilters
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DataFilters.html
DataFilters <- R6Class(classname = "DataFilters",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DataFilters()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DataFilters) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DataFilters()
        invisible()
    }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void add(DataFilter & filter_)
    add = function(filter_){
    
        if(!(is.R6(filter_) && class(filter_)[1] == "DataFilter")){ stop("arg filter_ wrong type") }
    
        private$py_obj$add(filter_)
        invisible()
    },
    
    # C++ signature: void remove(size_t index)
    remove = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        private$py_obj$remove(as.integer(index))
        invisible()
    },
    
    # C++ signature: void replace(size_t index, DataFilter & filter_)
    replace = function(index, filter_){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is.R6(filter_) && class(filter_)[1] == "DataFilter")){ stop("arg filter_ wrong type") }
    
    
        private$py_obj$replace(as.integer(index), filter_)
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void setActive(bool is_active)
    setActive = function(is_active){
    
        if(!( (is_scalar_integer(is_active) || is_scalar_double(is_active)) && is_active == as.integer(is_active))){ stop("arg is_active wrong type") }
    
        private$py_obj$setActive(as.integer(is_active))
        invisible()
    },
    
    # C++ signature: bool isActive()
    isActive = function(){
    
        py_ans = private$py_obj$isActive()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool passes(Feature & feature)
    passes_0 = function(feature){
    
        if(!(is.R6(feature) && class(feature)[1] == "Feature")){ stop("arg feature wrong type") }
    
        py_ans = private$py_obj$`_passes_0`(feature)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool passes(ConsensusFeature & consensus_feature)
    passes_1 = function(consensus_feature){
    
        if(!(is.R6(consensus_feature) && class(consensus_feature)[1] == "ConsensusFeature")){ stop("arg consensus_feature wrong type") }
    
        py_ans = private$py_obj$`_passes_1`(consensus_feature)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool passes(MSSpectrum & spectrum, size_t peak_index)
    passes_2 = function(spectrum, peak_index){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!( (is_scalar_integer(peak_index) || is_scalar_double(peak_index)) && peak_index == as.integer(peak_index))){ stop("arg peak_index wrong type") }
    
    
        py_ans = private$py_obj$`_passes_2`(spectrum, as.integer(peak_index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool passes(Feature & feature)
    # C++ signature: bool passes(ConsensusFeature & consensus_feature)
    # C++ signature: bool passes(MSSpectrum & spectrum, size_t peak_index)
    passes = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Feature")) { self$passes_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusFeature")) { self$passes_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$passes_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _DataProcessing
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DataProcessing.html
DataProcessing <- R6Class(classname = "DataProcessing",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DataProcessing()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DataProcessing) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DataProcessing()
        invisible()
    }
    
    },
    
    # C++ signature: void setProcessingActions(libcpp_set[ProcessingAction])
    setProcessingActions = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(el) el %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))) && !(TRUE %in% duplicated(in_0)))){ stop("arg in_0 wrong type") }
        py$v0 <- in_0
        py_run_string("v0 = [int(t) for t in v0];v0 = set(v0)")
        private$py_obj$setProcessingActions(py$v0)
        py_run_string('del v0');gc.collect()
        invisible()
    },
    
    # C++ signature: libcpp_set[ProcessingAction] getProcessingActions()
    getProcessingActions = function(){
    
        py_ans = private$py_obj$getProcessingActions()
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: Software getSoftware()
    getSoftware = function(){
    
        py_ans = private$py_obj$getSoftware()
        r_ans = Software$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSoftware(Software s)
    setSoftware = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "Software")){ stop("arg s wrong type") }
    
        private$py_obj$setSoftware(s)
        invisible()
    },
    
    # C++ signature: DateTime getCompletionTime()
    getCompletionTime = function(){
    
        py_ans = private$py_obj$getCompletionTime()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setCompletionTime(DateTime t)
    setCompletionTime = function(t){
    
        if(!(is.R6(t) && class(t)[1] == "DateTime")){ stop("arg t wrong type") }
    
        private$py_obj$setCompletionTime(t)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _DataValue
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DataValue.html
DataValue <- R6Class(classname = "DataValue",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DataValue()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DataValue()
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(char *)
    init_1 = function(in_0){
    
        if(!(is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    py_run_string("in_0 = bytes(in_0)")
    
        private$py_obj <- Pymod$DataValue(in_0)
        invisible()
    
        py_run_string("del in_0")
    
    },
    
    # C++ signature: void DataValue(const String &)
    init_2 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DataValue(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(int)
    init_3 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DataValue(as.integer(in_0))
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(double)
    init_4 = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DataValue(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(StringList)
    init_5 = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0),is_scalar_character))){ stop("arg in_0 wrong type") }
        v0 = r_to_py(modify_depth(in_0,1,py_builtin$bytes(in_0,'utf-8')))
    
        private$py_obj <- Pymod$DataValue(v0)
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(IntList)
    init_6 = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0), function(inner) inner == as.integer(inner)))){ stop("arg in_0 wrong type") }
        v0 = r_to_py(in_0)
    
        private$py_obj <- Pymod$DataValue(v0)
        invisible()
    
    
    },
    
    # C++ signature: void DataValue(DoubleList)
    init_7 = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0), is_scalar_character))){ stop("arg in_0 wrong type") }
        v0 = r_to_py(in_0)
    
        private$py_obj <- Pymod$DataValue(v0)
        invisible()
    
    
    },
    
    # C++ signature: void DataValue()
    # C++ signature: void DataValue(char *)
    # C++ signature: void DataValue(const String &)
    # C++ signature: void DataValue(int)
    # C++ signature: void DataValue(double)
    # C++ signature: void DataValue(StringList)
    # C++ signature: void DataValue(IntList)
    # C++ signature: void DataValue(DoubleList)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is_scalar_character(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_2(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_3(...) }
        else if ((length(arg_list)==1) && (is_scalar_double(arg_list[[1]]))) { self$init_4(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$init_5(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]), function(inner) inner == as.integer(inner)))) { self$init_6(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]), is_scalar_character))) { self$init_7(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DataValue" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: StringList toStringList()
    toStringList = function(){
    
        py_ans = private$py_obj$toStringList()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] toDoubleList()
    toDoubleList = function(){
    
        py_ans = private$py_obj$toDoubleList()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[int] toIntList()
    toIntList = function(){
    
        py_ans = private$py_obj$toIntList()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool toBool()
    toBool = function(){
    
        py_ans = private$py_obj$toBool()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DataType valueType()
    valueType = function(){
    
        py_ans = private$py_obj$valueType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int isEmpty()
    isEmpty = function(){
    
        py_ans = private$py_obj$isEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: UnitType getUnitType()
    getUnitType = function(){
    
        py_ans = private$py_obj$getUnitType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUnitType(UnitType u)
    setUnitType = function(u){
    
        if(!(u %in% c(0, 1, 2))){ stop("arg u wrong type") }
    
        private$py_obj$setUnitType(as.integer(u))
        invisible()
    },
    
    # C++ signature: bool hasUnit()
    hasUnit = function(){
    
        py_ans = private$py_obj$hasUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getUnit()
    getUnit = function(){
    
        py_ans = private$py_obj$getUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUnit(int unit_id)
    setUnit = function(unit_id){
    
        if(!( (is_scalar_integer(unit_id) || is_scalar_double(unit_id)) && unit_id == as.integer(unit_id))){ stop("arg unit_id wrong type") }
    
        private$py_obj$setUnit(as.integer(unit_id))
        invisible()
    }
)
)
    DataValue$set("public","toInt",
      function(){
          py_ans = private$py_obj$toInt()
                  r_ans = py_ans
          return(r_ans)
      }
    )
    
    DataValue$set("public","toDouble",
      function(){
          py_ans = private$py_obj$toDouble()
                  r_ans = py_ans
          return(r_ans)
      }
    )
     

# R implementation of _Date
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Date.html
Date <- R6Class(classname = "Date",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Date()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Date) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Date()
        invisible()
    }
    
    },
    
    # C++ signature: void set(const String & date)
    set = function(date){
    
        if(!((is.R6(date) && class(date)[1]=="String") || is_scalar_character(date))){ stop("arg date wrong type") }
    
        private$py_obj$set(date)
        invisible()
    },
    
    # C++ signature: Date today()
    today = function(){
    
        py_ans = private$py_obj$today()
        r_ans = Date$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String get()
    get = function(){
    
        py_ans = private$py_obj$get()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    }
)
) 

# R implementation of _DateTime
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DateTime.html
DateTime <- R6Class(classname = "DateTime",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DateTime()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DateTime) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DateTime()
        invisible()
    }
    
    },
    
    # C++ signature: void setDate(String date)
    setDate = function(date){
    
        if(!((is.R6(date) && class(date)[1]=="String") || is_scalar_character(date))){ stop("arg date wrong type") }
    
        private$py_obj$setDate(date)
        invisible()
    },
    
    # C++ signature: void setTime(String date)
    setTime = function(date){
    
        if(!((is.R6(date) && class(date)[1]=="String") || is_scalar_character(date))){ stop("arg date wrong type") }
    
        private$py_obj$setTime(date)
        invisible()
    },
    
    # C++ signature: String getDate()
    getDate = function(){
    
        py_ans = private$py_obj$getDate()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTime()
    getTime = function(){
    
        py_ans = private$py_obj$getTime()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DateTime now()
    now = function(){
    
        py_ans = private$py_obj$now()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: String get()
    get = function(){
    
        py_ans = private$py_obj$get()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void set(String date)
    set = function(date){
    
        if(!((is.R6(date) && class(date)[1]=="String") || is_scalar_character(date))){ stop("arg date wrong type") }
    
        private$py_obj$set(date)
        invisible()
    }
)
)
    
    # C++ signature: DateTime now()
    DateTime$now = function(){
    
        py_ans = Pymod$DateTime$now()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    } 

# R implementation of _DeNovoIonScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DeNovoIonScore.html
DeNovoIonScore <- R6Class(classname = "DeNovoIonScore",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        position = function(position){
    
        if(!missing(position)){
            if(!(is_scalar_double(position))){ stop("arg position wrong type") }
        
        
            private$py_obj$position <- position
            } else {
        
                py_ans = private$py_obj$position
                r_result = py_ans
                return(r_result)
                }
        },
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void DeNovoIonScore()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DeNovoIonScore()
        invisible()
    
    
    },
    
    # C++ signature: void DeNovoIonScore(DeNovoIonScore)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DeNovoIonScore")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DeNovoIonScore(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DeNovoIonScore()
    # C++ signature: void DeNovoIonScore(DeNovoIonScore)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DeNovoIonScore")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DeNovoIonScore" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _DecoyGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DecoyGenerator.html
DecoyGenerator <- R6Class(classname = "DecoyGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void setSeed(unsigned long int)
    setSeed = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSeed(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: AASequence reverseProtein(const AASequence & protein)
    reverseProtein = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
    
        py_ans = private$py_obj$reverseProtein(protein)
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: AASequence reversePeptides(const AASequence & protein, const String & protease)
    reversePeptides = function(protein, protease){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
        if(!((is.R6(protease) && class(protease)[1]=="String") || is_scalar_character(protease))){ stop("arg protease wrong type") }
    
    
        py_ans = private$py_obj$reversePeptides(protein, protease)
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: AASequence shufflePeptides(const AASequence & aas, const String & protease, const int max_attempts)
    shufflePeptides = function(aas, protease, max_attempts){
    
        if(!(is.R6(aas) && class(aas)[1] == "AASequence")){ stop("arg aas wrong type") }
        if(!((is.R6(protease) && class(protease)[1]=="String") || is_scalar_character(protease))){ stop("arg protease wrong type") }
        if(!( (is_scalar_integer(max_attempts) || is_scalar_double(max_attempts)) && max_attempts == as.integer(max_attempts))){ stop("arg max_attempts wrong type") }
    
    
    
        py_ans = private$py_obj$shufflePeptides(aas, protease, as.integer(max_attempts))
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _Deisotoper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Deisotoper.html
Deisotoper <- R6Class(classname = "Deisotoper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Deisotoper()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Deisotoper) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Deisotoper()
        invisible()
    }
    
    }
)
)
    
    # C++ signature: void deisotopeAndSingleCharge(MSSpectrum & spectra, double fragment_tolerance, bool fragment_unit_ppm, int min_charge, int max_charge, bool keep_only_deisotoped, unsigned int min_isopeaks, unsigned int max_isopeaks, bool make_single_charged, bool annotate_charge, bool annotate_iso_peak_count, bool use_decreasing_model, unsigned int start_intensity_check, bool add_up_intensity)
    Deisotoper$deisotopeAndSingleCharge = function(spectra, fragment_tolerance, fragment_unit_ppm, min_charge, max_charge, keep_only_deisotoped, min_isopeaks, max_isopeaks, make_single_charged, annotate_charge, annotate_iso_peak_count, use_decreasing_model, start_intensity_check, add_up_intensity){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSSpectrum")){ stop("arg spectra wrong type") }
        if(!(is_scalar_double(fragment_tolerance))){ stop("arg fragment_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_unit_ppm) || is_scalar_double(fragment_unit_ppm)) && fragment_unit_ppm == as.integer(fragment_unit_ppm))){ stop("arg fragment_unit_ppm wrong type") }
        if(!( (is_scalar_integer(min_charge) || is_scalar_double(min_charge)) && min_charge == as.integer(min_charge))){ stop("arg min_charge wrong type") }
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
        if(!( (is_scalar_integer(keep_only_deisotoped) || is_scalar_double(keep_only_deisotoped)) && keep_only_deisotoped == as.integer(keep_only_deisotoped))){ stop("arg keep_only_deisotoped wrong type") }
        if(!( (is_scalar_integer(min_isopeaks) || is_scalar_double(min_isopeaks)) && min_isopeaks == as.integer(min_isopeaks))){ stop("arg min_isopeaks wrong type") }
        if(!( (is_scalar_integer(max_isopeaks) || is_scalar_double(max_isopeaks)) && max_isopeaks == as.integer(max_isopeaks))){ stop("arg max_isopeaks wrong type") }
        if(!( (is_scalar_integer(make_single_charged) || is_scalar_double(make_single_charged)) && make_single_charged == as.integer(make_single_charged))){ stop("arg make_single_charged wrong type") }
        if(!( (is_scalar_integer(annotate_charge) || is_scalar_double(annotate_charge)) && annotate_charge == as.integer(annotate_charge))){ stop("arg annotate_charge wrong type") }
        if(!( (is_scalar_integer(annotate_iso_peak_count) || is_scalar_double(annotate_iso_peak_count)) && annotate_iso_peak_count == as.integer(annotate_iso_peak_count))){ stop("arg annotate_iso_peak_count wrong type") }
        if(!( (is_scalar_integer(use_decreasing_model) || is_scalar_double(use_decreasing_model)) && use_decreasing_model == as.integer(use_decreasing_model))){ stop("arg use_decreasing_model wrong type") }
        if(!( (is_scalar_integer(start_intensity_check) || is_scalar_double(start_intensity_check)) && start_intensity_check == as.integer(start_intensity_check))){ stop("arg start_intensity_check wrong type") }
        if(!( (is_scalar_integer(add_up_intensity) || is_scalar_double(add_up_intensity)) && add_up_intensity == as.integer(add_up_intensity))){ stop("arg add_up_intensity wrong type") }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        Pymod$Deisotoper$deisotopeAndSingleCharge(spectra, fragment_tolerance, as.integer(fragment_unit_ppm), as.integer(min_charge), as.integer(max_charge), as.integer(keep_only_deisotoped), as.integer(min_isopeaks), as.integer(max_isopeaks), as.integer(make_single_charged), as.integer(annotate_charge), as.integer(annotate_iso_peak_count), as.integer(use_decreasing_model), as.integer(start_intensity_check), as.integer(add_up_intensity))
    }
    
    # C++ signature: void deisotopeAndSingleChargeDefault(MSSpectrum & spectra, double fragment_tolerance, bool fragment_unit_ppm)
    Deisotoper$deisotopeAndSingleChargeDefault = function(spectra, fragment_tolerance, fragment_unit_ppm){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSSpectrum")){ stop("arg spectra wrong type") }
        if(!(is_scalar_double(fragment_tolerance))){ stop("arg fragment_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_unit_ppm) || is_scalar_double(fragment_unit_ppm)) && fragment_unit_ppm == as.integer(fragment_unit_ppm))){ stop("arg fragment_unit_ppm wrong type") }
    
    
    
        Pymod$Deisotoper$deisotopeAndSingleChargeDefault(spectra, fragment_tolerance, as.integer(fragment_unit_ppm))
    } 

# R implementation of _DigestSimulation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DigestSimulation.html
DigestSimulation <- R6Class(classname = "DigestSimulation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DigestSimulation()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DigestSimulation()
        invisible()
    
    
    },
    
    # C++ signature: void DigestSimulation(DigestSimulation)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DigestSimulation")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DigestSimulation(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DigestSimulation()
    # C++ signature: void DigestSimulation(DigestSimulation)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DigestSimulation")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DigestSimulation" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void digest(FeatureMap & feature_map)
    digest = function(feature_map){
    
        if(!(is.R6(feature_map) && class(feature_map)[1] == "FeatureMap")){ stop("arg feature_map wrong type") }
    
        private$py_obj$digest(feature_map)
        invisible()
    }
)
) 

# R implementation of _Digestion
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Digestion.html
Digestion <- R6Class(classname = "Digestion",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Digestion()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Digestion()
        invisible()
    
    
    },
    
    # C++ signature: void Digestion(Digestion)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Digestion")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Digestion(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Digestion()
    # C++ signature: void Digestion(Digestion)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Digestion")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Digestion" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getEnzyme()
    getEnzyme = function(){
    
        py_ans = private$py_obj$getEnzyme()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(const String & enzyme)
    setEnzyme = function(enzyme){
    
        if(!((is.R6(enzyme) && class(enzyme)[1]=="String") || is_scalar_character(enzyme))){ stop("arg enzyme wrong type") }
    
        private$py_obj$setEnzyme(enzyme)
        invisible()
    },
    
    # C++ signature: double getDigestionTime()
    getDigestionTime = function(){
    
        py_ans = private$py_obj$getDigestionTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDigestionTime(double digestion_time)
    setDigestionTime = function(digestion_time){
    
        if(!(is_scalar_double(digestion_time))){ stop("arg digestion_time wrong type") }
    
        private$py_obj$setDigestionTime(digestion_time)
        invisible()
    },
    
    # C++ signature: double getTemperature()
    getTemperature = function(){
    
        py_ans = private$py_obj$getTemperature()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTemperature(double temperature)
    setTemperature = function(temperature){
    
        if(!(is_scalar_double(temperature))){ stop("arg temperature wrong type") }
    
        private$py_obj$setTemperature(temperature)
        invisible()
    },
    
    # C++ signature: double getPh()
    getPh = function(){
    
        py_ans = private$py_obj$getPh()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPh(double ph)
    setPh = function(ph){
    
        if(!(is_scalar_double(ph))){ stop("arg ph wrong type") }
    
        private$py_obj$setPh(ph)
        invisible()
    }
)
) 

# R implementation of _DigestionEnzyme
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DigestionEnzyme.html
DigestionEnzyme <- R6Class(classname = "DigestionEnzyme",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DigestionEnzyme(DigestionEnzyme)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DigestionEnzyme")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DigestionEnzyme(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DigestionEnzyme(const String & name, const String & cleavage_regex, libcpp_set[String] & synonyms, String regex_description)
    init_1 = function(name, cleavage_regex, synonyms, regex_description){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        if(!((is.R6(regex_description) && class(regex_description)[1]=="String") || is_scalar_character(regex_description))){ stop("arg regex_description wrong type") }
    
    
        v2 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
    
    
        private$py_obj <- Pymod$DigestionEnzyme(name, cleavage_regex, v2, regex_description)
        invisible()
    
        byref_2 <- modify_depth(py_to_r(py_builtin$list(v2)),1,as.character)
    
    },
    
    # C++ signature: void DigestionEnzyme(DigestionEnzyme)
    # C++ signature: void DigestionEnzyme(const String & name, const String & cleavage_regex, libcpp_set[String] & synonyms, String regex_description)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DigestionEnzyme")) { self$init_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]]),is_scalar_character) && !any(duplicated(arg_list[[3]]) == T)) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DigestionEnzyme" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setName(const String & name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSynonyms(libcpp_set[String] & synonyms)
    setSynonyms = function(synonyms){
    
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        v0 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
        private$py_obj$setSynonyms(v0)
        byref_0 <- modify_depth(py_to_r(py_builtin$list(v0)),1,as.character)
    
        tryCatch({
        eval.parent(substitute(synonyms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addSynonym(const String & synonym)
    addSynonym = function(synonym){
    
        if(!((is.R6(synonym) && class(synonym)[1]=="String") || is_scalar_character(synonym))){ stop("arg synonym wrong type") }
    
        private$py_obj$addSynonym(synonym)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getSynonyms()
    getSynonyms = function(){
    
        py_ans = private$py_obj$getSynonyms()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setRegEx(const String & cleavage_regex)
    setRegEx = function(cleavage_regex){
    
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
    
        private$py_obj$setRegEx(cleavage_regex)
        invisible()
    },
    
    # C++ signature: String getRegEx()
    getRegEx = function(){
    
        py_ans = private$py_obj$getRegEx()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRegExDescription(const String & value)
    setRegExDescription = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setRegExDescription(value)
        invisible()
    },
    
    # C++ signature: String getRegExDescription()
    getRegExDescription = function(){
    
        py_ans = private$py_obj$getRegExDescription()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool setValueFromFile(const String & key, const String & value)
    setValueFromFile = function(key, value){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
    
        py_ans = private$py_obj$setValueFromFile(key, value)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DigestionEnzymeProtein
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DigestionEnzymeProtein.html
DigestionEnzymeProtein <- R6Class(classname = "DigestionEnzymeProtein",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DigestionEnzymeProtein(String name, String cleavage_regex, libcpp_set[String] synonyms, String regex_description, EmpiricalFormula n_term_gain, EmpiricalFormula c_term_gain, String psi_id, String xtandem_id, unsigned int comet_id, unsigned int omssa_id)
    initialize = function(name, cleavage_regex, synonyms, regex_description, n_term_gain, c_term_gain, psi_id, xtandem_id, comet_id, omssa_id){
    
    if(missing(cleavage_regex) && missing(synonyms) && missing(regex_description) && missing(n_term_gain) && missing(c_term_gain) && missing(psi_id) && missing(xtandem_id) && missing(comet_id) && missing(omssa_id)){
         if( "python.builtin.object" %in% class(name) && class_to_wrap(name) == DigestionEnzymeProtein ) { private$py_obj <- name }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        if(!((is.R6(regex_description) && class(regex_description)[1]=="String") || is_scalar_character(regex_description))){ stop("arg regex_description wrong type") }
        if(!(is.R6(n_term_gain) && class(n_term_gain)[1] == "EmpiricalFormula")){ stop("arg n_term_gain wrong type") }
        if(!(is.R6(c_term_gain) && class(c_term_gain)[1] == "EmpiricalFormula")){ stop("arg c_term_gain wrong type") }
        if(!((is.R6(psi_id) && class(psi_id)[1]=="String") || is_scalar_character(psi_id))){ stop("arg psi_id wrong type") }
        if(!((is.R6(xtandem_id) && class(xtandem_id)[1]=="String") || is_scalar_character(xtandem_id))){ stop("arg xtandem_id wrong type") }
        if(!( (is_scalar_integer(comet_id) || is_scalar_double(comet_id)) && comet_id == as.integer(comet_id))){ stop("arg comet_id wrong type") }
        if(!( (is_scalar_integer(omssa_id) || is_scalar_double(omssa_id)) && omssa_id == as.integer(omssa_id))){ stop("arg omssa_id wrong type") }
    
    
        v2 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
    
    
    
    
    
    
    
    
        private$py_obj <- Pymod$DigestionEnzymeProtein(name, cleavage_regex, v2, regex_description, n_term_gain, c_term_gain, psi_id, xtandem_id, as.integer(comet_id), as.integer(omssa_id))
        invisible()
    }
    
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSynonyms(libcpp_set[String] synonyms)
    setSynonyms = function(synonyms){
    
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        v0 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
        private$py_obj$setSynonyms(v0)
        invisible()
    },
    
    # C++ signature: void addSynonym(String synonym)
    addSynonym = function(synonym){
    
        if(!((is.R6(synonym) && class(synonym)[1]=="String") || is_scalar_character(synonym))){ stop("arg synonym wrong type") }
    
        private$py_obj$addSynonym(synonym)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getSynonyms()
    getSynonyms = function(){
    
        py_ans = private$py_obj$getSynonyms()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setRegEx(String three_letter_code)
    setRegEx = function(three_letter_code){
    
        if(!((is.R6(three_letter_code) && class(three_letter_code)[1]=="String") || is_scalar_character(three_letter_code))){ stop("arg three_letter_code wrong type") }
    
        private$py_obj$setRegEx(three_letter_code)
        invisible()
    },
    
    # C++ signature: String getRegEx()
    getRegEx = function(){
    
        py_ans = private$py_obj$getRegEx()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRegExDescription(String one_letter_code)
    setRegExDescription = function(one_letter_code){
    
        if(!((is.R6(one_letter_code) && class(one_letter_code)[1]=="String") || is_scalar_character(one_letter_code))){ stop("arg one_letter_code wrong type") }
    
        private$py_obj$setRegExDescription(one_letter_code)
        invisible()
    },
    
    # C++ signature: String getRegExDescription()
    getRegExDescription = function(){
    
        py_ans = private$py_obj$getRegExDescription()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNTermGain(EmpiricalFormula value)
    setNTermGain = function(value){
    
        if(!(is.R6(value) && class(value)[1] == "EmpiricalFormula")){ stop("arg value wrong type") }
    
        private$py_obj$setNTermGain(value)
        invisible()
    },
    
    # C++ signature: void setCTermGain(EmpiricalFormula value)
    setCTermGain = function(value){
    
        if(!(is.R6(value) && class(value)[1] == "EmpiricalFormula")){ stop("arg value wrong type") }
    
        private$py_obj$setCTermGain(value)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getNTermGain()
    getNTermGain = function(){
    
        py_ans = private$py_obj$getNTermGain()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getCTermGain()
    getCTermGain = function(){
    
        py_ans = private$py_obj$getCTermGain()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPSIID(String value)
    setPSIID = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setPSIID(value)
        invisible()
    },
    
    # C++ signature: String getPSIID()
    getPSIID = function(){
    
        py_ans = private$py_obj$getPSIID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setXTandemID(String value)
    setXTandemID = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setXTandemID(value)
        invisible()
    },
    
    # C++ signature: String getXTandemID()
    getXTandemID = function(){
    
        py_ans = private$py_obj$getXTandemID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getCruxID()
    getCruxID = function(){
    
        py_ans = private$py_obj$getCruxID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCruxID(const String & value)
    setCruxID = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setCruxID(value)
        invisible()
    },
    
    # C++ signature: void setCometID(int value)
    setCometID = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setCometID(as.integer(value))
        invisible()
    },
    
    # C++ signature: int getCometID()
    getCometID = function(){
    
        py_ans = private$py_obj$getCometID()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOMSSAID(int value)
    setOMSSAID = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setOMSSAID(as.integer(value))
        invisible()
    },
    
    # C++ signature: int getOMSSAID()
    getOMSSAID = function(){
    
        py_ans = private$py_obj$getOMSSAID()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMSGFID(int value)
    setMSGFID = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setMSGFID(as.integer(value))
        invisible()
    },
    
    # C++ signature: int getMSGFID()
    getMSGFID = function(){
    
        py_ans = private$py_obj$getMSGFID()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool setValueFromFile(const String & key, const String & value)
    setValueFromFile = function(key, value){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
    
        py_ans = private$py_obj$setValueFromFile(key, value)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DigestionEnzymeRNA
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DigestionEnzymeRNA.html
DigestionEnzymeRNA <- R6Class(classname = "DigestionEnzymeRNA",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: bool setValueFromFile(const String & key, const String & value)
    setValueFromFile = function(key, value){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
    
        py_ans = private$py_obj$setValueFromFile(key, value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSynonyms(libcpp_set[String] synonyms)
    setSynonyms = function(synonyms){
    
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        v0 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
        private$py_obj$setSynonyms(v0)
        invisible()
    },
    
    # C++ signature: void addSynonym(String synonym)
    addSynonym = function(synonym){
    
        if(!((is.R6(synonym) && class(synonym)[1]=="String") || is_scalar_character(synonym))){ stop("arg synonym wrong type") }
    
        private$py_obj$addSynonym(synonym)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getSynonyms()
    getSynonyms = function(){
    
        py_ans = private$py_obj$getSynonyms()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setRegEx(String three_letter_code)
    setRegEx = function(three_letter_code){
    
        if(!((is.R6(three_letter_code) && class(three_letter_code)[1]=="String") || is_scalar_character(three_letter_code))){ stop("arg three_letter_code wrong type") }
    
        private$py_obj$setRegEx(three_letter_code)
        invisible()
    },
    
    # C++ signature: String getRegEx()
    getRegEx = function(){
    
        py_ans = private$py_obj$getRegEx()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRegExDescription(String one_letter_code)
    setRegExDescription = function(one_letter_code){
    
        if(!((is.R6(one_letter_code) && class(one_letter_code)[1]=="String") || is_scalar_character(one_letter_code))){ stop("arg one_letter_code wrong type") }
    
        private$py_obj$setRegExDescription(one_letter_code)
        invisible()
    },
    
    # C++ signature: String getRegExDescription()
    getRegExDescription = function(){
    
        py_ans = private$py_obj$getRegExDescription()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setThreePrimeGain(String value)
    setThreePrimeGain = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setThreePrimeGain(value)
        invisible()
    },
    
    # C++ signature: void setFivePrimeGain(String value)
    setFivePrimeGain = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setFivePrimeGain(value)
        invisible()
    },
    
    # C++ signature: String getThreePrimeGain()
    getThreePrimeGain = function(){
    
        py_ans = private$py_obj$getThreePrimeGain()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getFivePrimeGain()
    getFivePrimeGain = function(){
    
        py_ans = private$py_obj$getFivePrimeGain()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _DigestionFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DigestionFilter.html
DigestionFilter <- R6Class(classname = "DigestionFilter",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        digestion_ = function(digestion_){
    
        if(!missing(digestion_)){
            if(!(is.R6(digestion_) && class(digestion_)[1] == "ProteaseDigestion")){ stop("arg digestion_ wrong type") }
        
        
            private$py_obj$digestion_ <- digestion_
            } else {
        
                py_ans = private$py_obj$digestion_
            r_result = ProteaseDigestion$new(py_ans)
                return(r_result)
                }
        },
        ignore_missed_cleavages_ = function(ignore_missed_cleavages_){
    
        if(!missing(ignore_missed_cleavages_)){
            if(!( (is_scalar_integer(ignore_missed_cleavages_) || is_scalar_double(ignore_missed_cleavages_)) && ignore_missed_cleavages_ == as.integer(ignore_missed_cleavages_))){ stop("arg ignore_missed_cleavages_ wrong type") }
        
        
            private$py_obj$ignore_missed_cleavages_ <- as.integer(ignore_missed_cleavages_)
            } else {
        
                py_ans = private$py_obj$ignore_missed_cleavages_
                r_result = py_ans
                return(r_result)
                }
        },
        methionine_cleavage_ = function(methionine_cleavage_){
    
        if(!missing(methionine_cleavage_)){
            if(!( (is_scalar_integer(methionine_cleavage_) || is_scalar_double(methionine_cleavage_)) && methionine_cleavage_ == as.integer(methionine_cleavage_))){ stop("arg methionine_cleavage_ wrong type") }
        
        
            private$py_obj$methionine_cleavage_ <- as.integer(methionine_cleavage_)
            } else {
        
                py_ans = private$py_obj$methionine_cleavage_
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void DigestionFilter(libcpp_vector[FASTAEntry] & entries, ProteaseDigestion & digestion, bool ignore_missed_cleavages, bool methionine_cleavage)
    initialize = function(entries, digestion, ignore_missed_cleavages, methionine_cleavage){
    
    if(missing(digestion) && missing(ignore_missed_cleavages) && missing(methionine_cleavage)){
         if( "python.builtin.object" %in% class(entries) && class_to_wrap(entries) == DigestionFilter ) { private$py_obj <- entries }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(entries) && all(sapply(entries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg entries wrong type") }
        if(!(is.R6(digestion) && class(digestion)[1] == "ProteaseDigestion")){ stop("arg digestion wrong type") }
        if(!( (is_scalar_integer(ignore_missed_cleavages) || is_scalar_double(ignore_missed_cleavages)) && ignore_missed_cleavages == as.integer(ignore_missed_cleavages))){ stop("arg ignore_missed_cleavages wrong type") }
        if(!( (is_scalar_integer(methionine_cleavage) || is_scalar_double(methionine_cleavage)) && methionine_cleavage == as.integer(methionine_cleavage))){ stop("arg methionine_cleavage wrong type") }
        v0 <- r_to_py(entries)
    
    
    
    
        private$py_obj <- Pymod$DigestionFilter(v0, digestion, as.integer(ignore_missed_cleavages), as.integer(methionine_cleavage))
        invisible()
    }
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void filterPeptideEvidences(libcpp_vector[PeptideIdentification] & peptides)
    filterPeptideEvidences = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$filterPeptideEvidences(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _DistanceMatrix[float]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DistanceMatrix[float].html
DistanceMatrix <- R6Class(classname = "DistanceMatrix",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DistanceMatrix()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$DistanceMatrix()
        invisible()
    
    
    },
    
    # C++ signature: void DistanceMatrix(DistanceMatrix)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "DistanceMatrix")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$DistanceMatrix(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void DistanceMatrix(size_t dimensionsize, float value)
    init_2 = function(dimensionsize, value){
    
        if(!( (is_scalar_integer(dimensionsize) || is_scalar_double(dimensionsize)) && dimensionsize == as.integer(dimensionsize))){ stop("arg dimensionsize wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj <- Pymod$DistanceMatrix(as.integer(dimensionsize), value)
        invisible()
    
    
    },
    
    # C++ signature: void DistanceMatrix()
    # C++ signature: void DistanceMatrix(DistanceMatrix)
    # C++ signature: void DistanceMatrix(size_t dimensionsize, float value)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "DistanceMatrix")) { self$init_1(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "DistanceMatrix" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getValue(size_t i, size_t j)
    getValue = function(i, j){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
    
    
        py_ans = private$py_obj$getValue(as.integer(i), as.integer(j))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setValue(size_t i, size_t j, float value)
    setValue = function(i, j, value){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj$setValue(as.integer(i), as.integer(j), value)
        invisible()
    },
    
    # C++ signature: void setValueQuick(size_t i, size_t j, float value)
    setValueQuick = function(i, j, value){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj$setValueQuick(as.integer(i), as.integer(j), value)
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void resize(size_t dimensionsize, float value)
    resize = function(dimensionsize, value){
    
        if(!( (is_scalar_integer(dimensionsize) || is_scalar_double(dimensionsize)) && dimensionsize == as.integer(dimensionsize))){ stop("arg dimensionsize wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
        private$py_obj$resize(as.integer(dimensionsize), value)
        invisible()
    },
    
    # C++ signature: void reduce(size_t j)
    reduce = function(j){
    
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
    
        private$py_obj$reduce(as.integer(j))
        invisible()
    },
    
    # C++ signature: size_t dimensionsize()
    dimensionsize = function(){
    
        py_ans = private$py_obj$dimensionsize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void updateMinElement()
    updateMinElement = function(){
    
        private$py_obj$updateMinElement()
        invisible()
    },
    
    # C++ signature: libcpp_pair[size_t,size_t] getMinElementCoordinates()
    getMinElementCoordinates = function(){
    
        py_ans = private$py_obj$getMinElementCoordinates()
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    }
)
) 

# R implementation of _DocumentIdentifier
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1DocumentIdentifier.html
DocumentIdentifier <- R6Class(classname = "DocumentIdentifier",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void DocumentIdentifier()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == DocumentIdentifier) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$DocumentIdentifier()
        invisible()
    }
    
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _EDTAFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EDTAFile.html
EDTAFile <- R6Class(classname = "EDTAFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EDTAFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$EDTAFile()
        invisible()
    
    
    },
    
    # C++ signature: void EDTAFile(EDTAFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EDTAFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EDTAFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EDTAFile()
    # C++ signature: void EDTAFile(EDTAFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "EDTAFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EDTAFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void store(String filename, FeatureMap & map)
    store_0 = function(filename, map){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(map) && class(map)[1] == "FeatureMap")){ stop("arg map wrong type") }
    
    
        private$py_obj$`_store_0`(filename, map)
        invisible()
    },
    
    # C++ signature: void store(String filename, ConsensusMap & map)
    store_1 = function(filename, map){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(map) && class(map)[1] == "ConsensusMap")){ stop("arg map wrong type") }
    
    
        private$py_obj$`_store_1`(filename, map)
        invisible()
    },
    
    # C++ signature: void store(String filename, FeatureMap & map)
    # C++ signature: void store(String filename, ConsensusMap & map)
    store = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap")) { self$store_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$store_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void load(String filename, ConsensusMap & consensus_map)
    load = function(filename, consensus_map){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
    
    
        private$py_obj$load(filename, consensus_map)
        invisible()
    }
)
) 

# R implementation of _Element
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Element.html
Element <- R6Class(classname = "Element",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Element()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Element()
        invisible()
    
    
    },
    
    # C++ signature: void Element(String name, String symbol, unsigned int atomic_number, double average_weight, double mono_weight, IsotopeDistribution isotopes)
    init_1 = function(name, symbol, atomic_number, average_weight, mono_weight, isotopes){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(symbol) && class(symbol)[1]=="String") || is_scalar_character(symbol))){ stop("arg symbol wrong type") }
        if(!( (is_scalar_integer(atomic_number) || is_scalar_double(atomic_number)) && atomic_number == as.integer(atomic_number))){ stop("arg atomic_number wrong type") }
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!(is_scalar_double(mono_weight))){ stop("arg mono_weight wrong type") }
        if(!(is.R6(isotopes) && class(isotopes)[1] == "IsotopeDistribution")){ stop("arg isotopes wrong type") }
    
    
    
    
    
    
    
        private$py_obj <- Pymod$Element(name, symbol, as.integer(atomic_number), average_weight, mono_weight, isotopes)
        invisible()
    
    
    },
    
    # C++ signature: void Element()
    # C++ signature: void Element(String name, String symbol, unsigned int atomic_number, double average_weight, double mono_weight, IsotopeDistribution isotopes)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==6) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]])) && (is.R6(arg_list[[6]]) && class(arg_list[[6]])[1] == "IsotopeDistribution")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Element" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setAtomicNumber(unsigned int atomic_number)
    setAtomicNumber = function(atomic_number){
    
        if(!( (is_scalar_integer(atomic_number) || is_scalar_double(atomic_number)) && atomic_number == as.integer(atomic_number))){ stop("arg atomic_number wrong type") }
    
        private$py_obj$setAtomicNumber(as.integer(atomic_number))
        invisible()
    },
    
    # C++ signature: unsigned int getAtomicNumber()
    getAtomicNumber = function(){
    
        py_ans = private$py_obj$getAtomicNumber()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAverageWeight(double weight)
    setAverageWeight = function(weight){
    
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
    
        private$py_obj$setAverageWeight(weight)
        invisible()
    },
    
    # C++ signature: double getAverageWeight()
    getAverageWeight = function(){
    
        py_ans = private$py_obj$getAverageWeight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMonoWeight(double weight)
    setMonoWeight = function(weight){
    
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
    
        private$py_obj$setMonoWeight(weight)
        invisible()
    },
    
    # C++ signature: double getMonoWeight()
    getMonoWeight = function(){
    
        py_ans = private$py_obj$getMonoWeight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsotopeDistribution(IsotopeDistribution isotopes)
    setIsotopeDistribution = function(isotopes){
    
        if(!(is.R6(isotopes) && class(isotopes)[1] == "IsotopeDistribution")){ stop("arg isotopes wrong type") }
    
        private$py_obj$setIsotopeDistribution(isotopes)
        invisible()
    },
    
    # C++ signature: IsotopeDistribution getIsotopeDistribution()
    getIsotopeDistribution = function(){
    
        py_ans = private$py_obj$getIsotopeDistribution()
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSymbol(String symbol)
    setSymbol = function(symbol){
    
        if(!((is.R6(symbol) && class(symbol)[1]=="String") || is_scalar_character(symbol))){ stop("arg symbol wrong type") }
    
        private$py_obj$setSymbol(symbol)
        invisible()
    },
    
    # C++ signature: String getSymbol()
    getSymbol = function(){
    
        py_ans = private$py_obj$getSymbol()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ElementDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ElementDB.html
ElementDB <- R6Class(classname = "ElementDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: const Element * getElement(const String & name)
    getElement_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_getElement_0`(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Element$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Element * getElement(unsigned int atomic_number)
    getElement_1 = function(atomic_number){
    
        if(!( (is_scalar_integer(atomic_number) || is_scalar_double(atomic_number)) && atomic_number == as.integer(atomic_number))){ stop("arg atomic_number wrong type") }
    
        py_ans = private$py_obj$`_getElement_1`(as.integer(atomic_number)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Element$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Element * getElement(const String & name)
    # C++ signature: const Element * getElement(unsigned int atomic_number)
    getElement = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getElement_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getElement_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool hasElement(const String & name)
    hasElement_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_hasElement_0`(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasElement(unsigned int atomic_number)
    hasElement_1 = function(atomic_number){
    
        if(!( (is_scalar_integer(atomic_number) || is_scalar_double(atomic_number)) && atomic_number == as.integer(atomic_number))){ stop("arg atomic_number wrong type") }
    
        py_ans = private$py_obj$`_hasElement_1`(as.integer(atomic_number))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasElement(const String & name)
    # C++ signature: bool hasElement(unsigned int atomic_number)
    hasElement = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$hasElement_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$hasElement_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _ElutionModelFitter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ElutionModelFitter.html
ElutionModelFitter <- R6Class(classname = "ElutionModelFitter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ElutionModelFitter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ElutionModelFitter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ElutionModelFitter()
        invisible()
    }
    
    },
    
    # C++ signature: void fitElutionModels(FeatureMap & features)
    fitElutionModels = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
    
        private$py_obj$fitElutionModels(features)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ElutionPeakDetection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ElutionPeakDetection.html
ElutionPeakDetection <- R6Class(classname = "ElutionPeakDetection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ElutionPeakDetection()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ElutionPeakDetection) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ElutionPeakDetection()
        invisible()
    }
    
    },
    
    # C++ signature: void detectPeaks(Kernel_MassTrace & in_, libcpp_vector[Kernel_MassTrace] & out)
    detectPeaks_0 = function(in_, out){
    
        if(!(is.R6(in_) && class(in_)[1] == "Kernel_MassTrace")){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg out wrong type") }
    
        v1 <- r_to_py(out)
        private$py_obj$`_detectPeaks_0`(in_, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void detectPeaks(libcpp_vector[Kernel_MassTrace] & in_, libcpp_vector[Kernel_MassTrace] & out)
    detectPeaks_1 = function(in_, out){
    
        if(!(is_list(in_) && all(sapply(in_,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg out wrong type") }
        v0 <- r_to_py(in_)
        v1 <- r_to_py(out)
        private$py_obj$`_detectPeaks_1`(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_ <- byref_0))
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void detectPeaks(Kernel_MassTrace & in_, libcpp_vector[Kernel_MassTrace] & out)
    # C++ signature: void detectPeaks(libcpp_vector[Kernel_MassTrace] & in_, libcpp_vector[Kernel_MassTrace] & out)
    detectPeaks = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Kernel_MassTrace") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))) { self$detectPeaks_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))) { self$detectPeaks_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void filterByPeakWidth(libcpp_vector[Kernel_MassTrace] & in_, libcpp_vector[Kernel_MassTrace] & out)
    filterByPeakWidth = function(in_, out){
    
        if(!(is_list(in_) && all(sapply(in_,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg out wrong type") }
        v0 <- r_to_py(in_)
        v1 <- r_to_py(out)
        private$py_obj$filterByPeakWidth(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_ <- byref_0))
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double computeMassTraceNoise(Kernel_MassTrace &)
    computeMassTraceNoise = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Kernel_MassTrace")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$computeMassTraceNoise(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeMassTraceSNR(Kernel_MassTrace &)
    computeMassTraceSNR = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Kernel_MassTrace")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$computeMassTraceSNR(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeApexSNR(Kernel_MassTrace &)
    computeApexSNR = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Kernel_MassTrace")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$computeApexSNR(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void findLocalExtrema(Kernel_MassTrace &, size_t &, libcpp_vector[size_t] &, libcpp_vector[size_t] &)
    findLocalExtrema = function(in_0, in_1, in_2, in_3){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Kernel_MassTrace")){ stop("arg in_0 wrong type") }
        if(!( (is_scalar_integer(in_1) || is_scalar_double(in_1)) && in_1 == as.integer(in_1))){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg in_2 wrong type") }
        if(!(is_list(in_3) && all(sapply(in_3,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg in_3 wrong type") }
    
    
        v2 <- r_to_py(in_2)
        v3 <- r_to_py(in_3)
        private$py_obj$findLocalExtrema(in_0, as.integer(in_1), v2, v3)
        byref_3 <- py_to_r(v3)
        byref_2 <- py_to_r(v2)
    
        tryCatch({
        eval.parent(substitute(in_2 <- byref_2))
        eval.parent(substitute(in_3 <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void smoothData(Kernel_MassTrace & mt, int win_size)
    smoothData = function(mt, win_size){
    
        if(!(is.R6(mt) && class(mt)[1] == "Kernel_MassTrace")){ stop("arg mt wrong type") }
        if(!( (is_scalar_integer(win_size) || is_scalar_double(win_size)) && win_size == as.integer(win_size))){ stop("arg win_size wrong type") }
    
    
        private$py_obj$smoothData(mt, as.integer(win_size))
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _EmgFitter1D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EmgFitter1D.html
EmgFitter1D <- R6Class(classname = "EmgFitter1D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EmgFitter1D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$EmgFitter1D()
        invisible()
    
    
    },
    
    # C++ signature: void EmgFitter1D(EmgFitter1D)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmgFitter1D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EmgFitter1D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EmgFitter1D()
    # C++ signature: void EmgFitter1D(EmgFitter1D)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "EmgFitter1D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EmgFitter1D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _EmgGradientDescent
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EmgGradientDescent.html
EmgGradientDescent <- R6Class(classname = "EmgGradientDescent",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EmgGradientDescent()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$EmgGradientDescent()
        invisible()
    
    
    },
    
    # C++ signature: void EmgGradientDescent(EmgGradientDescent)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmgGradientDescent")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EmgGradientDescent(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EmgGradientDescent()
    # C++ signature: void EmgGradientDescent(EmgGradientDescent)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "EmgGradientDescent")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EmgGradientDescent" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getDefaultParameters(Param &)
    getDefaultParameters = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
        private$py_obj$getDefaultParameters(in_0)
        invisible()
    },
    
    # C++ signature: void fitEMGPeakModel(MSChromatogram & input_peak, MSChromatogram & output_peak)
    fitEMGPeakModel_0 = function(input_peak, output_peak){
    
        if(!(is.R6(input_peak) && class(input_peak)[1] == "MSChromatogram")){ stop("arg input_peak wrong type") }
        if(!(is.R6(output_peak) && class(output_peak)[1] == "MSChromatogram")){ stop("arg output_peak wrong type") }
    
    
        private$py_obj$`_fitEMGPeakModel_0`(input_peak, output_peak)
        invisible()
    },
    
    # C++ signature: void fitEMGPeakModel(MSSpectrum & input_peak, MSSpectrum & output_peak)
    fitEMGPeakModel_1 = function(input_peak, output_peak){
    
        if(!(is.R6(input_peak) && class(input_peak)[1] == "MSSpectrum")){ stop("arg input_peak wrong type") }
        if(!(is.R6(output_peak) && class(output_peak)[1] == "MSSpectrum")){ stop("arg output_peak wrong type") }
    
    
        private$py_obj$`_fitEMGPeakModel_1`(input_peak, output_peak)
        invisible()
    },
    
    # C++ signature: void fitEMGPeakModel(MSChromatogram & input_peak, MSChromatogram & output_peak, double left_pos, double right_pos)
    fitEMGPeakModel_2 = function(input_peak, output_peak, left_pos, right_pos){
    
        if(!(is.R6(input_peak) && class(input_peak)[1] == "MSChromatogram")){ stop("arg input_peak wrong type") }
        if(!(is.R6(output_peak) && class(output_peak)[1] == "MSChromatogram")){ stop("arg output_peak wrong type") }
        if(!(is_scalar_double(left_pos))){ stop("arg left_pos wrong type") }
        if(!(is_scalar_double(right_pos))){ stop("arg right_pos wrong type") }
    
    
    
    
        private$py_obj$`_fitEMGPeakModel_2`(input_peak, output_peak, left_pos, right_pos)
        invisible()
    },
    
    # C++ signature: void fitEMGPeakModel(MSSpectrum & input_peak, MSSpectrum & output_peak, double left_pos, double right_pos)
    fitEMGPeakModel_3 = function(input_peak, output_peak, left_pos, right_pos){
    
        if(!(is.R6(input_peak) && class(input_peak)[1] == "MSSpectrum")){ stop("arg input_peak wrong type") }
        if(!(is.R6(output_peak) && class(output_peak)[1] == "MSSpectrum")){ stop("arg output_peak wrong type") }
        if(!(is_scalar_double(left_pos))){ stop("arg left_pos wrong type") }
        if(!(is_scalar_double(right_pos))){ stop("arg right_pos wrong type") }
    
    
    
    
        private$py_obj$`_fitEMGPeakModel_3`(input_peak, output_peak, left_pos, right_pos)
        invisible()
    },
    
    # C++ signature: void fitEMGPeakModel(MSChromatogram & input_peak, MSChromatogram & output_peak)
    # C++ signature: void fitEMGPeakModel(MSSpectrum & input_peak, MSSpectrum & output_peak)
    # C++ signature: void fitEMGPeakModel(MSChromatogram & input_peak, MSChromatogram & output_peak, double left_pos, double right_pos)
    # C++ signature: void fitEMGPeakModel(MSSpectrum & input_peak, MSSpectrum & output_peak, double left_pos, double right_pos)
    fitEMGPeakModel = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSChromatogram")) { self$fitEMGPeakModel_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSSpectrum")) { self$fitEMGPeakModel_1(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSChromatogram") && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$fitEMGPeakModel_2(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$fitEMGPeakModel_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _EmgModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EmgModel.html
EmgModel <- R6Class(classname = "EmgModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EmgModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$EmgModel()
        invisible()
    
    
    },
    
    # C++ signature: void EmgModel(EmgModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmgModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EmgModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EmgModel()
    # C++ signature: void EmgModel(EmgModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "EmgModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EmgModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getIntensity(double coord)
    getIntensity = function(coord){
    
        if(!(is_scalar_double(coord))){ stop("arg coord wrong type") }
    
        py_ans = private$py_obj$getIntensity(coord)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getScalingFactor()
    getScalingFactor = function(){
    
        py_ans = private$py_obj$getScalingFactor()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset(double offset)
    setOffset = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset(offset)
        invisible()
    },
    
    # C++ signature: double getCenter()
    getCenter = function(){
    
        py_ans = private$py_obj$getCenter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSamples()
    setSamples = function(){
    
        private$py_obj$setSamples()
        invisible()
    },
    
    # C++ signature: void setInterpolationStep(double interpolation_step)
    setInterpolationStep = function(interpolation_step){
    
        if(!(is_scalar_double(interpolation_step))){ stop("arg interpolation_step wrong type") }
    
        private$py_obj$setInterpolationStep(interpolation_step)
        invisible()
    },
    
    # C++ signature: void setScalingFactor(double scaling)
    setScalingFactor = function(scaling){
    
        if(!(is_scalar_double(scaling))){ stop("arg scaling wrong type") }
    
        private$py_obj$setScalingFactor(scaling)
        invisible()
    },
    
    # C++ signature: LinearInterpolation getInterpolation()
    getInterpolation = function(){
    
        py_ans = private$py_obj$getInterpolation()
        r_ans = LinearInterpolation$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _EmgScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EmgScoring.html
EmgScoring <- R6Class(classname = "EmgScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EmgScoring()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == EmgScoring) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$EmgScoring()
        invisible()
    }
    
    },
    
    # C++ signature: void setFitterParam(Param param)
    setFitterParam = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setFitterParam(param)
        invisible()
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double elutionModelFit(libcpp_vector[DPosition2] current_section, bool smooth_data)
    elutionModelFit = function(current_section, smooth_data){
    
        if(!(is.matrix(current_section) && NROW(current_section) == 2 && is_double(current_section[1,]) && is_double(current_section[2,]))){ stop("arg current_section wrong type") }
        if(!( (is_scalar_integer(smooth_data) || is_scalar_double(smooth_data)) && smooth_data == as.integer(smooth_data))){ stop("arg smooth_data wrong type") }
        dp_0 <- r_to_py(current_section)
    
        py_ans = private$py_obj$elutionModelFit(dp_0, as.integer(smooth_data))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _EmpiricalFormula
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EmpiricalFormula.html
EmpiricalFormula <- R6Class(classname = "EmpiricalFormula",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EmpiricalFormula()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$EmpiricalFormula()
        invisible()
    
    
    },
    
    # C++ signature: void EmpiricalFormula(String)
    init_1 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EmpiricalFormula(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EmpiricalFormula(ptrdiff_t number, Element * element, ptrdiff_t charge)
    init_2 = function(number, element, charge){
    
        if(!( (is_scalar_integer(number) || is_scalar_double(number)) && number == as.integer(number))){ stop("arg number wrong type") }
        if(!(is.R6(element) && class(element)[1] == "Element")){ stop("arg element wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
    
    
        private$py_obj <- Pymod$EmpiricalFormula(as.integer(number), element, as.integer(charge))
        invisible()
    
    
    },
    
    # C++ signature: void EmpiricalFormula()
    # C++ signature: void EmpiricalFormula(String)
    # C++ signature: void EmpiricalFormula(ptrdiff_t number, Element * element, ptrdiff_t charge)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Element") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EmpiricalFormula" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMonoWeight()
    getMonoWeight = function(){
    
        py_ans = private$py_obj$getMonoWeight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight()
    getAverageWeight = function(){
    
        py_ans = private$py_obj$getAverageWeight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool estimateFromWeightAndComp(double average_weight, double C, double H, double N, double O, double S, double P)
    estimateFromWeightAndComp = function(average_weight, C, H, N, O, S, P){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!(is_scalar_double(C))){ stop("arg C wrong type") }
        if(!(is_scalar_double(H))){ stop("arg H wrong type") }
        if(!(is_scalar_double(N))){ stop("arg N wrong type") }
        if(!(is_scalar_double(O))){ stop("arg O wrong type") }
        if(!(is_scalar_double(S))){ stop("arg S wrong type") }
        if(!(is_scalar_double(P))){ stop("arg P wrong type") }
    
    
    
    
    
    
    
        py_ans = private$py_obj$estimateFromWeightAndComp(average_weight, C, H, N, O, S, P)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool estimateFromWeightAndCompAndS(double average_weight, unsigned int S, double C, double H, double N, double O, double P)
    estimateFromWeightAndCompAndS = function(average_weight, S, C, H, N, O, P){
    
        if(!(is_scalar_double(average_weight))){ stop("arg average_weight wrong type") }
        if(!( (is_scalar_integer(S) || is_scalar_double(S)) && S == as.integer(S))){ stop("arg S wrong type") }
        if(!(is_scalar_double(C))){ stop("arg C wrong type") }
        if(!(is_scalar_double(H))){ stop("arg H wrong type") }
        if(!(is_scalar_double(N))){ stop("arg N wrong type") }
        if(!(is_scalar_double(O))){ stop("arg O wrong type") }
        if(!(is_scalar_double(P))){ stop("arg P wrong type") }
    
    
    
    
    
    
    
        py_ans = private$py_obj$estimateFromWeightAndCompAndS(average_weight, as.integer(S), C, H, N, O, P)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution getIsotopeDistribution(CoarseIsotopePatternGenerator)
    getIsotopeDistribution_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CoarseIsotopePatternGenerator")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getIsotopeDistribution_0`(in_0)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution getIsotopeDistribution(FineIsotopePatternGenerator)
    getIsotopeDistribution_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FineIsotopePatternGenerator")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getIsotopeDistribution_1`(in_0)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution getIsotopeDistribution(CoarseIsotopePatternGenerator)
    # C++ signature: IsotopeDistribution getIsotopeDistribution(FineIsotopePatternGenerator)
    getIsotopeDistribution = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CoarseIsotopePatternGenerator")) { self$getIsotopeDistribution_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FineIsotopePatternGenerator")) { self$getIsotopeDistribution_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: IsotopeDistribution getConditionalFragmentIsotopeDist(EmpiricalFormula & precursor, libcpp_set[unsigned int] & precursor_isotopes, CoarseIsotopePatternGenerator method)
    getConditionalFragmentIsotopeDist = function(precursor, precursor_isotopes, method){
    
        if(!(is.R6(precursor) && class(precursor)[1] == "EmpiricalFormula")){ stop("arg precursor wrong type") }
        if(!(is_list(precursor_isotopes) && all(sapply(precursor_isotopes,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(precursor_isotopes)))){ stop("arg precursor_isotopes wrong type") }
        if(!(is.R6(method) && class(method)[1] == "CoarseIsotopePatternGenerator")){ stop("arg method wrong type") }
    
        py$v1 <- precursor_isotopes
        py_run_string("v1 = [int(t) for t in v1];v1 = set(v1)")
    
        py_ans = private$py_obj$getConditionalFragmentIsotopeDist(precursor, py$v1, method)
        byref_1 <- as.list(py_eval("list(v1)"))
        py_run_string("del v1; gc.collect()")
        r_ans = IsotopeDistribution$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(precursor_isotopes <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: size_t getNumberOfAtoms()
    getNumberOfAtoms = function(){
    
        py_ans = private$py_obj$getNumberOfAtoms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: ptrdiff_t getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(ptrdiff_t charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_map[libcpp_string,int] getElementalComposition()
# Get elemental composition as a hash {'Symbol' -> NrAtoms}
    getElementalComposition = function(){
    
        py_ans = py_call(private$py_obj$getElementalComposition,)
        r_ans <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),py_to_r(py_builtin$list(py_ans$keys())))
        return(r_ans)
    },
    
    # C++ signature: bool isEmpty()
    isEmpty = function(){
    
        py_ans = private$py_obj$isEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isCharged()
    isCharged = function(){
    
        py_ans = private$py_obj$isCharged()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasElement(Element * element)
    hasElement = function(element){
    
        if(!(is.R6(element) && class(element)[1] == "Element")){ stop("arg element wrong type") }
    
        py_ans = private$py_obj$hasElement(element)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool contains(EmpiricalFormula ef)
    contains = function(ef){
    
        if(!(is.R6(ef) && class(ef)[1] == "EmpiricalFormula")){ stop("arg ef wrong type") }
    
        py_ans = private$py_obj$contains(ef)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calculateTheoreticalIsotopesNumber()
    calculateTheoreticalIsotopesNumber = function(){
    
        py_ans = private$py_obj$calculateTheoreticalIsotopesNumber()
        r_ans = py_ans
        return(r_ans)
    }
)
)
    #' @export
    `+.EmpiricalFormula` <- function(e1, e2){
       added <- e1$.__enclos_env__$private$py_obj + e2$.__enclos_env__$private$py_obj
       result <- EmpiricalFormula$new(added)
       return(result)
    } 

# R implementation of _EnzymaticDigestion
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EnzymaticDigestion.html
EnzymaticDigestion <- R6Class(classname = "EnzymaticDigestion",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EnzymaticDigestion(EnzymaticDigestion)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EnzymaticDigestion")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$EnzymaticDigestion(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void EnzymaticDigestion()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$EnzymaticDigestion()
        invisible()
    
    
    },
    
    # C++ signature: void EnzymaticDigestion(EnzymaticDigestion)
    # C++ signature: void EnzymaticDigestion()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "EnzymaticDigestion")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "EnzymaticDigestion" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t getMissedCleavages()
    getMissedCleavages = function(){
    
        py_ans = private$py_obj$getMissedCleavages()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMissedCleavages(size_t missed_cleavages)
    setMissedCleavages = function(missed_cleavages){
    
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
    
        private$py_obj$setMissedCleavages(as.integer(missed_cleavages))
        invisible()
    },
    
    # C++ signature: String getEnzymeName()
    getEnzymeName = function(){
    
        py_ans = private$py_obj$getEnzymeName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(DigestionEnzyme * enzyme)
    setEnzyme = function(enzyme){
    
        if(!(is.R6(enzyme) && class(enzyme)[1] == "DigestionEnzyme")){ stop("arg enzyme wrong type") }
    
        private$py_obj$setEnzyme(enzyme)
        invisible()
    },
    
    # C++ signature: Specificity getSpecificity()
    getSpecificity = function(){
    
        py_ans = private$py_obj$getSpecificity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpecificity(Specificity spec)
    setSpecificity = function(spec){
    
        if(!(spec %in% c(0, 1, 2, 3, 8, 9, 10))){ stop("arg spec wrong type") }
    
        private$py_obj$setSpecificity(as.integer(spec))
        invisible()
    },
    
    # C++ signature: Specificity getSpecificityByName(const String & name)
    getSpecificityByName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getSpecificityByName(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t digestUnmodified(StringView sequence, libcpp_vector[StringView] & output, size_t min_length, size_t max_length)
    digestUnmodified = function(sequence, output, min_length, max_length){
    
        if(!(is.R6(sequence) && class(sequence)[1] == "StringView")){ stop("arg sequence wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "StringView")))){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(min_length) || is_scalar_double(min_length)) && min_length == as.integer(min_length))){ stop("arg min_length wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
    
        v1 <- r_to_py(output)
    
    
        py_ans = private$py_obj$digestUnmodified(sequence, v1, as.integer(min_length), as.integer(max_length))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: bool isValidProduct(const String & sequence, int pos, int length, bool ignore_missed_cleavages)
    isValidProduct = function(sequence, pos, length, ignore_missed_cleavages){
    
        if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        if(!( (is_scalar_integer(pos) || is_scalar_double(pos)) && pos == as.integer(pos))){ stop("arg pos wrong type") }
        if(!( (is_scalar_integer(length) || is_scalar_double(length)) && length == as.integer(length))){ stop("arg length wrong type") }
        if(!( (is_scalar_integer(ignore_missed_cleavages) || is_scalar_double(ignore_missed_cleavages)) && ignore_missed_cleavages == as.integer(ignore_missed_cleavages))){ stop("arg ignore_missed_cleavages wrong type") }
    
    
    
    
        py_ans = private$py_obj$isValidProduct(sequence, as.integer(pos), as.integer(length), as.integer(ignore_missed_cleavages))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _EnzymaticDigestionLogModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1EnzymaticDigestionLogModel.html
EnzymaticDigestionLogModel <- R6Class(classname = "EnzymaticDigestionLogModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void EnzymaticDigestionLogModel()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == EnzymaticDigestionLogModel) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$EnzymaticDigestionLogModel()
        invisible()
    }
    
    },
    
    # C++ signature: String getEnzymeName()
    getEnzymeName = function(){
    
        py_ans = private$py_obj$getEnzymeName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(String name)
    setEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setEnzyme(name)
        invisible()
    },
    
    # C++ signature: double getLogThreshold()
    getLogThreshold = function(){
    
        py_ans = private$py_obj$getLogThreshold()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLogThreshold(double threshold)
    setLogThreshold = function(threshold){
    
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
    
        private$py_obj$setLogThreshold(threshold)
        invisible()
    },
    
    # C++ signature: void digest(AASequence & protein, libcpp_vector[AASequence] & output)
    digest = function(protein, output){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg output wrong type") }
    
        v1 <- r_to_py(output)
        private$py_obj$digest(protein, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t peptideCount(AASequence & protein)
    peptideCount = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
    
        py_ans = private$py_obj$peptideCount(protein)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ExperimentalDesign
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExperimentalDesign.html
ExperimentalDesign <- R6Class(classname = "ExperimentalDesign",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ExperimentalDesign()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ExperimentalDesign) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ExperimentalDesign()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[ExperimentalDesign_MSFileSectionEntry] getMSFileSection()
    getMSFileSection = function(){
    
        py_ans = private$py_obj$getMSFileSection()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setMSFileSection(libcpp_vector[ExperimentalDesign_MSFileSectionEntry] msfile_section)
    setMSFileSection = function(msfile_section){
    
        if(!(is_list(msfile_section) && all(sapply(msfile_section,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ExperimentalDesign_MSFileSectionEntry")))){ stop("arg msfile_section wrong type") }
        v0 <- r_to_py(msfile_section)
        private$py_obj$setMSFileSection(v0)
        
        invisible()
    },
    
    # C++ signature: ExperimentalDesign_SampleSection getSampleSection()
    getSampleSection = function(){
    
        py_ans = private$py_obj$getSampleSection()
        r_ans = ExperimentalDesign_SampleSection$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSampleSection(ExperimentalDesign_SampleSection sample_section)
    setSampleSection = function(sample_section){
    
        if(!(is.R6(sample_section) && class(sample_section)[1] == "ExperimentalDesign_SampleSection")){ stop("arg sample_section wrong type") }
    
        private$py_obj$setSampleSection(sample_section)
        invisible()
    },
    
    # C++ signature: unsigned int getNumberOfSamples()
    getNumberOfSamples = function(){
    
        py_ans = private$py_obj$getNumberOfSamples()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumberOfFractions()
    getNumberOfFractions = function(){
    
        py_ans = private$py_obj$getNumberOfFractions()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumberOfLabels()
    getNumberOfLabels = function(){
    
        py_ans = private$py_obj$getNumberOfLabels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumberOfMSFiles()
    getNumberOfMSFiles = function(){
    
        py_ans = private$py_obj$getNumberOfMSFiles()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumberOfFractionGroups()
    getNumberOfFractionGroups = function(){
    
        py_ans = private$py_obj$getNumberOfFractionGroups()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getSample(unsigned int fraction_group, unsigned int label)
    getSample = function(fraction_group, label){
    
        if(!( (is_scalar_integer(fraction_group) || is_scalar_double(fraction_group)) && fraction_group == as.integer(fraction_group))){ stop("arg fraction_group wrong type") }
        if(!( (is_scalar_integer(label) || is_scalar_double(label)) && label == as.integer(label))){ stop("arg label wrong type") }
    
    
        py_ans = private$py_obj$getSample(as.integer(fraction_group), as.integer(label))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isFractionated()
    isFractionated = function(){
    
        py_ans = private$py_obj$isFractionated()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool sameNrOfMSFilesPerFraction()
    sameNrOfMSFilesPerFraction = function(){
    
        py_ans = private$py_obj$sameNrOfMSFilesPerFraction()
        r_ans = py_ans
        return(r_ans)
    }
)
)
    
    # C++ signature: ExperimentalDesign fromConsensusMap(ConsensusMap c)
    ExperimentalDesign$fromConsensusMap = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "ConsensusMap")){ stop("arg c wrong type") }
    
        py_ans = Pymod$ExperimentalDesign$fromConsensusMap(c)
        r_ans = ExperimentalDesign$new(py_ans)
        return(r_ans)
    }
    
    # C++ signature: ExperimentalDesign fromFeatureMap(FeatureMap f)
    ExperimentalDesign$fromFeatureMap = function(f){
    
        if(!(is.R6(f) && class(f)[1] == "FeatureMap")){ stop("arg f wrong type") }
    
        py_ans = Pymod$ExperimentalDesign$fromFeatureMap(f)
        r_ans = ExperimentalDesign$new(py_ans)
        return(r_ans)
    }
    
    # C++ signature: ExperimentalDesign fromIdentifications(libcpp_vector[ProteinIdentification] & proteins)
    ExperimentalDesign$fromIdentifications = function(proteins){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        v0 <- r_to_py(proteins)
        py_ans = Pymod$ExperimentalDesign$fromIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = ExperimentalDesign$new(py_ans)
        return(r_ans)
    } 

# R implementation of _ExperimentalDesignFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExperimentalDesignFile.html
ExperimentalDesignFile <- R6Class(classname = "ExperimentalDesignFile",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: ExperimentalDesign load(const String & tsv_file, bool)
    ExperimentalDesignFile$load = function(tsv_file, in_1){
    
        if(!((is.R6(tsv_file) && class(tsv_file)[1]=="String") || is_scalar_character(tsv_file))){ stop("arg tsv_file wrong type") }
        if(!( (is_scalar_integer(in_1) || is_scalar_double(in_1)) && in_1 == as.integer(in_1))){ stop("arg in_1 wrong type") }
    
    
        py_ans = Pymod$ExperimentalDesignFile$load(tsv_file, as.integer(in_1))
        r_ans = ExperimentalDesign$new(py_ans)
        return(r_ans)
    } 

# R implementation of _ExperimentalDesign_MSFileSectionEntry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExperimentalDesign_MSFileSectionEntry.html
ExperimentalDesign_MSFileSectionEntry <- R6Class(classname = "ExperimentalDesign_MSFileSectionEntry",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        path = function(path){
    
        if(!missing(path)){
            if(!(is_scalar_character(path))){ stop("arg path wrong type") }
        
        path_0 = py_builtin$bytes(path,'utf-8')
            private$py_obj$path <- path
            } else {
        
                py_ans = private$py_obj$path
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        fraction_group = function(fraction_group){
    
        if(!missing(fraction_group)){
            if(!( (is_scalar_integer(fraction_group) || is_scalar_double(fraction_group)) && fraction_group == as.integer(fraction_group))){ stop("arg fraction_group wrong type") }
        
        
            private$py_obj$fraction_group <- as.integer(fraction_group)
            } else {
        
                py_ans = private$py_obj$fraction_group
                r_result = py_ans
                return(r_result)
                }
        },
        fraction = function(fraction){
    
        if(!missing(fraction)){
            if(!( (is_scalar_integer(fraction) || is_scalar_double(fraction)) && fraction == as.integer(fraction))){ stop("arg fraction wrong type") }
        
        
            private$py_obj$fraction <- as.integer(fraction)
            } else {
        
                py_ans = private$py_obj$fraction
                r_result = py_ans
                return(r_result)
                }
        },
        label = function(label){
    
        if(!missing(label)){
            if(!( (is_scalar_integer(label) || is_scalar_double(label)) && label == as.integer(label))){ stop("arg label wrong type") }
        
        
            private$py_obj$label <- as.integer(label)
            } else {
        
                py_ans = private$py_obj$label
                r_result = py_ans
                return(r_result)
                }
        },
        sample = function(sample){
    
        if(!missing(sample)){
            if(!( (is_scalar_integer(sample) || is_scalar_double(sample)) && sample == as.integer(sample))){ stop("arg sample wrong type") }
        
        
            private$py_obj$sample <- as.integer(sample)
            } else {
        
                py_ans = private$py_obj$sample
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ExperimentalDesign_MSFileSectionEntry()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ExperimentalDesign_MSFileSectionEntry) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ExperimentalDesign_MSFileSectionEntry()
        invisible()
    }
    
    }
)
) 

# R implementation of _ExperimentalDesign_SampleSection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExperimentalDesign_SampleSection.html
ExperimentalDesign_SampleSection <- R6Class(classname = "ExperimentalDesign_SampleSection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ExperimentalDesign_SampleSection()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ExperimentalDesign_SampleSection()
        invisible()
    
    
    },
    
    # C++ signature: void ExperimentalDesign_SampleSection(ExperimentalDesign_SampleSection)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ExperimentalDesign_SampleSection")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ExperimentalDesign_SampleSection(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ExperimentalDesign_SampleSection()
    # C++ signature: void ExperimentalDesign_SampleSection(ExperimentalDesign_SampleSection)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ExperimentalDesign_SampleSection")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ExperimentalDesign_SampleSection" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_set[unsigned int] getSamples()
    getSamples = function(){
    
        py_ans = private$py_obj$getSamples()
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[String] getFactors()
    getFactors = function(){
    
        py_ans = private$py_obj$getFactors()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: bool hasSample(unsigned int sample)
    hasSample = function(sample){
    
        if(!( (is_scalar_integer(sample) || is_scalar_double(sample)) && sample == as.integer(sample))){ stop("arg sample wrong type") }
    
        py_ans = private$py_obj$hasSample(as.integer(sample))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasFactor(String & factor)
    hasFactor = function(factor){
    
        if(!((is.R6(factor) && class(factor)[1]=="String") || is_scalar_character(factor))){ stop("arg factor wrong type") }
    
        py_ans = private$py_obj$hasFactor(factor)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getFactorValue(unsigned int sample, String & factor)
    getFactorValue = function(sample, factor){
    
        if(!( (is_scalar_integer(sample) || is_scalar_double(sample)) && sample == as.integer(sample))){ stop("arg sample wrong type") }
        if(!((is.R6(factor) && class(factor)[1]=="String") || is_scalar_character(factor))){ stop("arg factor wrong type") }
    
    
        py_ans = private$py_obj$getFactorValue(as.integer(sample), factor)
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ExperimentalSettings
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExperimentalSettings.html

# Description of the experimental settings, provides meta-information
# about an LC-MS/MS injection.
ExperimentalSettings <- R6Class(classname = "ExperimentalSettings",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ExperimentalSettings()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ExperimentalSettings) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ExperimentalSettings()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[SourceFile] getSourceFiles()
    getSourceFiles = function(){
    
        py_ans = private$py_obj$getSourceFiles()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSourceFiles(libcpp_vector[SourceFile] source_files)
    setSourceFiles = function(source_files){
    
        if(!(is_list(source_files) && all(sapply(source_files,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SourceFile")))){ stop("arg source_files wrong type") }
        v0 <- r_to_py(source_files)
        private$py_obj$setSourceFiles(v0)
        
        invisible()
    },
    
    # C++ signature: DateTime getDateTime()
    getDateTime = function(){
    
        py_ans = private$py_obj$getDateTime()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDateTime(DateTime date_time)
    setDateTime = function(date_time){
    
        if(!(is.R6(date_time) && class(date_time)[1] == "DateTime")){ stop("arg date_time wrong type") }
    
        private$py_obj$setDateTime(date_time)
        invisible()
    },
    
    # C++ signature: Sample getSample()
    getSample = function(){
    
        py_ans = private$py_obj$getSample()
        r_ans = Sample$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSample(Sample sample)
    setSample = function(sample){
    
        if(!(is.R6(sample) && class(sample)[1] == "Sample")){ stop("arg sample wrong type") }
    
        private$py_obj$setSample(sample)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ContactPerson] getContacts()
    getContacts = function(){
    
        py_ans = private$py_obj$getContacts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setContacts(libcpp_vector[ContactPerson] contacts)
    setContacts = function(contacts){
    
        if(!(is_list(contacts) && all(sapply(contacts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ContactPerson")))){ stop("arg contacts wrong type") }
        v0 <- r_to_py(contacts)
        private$py_obj$setContacts(v0)
        
        invisible()
    },
    
    # C++ signature: Instrument getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
        r_ans = Instrument$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(Instrument instrument)
    setInstrument = function(instrument){
    
        if(!(is.R6(instrument) && class(instrument)[1] == "Instrument")){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: HPLC getHPLC()
    getHPLC = function(){
    
        py_ans = private$py_obj$getHPLC()
        r_ans = HPLC$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setHPLC(HPLC hplc)
    setHPLC = function(hplc){
    
        if(!(is.R6(hplc) && class(hplc)[1] == "HPLC")){ stop("arg hplc wrong type") }
    
        private$py_obj$setHPLC(hplc)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinIdentification] getProteinIdentifications()
    getProteinIdentifications = function(){
    
        py_ans = private$py_obj$getProteinIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProteinIdentifications(libcpp_vector[ProteinIdentification] protein_identifications)
    setProteinIdentifications = function(protein_identifications){
    
        if(!(is_list(protein_identifications) && all(sapply(protein_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_identifications wrong type") }
        v0 <- r_to_py(protein_identifications)
        private$py_obj$setProteinIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: String getFractionIdentifier()
    getFractionIdentifier = function(){
    
        py_ans = private$py_obj$getFractionIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFractionIdentifier(String fraction_identifier)
    setFractionIdentifier = function(fraction_identifier){
    
        if(!((is.R6(fraction_identifier) && class(fraction_identifier)[1]=="String") || is_scalar_character(fraction_identifier))){ stop("arg fraction_identifier wrong type") }
    
        private$py_obj$setFractionIdentifier(fraction_identifier)
        invisible()
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ExtractionCoordinates
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ExtractionCoordinates.html
ExtractionCoordinates <- R6Class(classname = "ExtractionCoordinates",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mz = function(mz){
    
        if(!missing(mz)){
            if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        
        
            private$py_obj$mz <- mz
            } else {
        
                py_ans = private$py_obj$mz
                r_result = py_ans
                return(r_result)
                }
        },
        mz_precursor = function(mz_precursor){
    
        if(!missing(mz_precursor)){
            if(!(is_scalar_double(mz_precursor))){ stop("arg mz_precursor wrong type") }
        
        
            private$py_obj$mz_precursor <- mz_precursor
            } else {
        
                py_ans = private$py_obj$mz_precursor
                r_result = py_ans
                return(r_result)
                }
        },
        rt_start = function(rt_start){
    
        if(!missing(rt_start)){
            if(!(is_scalar_double(rt_start))){ stop("arg rt_start wrong type") }
        
        
            private$py_obj$rt_start <- rt_start
            } else {
        
                py_ans = private$py_obj$rt_start
                r_result = py_ans
                return(r_result)
                }
        },
        rt_end = function(rt_end){
    
        if(!missing(rt_end)){
            if(!(is_scalar_double(rt_end))){ stop("arg rt_end wrong type") }
        
        
            private$py_obj$rt_end <- rt_end
            } else {
        
                py_ans = private$py_obj$rt_end
                r_result = py_ans
                return(r_result)
                }
        },
        ion_mobility = function(ion_mobility){
    
        if(!missing(ion_mobility)){
            if(!(is_scalar_double(ion_mobility))){ stop("arg ion_mobility wrong type") }
        
        
            private$py_obj$ion_mobility <- ion_mobility
            } else {
        
                py_ans = private$py_obj$ion_mobility
                r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!(is_scalar_character(id))){ stop("arg id wrong type") }
        
        id_0 = py_builtin$bytes(id,'utf-8')
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = as.character(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ExtractionCoordinates()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ExtractionCoordinates()
        invisible()
    
    
    },
    
    # C++ signature: void ExtractionCoordinates(ExtractionCoordinates)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ExtractionCoordinates")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ExtractionCoordinates(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ExtractionCoordinates()
    # C++ signature: void ExtractionCoordinates(ExtractionCoordinates)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ExtractionCoordinates")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ExtractionCoordinates" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _FASTAEntry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FASTAEntry.html
FASTAEntry <- R6Class(classname = "FASTAEntry",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        identifier = function(identifier){
    
        if(!missing(identifier)){
            if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
        
        
            private$py_obj$identifier <- identifier
            } else {
        
                py_ans = private$py_obj$identifier
            r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void FASTAEntry()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FASTAEntry()
        invisible()
    
    
    },
    
    # C++ signature: void FASTAEntry(FASTAEntry)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FASTAEntry")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FASTAEntry(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FASTAEntry()
    # C++ signature: void FASTAEntry(FASTAEntry)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FASTAEntry")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FASTAEntry" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool headerMatches(const FASTAEntry & rhs)
    headerMatches = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "FASTAEntry")){ stop("arg rhs wrong type") }
    
        py_ans = private$py_obj$headerMatches(rhs)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool sequenceMatches(const FASTAEntry & rhs)
    sequenceMatches = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "FASTAEntry")){ stop("arg rhs wrong type") }
    
        py_ans = private$py_obj$sequenceMatches(rhs)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _FASTAFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FASTAFile.html
FASTAFile <- R6Class(classname = "FASTAFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FASTAFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FASTAFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FASTAFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, libcpp_vector[FASTAEntry] & data)
    load = function(filename, data){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg data wrong type") }
    
        v1 <- r_to_py(data)
        private$py_obj$load(filename, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(const String & filename, libcpp_vector[FASTAEntry] & data)
    store = function(filename, data){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg data wrong type") }
    
        v1 <- r_to_py(data)
        private$py_obj$store(filename, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void readStart(const String & filename)
    readStart = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$readStart(filename)
        invisible()
    },
    
    # C++ signature: bool readNext(FASTAEntry & protein)
    readNext = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "FASTAEntry")){ stop("arg protein wrong type") }
    
        py_ans = private$py_obj$readNext(protein)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool atEnd()
    atEnd = function(){
    
        py_ans = private$py_obj$atEnd()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void writeStart(const String & filename)
    writeStart = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$writeStart(filename)
        invisible()
    },
    
    # C++ signature: void writeNext(const FASTAEntry & protein)
    writeNext = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "FASTAEntry")){ stop("arg protein wrong type") }
    
        private$py_obj$writeNext(protein)
        invisible()
    },
    
    # C++ signature: void writeEnd()
    writeEnd = function(){
    
        private$py_obj$writeEnd()
        invisible()
    }
)
) 

# R implementation of _FIAMSDataProcessor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FIAMSDataProcessor.html

# ADD PYTHON DOCUMENTATION HERE
FIAMSDataProcessor <- R6Class(classname = "FIAMSDataProcessor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FIAMSDataProcessor()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FIAMSDataProcessor()
        invisible()
    
    
    },
    
    # C++ signature: void FIAMSDataProcessor(FIAMSDataProcessor)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FIAMSDataProcessor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FIAMSDataProcessor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FIAMSDataProcessor()
    # C++ signature: void FIAMSDataProcessor(FIAMSDataProcessor)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FIAMSDataProcessor")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FIAMSDataProcessor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool run(MSExperiment & experiment, float & n_seconds, MzTab & output, bool load_cached_spectrum)
    run = function(experiment, n_seconds, output, load_cached_spectrum){
    
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!(is_scalar_double(n_seconds))){ stop("arg n_seconds wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MzTab")){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(load_cached_spectrum) || is_scalar_double(load_cached_spectrum)) && load_cached_spectrum == as.integer(load_cached_spectrum))){ stop("arg load_cached_spectrum wrong type") }
    
    
    
    
        py_ans = private$py_obj$run(experiment, n_seconds, output, as.integer(load_cached_spectrum))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum extractPeaks(MSSpectrum & input_)
    extractPeaks = function(input_){
    
        if(!(is.R6(input_) && class(input_)[1] == "MSSpectrum")){ stop("arg input_ wrong type") }
    
        py_ans = private$py_obj$extractPeaks(input_)
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: FeatureMap convertToFeatureMap(MSSpectrum & input_)
    convertToFeatureMap = function(input_){
    
        if(!(is.R6(input_) && class(input_)[1] == "MSSpectrum")){ stop("arg input_ wrong type") }
    
        py_ans = private$py_obj$convertToFeatureMap(input_)
        r_ans = FeatureMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum trackNoise(MSSpectrum & input_)
    trackNoise = function(input_){
    
        if(!(is.R6(input_) && class(input_)[1] == "MSSpectrum")){ stop("arg input_ wrong type") }
    
        py_ans = private$py_obj$trackNoise(input_)
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FIAMSScheduler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FIAMSScheduler.html

# ADD PYTHON DOCUMENTATION HERE
FIAMSScheduler <- R6Class(classname = "FIAMSScheduler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FIAMSScheduler()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FIAMSScheduler()
        invisible()
    
    
    },
    
    # C++ signature: void FIAMSScheduler(FIAMSScheduler)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FIAMSScheduler")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FIAMSScheduler(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FIAMSScheduler(String filename, String base_dir, bool load_cached_)
    init_2 = function(filename, base_dir, load_cached_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(base_dir) && class(base_dir)[1]=="String") || is_scalar_character(base_dir))){ stop("arg base_dir wrong type") }
        if(!( (is_scalar_integer(load_cached_) || is_scalar_double(load_cached_)) && load_cached_ == as.integer(load_cached_))){ stop("arg load_cached_ wrong type") }
    
    
    
    
        private$py_obj <- Pymod$FIAMSScheduler(filename, base_dir, as.integer(load_cached_))
        invisible()
    
    
    },
    
    # C++ signature: void FIAMSScheduler()
    # C++ signature: void FIAMSScheduler(FIAMSScheduler)
    # C++ signature: void FIAMSScheduler(String filename, String base_dir, bool load_cached_)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FIAMSScheduler")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FIAMSScheduler" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void run()
    run = function(){
    
        private$py_obj$run()
        invisible()
    },
    
    # C++ signature: String getBaseDir()
    getBaseDir = function(){
    
        py_ans = private$py_obj$getBaseDir()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _FalseDiscoveryRate
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FalseDiscoveryRate.html
FalseDiscoveryRate <- R6Class(classname = "FalseDiscoveryRate",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FalseDiscoveryRate()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FalseDiscoveryRate) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FalseDiscoveryRate()
        invisible()
    }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & forward_ids, libcpp_vector[PeptideIdentification] & reverse_ids)
    apply_0 = function(forward_ids, reverse_ids){
    
        if(!(is_list(forward_ids) && all(sapply(forward_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg forward_ids wrong type") }
        if(!(is_list(reverse_ids) && all(sapply(reverse_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg reverse_ids wrong type") }
        v0 <- r_to_py(forward_ids)
        v1 <- r_to_py(reverse_ids)
        private$py_obj$`_apply_0`(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(forward_ids <- byref_0))
        eval.parent(substitute(reverse_ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & id)
    apply_1 = function(id){
    
        if(!(is_list(id) && all(sapply(id,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg id wrong type") }
        v0 <- r_to_py(id)
        private$py_obj$`_apply_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[ProteinIdentification] & forward_ids, libcpp_vector[ProteinIdentification] & reverse_ids)
    apply_2 = function(forward_ids, reverse_ids){
    
        if(!(is_list(forward_ids) && all(sapply(forward_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg forward_ids wrong type") }
        if(!(is_list(reverse_ids) && all(sapply(reverse_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg reverse_ids wrong type") }
        v0 <- r_to_py(forward_ids)
        v1 <- r_to_py(reverse_ids)
        private$py_obj$`_apply_2`(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(forward_ids <- byref_0))
        eval.parent(substitute(reverse_ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[ProteinIdentification] & id)
    apply_3 = function(id){
    
        if(!(is_list(id) && all(sapply(id,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg id wrong type") }
        v0 <- r_to_py(id)
        private$py_obj$`_apply_3`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & forward_ids, libcpp_vector[PeptideIdentification] & reverse_ids)
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & id)
    # C++ signature: void apply(libcpp_vector[ProteinIdentification] & forward_ids, libcpp_vector[ProteinIdentification] & reverse_ids)
    # C++ signature: void apply(libcpp_vector[ProteinIdentification] & id)
    apply = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$apply_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$apply_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$apply_2(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$apply_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Feature
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Feature.html

# An LC-MS feature.
# -----
# The Feature class is used to describe the two-dimensional signal caused by an
# analyte. It can store a charge state and a list of peptide identifications
# (for peptides). The area occupied by the Feature in the LC-MS data set is
# represented by a list of convex hulls (one for each isotopic peak). There is
# also a convex hull for the entire Feature. The model description can store
# the parameters of a two-dimensional theoretical model of the underlying
# signal in LC-MS. Currently, non-peptide compounds are also represented as
# features.
Feature <- R6Class(classname = "Feature",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Feature()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Feature()
        invisible()
    
    
    },
    
    # C++ signature: void Feature(Feature &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Feature")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Feature(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Feature()
    # C++ signature: void Feature(Feature &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Feature")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Feature" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getQuality(size_t index)
    getQuality = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getQuality(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuality(size_t index, float q)
    setQuality = function(index, q){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
    
        private$py_obj$setQuality(as.integer(index), q)
        invisible()
    },
    
    # C++ signature: float getOverallQuality()
    getOverallQuality = function(){
    
        py_ans = private$py_obj$getOverallQuality()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOverallQuality(float q)
    setOverallQuality = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setOverallQuality(q)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Feature] getSubordinates()
    getSubordinates = function(){
    
        py_ans = private$py_obj$getSubordinates()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSubordinates(libcpp_vector[Feature])
    setSubordinates = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Feature")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setSubordinates(v0)
        
        invisible()
    },
    
    # C++ signature: bool encloses(double rt, double mz)
    encloses = function(rt, mz){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
    
        py_ans = private$py_obj$encloses(rt, mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: ConvexHull2D getConvexHull()
    getConvexHull = function(){
    
        py_ans = private$py_obj$getConvexHull()
        r_ans = ConvexHull2D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[ConvexHull2D] getConvexHulls()
    getConvexHulls = function(){
    
        py_ans = private$py_obj$getConvexHulls()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setConvexHulls(libcpp_vector[ConvexHull2D])
    setConvexHulls = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConvexHull2D")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setConvexHulls(v0)
        
        invisible()
    },
    
    # C++ signature: float getWidth()
    getWidth = function(){
    
        py_ans = private$py_obj$getWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWidth(float q)
    setWidth = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setWidth(q)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int q)
    setCharge = function(q){
    
        if(!( (is_scalar_integer(q) || is_scalar_double(q)) && q == as.integer(q))){ stop("arg q wrong type") }
    
        private$py_obj$setCharge(as.integer(q))
        invisible()
    },
    
    # C++ signature: AnnotationState getAnnotationState()
    getAnnotationState = function(){
    
        py_ans = private$py_obj$getAnnotationState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification] & peptides)
    setPeptideIdentifications = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$setPeptideIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureDeconvolution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureDeconvolution.html
FeatureDeconvolution <- R6Class(classname = "FeatureDeconvolution",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureDeconvolution()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureDeconvolution) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureDeconvolution()
        invisible()
    }
    
    },
    
    # C++ signature: void compute(FeatureMap & input, FeatureMap & output, ConsensusMap & cmap1, ConsensusMap & cmap2)
    compute = function(input, output, cmap1, cmap2){
    
        if(!(is.R6(input) && class(input)[1] == "FeatureMap")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!(is.R6(cmap1) && class(cmap1)[1] == "ConsensusMap")){ stop("arg cmap1 wrong type") }
        if(!(is.R6(cmap2) && class(cmap2)[1] == "ConsensusMap")){ stop("arg cmap2 wrong type") }
    
    
    
    
        private$py_obj$compute(input, output, cmap1, cmap2)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureDistance
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureDistance.html
FeatureDistance <- R6Class(classname = "FeatureDistance",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureDistance(double max_intensity, bool force_constraints)
    initialize = function(max_intensity, force_constraints){
    
    if(missing(force_constraints)){
         if( "python.builtin.object" %in% class(max_intensity) && class_to_wrap(max_intensity) == FeatureDistance ) { private$py_obj <- max_intensity }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(max_intensity))){ stop("arg max_intensity wrong type") }
        if(!( (is_scalar_integer(force_constraints) || is_scalar_double(force_constraints)) && force_constraints == as.integer(force_constraints))){ stop("arg force_constraints wrong type") }
    
    
    
        private$py_obj <- Pymod$FeatureDistance(max_intensity, as.integer(force_constraints))
        invisible()
    }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureFileOptions
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFileOptions.html
FeatureFileOptions <- R6Class(classname = "FeatureFileOptions",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFileOptions()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FeatureFileOptions()
        invisible()
    
    
    },
    
    # C++ signature: void FeatureFileOptions(FeatureFileOptions)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureFileOptions")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FeatureFileOptions(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FeatureFileOptions()
    # C++ signature: void FeatureFileOptions(FeatureFileOptions)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureFileOptions")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FeatureFileOptions" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setMetadataOnly(bool)
    setMetadataOnly = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMetadataOnly(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getMetadataOnly()
    getMetadataOnly = function(){
    
        py_ans = private$py_obj$getMetadataOnly()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSizeOnly(bool)
    setSizeOnly = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSizeOnly(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getSizeOnly()
    getSizeOnly = function(){
    
        py_ans = private$py_obj$getSizeOnly()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadConvexHull(bool)
    setLoadConvexHull = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLoadConvexHull(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getLoadConvexHull()
    getLoadConvexHull = function(){
    
        py_ans = private$py_obj$getLoadConvexHull()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadSubordinates(bool)
    setLoadSubordinates = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLoadSubordinates(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getLoadSubordinates()
    getLoadSubordinates = function(){
    
        py_ans = private$py_obj$getLoadSubordinates()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRTRange(DRange1 & range_)
    setRTRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setRTRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasRTRange()
    hasRTRange = function(){
    
        py_ans = private$py_obj$hasRTRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getRTRange()
    getRTRange = function(){
    
        py_ans = private$py_obj$getRTRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setMZRange(DRange1 & range_)
    setMZRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setMZRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasMZRange()
    hasMZRange = function(){
    
        py_ans = private$py_obj$hasMZRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getMZRange()
    getMZRange = function(){
    
        py_ans = private$py_obj$getMZRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setIntensityRange(DRange1 & range_)
    setIntensityRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setIntensityRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasIntensityRange()
    hasIntensityRange = function(){
    
        py_ans = private$py_obj$hasIntensityRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getIntensityRange()
    getIntensityRange = function(){
    
        py_ans = private$py_obj$getIntensityRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _FeatureFinder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFinder.html
FeatureFinder <- R6Class(classname = "FeatureFinder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFinder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFinder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFinder()
        invisible()
    }
    
    },
    
    # C++ signature: void run(String algorithm_name, MSExperiment & input_map, FeatureMap & feats, Param & param, FeatureMap & seeds)
    run = function(algorithm_name, input_map, feats, param, seeds){
    
        if(!((is.R6(algorithm_name) && class(algorithm_name)[1]=="String") || is_scalar_character(algorithm_name))){ stop("arg algorithm_name wrong type") }
        if(!(is.R6(input_map) && class(input_map)[1] == "MSExperiment")){ stop("arg input_map wrong type") }
        if(!(is.R6(feats) && class(feats)[1] == "FeatureMap")){ stop("arg feats wrong type") }
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
        if(!(is.R6(seeds) && class(seeds)[1] == "FeatureMap")){ stop("arg seeds wrong type") }
    
    
    
    
    
        private$py_obj$run(algorithm_name, input_map, feats, param, seeds)
        invisible()
    },
    
    # C++ signature: Param getParameters(String algorithm_name)
    getParameters = function(algorithm_name){
    
        if(!((is.R6(algorithm_name) && class(algorithm_name)[1]=="String") || is_scalar_character(algorithm_name))){ stop("arg algorithm_name wrong type") }
    
        py_ans = private$py_obj$getParameters(algorithm_name)
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _FeatureFinderAlgorithmIsotopeWavelet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFinderAlgorithmIsotopeWavelet.html
FeatureFinderAlgorithmIsotopeWavelet <- R6Class(classname = "FeatureFinderAlgorithmIsotopeWavelet",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFinderAlgorithmIsotopeWavelet()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFinderAlgorithmIsotopeWavelet) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFinderAlgorithmIsotopeWavelet()
        invisible()
    }
    
    },
    
    # C++ signature: void setData(MSExperiment & input, FeatureMap & output, FeatureFinder & ff)
    setData = function(input, output, ff){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!(is.R6(ff) && class(ff)[1] == "FeatureFinder")){ stop("arg ff wrong type") }
    
    
    
        private$py_obj$setData(input, output, ff)
        invisible()
    },
    
    # C++ signature: void run()
    run = function(){
    
        private$py_obj$run()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
)
    
    # C++ signature: String getProductName()
    FeatureFinderAlgorithmIsotopeWavelet$getProductName = function(){
    
        py_ans = Pymod$FeatureFinderAlgorithmIsotopeWavelet$getProductName()
        r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _FeatureFinderAlgorithmPicked
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFinderAlgorithmPicked.html
FeatureFinderAlgorithmPicked <- R6Class(classname = "FeatureFinderAlgorithmPicked",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFinderAlgorithmPicked()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFinderAlgorithmPicked) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFinderAlgorithmPicked()
        invisible()
    }
    
    },
    
    # C++ signature: void setData(MSExperiment & input, FeatureMap & output, FeatureFinder & ff)
    setData = function(input, output, ff){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!(is.R6(ff) && class(ff)[1] == "FeatureFinder")){ stop("arg ff wrong type") }
    
    
    
        private$py_obj$setData(input, output, ff)
        invisible()
    },
    
    # C++ signature: void run()
    run = function(){
    
        private$py_obj$run()
        invisible()
    },
    
    # C++ signature: void setSeeds(FeatureMap & seeds)
    setSeeds = function(seeds){
    
        if(!(is.R6(seeds) && class(seeds)[1] == "FeatureMap")){ stop("arg seeds wrong type") }
    
        private$py_obj$setSeeds(seeds)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
)
    
    # C++ signature: String getProductName()
    FeatureFinderAlgorithmPicked$getProductName = function(){
    
        py_ans = Pymod$FeatureFinderAlgorithmPicked$getProductName()
        r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _FeatureFinderAlgorithmSH
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFinderAlgorithmSH.html
FeatureFinderAlgorithmSH <- R6Class(classname = "FeatureFinderAlgorithmSH",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFinderAlgorithmSH()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFinderAlgorithmSH) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFinderAlgorithmSH()
        invisible()
    }
    
    },
    
    # C++ signature: void setData(MSExperiment & input, FeatureMap & output, FeatureFinder & ff)
    setData = function(input, output, ff){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!(is.R6(ff) && class(ff)[1] == "FeatureFinder")){ stop("arg ff wrong type") }
    
    
    
        private$py_obj$setData(input, output, ff)
        invisible()
    },
    
    # C++ signature: void run()
    run = function(){
    
        private$py_obj$run()
        invisible()
    },
    
    # C++ signature: unsigned int getNativeScanId(String native_id)
    getNativeScanId = function(native_id){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
    
        py_ans = private$py_obj$getNativeScanId(native_id)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
)
    
    # C++ signature: String getProductName()
    FeatureFinderAlgorithmSH$getProductName = function(){
    
        py_ans = Pymod$FeatureFinderAlgorithmSH$getProductName()
        r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _FeatureFinderMultiplexAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFinderMultiplexAlgorithm.html
FeatureFinderMultiplexAlgorithm <- R6Class(classname = "FeatureFinderMultiplexAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFinderMultiplexAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFinderMultiplexAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFinderMultiplexAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: void run(MSExperiment & exp, bool progress)
    run = function(exp, progress){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!( (is_scalar_integer(progress) || is_scalar_double(progress)) && progress == as.integer(progress))){ stop("arg progress wrong type") }
    
    
        private$py_obj$run(exp, as.integer(progress))
        invisible()
    },
    
    # C++ signature: FeatureMap getFeatureMap()
    getFeatureMap = function(){
    
        py_ans = private$py_obj$getFeatureMap()
        r_ans = FeatureMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: ConsensusMap getConsensusMap()
    getConsensusMap = function(){
    
        py_ans = private$py_obj$getConsensusMap()
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureFindingMetabo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureFindingMetabo.html
FeatureFindingMetabo <- R6Class(classname = "FeatureFindingMetabo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureFindingMetabo()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureFindingMetabo) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureFindingMetabo()
        invisible()
    }
    
    },
    
    # C++ signature: void run(libcpp_vector[Kernel_MassTrace] input_mtraces, FeatureMap & output_featmap, libcpp_vector[libcpp_vector[MSChromatogram]] & output_chromatograms)
    run = function(input_mtraces, output_featmap, output_chromatograms){
    
        if(!(is_list(input_mtraces) && all(sapply(input_mtraces,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg input_mtraces wrong type") }
        if(!(is.R6(output_featmap) && class(output_featmap)[1] == "FeatureMap")){ stop("arg output_featmap wrong type") }
        if(!(is_list(output_chromatograms) && all(sapply(output_chromatograms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "MSChromatogram")))))){ stop("arg output_chromatograms wrong type") }
        v0 <- r_to_py(input_mtraces)
    
        v2 <- r_to_py(output_chromatograms)
        private$py_obj$run(v0, output_featmap, v2)
        v2 <- py_to_r(v2)
        byref_2 <- map_depth(v2,listDepth(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        
    
        tryCatch({
        eval.parent(substitute(output_chromatograms <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureGroupingAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureGroupingAlgorithm.html
FeatureGroupingAlgorithm <- R6Class(classname = "FeatureGroupingAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void transferSubelements(libcpp_vector[ConsensusMap] maps, ConsensusMap & out)
    transferSubelements = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$transferSubelements(v0, out)
        
        invisible()
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureGroupingAlgorithmKD
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureGroupingAlgorithmKD.html
FeatureGroupingAlgorithmKD <- R6Class(classname = "FeatureGroupingAlgorithmKD",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureGroupingAlgorithmKD()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureGroupingAlgorithmKD) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureGroupingAlgorithmKD()
        invisible()
    }
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    group_0 = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$`_group_0`(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void group(libcpp_vector[ConsensusMap] & maps, ConsensusMap & out)
    group_1 = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$`_group_1`(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    # C++ signature: void group(libcpp_vector[ConsensusMap] & maps, ConsensusMap & out)
    group = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$group_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$group_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void transferSubelements(libcpp_vector[ConsensusMap] maps, ConsensusMap & out)
    transferSubelements = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$transferSubelements(v0, out)
        
        invisible()
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _FeatureGroupingAlgorithmLabeled
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureGroupingAlgorithmLabeled.html
FeatureGroupingAlgorithmLabeled <- R6Class(classname = "FeatureGroupingAlgorithmLabeled",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureGroupingAlgorithmLabeled()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureGroupingAlgorithmLabeled) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureGroupingAlgorithmLabeled()
        invisible()
    }
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    group = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$group(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void transferSubelements(libcpp_vector[ConsensusMap] maps, ConsensusMap & out)
    transferSubelements = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$transferSubelements(v0, out)
        
        invisible()
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureGroupingAlgorithmQT
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureGroupingAlgorithmQT.html
FeatureGroupingAlgorithmQT <- R6Class(classname = "FeatureGroupingAlgorithmQT",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureGroupingAlgorithmQT()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureGroupingAlgorithmQT) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureGroupingAlgorithmQT()
        invisible()
    }
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    group_0 = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$`_group_0`(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void group(libcpp_vector[ConsensusMap] & maps, ConsensusMap & out)
    group_1 = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$`_group_1`(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    # C++ signature: void group(libcpp_vector[ConsensusMap] & maps, ConsensusMap & out)
    group = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$group_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$group_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void transferSubelements(libcpp_vector[ConsensusMap] maps, ConsensusMap & out)
    transferSubelements = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$transferSubelements(v0, out)
        
        invisible()
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureGroupingAlgorithmUnlabeled
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureGroupingAlgorithmUnlabeled.html
FeatureGroupingAlgorithmUnlabeled <- R6Class(classname = "FeatureGroupingAlgorithmUnlabeled",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureGroupingAlgorithmUnlabeled()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureGroupingAlgorithmUnlabeled) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureGroupingAlgorithmUnlabeled()
        invisible()
    }
    
    },
    
    # C++ signature: void group(libcpp_vector[FeatureMap] & maps, ConsensusMap & out)
    group = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$group(v0, out)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addToGroup(int map_id, FeatureMap feature_map)
    addToGroup = function(map_id, feature_map){
    
        if(!( (is_scalar_integer(map_id) || is_scalar_double(map_id)) && map_id == as.integer(map_id))){ stop("arg map_id wrong type") }
        if(!(is.R6(feature_map) && class(feature_map)[1] == "FeatureMap")){ stop("arg feature_map wrong type") }
    
    
        private$py_obj$addToGroup(as.integer(map_id), feature_map)
        invisible()
    },
    
    # C++ signature: void setReference(int map_id, FeatureMap map)
    setReference = function(map_id, map){
    
        if(!( (is_scalar_integer(map_id) || is_scalar_double(map_id)) && map_id == as.integer(map_id))){ stop("arg map_id wrong type") }
        if(!(is.R6(map) && class(map)[1] == "FeatureMap")){ stop("arg map wrong type") }
    
    
        private$py_obj$setReference(as.integer(map_id), map)
        invisible()
    },
    
    # C++ signature: ConsensusMap getResultMap()
    getResultMap = function(){
    
        py_ans = private$py_obj$getResultMap()
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void transferSubelements(libcpp_vector[ConsensusMap] maps, ConsensusMap & out)
    transferSubelements = function(maps, out){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(out) && class(out)[1] == "ConsensusMap")){ stop("arg out wrong type") }
        v0 <- r_to_py(maps)
    
        private$py_obj$transferSubelements(v0, out)
        
        invisible()
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FeatureHandle
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureHandle.html
FeatureHandle <- R6Class(classname = "FeatureHandle",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureHandle()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FeatureHandle()
        invisible()
    
    
    },
    
    # C++ signature: void FeatureHandle(FeatureHandle)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureHandle")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FeatureHandle(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FeatureHandle(unsigned long int map_index, Peak2D & point, unsigned long int element_index)
    init_2 = function(map_index, point, element_index){
    
        if(!( (is_scalar_integer(map_index) || is_scalar_double(map_index)) && map_index == as.integer(map_index))){ stop("arg map_index wrong type") }
        if(!(is.R6(point) && class(point)[1] == "Peak2D")){ stop("arg point wrong type") }
        if(!( (is_scalar_integer(element_index) || is_scalar_double(element_index)) && element_index == as.integer(element_index))){ stop("arg element_index wrong type") }
    
    
    
    
        private$py_obj <- Pymod$FeatureHandle(as.integer(map_index), point, as.integer(element_index))
        invisible()
    
    
    },
    
    # C++ signature: void FeatureHandle()
    # C++ signature: void FeatureHandle(FeatureHandle)
    # C++ signature: void FeatureHandle(unsigned long int map_index, Peak2D & point, unsigned long int element_index)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureHandle")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Peak2D") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FeatureHandle" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: unsigned long int getMapIndex()
    getMapIndex = function(){
    
        py_ans = private$py_obj$getMapIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMapIndex(unsigned long int i)
    setMapIndex = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        private$py_obj$setMapIndex(as.integer(i))
        invisible()
    },
    
    # C++ signature: void setCharge(int charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWidth(float width)
    setWidth = function(width){
    
        if(!(is_scalar_double(width))){ stop("arg width wrong type") }
    
        private$py_obj$setWidth(width)
        invisible()
    },
    
    # C++ signature: float getWidth()
    getWidth = function(){
    
        py_ans = private$py_obj$getWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _FeatureMap
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureMap.html

# A container for features.
# -----
# A feature map is a container holding features, which represent
# chemical entities (peptides, proteins, small molecules etc.) found
# in an LC-MS/MS experiment.
# -----
# This class supports direct iteration in Python.
FeatureMap <- R6Class(classname = "FeatureMap",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureMap()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FeatureMap()
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMap(FeatureMap &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FeatureMap(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMap()
    # C++ signature: void FeatureMap(FeatureMap &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FeatureMap" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void push_back(Feature spec)
    push_back_0 = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "Feature")){ stop("arg spec wrong type") }
    
        private$py_obj$`_push_back_0`(spec)
        invisible()
    },
    
    # C++ signature: void push_back(MRMFeature spec)
    push_back_1 = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MRMFeature")){ stop("arg spec wrong type") }
    
        private$py_obj$`_push_back_1`(spec)
        invisible()
    },
    
    # C++ signature: void push_back(Feature spec)
    # C++ signature: void push_back(MRMFeature spec)
    push_back = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Feature")) { self$push_back_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeature")) { self$push_back_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void sortByIntensity()
    sortByIntensity_0 = function(){
    
        private$py_obj$`_sortByIntensity_0`()
        invisible()
    },
    
    # C++ signature: void sortByIntensity(bool reverse)
    sortByIntensity_1 = function(reverse){
    
        if(!( (is_scalar_integer(reverse) || is_scalar_double(reverse)) && reverse == as.integer(reverse))){ stop("arg reverse wrong type") }
    
        private$py_obj$`_sortByIntensity_1`(as.integer(reverse))
        invisible()
    },
    
    # C++ signature: void sortByIntensity()
    # C++ signature: void sortByIntensity(bool reverse)
    sortByIntensity = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$sortByIntensity_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$sortByIntensity_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void sortByPosition()
    sortByPosition = function(){
    
        private$py_obj$sortByPosition()
        invisible()
    },
    
    # C++ signature: void sortByRT()
    sortByRT = function(){
    
        private$py_obj$sortByRT()
        invisible()
    },
    
    # C++ signature: void sortByMZ()
    sortByMZ = function(){
    
        private$py_obj$sortByMZ()
        invisible()
    },
    
    # C++ signature: void sortByOverallQuality()
    sortByOverallQuality = function(){
    
        private$py_obj$sortByOverallQuality()
        invisible()
    },
    
    # C++ signature: void swap(FeatureMap &)
    swap = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
    
        private$py_obj$swap(in_0)
        invisible()
    },
    
    # C++ signature: void swapFeaturesOnly(FeatureMap swapfrom)
    swapFeaturesOnly = function(swapfrom){
    
        if(!(is.R6(swapfrom) && class(swapfrom)[1] == "FeatureMap")){ stop("arg swapfrom wrong type") }
    
        private$py_obj$swapFeaturesOnly(swapfrom)
        invisible()
    },
    
    # C++ signature: void clear()
    clear_0 = function(){
    
        private$py_obj$`_clear_0`()
        invisible()
    },
    
    # C++ signature: void clear(bool clear_meta_data)
    clear_1 = function(clear_meta_data){
    
        if(!( (is_scalar_integer(clear_meta_data) || is_scalar_double(clear_meta_data)) && clear_meta_data == as.integer(clear_meta_data))){ stop("arg clear_meta_data wrong type") }
    
        private$py_obj$`_clear_1`(as.integer(clear_meta_data))
        invisible()
    },
    
    # C++ signature: void clear()
    # C++ signature: void clear(bool clear_meta_data)
    clear = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$clear_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$clear_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void updateRanges()
    updateRanges = function(){
    
        private$py_obj$updateRanges()
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinIdentification] getProteinIdentifications()
    getProteinIdentifications = function(){
    
        py_ans = private$py_obj$getProteinIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProteinIdentifications(libcpp_vector[ProteinIdentification])
    setProteinIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setProteinIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getUnassignedPeptideIdentifications()
    getUnassignedPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getUnassignedPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setUnassignedPeptideIdentifications(libcpp_vector[PeptideIdentification])
    setUnassignedPeptideIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setUnassignedPeptideIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[DataProcessing] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[DataProcessing])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "DataProcessing")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    setPrimaryMSRunPath_0 = function(s){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
        private$py_obj$`_setPrimaryMSRunPath_0`(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s, MSExperiment & e)
    setPrimaryMSRunPath_1 = function(s, e){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        if(!(is.R6(e) && class(e)[1] == "MSExperiment")){ stop("arg e wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
    
        private$py_obj$`_setPrimaryMSRunPath_1`(v0, e)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    # C++ signature: void setPrimaryMSRunPath(StringList & s, MSExperiment & e)
    setPrimaryMSRunPath = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$setPrimaryMSRunPath_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment")) { self$setPrimaryMSRunPath_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & toFill)
    getPrimaryMSRunPath = function(toFill){
    
        if(!(is_list(toFill) && all(sapply(toFill),is_scalar_character))){ stop("arg toFill wrong type") }
        v0 = r_to_py(modify_depth(toFill,1,py_builtin$bytes(toFill,'utf-8')))
        private$py_obj$getPrimaryMSRunPath(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(toFill <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DPosition2 getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition2 getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMinInt()
    getMinInt = function(){
    
        py_ans = private$py_obj$getMinInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxInt()
    getMaxInt = function(){
    
        py_ans = private$py_obj$getMaxInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearRanges()
    clearRanges = function(){
    
        private$py_obj$clearRanges()
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
)
    #' @export
    `+.FeatureMap` <- function(e1, e2){
       added <- e1$.__enclos_env__$private$py_obj + e2$.__enclos_env__$private$py_obj
       result <- FeatureMap$new(added)
       return(result)
    } 

# R implementation of _FeatureMapping
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureMapping.html
FeatureMapping <- R6Class(classname = "FeatureMapping",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureMapping()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FeatureMapping()
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMapping(FeatureMapping)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMapping")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FeatureMapping(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMapping()
    # C++ signature: void FeatureMapping(FeatureMapping)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMapping")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FeatureMapping" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: FeatureMapping_FeatureToMs2Indices assignMS2IndexToFeature(MSExperiment & spectra, KDTreeFeatureMaps & fp_map_kd, double & precursor_mz_tolerance, double & precursor_rt_tolerance, bool ppm)
    assignMS2IndexToFeature = function(spectra, fp_map_kd, precursor_mz_tolerance, precursor_rt_tolerance, ppm){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is.R6(fp_map_kd) && class(fp_map_kd)[1] == "KDTreeFeatureMaps")){ stop("arg fp_map_kd wrong type") }
        if(!(is_scalar_double(precursor_mz_tolerance))){ stop("arg precursor_mz_tolerance wrong type") }
        if(!(is_scalar_double(precursor_rt_tolerance))){ stop("arg precursor_rt_tolerance wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$assignMS2IndexToFeature(spectra, fp_map_kd, precursor_mz_tolerance, precursor_rt_tolerance, as.integer(ppm))
        r_ans = FeatureMapping_FeatureToMs2Indices$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _FeatureMapping_FeatureToMs2Indices
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureMapping_FeatureToMs2Indices.html
FeatureMapping_FeatureToMs2Indices <- R6Class(classname = "FeatureMapping_FeatureToMs2Indices",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureMapping_FeatureToMs2Indices()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FeatureMapping_FeatureToMs2Indices()
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMapping_FeatureToMs2Indices(FeatureMapping_FeatureToMs2Indices)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMapping_FeatureToMs2Indices")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FeatureMapping_FeatureToMs2Indices(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FeatureMapping_FeatureToMs2Indices()
    # C++ signature: void FeatureMapping_FeatureToMs2Indices(FeatureMapping_FeatureToMs2Indices)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMapping_FeatureToMs2Indices")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FeatureMapping_FeatureToMs2Indices" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _FeatureXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FeatureXMLFile.html
FeatureXMLFile <- R6Class(classname = "FeatureXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FeatureXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FeatureXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FeatureXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, FeatureMap &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "FeatureMap")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, FeatureMap &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "FeatureMap")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    },
    
    # C++ signature: FeatureFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = FeatureFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(FeatureFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    },
    
    # C++ signature: size_t loadSize(String path)
    loadSize = function(path){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
    
        py_ans = private$py_obj$loadSize(path)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _File
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1File.html
File <- R6Class(classname = "File",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: String absolutePath(String file)
    File$absolutePath = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$File$absolutePath(file)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String basename(String file)
    File$basename = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$File$basename(file)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool empty(String file_)
    File$empty = function(file_){
    
        if(!((is.R6(file_) && class(file_)[1]=="String") || is_scalar_character(file_))){ stop("arg file_ wrong type") }
    
        py_ans = Pymod$File$empty(file_)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool exists(String file_)
    File$exists = function(file_){
    
        if(!((is.R6(file_) && class(file_)[1]=="String") || is_scalar_character(file_))){ stop("arg file_ wrong type") }
    
        py_ans = Pymod$File$exists(file_)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool fileList(String dir, String file_pattern, StringList output, bool full_path)
    File$fileList = function(dir, file_pattern, output, full_path){
    
        if(!((is.R6(dir) && class(dir)[1]=="String") || is_scalar_character(dir))){ stop("arg dir wrong type") }
        if(!((is.R6(file_pattern) && class(file_pattern)[1]=="String") || is_scalar_character(file_pattern))){ stop("arg file_pattern wrong type") }
        if(!(is_list(output) && all(sapply(output),is_scalar_character))){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(full_path) || is_scalar_double(full_path)) && full_path == as.integer(full_path))){ stop("arg full_path wrong type") }
    
    
        v2 = r_to_py(modify_depth(output,1,py_builtin$bytes(output,'utf-8')))
    
        py_ans = Pymod$File$fileList(dir, file_pattern, v2, as.integer(full_path))
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String find(String filename, StringList directories)
    File$find = function(filename, directories){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(directories) && all(sapply(directories),is_scalar_character))){ stop("arg directories wrong type") }
    
        v1 = r_to_py(modify_depth(directories,1,py_builtin$bytes(directories,'utf-8')))
        py_ans = Pymod$File$find(filename, v1)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String findDatabase(String db_name)
    File$findDatabase = function(db_name){
    
        if(!((is.R6(db_name) && class(db_name)[1]=="String") || is_scalar_character(db_name))){ stop("arg db_name wrong type") }
    
        py_ans = Pymod$File$findDatabase(db_name)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String findDoc(String filename)
    File$findDoc = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = Pymod$File$findDoc(filename)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String findExecutable(String toolName)
    File$findExecutable = function(toolName){
    
        if(!((is.R6(toolName) && class(toolName)[1]=="String") || is_scalar_character(toolName))){ stop("arg toolName wrong type") }
    
        py_ans = Pymod$File$findExecutable(toolName)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getExecutablePath()
    File$getExecutablePath = function(){
    
        py_ans = Pymod$File$getExecutablePath()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getOpenMSDataPath()
    File$getOpenMSDataPath = function(){
    
        py_ans = Pymod$File$getOpenMSDataPath()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getOpenMSHomePath()
    File$getOpenMSHomePath = function(){
    
        py_ans = Pymod$File$getOpenMSHomePath()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: Param getSystemParameters()
    File$getSystemParameters = function(){
    
        py_ans = Pymod$File$getSystemParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    }
    
    # C++ signature: String getTempDirectory()
    File$getTempDirectory = function(){
    
        py_ans = Pymod$File$getTempDirectory()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getTemporaryFile(const String & alternative_file)
    File$getTemporaryFile = function(alternative_file){
    
        if(!((is.R6(alternative_file) && class(alternative_file)[1]=="String") || is_scalar_character(alternative_file))){ stop("arg alternative_file wrong type") }
    
        py_ans = Pymod$File$getTemporaryFile(alternative_file)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getUniqueName()
    File$getUniqueName = function(){
    
        py_ans = Pymod$File$getUniqueName()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getUserDirectory()
    File$getUserDirectory = function(){
    
        py_ans = Pymod$File$getUserDirectory()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool isDirectory(String path)
    File$isDirectory = function(path){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
    
        py_ans = Pymod$File$isDirectory(path)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String path(String file)
    File$path = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$File$path(file)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool readable(String file)
    File$readable = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$File$readable(file)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool remove(String file_)
    File$remove = function(file_){
    
        if(!((is.R6(file_) && class(file_)[1]=="String") || is_scalar_character(file_))){ stop("arg file_ wrong type") }
    
        py_ans = Pymod$File$remove(file_)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool removeDirRecursively(String dir_name)
    File$removeDirRecursively = function(dir_name){
    
        if(!((is.R6(dir_name) && class(dir_name)[1]=="String") || is_scalar_character(dir_name))){ stop("arg dir_name wrong type") }
    
        py_ans = Pymod$File$removeDirRecursively(dir_name)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool rename(const String & from_, const String & to, bool overwrite_existing, bool verbose)
    File$rename = function(from_, to, overwrite_existing, verbose){
    
        if(!((is.R6(from_) && class(from_)[1]=="String") || is_scalar_character(from_))){ stop("arg from_ wrong type") }
        if(!((is.R6(to) && class(to)[1]=="String") || is_scalar_character(to))){ stop("arg to wrong type") }
        if(!( (is_scalar_integer(overwrite_existing) || is_scalar_double(overwrite_existing)) && overwrite_existing == as.integer(overwrite_existing))){ stop("arg overwrite_existing wrong type") }
        if(!( (is_scalar_integer(verbose) || is_scalar_double(verbose)) && verbose == as.integer(verbose))){ stop("arg verbose wrong type") }
    
    
    
    
        py_ans = Pymod$File$rename(from_, to, as.integer(overwrite_existing), as.integer(verbose))
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool writable(String file)
    File$writable = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$File$writable(file)
            r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _FileHandler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FileHandler.html
FileHandler <- R6Class(classname = "FileHandler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FileHandler()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FileHandler()
        invisible()
    
    
    },
    
    # C++ signature: void FileHandler(FileHandler)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FileHandler")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FileHandler(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FileHandler()
    # C++ signature: void FileHandler(FileHandler)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FileHandler")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FileHandler" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool loadExperiment(String, MSExperiment &)
    loadExperiment = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$loadExperiment(in_0, in_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void storeExperiment(String, MSExperiment)
    storeExperiment = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$storeExperiment(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool loadFeatures(String, FeatureMap &)
    loadFeatures = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "FeatureMap")){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$loadFeatures(in_0, in_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    }
)
)
    
    # C++ signature: String computeFileHash(const String & filename)
    FileHandler$computeFileHash = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = Pymod$FileHandler$computeFileHash(filename)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: int getType(const String & filename)
    FileHandler$getType = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = Pymod$FileHandler$getType(filename)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: FileType getTypeByContent(const String & filename)
    FileHandler$getTypeByContent = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = Pymod$FileHandler$getTypeByContent(filename)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: FileType getTypeByFileName(const String & filename)
    FileHandler$getTypeByFileName = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = Pymod$FileHandler$getTypeByFileName(filename)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool hasValidExtension(const String & filename, FileType type_)
    FileHandler$hasValidExtension = function(filename, type_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg type_ wrong type") }
    
    
        py_ans = Pymod$FileHandler$hasValidExtension(filename, as.integer(type_))
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool isSupported(FileType type_)
    FileHandler$isSupported = function(type_){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg type_ wrong type") }
    
        py_ans = Pymod$FileHandler$isSupported(as.integer(type_))
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String stripExtension(String file)
    FileHandler$stripExtension = function(file){
    
        if(!((is.R6(file) && class(file)[1]=="String") || is_scalar_character(file))){ stop("arg file wrong type") }
    
        py_ans = Pymod$FileHandler$stripExtension(file)
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String swapExtension(String filename, FileType new_type)
    FileHandler$swapExtension = function(filename, new_type){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(new_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg new_type wrong type") }
    
    
        py_ans = Pymod$FileHandler$swapExtension(filename, as.integer(new_type))
        r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _FileTypes
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FileTypes.html
FileTypes <- R6Class(classname = "FileTypes",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FileTypes()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FileTypes()
        invisible()
    
    
    },
    
    # C++ signature: void FileTypes(FileTypes)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FileTypes")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FileTypes(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FileTypes()
    # C++ signature: void FileTypes(FileTypes)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FileTypes")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FileTypes" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String typeToName(FileType t)
    typeToName = function(t){
    
        if(!(t %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg t wrong type") }
    
        py_ans = private$py_obj$typeToName(as.integer(t))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String typeToMZML(FileType t)
    typeToMZML = function(t){
    
        if(!(t %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg t wrong type") }
    
        py_ans = private$py_obj$typeToMZML(as.integer(t))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: FileType nameToType(String name)
    nameToType = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$nameToType(name)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _FilterFunctor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FilterFunctor.html
FilterFunctor <- R6Class(classname = "FilterFunctor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FilterFunctor()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FilterFunctor()
        invisible()
    
    
    },
    
    # C++ signature: void FilterFunctor(FilterFunctor)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FilterFunctor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$FilterFunctor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void FilterFunctor()
    # C++ signature: void FilterFunctor(FilterFunctor)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FilterFunctor")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FilterFunctor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FineIsotopePatternGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1FineIsotopePatternGenerator.html

# Isotope pattern generator for fine isotope distributions.
# Generates isotopes until a stop condition (threshold) is reached,
# the lower the threshold the more isotopes are generated. The
# parameter use_total_prob defines whether the stop condition is
# interpreted as the total probability that the distribution should
# cover (default) or as a threshold for individual peaks. Finally,
# the absolute parameter specifies for individual peak thresholding
# if the threshold is absolute or relative.
FineIsotopePatternGenerator <- R6Class(classname = "FineIsotopePatternGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FineIsotopePatternGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$FineIsotopePatternGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void FineIsotopePatternGenerator(double threshold)
    init_1 = function(threshold){
    
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
    
    
        private$py_obj <- Pymod$FineIsotopePatternGenerator(threshold)
        invisible()
    
    
    },
    
    # C++ signature: void FineIsotopePatternGenerator(double threshold, bool use_total_prob)
    init_2 = function(threshold, use_total_prob){
    
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
        if(!( (is_scalar_integer(use_total_prob) || is_scalar_double(use_total_prob)) && use_total_prob == as.integer(use_total_prob))){ stop("arg use_total_prob wrong type") }
    
    
    
        private$py_obj <- Pymod$FineIsotopePatternGenerator(threshold, as.integer(use_total_prob))
        invisible()
    
    
    },
    
    # C++ signature: void FineIsotopePatternGenerator(double threshold, bool use_total_prob, bool absolute)
    init_3 = function(threshold, use_total_prob, absolute){
    
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
        if(!( (is_scalar_integer(use_total_prob) || is_scalar_double(use_total_prob)) && use_total_prob == as.integer(use_total_prob))){ stop("arg use_total_prob wrong type") }
        if(!( (is_scalar_integer(absolute) || is_scalar_double(absolute)) && absolute == as.integer(absolute))){ stop("arg absolute wrong type") }
    
    
    
    
        private$py_obj <- Pymod$FineIsotopePatternGenerator(threshold, as.integer(use_total_prob), as.integer(absolute))
        invisible()
    
    
    },
    
    # C++ signature: void FineIsotopePatternGenerator()
    # C++ signature: void FineIsotopePatternGenerator(double threshold)
    # C++ signature: void FineIsotopePatternGenerator(double threshold, bool use_total_prob)
    # C++ signature: void FineIsotopePatternGenerator(double threshold, bool use_total_prob, bool absolute)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is_scalar_double(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_2(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_3(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "FineIsotopePatternGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setThreshold(double threshold)
    setThreshold = function(threshold){
    
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
    
        private$py_obj$setThreshold(threshold)
        invisible()
    },
    
    # C++ signature: double getThreshold()
    getThreshold = function(){
    
        py_ans = private$py_obj$getThreshold()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAbsolute(bool absolute)
    setAbsolute = function(absolute){
    
        if(!( (is_scalar_integer(absolute) || is_scalar_double(absolute)) && absolute == as.integer(absolute))){ stop("arg absolute wrong type") }
    
        private$py_obj$setAbsolute(as.integer(absolute))
        invisible()
    },
    
    # C++ signature: bool getAbsolute()
    getAbsolute = function(){
    
        py_ans = private$py_obj$getAbsolute()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTotalProbability(bool total)
    setTotalProbability = function(total){
    
        if(!( (is_scalar_integer(total) || is_scalar_double(total)) && total == as.integer(total))){ stop("arg total wrong type") }
    
        private$py_obj$setTotalProbability(as.integer(total))
        invisible()
    },
    
    # C++ signature: bool getTotalProbability()
    getTotalProbability = function(){
    
        py_ans = private$py_obj$getTotalProbability()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution run(EmpiricalFormula)
    run = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmpiricalFormula")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$run(in_0)
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _Fitter1D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Fitter1D.html
Fitter1D <- R6Class(classname = "Fitter1D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Fitter1D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Fitter1D()
        invisible()
    
    
    },
    
    # C++ signature: void Fitter1D(Fitter1D)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Fitter1D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Fitter1D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Fitter1D()
    # C++ signature: void Fitter1D(Fitter1D)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Fitter1D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Fitter1D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _FloatDataArray
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::DataArrays_1_1FloatDataArray.html

# The representation of extra float data attached to a spectrum or chromatogram.
# Raw data access is proved by `get_peaks` and `set_peaks`, which yields numpy arrays
FloatDataArray <- R6Class(classname = "FloatDataArray",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void FloatDataArray()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == FloatDataArray) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$FloatDataArray()
        invisible()
    }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void resize(size_t n)
    resize = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$resize(as.integer(n))
        invisible()
    },
    
    # C++ signature: void reserve(size_t n)
    reserve = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$reserve(as.integer(n))
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void push_back(float)
    push_back = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(in_0)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _GaussFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1GaussFilter.html
GaussFilter <- R6Class(classname = "GaussFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void GaussFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$GaussFilter()
        invisible()
    
    
    },
    
    # C++ signature: void GaussFilter(GaussFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "GaussFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$GaussFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void GaussFilter()
    # C++ signature: void GaussFilter(GaussFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "GaussFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "GaussFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void filter(MSSpectrum & spectrum)
    filter_0 = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$`_filter_0`(spectrum)
        invisible()
    },
    
    # C++ signature: void filter(MSChromatogram & chromatogram)
    filter_1 = function(chromatogram){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
    
        private$py_obj$`_filter_1`(chromatogram)
        invisible()
    },
    
    # C++ signature: void filter(MSSpectrum & spectrum)
    # C++ signature: void filter(MSChromatogram & chromatogram)
    filter = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum")) { self$filter_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram")) { self$filter_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void filterExperiment(MSExperiment & exp)
    filterExperiment = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterExperiment(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _GaussFitResult
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1GaussFitResult.html
GaussFitResult <- R6Class(classname = "GaussFitResult",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        A = function(A){
    
        if(!missing(A)){
            if(!(is_scalar_double(A))){ stop("arg A wrong type") }
        
        
            private$py_obj$A <- A
            } else {
        
                py_ans = private$py_obj$A
                r_result = py_ans
                return(r_result)
                }
        },
        x0 = function(x0){
    
        if(!missing(x0)){
            if(!(is_scalar_double(x0))){ stop("arg x0 wrong type") }
        
        
            private$py_obj$x0 <- x0
            } else {
        
                py_ans = private$py_obj$x0
                r_result = py_ans
                return(r_result)
                }
        },
        sigma = function(sigma){
    
        if(!missing(sigma)){
            if(!(is_scalar_double(sigma))){ stop("arg sigma wrong type") }
        
        
            private$py_obj$sigma <- sigma
            } else {
        
                py_ans = private$py_obj$sigma
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void GaussFitResult()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$GaussFitResult()
        invisible()
    
    
    },
    
    # C++ signature: void GaussFitResult(double, double, double)
    init_1 = function(in_0, in_1, in_2){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        if(!(is_scalar_double(in_2))){ stop("arg in_2 wrong type") }
    
    
    
    
        private$py_obj <- Pymod$GaussFitResult(in_0, in_1, in_2)
        invisible()
    
    
    },
    
    # C++ signature: void GaussFitResult()
    # C++ signature: void GaussFitResult(double, double, double)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "GaussFitResult" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double eval(double)
    eval = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$eval(in_0)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _GaussFitter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1GaussFitter.html
GaussFitter <- R6Class(classname = "GaussFitter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void GaussFitter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == GaussFitter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$GaussFitter()
        invisible()
    }
    
    },
    
    # C++ signature: void setInitialParameters(GaussFitResult & result)
    setInitialParameters = function(result){
    
        if(!(is.R6(result) && class(result)[1] == "GaussFitResult")){ stop("arg result wrong type") }
    
        private$py_obj$setInitialParameters(result)
        invisible()
    },
    
    # C++ signature: GaussFitResult fit(libcpp_vector[DPosition2] points)
    fit = function(points){
    
        if(!(is.matrix(points) && NROW(points) == 2 && is_double(points[1,]) && is_double(points[2,]))){ stop("arg points wrong type") }
        dp_0 <- r_to_py(points)
        py_ans = private$py_obj$fit(dp_0)
        r_ans = GaussFitResult$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _GaussTraceFitter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1GaussTraceFitter.html
GaussTraceFitter <- R6Class(classname = "GaussTraceFitter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void GaussTraceFitter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$GaussTraceFitter()
        invisible()
    
    
    },
    
    # C++ signature: void GaussTraceFitter(GaussTraceFitter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "GaussTraceFitter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$GaussTraceFitter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void GaussTraceFitter()
    # C++ signature: void GaussTraceFitter(GaussTraceFitter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "GaussTraceFitter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "GaussTraceFitter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void fit(MassTraces & traces)
    fit = function(traces){
    
        if(!(is.R6(traces) && class(traces)[1] == "MassTraces")){ stop("arg traces wrong type") }
    
        private$py_obj$fit(traces)
        invisible()
    },
    
    # C++ signature: double getLowerRTBound()
    getLowerRTBound = function(){
    
        py_ans = private$py_obj$getLowerRTBound()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getUpperRTBound()
    getUpperRTBound = function(){
    
        py_ans = private$py_obj$getUpperRTBound()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getHeight()
    getHeight = function(){
    
        py_ans = private$py_obj$getHeight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCenter()
    getCenter = function(){
    
        py_ans = private$py_obj$getCenter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getFWHM()
    getFWHM = function(){
    
        py_ans = private$py_obj$getFWHM()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getSigma()
    getSigma = function(){
    
        py_ans = private$py_obj$getSigma()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool checkMaximalRTSpan(double max_rt_span)
    checkMaximalRTSpan = function(max_rt_span){
    
        if(!(is_scalar_double(max_rt_span))){ stop("arg max_rt_span wrong type") }
    
        py_ans = private$py_obj$checkMaximalRTSpan(max_rt_span)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool checkMinimalRTSpan(libcpp_pair[double,double] & rt_bounds, double min_rt_span)
    checkMinimalRTSpan = function(rt_bounds, min_rt_span){
    
        if(!(is_list(rt_bounds) && length(rt_bounds) == 2 && is_scalar_double(rt_bounds[[1]]) && is_scalar_double(rt_bounds[[2]]))){ stop("arg rt_bounds wrong type") }
        if(!(is_scalar_double(min_rt_span))){ stop("arg min_rt_span wrong type") }
        v0 = r_to_py(list(rt_bounds[[1]],rt_bounds[[2]]))
    
        py_ans = private$py_obj$checkMinimalRTSpan(v0, min_rt_span)
        byref_0 = list(py_to_r(v0[0]), py_to_r(v0[1]))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(rt_bounds <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double computeTheoretical(MassTrace & trace, size_t k)
    computeTheoretical = function(trace, k){
    
        if(!(is.R6(trace) && class(trace)[1] == "MassTrace")){ stop("arg trace wrong type") }
        if(!( (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k))){ stop("arg k wrong type") }
    
    
        py_ans = private$py_obj$computeTheoretical(trace, as.integer(k))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getArea()
    getArea = function(){
    
        py_ans = private$py_obj$getArea()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getGnuplotFormula(MassTrace & trace, char function_name, double baseline, double rt_shift)
    getGnuplotFormula = function(trace, function_name, baseline, rt_shift){
    
        if(!(is.R6(trace) && class(trace)[1] == "MassTrace")){ stop("arg trace wrong type") }
        if(!(is_scalar_character(function_name))){ stop("arg function_name wrong type") }
        if(!(is_scalar_double(baseline))){ stop("arg baseline wrong type") }
        if(!(is_scalar_double(rt_shift))){ stop("arg rt_shift wrong type") }
    
    py_run_string("function_name = bytes(function_name)")
    
    
        py_ans = private$py_obj$getGnuplotFormula(trace, py$function_name, baseline, rt_shift)
        py_run_string("del function_name")
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getValue(double rt)
    getValue = function(rt){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
    
        py_ans = private$py_obj$getValue(rt)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _GoodDiffFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1GoodDiffFilter.html
GoodDiffFilter <- R6Class(classname = "GoodDiffFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void GoodDiffFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$GoodDiffFilter()
        invisible()
    
    
    },
    
    # C++ signature: void GoodDiffFilter(GoodDiffFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "GoodDiffFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$GoodDiffFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void GoodDiffFilter()
    # C++ signature: void GoodDiffFilter(GoodDiffFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "GoodDiffFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "GoodDiffFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Gradient
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Gradient.html
Gradient <- R6Class(classname = "Gradient",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Gradient()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Gradient) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Gradient()
        invisible()
    }
    
    },
    
    # C++ signature: void addEluent(String eluent)
    addEluent = function(eluent){
    
        if(!((is.R6(eluent) && class(eluent)[1]=="String") || is_scalar_character(eluent))){ stop("arg eluent wrong type") }
    
        private$py_obj$addEluent(eluent)
        invisible()
    },
    
    # C++ signature: void clearEluents()
    clearEluents = function(){
    
        private$py_obj$clearEluents()
        invisible()
    },
    
    # C++ signature: libcpp_vector[String] getEluents()
    getEluents = function(){
    
        py_ans = private$py_obj$getEluents()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void addTimepoint(int timepoint)
    addTimepoint = function(timepoint){
    
        if(!( (is_scalar_integer(timepoint) || is_scalar_double(timepoint)) && timepoint == as.integer(timepoint))){ stop("arg timepoint wrong type") }
    
        private$py_obj$addTimepoint(as.integer(timepoint))
        invisible()
    },
    
    # C++ signature: void clearTimepoints()
    clearTimepoints = function(){
    
        private$py_obj$clearTimepoints()
        invisible()
    },
    
    # C++ signature: libcpp_vector[int] getTimepoints()
    getTimepoints = function(){
    
        py_ans = private$py_obj$getTimepoints()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setPercentage(String eluent, int timepoint, unsigned int percentage)
    setPercentage = function(eluent, timepoint, percentage){
    
        if(!((is.R6(eluent) && class(eluent)[1]=="String") || is_scalar_character(eluent))){ stop("arg eluent wrong type") }
        if(!( (is_scalar_integer(timepoint) || is_scalar_double(timepoint)) && timepoint == as.integer(timepoint))){ stop("arg timepoint wrong type") }
        if(!( (is_scalar_integer(percentage) || is_scalar_double(percentage)) && percentage == as.integer(percentage))){ stop("arg percentage wrong type") }
    
    
    
        private$py_obj$setPercentage(eluent, as.integer(timepoint), as.integer(percentage))
        invisible()
    },
    
    # C++ signature: unsigned int getPercentage(String eluent, int timepoint)
    getPercentage = function(eluent, timepoint){
    
        if(!((is.R6(eluent) && class(eluent)[1]=="String") || is_scalar_character(eluent))){ stop("arg eluent wrong type") }
        if(!( (is_scalar_integer(timepoint) || is_scalar_double(timepoint)) && timepoint == as.integer(timepoint))){ stop("arg timepoint wrong type") }
    
    
        py_ans = private$py_obj$getPercentage(eluent, as.integer(timepoint))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearPercentages()
    clearPercentages = function(){
    
        private$py_obj$clearPercentages()
        invisible()
    },
    
    # C++ signature: bool isValid()
    isValid = function(){
    
        py_ans = private$py_obj$isValid()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _GridBasedCluster
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1GridBasedCluster.html
GridBasedCluster <- R6Class(classname = "GridBasedCluster",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void GridBasedCluster(DPosition2 centre, DBoundingBox2 bounding_box, libcpp_vector[int] point_indices, int property_A, libcpp_vector[int] properties_B)
    init_0 = function(centre, bounding_box, point_indices, property_A, properties_B){
    
        if(!(is_list(centre) && length(centre) == 2 && (is_scalar_integer(centre[[1]]) || is_scalar_double(centre[[1]])) && (is_scalar_integer(centre[[2]]) || is_scalar_double(centre[[2]])))){ stop("arg centre wrong type") }
        if(!(is.R6(bounding_box) && class(bounding_box)[1] == "DBoundingBox2")){ stop("arg bounding_box wrong type") }
        if(!(is_list(point_indices) && all(sapply(point_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg point_indices wrong type") }
        if(!( (is_scalar_integer(property_A) || is_scalar_double(property_A)) && property_A == as.integer(property_A))){ stop("arg property_A wrong type") }
        if(!(is_list(properties_B) && all(sapply(properties_B,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg properties_B wrong type") }
        dp_0 <- r_to_py(centre)
    
        v2 <- r_to_py(modify_depth(point_indices,1,as.integer))
    
        v4 <- r_to_py(modify_depth(properties_B,1,as.integer))
    
        private$py_obj <- Pymod$GridBasedCluster(dp_0, bounding_box, v2, as.integer(property_A), v4)
        invisible()
    
        
        
    
    },
    
    # C++ signature: void GridBasedCluster(DPosition2 centre, DBoundingBox2 bounding_box, libcpp_vector[int] point_indices)
    init_1 = function(centre, bounding_box, point_indices){
    
        if(!(is_list(centre) && length(centre) == 2 && (is_scalar_integer(centre[[1]]) || is_scalar_double(centre[[1]])) && (is_scalar_integer(centre[[2]]) || is_scalar_double(centre[[2]])))){ stop("arg centre wrong type") }
        if(!(is.R6(bounding_box) && class(bounding_box)[1] == "DBoundingBox2")){ stop("arg bounding_box wrong type") }
        if(!(is_list(point_indices) && all(sapply(point_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg point_indices wrong type") }
        dp_0 <- r_to_py(centre)
    
        v2 <- r_to_py(modify_depth(point_indices,1,as.integer))
    
        private$py_obj <- Pymod$GridBasedCluster(dp_0, bounding_box, v2)
        invisible()
    
        
    
    },
    
    # C++ signature: void GridBasedCluster(DPosition2 centre, DBoundingBox2 bounding_box, libcpp_vector[int] point_indices, int property_A, libcpp_vector[int] properties_B)
    # C++ signature: void GridBasedCluster(DPosition2 centre, DBoundingBox2 bounding_box, libcpp_vector[int] point_indices)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is_list(arg_list[[1]]) && length(arg_list[[1]]) == 2 && (is_scalar_integer(arg_list[[1]][[1]]) || is_scalar_double(arg_list[[1]][[1]])) && (is_scalar_integer(arg_list[[1]][[2]]) || is_scalar_double(arg_list[[1]][[2]]))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DBoundingBox2") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && (is_list(arg_list[[5]]) && all(sapply(arg_list[[5]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))) { self$init_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && length(arg_list[[1]]) == 2 && (is_scalar_integer(arg_list[[1]][[1]]) || is_scalar_double(arg_list[[1]][[1]])) && (is_scalar_integer(arg_list[[1]][[2]]) || is_scalar_double(arg_list[[1]][[2]]))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DBoundingBox2") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "GridBasedCluster" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: DPosition2 getCentre()
    getCentre = function(){
    
        py_ans = private$py_obj$getCentre()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DBoundingBox2 getBoundingBox()
    getBoundingBox = function(){
    
        py_ans = private$py_obj$getBoundingBox()
        r_ans = DBoundingBox2$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[int] getPoints()
    getPoints = function(){
    
        py_ans = private$py_obj$getPoints()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: int getPropertyA()
    getPropertyA = function(){
    
        py_ans = private$py_obj$getPropertyA()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[int] getPropertiesB()
    getPropertiesB = function(){
    
        py_ans = private$py_obj$getPropertiesB()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    }
)
) 

# R implementation of _HMMState
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1HMMState.html
HMMState <- R6Class(classname = "HMMState",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void HMMState()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$HMMState()
        invisible()
    
    
    },
    
    # C++ signature: void HMMState(HMMState)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "HMMState")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$HMMState(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void HMMState(const String & name, bool hidden)
    init_2 = function(name, hidden){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!( (is_scalar_integer(hidden) || is_scalar_double(hidden)) && hidden == as.integer(hidden))){ stop("arg hidden wrong type") }
    
    
    
        private$py_obj <- Pymod$HMMState(name, as.integer(hidden))
        invisible()
    
    
    },
    
    # C++ signature: void HMMState()
    # C++ signature: void HMMState(HMMState)
    # C++ signature: void HMMState(const String & name, bool hidden)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "HMMState")) { self$init_1(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "HMMState" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setName(const String & name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setHidden(bool hidden)
    setHidden = function(hidden){
    
        if(!( (is_scalar_integer(hidden) || is_scalar_double(hidden)) && hidden == as.integer(hidden))){ stop("arg hidden wrong type") }
    
        private$py_obj$setHidden(as.integer(hidden))
        invisible()
    },
    
    # C++ signature: bool isHidden()
    isHidden = function(){
    
        py_ans = private$py_obj$isHidden()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addPredecessorState(HMMState * state)
    addPredecessorState = function(state){
    
        if(!(is.R6(state) && class(state)[1] == "HMMState")){ stop("arg state wrong type") }
    
        private$py_obj$addPredecessorState(state)
        invisible()
    },
    
    # C++ signature: void deletePredecessorState(HMMState * state)
    deletePredecessorState = function(state){
    
        if(!(is.R6(state) && class(state)[1] == "HMMState")){ stop("arg state wrong type") }
    
        private$py_obj$deletePredecessorState(state)
        invisible()
    },
    
    # C++ signature: void addSuccessorState(HMMState * state)
    addSuccessorState = function(state){
    
        if(!(is.R6(state) && class(state)[1] == "HMMState")){ stop("arg state wrong type") }
    
        private$py_obj$addSuccessorState(state)
        invisible()
    },
    
    # C++ signature: void deleteSuccessorState(HMMState * state)
    deleteSuccessorState = function(state){
    
        if(!(is.R6(state) && class(state)[1] == "HMMState")){ stop("arg state wrong type") }
    
        private$py_obj$deleteSuccessorState(state)
        invisible()
    },
    
    # C++ signature: libcpp_set[HMMState *] getPredecessorStates()
    getPredecessorStates = function(){
    
        py_ans = private$py_obj$getPredecessorStates()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) HMMState$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[HMMState *] getSuccessorStates()
    getSuccessorStates = function(){
    
        py_ans = private$py_obj$getSuccessorStates()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) HMMState$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    }
)
) 

# R implementation of _HPLC
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1HPLC.html
HPLC <- R6Class(classname = "HPLC",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void HPLC()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == HPLC) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$HPLC()
        invisible()
    }
    
    },
    
    # C++ signature: String getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(String instrument)
    setInstrument = function(instrument){
    
        if(!((is.R6(instrument) && class(instrument)[1]=="String") || is_scalar_character(instrument))){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: String getColumn()
    getColumn = function(){
    
        py_ans = private$py_obj$getColumn()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setColumn(String column)
    setColumn = function(column){
    
        if(!((is.R6(column) && class(column)[1]=="String") || is_scalar_character(column))){ stop("arg column wrong type") }
    
        private$py_obj$setColumn(column)
        invisible()
    },
    
    # C++ signature: int getTemperature()
    getTemperature = function(){
    
        py_ans = private$py_obj$getTemperature()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTemperature(int temperature)
    setTemperature = function(temperature){
    
        if(!( (is_scalar_integer(temperature) || is_scalar_double(temperature)) && temperature == as.integer(temperature))){ stop("arg temperature wrong type") }
    
        private$py_obj$setTemperature(as.integer(temperature))
        invisible()
    },
    
    # C++ signature: unsigned int getPressure()
    getPressure = function(){
    
        py_ans = private$py_obj$getPressure()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPressure(unsigned int pressure)
    setPressure = function(pressure){
    
        if(!( (is_scalar_integer(pressure) || is_scalar_double(pressure)) && pressure == as.integer(pressure))){ stop("arg pressure wrong type") }
    
        private$py_obj$setPressure(as.integer(pressure))
        invisible()
    },
    
    # C++ signature: unsigned int getFlux()
    getFlux = function(){
    
        py_ans = private$py_obj$getFlux()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFlux(unsigned int flux)
    setFlux = function(flux){
    
        if(!( (is_scalar_integer(flux) || is_scalar_double(flux)) && flux == as.integer(flux))){ stop("arg flux wrong type") }
    
        private$py_obj$setFlux(as.integer(flux))
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: Gradient getGradient()
    getGradient = function(){
    
        py_ans = private$py_obj$getGradient()
        r_ans = Gradient$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setGradient(Gradient gradient)
    setGradient = function(gradient){
    
        if(!(is.R6(gradient) && class(gradient)[1] == "Gradient")){ stop("arg gradient wrong type") }
    
        private$py_obj$setGradient(gradient)
        invisible()
    }
)
) 

# R implementation of _HiddenMarkovModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1HiddenMarkovModel.html
HiddenMarkovModel <- R6Class(classname = "HiddenMarkovModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void HiddenMarkovModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$HiddenMarkovModel()
        invisible()
    
    
    },
    
    # C++ signature: void HiddenMarkovModel(HiddenMarkovModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "HiddenMarkovModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$HiddenMarkovModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void HiddenMarkovModel()
    # C++ signature: void HiddenMarkovModel(HiddenMarkovModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "HiddenMarkovModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "HiddenMarkovModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void writeGraphMLFile(const String & filename)
    writeGraphMLFile = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$writeGraphMLFile(filename)
        invisible()
    },
    
    # C++ signature: double getTransitionProbability(const String & s1, const String & s2)
    getTransitionProbability = function(s1, s2){
    
        if(!((is.R6(s1) && class(s1)[1]=="String") || is_scalar_character(s1))){ stop("arg s1 wrong type") }
        if(!((is.R6(s2) && class(s2)[1]=="String") || is_scalar_character(s2))){ stop("arg s2 wrong type") }
    
    
        py_ans = private$py_obj$getTransitionProbability(s1, s2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTransitionProbability(const String & s1, const String & s2, double prob)
    setTransitionProbability = function(s1, s2, prob){
    
        if(!((is.R6(s1) && class(s1)[1]=="String") || is_scalar_character(s1))){ stop("arg s1 wrong type") }
        if(!((is.R6(s2) && class(s2)[1]=="String") || is_scalar_character(s2))){ stop("arg s2 wrong type") }
        if(!(is_scalar_double(prob))){ stop("arg prob wrong type") }
    
    
    
        private$py_obj$setTransitionProbability(s1, s2, prob)
        invisible()
    },
    
    # C++ signature: size_t getNumberOfStates()
    getNumberOfStates = function(){
    
        py_ans = private$py_obj$getNumberOfStates()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addNewState(HMMState * state)
    addNewState_0 = function(state){
    
        if(!(is.R6(state) && class(state)[1] == "HMMState")){ stop("arg state wrong type") }
    
        private$py_obj$`_addNewState_0`(state)
        invisible()
    },
    
    # C++ signature: void addNewState(const String & name)
    addNewState_1 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$`_addNewState_1`(name)
        invisible()
    },
    
    # C++ signature: void addNewState(HMMState * state)
    # C++ signature: void addNewState(const String & name)
    addNewState = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "HMMState")) { self$addNewState_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$addNewState_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void addSynonymTransition(const String & name1, const String & name2, const String & synonym1, const String & synonym2)
    addSynonymTransition = function(name1, name2, synonym1, synonym2){
    
        if(!((is.R6(name1) && class(name1)[1]=="String") || is_scalar_character(name1))){ stop("arg name1 wrong type") }
        if(!((is.R6(name2) && class(name2)[1]=="String") || is_scalar_character(name2))){ stop("arg name2 wrong type") }
        if(!((is.R6(synonym1) && class(synonym1)[1]=="String") || is_scalar_character(synonym1))){ stop("arg synonym1 wrong type") }
        if(!((is.R6(synonym2) && class(synonym2)[1]=="String") || is_scalar_character(synonym2))){ stop("arg synonym2 wrong type") }
    
    
    
    
        private$py_obj$addSynonymTransition(name1, name2, synonym1, synonym2)
        invisible()
    },
    
    # C++ signature: void evaluate()
    evaluate = function(){
    
        private$py_obj$evaluate()
        invisible()
    },
    
    # C++ signature: void train()
    train = function(){
    
        private$py_obj$train()
        invisible()
    },
    
    # C++ signature: void setInitialTransitionProbability(const String & state, double prob)
    setInitialTransitionProbability = function(state, prob){
    
        if(!((is.R6(state) && class(state)[1]=="String") || is_scalar_character(state))){ stop("arg state wrong type") }
        if(!(is_scalar_double(prob))){ stop("arg prob wrong type") }
    
    
        private$py_obj$setInitialTransitionProbability(state, prob)
        invisible()
    },
    
    # C++ signature: void clearInitialTransitionProbabilities()
    clearInitialTransitionProbabilities = function(){
    
        private$py_obj$clearInitialTransitionProbabilities()
        invisible()
    },
    
    # C++ signature: void setTrainingEmissionProbability(const String & state, double prob)
    setTrainingEmissionProbability = function(state, prob){
    
        if(!((is.R6(state) && class(state)[1]=="String") || is_scalar_character(state))){ stop("arg state wrong type") }
        if(!(is_scalar_double(prob))){ stop("arg prob wrong type") }
    
    
        private$py_obj$setTrainingEmissionProbability(state, prob)
        invisible()
    },
    
    # C++ signature: void clearTrainingEmissionProbabilities()
    clearTrainingEmissionProbabilities = function(){
    
        private$py_obj$clearTrainingEmissionProbabilities()
        invisible()
    },
    
    # C++ signature: void enableTransition(const String & s1, const String & s2)
    enableTransition = function(s1, s2){
    
        if(!((is.R6(s1) && class(s1)[1]=="String") || is_scalar_character(s1))){ stop("arg s1 wrong type") }
        if(!((is.R6(s2) && class(s2)[1]=="String") || is_scalar_character(s2))){ stop("arg s2 wrong type") }
    
    
        private$py_obj$enableTransition(s1, s2)
        invisible()
    },
    
    # C++ signature: void disableTransition(const String & s1, const String & s2)
    disableTransition = function(s1, s2){
    
        if(!((is.R6(s1) && class(s1)[1]=="String") || is_scalar_character(s1))){ stop("arg s1 wrong type") }
        if(!((is.R6(s2) && class(s2)[1]=="String") || is_scalar_character(s2))){ stop("arg s2 wrong type") }
    
    
        private$py_obj$disableTransition(s1, s2)
        invisible()
    },
    
    # C++ signature: void disableTransitions()
    disableTransitions = function(){
    
        private$py_obj$disableTransitions()
        invisible()
    },
    
    # C++ signature: void dump()
    dump = function(){
    
        private$py_obj$dump()
        invisible()
    },
    
    # C++ signature: void forwardDump()
    forwardDump = function(){
    
        private$py_obj$forwardDump()
        invisible()
    },
    
    # C++ signature: void estimateUntrainedTransitions()
    estimateUntrainedTransitions = function(){
    
        private$py_obj$estimateUntrainedTransitions()
        invisible()
    },
    
    # C++ signature: HMMState * getState(const String & name)
    getState = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getState(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = HMMState$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void setPseudoCounts(double pseudo_counts)
    setPseudoCounts = function(pseudo_counts){
    
        if(!(is_scalar_double(pseudo_counts))){ stop("arg pseudo_counts wrong type") }
    
        private$py_obj$setPseudoCounts(pseudo_counts)
        invisible()
    },
    
    # C++ signature: double getPseudoCounts()
    getPseudoCounts = function(){
    
        py_ans = private$py_obj$getPseudoCounts()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setVariableModifications(StringList & modifications)
    setVariableModifications = function(modifications){
    
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character))){ stop("arg modifications wrong type") }
        v0 = r_to_py(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$setVariableModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(modifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _HyperScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1HyperScore.html
HyperScore <- R6Class(classname = "HyperScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void HyperScore()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == HyperScore) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$HyperScore()
        invisible()
    }
    
    },
    
    # C++ signature: double compute(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, MSSpectrum & exp_spectrum, MSSpectrum & theo_spectrum)
    compute = function(fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, exp_spectrum, theo_spectrum){
    
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(is.R6(exp_spectrum) && class(exp_spectrum)[1] == "MSSpectrum")){ stop("arg exp_spectrum wrong type") }
        if(!(is.R6(theo_spectrum) && class(theo_spectrum)[1] == "MSSpectrum")){ stop("arg theo_spectrum wrong type") }
    
    
    
    
        py_ans = private$py_obj$compute(fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), exp_spectrum, theo_spectrum)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IBSpectraFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IBSpectraFile.html
IBSpectraFile <- R6Class(classname = "IBSpectraFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IBSpectraFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IBSpectraFile()
        invisible()
    
    
    },
    
    # C++ signature: void IBSpectraFile(IBSpectraFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IBSpectraFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IBSpectraFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IBSpectraFile()
    # C++ signature: void IBSpectraFile(IBSpectraFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IBSpectraFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IBSpectraFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void store(const String & filename, ConsensusMap & cm)
    store = function(filename, cm){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(cm) && class(cm)[1] == "ConsensusMap")){ stop("arg cm wrong type") }
    
    
        private$py_obj$store(filename, cm)
        invisible()
    }
)
) 

# R implementation of _IDConflictResolverAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDConflictResolverAlgorithm.html
IDConflictResolverAlgorithm <- R6Class(classname = "IDConflictResolverAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IDConflictResolverAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IDConflictResolverAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IDConflictResolverAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: void resolve(FeatureMap & features)
    resolve_0 = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
    
        private$py_obj$`_resolve_0`(features)
        invisible()
    },
    
    # C++ signature: void resolve(ConsensusMap & features)
    resolve_1 = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "ConsensusMap")){ stop("arg features wrong type") }
    
        private$py_obj$`_resolve_1`(features)
        invisible()
    },
    
    # C++ signature: void resolve(FeatureMap & features)
    # C++ signature: void resolve(ConsensusMap & features)
    resolve = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap")) { self$resolve_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap")) { self$resolve_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void resolveBetweenFeatures(FeatureMap & features)
    resolveBetweenFeatures_0 = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
    
        private$py_obj$`_resolveBetweenFeatures_0`(features)
        invisible()
    },
    
    # C++ signature: void resolveBetweenFeatures(ConsensusMap & features)
    resolveBetweenFeatures_1 = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "ConsensusMap")){ stop("arg features wrong type") }
    
        private$py_obj$`_resolveBetweenFeatures_1`(features)
        invisible()
    },
    
    # C++ signature: void resolveBetweenFeatures(FeatureMap & features)
    # C++ signature: void resolveBetweenFeatures(ConsensusMap & features)
    resolveBetweenFeatures = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap")) { self$resolveBetweenFeatures_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap")) { self$resolveBetweenFeatures_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _IDDecoyProbability
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDDecoyProbability.html
IDDecoyProbability <- R6Class(classname = "IDDecoyProbability",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IDDecoyProbability()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IDDecoyProbability()
        invisible()
    
    
    },
    
    # C++ signature: void IDDecoyProbability(IDDecoyProbability)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IDDecoyProbability")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IDDecoyProbability(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IDDecoyProbability()
    # C++ signature: void IDDecoyProbability(IDDecoyProbability)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IDDecoyProbability")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IDDecoyProbability" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & prob_ids, libcpp_vector[PeptideIdentification] & fwd_ids, libcpp_vector[PeptideIdentification] & rev_ids)
    apply_0 = function(prob_ids, fwd_ids, rev_ids){
    
        if(!(is_list(prob_ids) && all(sapply(prob_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg prob_ids wrong type") }
        if(!(is_list(fwd_ids) && all(sapply(fwd_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg fwd_ids wrong type") }
        if(!(is_list(rev_ids) && all(sapply(rev_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg rev_ids wrong type") }
        v0 <- r_to_py(prob_ids)
        v1 <- r_to_py(fwd_ids)
        v2 <- r_to_py(rev_ids)
        private$py_obj$`_apply_0`(v0, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(prob_ids <- byref_0))
        eval.parent(substitute(fwd_ids <- byref_1))
        eval.parent(substitute(rev_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids)
    apply_1 = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$`_apply_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & prob_ids, libcpp_vector[PeptideIdentification] & fwd_ids, libcpp_vector[PeptideIdentification] & rev_ids)
    # C++ signature: void apply(libcpp_vector[PeptideIdentification] & ids)
    apply = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$apply_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$apply_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IDFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDFilter.html
IDFilter <- R6Class(classname = "IDFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IDFilter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IDFilter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IDFilter()
        invisible()
    }
    
    },
    
    # C++ signature: size_t countHits(libcpp_vector[PeptideIdentification] identifications)
    countHits_0 = function(identifications){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg identifications wrong type") }
        v0 <- r_to_py(identifications)
        py_ans = private$py_obj$`_countHits_0`(v0)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t countHits(libcpp_vector[ProteinIdentification] identifications)
    countHits_1 = function(identifications){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg identifications wrong type") }
        v0 <- r_to_py(identifications)
        py_ans = private$py_obj$`_countHits_1`(v0)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t countHits(libcpp_vector[PeptideIdentification] identifications)
    # C++ signature: size_t countHits(libcpp_vector[ProteinIdentification] identifications)
    countHits = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$countHits_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$countHits_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool getBestHit(libcpp_vector[PeptideIdentification] identifications, bool assume_sorted, PeptideHit & best_hit)
    getBestHit_0 = function(identifications, assume_sorted, best_hit){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg identifications wrong type") }
        if(!( (is_scalar_integer(assume_sorted) || is_scalar_double(assume_sorted)) && assume_sorted == as.integer(assume_sorted))){ stop("arg assume_sorted wrong type") }
        if(!(is.R6(best_hit) && class(best_hit)[1] == "PeptideHit")){ stop("arg best_hit wrong type") }
        v0 <- r_to_py(identifications)
    
    
        py_ans = private$py_obj$`_getBestHit_0`(v0, as.integer(assume_sorted), best_hit)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool getBestHit(libcpp_vector[ProteinIdentification] identifications, bool assume_sorted, ProteinHit & best_hit)
    getBestHit_1 = function(identifications, assume_sorted, best_hit){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg identifications wrong type") }
        if(!( (is_scalar_integer(assume_sorted) || is_scalar_double(assume_sorted)) && assume_sorted == as.integer(assume_sorted))){ stop("arg assume_sorted wrong type") }
        if(!(is.R6(best_hit) && class(best_hit)[1] == "ProteinHit")){ stop("arg best_hit wrong type") }
        v0 <- r_to_py(identifications)
    
    
        py_ans = private$py_obj$`_getBestHit_1`(v0, as.integer(assume_sorted), best_hit)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool getBestHit(libcpp_vector[PeptideIdentification] identifications, bool assume_sorted, PeptideHit & best_hit)
    # C++ signature: bool getBestHit(libcpp_vector[ProteinIdentification] identifications, bool assume_sorted, ProteinHit & best_hit)
    getBestHit = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "PeptideHit")) { self$getBestHit_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ProteinHit")) { self$getBestHit_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void extractPeptideSequences(libcpp_vector[PeptideIdentification] & peptides, libcpp_set[String] & sequences, bool ignore_mods)
    extractPeptideSequences = function(peptides, sequences, ignore_mods){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(sequences) && all(sapply(sequences),is_scalar_character) && !any(duplicated(sequences) == T))){ stop("arg sequences wrong type") }
        if(!( (is_scalar_integer(ignore_mods) || is_scalar_double(ignore_mods)) && ignore_mods == as.integer(ignore_mods))){ stop("arg ignore_mods wrong type") }
        v0 <- r_to_py(peptides)
        v1 = py_builtin$set(modify_depth(sequences,1,py_builtin$bytes(sequences,'utf-8')))
    
        private$py_obj$extractPeptideSequences(v0, v1, as.integer(ignore_mods))
        byref_1 <- modify_depth(py_to_r(py_builtin$list(v1)),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(sequences <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void updateHitRanks(libcpp_vector[PeptideIdentification] & identifications)
    updateHitRanks_0 = function(identifications){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg identifications wrong type") }
        v0 <- r_to_py(identifications)
        private$py_obj$`_updateHitRanks_0`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(identifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void updateHitRanks(libcpp_vector[ProteinIdentification] & identifications)
    updateHitRanks_1 = function(identifications){
    
        if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg identifications wrong type") }
        v0 <- r_to_py(identifications)
        private$py_obj$`_updateHitRanks_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(identifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void updateHitRanks(libcpp_vector[PeptideIdentification] & identifications)
    # C++ signature: void updateHitRanks(libcpp_vector[ProteinIdentification] & identifications)
    updateHitRanks = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$updateHitRanks_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$updateHitRanks_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeUnreferencedProteins(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides)
    removeUnreferencedProteins = function(proteins, peptides){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(peptides)
        private$py_obj$removeUnreferencedProteins(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void updateProteinReferences(libcpp_vector[PeptideIdentification] & peptides, libcpp_vector[ProteinIdentification] & proteins, bool remove_peptides_without_reference)
    updateProteinReferences = function(peptides, proteins, remove_peptides_without_reference){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!( (is_scalar_integer(remove_peptides_without_reference) || is_scalar_double(remove_peptides_without_reference)) && remove_peptides_without_reference == as.integer(remove_peptides_without_reference))){ stop("arg remove_peptides_without_reference wrong type") }
        v0 <- r_to_py(peptides)
        v1 <- r_to_py(proteins)
    
        private$py_obj$updateProteinReferences(v0, v1, as.integer(remove_peptides_without_reference))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(proteins <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool updateProteinGroups(libcpp_vector[ProteinGroup] & groups, libcpp_vector[ProteinHit] & hits)
    updateProteinGroups = function(groups, hits){
    
        if(!(is_list(groups) && all(sapply(groups,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinGroup")))){ stop("arg groups wrong type") }
        if(!(is_list(hits) && all(sapply(hits,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinHit")))){ stop("arg hits wrong type") }
        v0 <- r_to_py(groups)
        v1 <- r_to_py(hits)
        py_ans = private$py_obj$updateProteinGroups(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(groups <- byref_0))
        eval.parent(substitute(hits <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void removeEmptyIdentifications(libcpp_vector[PeptideIdentification] & ids)
    removeEmptyIdentifications_0 = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$`_removeEmptyIdentifications_0`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeEmptyIdentifications(libcpp_vector[ProteinIdentification] & ids)
    removeEmptyIdentifications_1 = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$`_removeEmptyIdentifications_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeEmptyIdentifications(libcpp_vector[PeptideIdentification] & ids)
    # C++ signature: void removeEmptyIdentifications(libcpp_vector[ProteinIdentification] & ids)
    removeEmptyIdentifications = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$removeEmptyIdentifications_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$removeEmptyIdentifications_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void filterHitsByScore(libcpp_vector[PeptideIdentification] & ids, double threshold_score)
    filterHitsByScore_0 = function(ids, threshold_score){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_scalar_double(threshold_score))){ stop("arg threshold_score wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$`_filterHitsByScore_0`(v0, threshold_score)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterHitsByScore(libcpp_vector[ProteinIdentification] & ids, double threshold_score)
    filterHitsByScore_1 = function(ids, threshold_score){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        if(!(is_scalar_double(threshold_score))){ stop("arg threshold_score wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$`_filterHitsByScore_1`(v0, threshold_score)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterHitsByScore(MSExperiment & experiment, double peptide_threshold_score, double protein_threshold_score)
    filterHitsByScore_2 = function(experiment, peptide_threshold_score, protein_threshold_score){
    
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!(is_scalar_double(peptide_threshold_score))){ stop("arg peptide_threshold_score wrong type") }
        if(!(is_scalar_double(protein_threshold_score))){ stop("arg protein_threshold_score wrong type") }
    
    
    
        private$py_obj$`_filterHitsByScore_2`(experiment, peptide_threshold_score, protein_threshold_score)
        invisible()
    },
    
    # C++ signature: void filterHitsByScore(libcpp_vector[PeptideIdentification] & ids, double threshold_score)
    # C++ signature: void filterHitsByScore(libcpp_vector[ProteinIdentification] & ids, double threshold_score)
    # C++ signature: void filterHitsByScore(MSExperiment & experiment, double peptide_threshold_score, double protein_threshold_score)
    filterHitsByScore = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_scalar_double(arg_list[[2]]))) { self$filterHitsByScore_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_scalar_double(arg_list[[2]]))) { self$filterHitsByScore_1(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$filterHitsByScore_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void keepNBestHits(libcpp_vector[PeptideIdentification] & ids, size_t n)
    keepNBestHits_0 = function(ids, n){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$`_keepNBestHits_0`(v0, as.integer(n))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepNBestHits(libcpp_vector[ProteinIdentification] & ids, size_t n)
    keepNBestHits_1 = function(ids, n){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
        v0 <- r_to_py(ids)
    
        private$py_obj$`_keepNBestHits_1`(v0, as.integer(n))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepNBestHits(MSExperiment & experiment, size_t n)
    keepNBestHits_2 = function(experiment, n){
    
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
    
        private$py_obj$`_keepNBestHits_2`(experiment, as.integer(n))
        invisible()
    },
    
    # C++ signature: void keepNBestHits(libcpp_vector[PeptideIdentification] & ids, size_t n)
    # C++ signature: void keepNBestHits(libcpp_vector[ProteinIdentification] & ids, size_t n)
    # C++ signature: void keepNBestHits(MSExperiment & experiment, size_t n)
    keepNBestHits = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$keepNBestHits_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$keepNBestHits_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$keepNBestHits_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void filterHitsByRank(libcpp_vector[PeptideIdentification] & ids, size_t min_rank, size_t max_rank)
    filterHitsByRank_0 = function(ids, min_rank, max_rank){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(min_rank) || is_scalar_double(min_rank)) && min_rank == as.integer(min_rank))){ stop("arg min_rank wrong type") }
        if(!( (is_scalar_integer(max_rank) || is_scalar_double(max_rank)) && max_rank == as.integer(max_rank))){ stop("arg max_rank wrong type") }
        v0 <- r_to_py(ids)
    
    
        private$py_obj$`_filterHitsByRank_0`(v0, as.integer(min_rank), as.integer(max_rank))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterHitsByRank(libcpp_vector[ProteinIdentification] & ids, size_t min_rank, size_t max_rank)
    filterHitsByRank_1 = function(ids, min_rank, max_rank){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        if(!( (is_scalar_integer(min_rank) || is_scalar_double(min_rank)) && min_rank == as.integer(min_rank))){ stop("arg min_rank wrong type") }
        if(!( (is_scalar_integer(max_rank) || is_scalar_double(max_rank)) && max_rank == as.integer(max_rank))){ stop("arg max_rank wrong type") }
        v0 <- r_to_py(ids)
    
    
        private$py_obj$`_filterHitsByRank_1`(v0, as.integer(min_rank), as.integer(max_rank))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterHitsByRank(libcpp_vector[PeptideIdentification] & ids, size_t min_rank, size_t max_rank)
    # C++ signature: void filterHitsByRank(libcpp_vector[ProteinIdentification] & ids, size_t min_rank, size_t max_rank)
    filterHitsByRank = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$filterHitsByRank_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$filterHitsByRank_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeDecoyHits(libcpp_vector[PeptideIdentification] & ids)
    removeDecoyHits_0 = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$`_removeDecoyHits_0`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeDecoyHits(libcpp_vector[ProteinIdentification] & ids)
    removeDecoyHits_1 = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$`_removeDecoyHits_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeDecoyHits(libcpp_vector[PeptideIdentification] & ids)
    # C++ signature: void removeDecoyHits(libcpp_vector[ProteinIdentification] & ids)
    removeDecoyHits = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$removeDecoyHits_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))) { self$removeDecoyHits_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeHitsMatchingProteins(libcpp_vector[PeptideIdentification] & ids, libcpp_set[String] accessions)
    removeHitsMatchingProteins_0 = function(ids, accessions){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character) && !any(duplicated(accessions) == T))){ stop("arg accessions wrong type") }
        v0 <- r_to_py(ids)
        v1 = py_builtin$set(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
        private$py_obj$`_removeHitsMatchingProteins_0`(v0, v1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeHitsMatchingProteins(libcpp_vector[ProteinIdentification] & ids, libcpp_set[String] accessions)
    removeHitsMatchingProteins_1 = function(ids, accessions){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character) && !any(duplicated(accessions) == T))){ stop("arg accessions wrong type") }
        v0 <- r_to_py(ids)
        v1 = py_builtin$set(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
        private$py_obj$`_removeHitsMatchingProteins_1`(v0, v1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeHitsMatchingProteins(libcpp_vector[PeptideIdentification] & ids, libcpp_set[String] accessions)
    # C++ signature: void removeHitsMatchingProteins(libcpp_vector[ProteinIdentification] & ids, libcpp_set[String] accessions)
    removeHitsMatchingProteins = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character) && !any(duplicated(arg_list[[2]]) == T))) { self$removeHitsMatchingProteins_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character) && !any(duplicated(arg_list[[2]]) == T))) { self$removeHitsMatchingProteins_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void keepHitsMatchingProteins(libcpp_vector[PeptideIdentification] & ids, libcpp_set[String] accessions)
    keepHitsMatchingProteins_0 = function(ids, accessions){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character) && !any(duplicated(accessions) == T))){ stop("arg accessions wrong type") }
        v0 <- r_to_py(ids)
        v1 = py_builtin$set(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
        private$py_obj$`_keepHitsMatchingProteins_0`(v0, v1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepHitsMatchingProteins(libcpp_vector[ProteinIdentification] & ids, libcpp_set[String] accessions)
    keepHitsMatchingProteins_1 = function(ids, accessions){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character) && !any(duplicated(accessions) == T))){ stop("arg accessions wrong type") }
        v0 <- r_to_py(ids)
        v1 = py_builtin$set(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
        private$py_obj$`_keepHitsMatchingProteins_1`(v0, v1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepHitsMatchingProteins(MSExperiment & experiment, libcpp_vector[FASTAEntry] & proteins)
    keepHitsMatchingProteins_2 = function(experiment, proteins){
    
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg proteins wrong type") }
    
        v1 <- r_to_py(proteins)
        private$py_obj$`_keepHitsMatchingProteins_2`(experiment, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepHitsMatchingProteins(libcpp_vector[PeptideIdentification] & ids, libcpp_set[String] accessions)
    # C++ signature: void keepHitsMatchingProteins(libcpp_vector[ProteinIdentification] & ids, libcpp_set[String] accessions)
    # C++ signature: void keepHitsMatchingProteins(MSExperiment & experiment, libcpp_vector[FASTAEntry] & proteins)
    keepHitsMatchingProteins = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character) && !any(duplicated(arg_list[[2]]) == T))) { self$keepHitsMatchingProteins_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character) && !any(duplicated(arg_list[[2]]) == T))) { self$keepHitsMatchingProteins_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))) { self$keepHitsMatchingProteins_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void keepBestPeptideHits(libcpp_vector[PeptideIdentification] & peptides, bool strict)
    keepBestPeptideHits = function(peptides, strict){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(strict) || is_scalar_double(strict)) && strict == as.integer(strict))){ stop("arg strict wrong type") }
        v0 <- r_to_py(peptides)
    
        private$py_obj$keepBestPeptideHits(v0, as.integer(strict))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByLength(libcpp_vector[PeptideIdentification] & peptides, size_t min_length, size_t max_length)
    filterPeptidesByLength = function(peptides, min_length, max_length){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(min_length) || is_scalar_double(min_length)) && min_length == as.integer(min_length))){ stop("arg min_length wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByLength(v0, as.integer(min_length), as.integer(max_length))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByCharge(libcpp_vector[PeptideIdentification] & peptides, size_t min_charge, size_t max_charge)
    filterPeptidesByCharge = function(peptides, min_charge, max_charge){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(min_charge) || is_scalar_double(min_charge)) && min_charge == as.integer(min_charge))){ stop("arg min_charge wrong type") }
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByCharge(v0, as.integer(min_charge), as.integer(max_charge))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByRT(libcpp_vector[PeptideIdentification] & peptides, size_t min_rt, size_t max_rt)
    filterPeptidesByRT = function(peptides, min_rt, max_rt){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(min_rt) || is_scalar_double(min_rt)) && min_rt == as.integer(min_rt))){ stop("arg min_rt wrong type") }
        if(!( (is_scalar_integer(max_rt) || is_scalar_double(max_rt)) && max_rt == as.integer(max_rt))){ stop("arg max_rt wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByRT(v0, as.integer(min_rt), as.integer(max_rt))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByMZ(libcpp_vector[PeptideIdentification] & peptides, size_t min_mz, size_t max_mz)
    filterPeptidesByMZ = function(peptides, min_mz, max_mz){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(min_mz) || is_scalar_double(min_mz)) && min_mz == as.integer(min_mz))){ stop("arg min_mz wrong type") }
        if(!( (is_scalar_integer(max_mz) || is_scalar_double(max_mz)) && max_mz == as.integer(max_mz))){ stop("arg max_mz wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByMZ(v0, as.integer(min_mz), as.integer(max_mz))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByMZError(libcpp_vector[PeptideIdentification] & peptides, double mass_error, bool unit_ppm)
    filterPeptidesByMZError = function(peptides, mass_error, unit_ppm){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_scalar_double(mass_error))){ stop("arg mass_error wrong type") }
        if(!( (is_scalar_integer(unit_ppm) || is_scalar_double(unit_ppm)) && unit_ppm == as.integer(unit_ppm))){ stop("arg unit_ppm wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByMZError(v0, mass_error, as.integer(unit_ppm))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void filterPeptidesByRTPredictPValue(libcpp_vector[PeptideIdentification] & peptides, const String & metavalue_key, double threshold)
    filterPeptidesByRTPredictPValue = function(peptides, metavalue_key, threshold){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!((is.R6(metavalue_key) && class(metavalue_key)[1]=="String") || is_scalar_character(metavalue_key))){ stop("arg metavalue_key wrong type") }
        if(!(is_scalar_double(threshold))){ stop("arg threshold wrong type") }
        v0 <- r_to_py(peptides)
    
    
        private$py_obj$filterPeptidesByRTPredictPValue(v0, metavalue_key, threshold)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removePeptidesWithMatchingModifications(libcpp_vector[PeptideIdentification] & peptides, libcpp_set[String] & modifications)
    removePeptidesWithMatchingModifications = function(peptides, modifications){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character) && !any(duplicated(modifications) == T))){ stop("arg modifications wrong type") }
        v0 <- r_to_py(peptides)
        v1 = py_builtin$set(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$removePeptidesWithMatchingModifications(v0, v1)
        byref_1 <- modify_depth(py_to_r(py_builtin$list(v1)),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(modifications <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepPeptidesWithMatchingModifications(libcpp_vector[PeptideIdentification] & peptides, libcpp_set[String] & modifications)
    keepPeptidesWithMatchingModifications = function(peptides, modifications){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character) && !any(duplicated(modifications) == T))){ stop("arg modifications wrong type") }
        v0 <- r_to_py(peptides)
        v1 = py_builtin$set(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$keepPeptidesWithMatchingModifications(v0, v1)
        byref_1 <- modify_depth(py_to_r(py_builtin$list(v1)),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(modifications <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removePeptidesWithMatchingSequences(libcpp_vector[PeptideIdentification] & peptides, libcpp_vector[PeptideIdentification] & bad_peptides, bool ignore_mods)
    removePeptidesWithMatchingSequences = function(peptides, bad_peptides, ignore_mods){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(bad_peptides) && all(sapply(bad_peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg bad_peptides wrong type") }
        if(!( (is_scalar_integer(ignore_mods) || is_scalar_double(ignore_mods)) && ignore_mods == as.integer(ignore_mods))){ stop("arg ignore_mods wrong type") }
        v0 <- r_to_py(peptides)
        v1 <- r_to_py(bad_peptides)
    
        private$py_obj$removePeptidesWithMatchingSequences(v0, v1, as.integer(ignore_mods))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(bad_peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepPeptidesWithMatchingSequences(libcpp_vector[PeptideIdentification] & peptides, libcpp_vector[PeptideIdentification] & bad_peptides, bool ignore_mods)
    keepPeptidesWithMatchingSequences = function(peptides, bad_peptides, ignore_mods){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is_list(bad_peptides) && all(sapply(bad_peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg bad_peptides wrong type") }
        if(!( (is_scalar_integer(ignore_mods) || is_scalar_double(ignore_mods)) && ignore_mods == as.integer(ignore_mods))){ stop("arg ignore_mods wrong type") }
        v0 <- r_to_py(peptides)
        v1 <- r_to_py(bad_peptides)
    
        private$py_obj$keepPeptidesWithMatchingSequences(v0, v1, as.integer(ignore_mods))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(bad_peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void keepUniquePeptidesPerProtein(libcpp_vector[PeptideIdentification] & peptides)
    keepUniquePeptidesPerProtein = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$keepUniquePeptidesPerProtein(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeDuplicatePeptideHits(libcpp_vector[PeptideIdentification] & peptides)
    removeDuplicatePeptideHits = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$removeDuplicatePeptideHits(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _IDMapper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDMapper.html
IDMapper <- R6Class(classname = "IDMapper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IDMapper()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IDMapper()
        invisible()
    
    
    },
    
    # C++ signature: void IDMapper(IDMapper)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IDMapper")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IDMapper(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IDMapper()
    # C++ signature: void IDMapper(IDMapper)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IDMapper")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IDMapper" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void annotate(MSExperiment & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool clear_ids, bool mapMS1)
    annotate_0 = function(map_, ids, protein_ids, clear_ids, mapMS1){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!( (is_scalar_integer(clear_ids) || is_scalar_double(clear_ids)) && clear_ids == as.integer(clear_ids))){ stop("arg clear_ids wrong type") }
        if(!( (is_scalar_integer(mapMS1) || is_scalar_double(mapMS1)) && mapMS1 == as.integer(mapMS1))){ stop("arg mapMS1 wrong type") }
    
        v1 <- r_to_py(ids)
        v2 <- r_to_py(protein_ids)
    
    
        private$py_obj$`_annotate_0`(map_, v1, v2, as.integer(clear_ids), as.integer(mapMS1))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        eval.parent(substitute(protein_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void annotate(MSExperiment & map_, FeatureMap & fmap, bool clear_ids, bool mapMS1)
    annotate_1 = function(map_, fmap, clear_ids, mapMS1){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
        if(!(is.R6(fmap) && class(fmap)[1] == "FeatureMap")){ stop("arg fmap wrong type") }
        if(!( (is_scalar_integer(clear_ids) || is_scalar_double(clear_ids)) && clear_ids == as.integer(clear_ids))){ stop("arg clear_ids wrong type") }
        if(!( (is_scalar_integer(mapMS1) || is_scalar_double(mapMS1)) && mapMS1 == as.integer(mapMS1))){ stop("arg mapMS1 wrong type") }
    
    
    
    
        private$py_obj$`_annotate_1`(map_, fmap, as.integer(clear_ids), as.integer(mapMS1))
        invisible()
    },
    
    # C++ signature: void annotate(FeatureMap & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool use_centroid_rt, bool use_centroid_mz, MSExperiment & spectra)
    annotate_2 = function(map_, ids, protein_ids, use_centroid_rt, use_centroid_mz, spectra){
    
        if(!(is.R6(map_) && class(map_)[1] == "FeatureMap")){ stop("arg map_ wrong type") }
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!( (is_scalar_integer(use_centroid_rt) || is_scalar_double(use_centroid_rt)) && use_centroid_rt == as.integer(use_centroid_rt))){ stop("arg use_centroid_rt wrong type") }
        if(!( (is_scalar_integer(use_centroid_mz) || is_scalar_double(use_centroid_mz)) && use_centroid_mz == as.integer(use_centroid_mz))){ stop("arg use_centroid_mz wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
        v1 <- r_to_py(ids)
        v2 <- r_to_py(protein_ids)
    
    
    
        private$py_obj$`_annotate_2`(map_, v1, v2, as.integer(use_centroid_rt), as.integer(use_centroid_mz), spectra)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        eval.parent(substitute(protein_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void annotate(ConsensusMap & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool measure_from_subelements, bool annotate_ids_with_subelements, MSExperiment & spectra)
    annotate_3 = function(map_, ids, protein_ids, measure_from_subelements, annotate_ids_with_subelements, spectra){
    
        if(!(is.R6(map_) && class(map_)[1] == "ConsensusMap")){ stop("arg map_ wrong type") }
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!( (is_scalar_integer(measure_from_subelements) || is_scalar_double(measure_from_subelements)) && measure_from_subelements == as.integer(measure_from_subelements))){ stop("arg measure_from_subelements wrong type") }
        if(!( (is_scalar_integer(annotate_ids_with_subelements) || is_scalar_double(annotate_ids_with_subelements)) && annotate_ids_with_subelements == as.integer(annotate_ids_with_subelements))){ stop("arg annotate_ids_with_subelements wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
        v1 <- r_to_py(ids)
        v2 <- r_to_py(protein_ids)
    
    
    
        private$py_obj$`_annotate_3`(map_, v1, v2, as.integer(measure_from_subelements), as.integer(annotate_ids_with_subelements), spectra)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        eval.parent(substitute(protein_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void annotate(MSExperiment & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool clear_ids, bool mapMS1)
    # C++ signature: void annotate(MSExperiment & map_, FeatureMap & fmap, bool clear_ids, bool mapMS1)
    # C++ signature: void annotate(FeatureMap & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool use_centroid_rt, bool use_centroid_mz, MSExperiment & spectra)
    # C++ signature: void annotate(ConsensusMap & map_, libcpp_vector[PeptideIdentification] & ids, libcpp_vector[ProteinIdentification] & protein_ids, bool measure_from_subelements, bool annotate_ids_with_subelements, MSExperiment & spectra)
    annotate = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$annotate_0(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$annotate_1(...) }
        else if ((length(arg_list)==6) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is.R6(arg_list[[6]]) && class(arg_list[[6]])[1] == "MSExperiment")) { self$annotate_2(...) }
        else if ((length(arg_list)==6) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is.R6(arg_list[[6]]) && class(arg_list[[6]])[1] == "MSExperiment")) { self$annotate_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: IDMapper_SpectraIdentificationState mapPrecursorsToIdentifications(MSExperiment spectra, libcpp_vector[PeptideIdentification] & ids, double mz_tol, double rt_tol)
    mapPrecursorsToIdentifications = function(spectra, ids, mz_tol, rt_tol){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is_scalar_double(mz_tol))){ stop("arg mz_tol wrong type") }
        if(!(is_scalar_double(rt_tol))){ stop("arg rt_tol wrong type") }
    
        v1 <- r_to_py(ids)
    
    
        py_ans = private$py_obj$mapPrecursorsToIdentifications(spectra, v1, mz_tol, rt_tol)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = IDMapper_SpectraIdentificationState$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IDMapper_SpectraIdentificationState
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDMapper_SpectraIdentificationState.html
IDMapper_SpectraIdentificationState <- R6Class(classname = "IDMapper_SpectraIdentificationState",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        no_precursors = function(no_precursors){
    
        if(!missing(no_precursors)){
            if(!(is_list(no_precursors) && all(sapply(no_precursors,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg no_precursors wrong type") }
        
            v0 <- r_to_py(no_precursors)
            private$py_obj$no_precursors <- v0
            } else {
            
                py_ans = private$py_obj$no_precursors
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        identified = function(identified){
    
        if(!missing(identified)){
            if(!(is_list(identified) && all(sapply(identified,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg identified wrong type") }
        
            v0 <- r_to_py(identified)
            private$py_obj$identified <- v0
            } else {
            
                py_ans = private$py_obj$identified
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        unidentified = function(unidentified){
    
        if(!missing(unidentified)){
            if(!(is_list(unidentified) && all(sapply(unidentified,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg unidentified wrong type") }
        
            v0 <- r_to_py(unidentified)
            private$py_obj$unidentified <- v0
            } else {
            
                py_ans = private$py_obj$unidentified
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IDMapper_SpectraIdentificationState()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IDMapper_SpectraIdentificationState) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IDMapper_SpectraIdentificationState()
        invisible()
    }
    
    }
)
) 

# R implementation of _IDRipper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IDRipper.html
IDRipper <- R6Class(classname = "IDRipper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IDRipper()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IDRipper) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IDRipper()
        invisible()
    }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ILPDCWrapper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ILPDCWrapper.html
ILPDCWrapper <- R6Class(classname = "ILPDCWrapper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ILPDCWrapper()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ILPDCWrapper) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ILPDCWrapper()
        invisible()
    }
    
    },
    
    # C++ signature: double compute(FeatureMap fm, libcpp_vector[ChargePair] & pairs, size_t verbose_level)
    compute = function(fm, pairs, verbose_level){
    
        if(!(is.R6(fm) && class(fm)[1] == "FeatureMap")){ stop("arg fm wrong type") }
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ChargePair")))){ stop("arg pairs wrong type") }
        if(!( (is_scalar_integer(verbose_level) || is_scalar_double(verbose_level)) && verbose_level == as.integer(verbose_level))){ stop("arg verbose_level wrong type") }
    
        v1 <- r_to_py(pairs)
    
        py_ans = private$py_obj$compute(fm, v1, as.integer(verbose_level))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(pairs <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _IMSAlphabet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims::IMSAlphabet_1_1IMSAlphabet.html
IMSAlphabet <- R6Class(classname = "IMSAlphabet",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IMSAlphabet()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IMSAlphabet()
        invisible()
    
    
    },
    
    # C++ signature: void IMSAlphabet(IMSAlphabet)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IMSAlphabet")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IMSAlphabet(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IMSAlphabet(libcpp_vector[IMSElement] & elements)
    init_2 = function(elements){
    
        if(!(is_list(elements) && all(sapply(elements,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IMSElement")))){ stop("arg elements wrong type") }
        v0 <- r_to_py(elements)
    
        private$py_obj <- Pymod$IMSAlphabet(v0)
        invisible()
    
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void IMSAlphabet()
    # C++ signature: void IMSAlphabet(IMSAlphabet)
    # C++ signature: void IMSAlphabet(libcpp_vector[IMSElement] & elements)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IMSAlphabet")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IMSElement")))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IMSAlphabet" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: IMSElement getElement(libcpp_string & name)
    getElement_0 = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        py_ans = private$py_obj$`_getElement_0`(name)
        r_ans = IMSElement$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IMSElement getElement(int index)
    getElement_1 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getElement_1`(as.integer(index))
        r_ans = IMSElement$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IMSElement getElement(libcpp_string & name)
    # C++ signature: IMSElement getElement(int index)
    getElement = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_scalar_character(arg_list[[1]]))) { self$getElement_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getElement_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_string getName(int index)
    getName = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getName(as.integer(index))
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMass(libcpp_string & name)
    getMass_0 = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        py_ans = private$py_obj$`_getMass_0`(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMass(int index)
    getMass_1 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getMass_1`(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMass(libcpp_string & name)
    # C++ signature: double getMass(int index)
    getMass = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_scalar_character(arg_list[[1]]))) { self$getMass_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getMass_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_vector[double] getMasses(int isotope_index)
    getMasses = function(isotope_index){
    
        if(!( (is_scalar_integer(isotope_index) || is_scalar_double(isotope_index)) && isotope_index == as.integer(isotope_index))){ stop("arg isotope_index wrong type") }
    
        py_ans = private$py_obj$getMasses(as.integer(isotope_index))
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getAverageMasses()
    getAverageMasses = function(){
    
        py_ans = private$py_obj$getAverageMasses()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: bool hasName(libcpp_string & name)
    hasName = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        py_ans = private$py_obj$hasName(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void push_back(libcpp_string & name, double value)
    push_back_0 = function(name, value){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
    
        private$py_obj$`_push_back_0`(name, value)
        invisible()
    },
    
    # C++ signature: void push_back(IMSElement & element)
    push_back_1 = function(element){
    
        if(!(is.R6(element) && class(element)[1] == "IMSElement")){ stop("arg element wrong type") }
    
        private$py_obj$`_push_back_1`(element)
        invisible()
    },
    
    # C++ signature: void push_back(libcpp_string & name, double value)
    # C++ signature: void push_back(IMSElement & element)
    push_back = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_scalar_character(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$push_back_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IMSElement")) { self$push_back_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void sortByNames()
    sortByNames = function(){
    
        private$py_obj$sortByNames()
        invisible()
    },
    
    # C++ signature: void sortByValues()
    sortByValues = function(){
    
        private$py_obj$sortByValues()
        invisible()
    },
    
    # C++ signature: void load(String & fname)
    load = function(fname){
    
        if(!((is.R6(fname) && class(fname)[1]=="String") || is_scalar_character(fname))){ stop("arg fname wrong type") }
    
        private$py_obj$load(fname)
        invisible()
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setElement(libcpp_string & name, double mass, bool forced)
    setElement = function(name, mass, forced){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!( (is_scalar_integer(forced) || is_scalar_double(forced)) && forced == as.integer(forced))){ stop("arg forced wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
    
    
        private$py_obj$setElement(name, mass, as.integer(forced))
        invisible()
    },
    
    # C++ signature: bool erase(libcpp_string & name)
    erase = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        py_ans = private$py_obj$erase(name)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IMSElement
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims::IMSElement_1_1IMSElement.html
IMSElement <- R6Class(classname = "IMSElement",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IMSElement()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IMSElement()
        invisible()
    
    
    },
    
    # C++ signature: void IMSElement(IMSElement)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IMSElement")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IMSElement(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IMSElement(libcpp_string & name, IMSIsotopeDistribution & isotopes)
    init_2 = function(name, isotopes){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(isotopes) && class(isotopes)[1] == "IMSIsotopeDistribution")){ stop("arg isotopes wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
    
    
        private$py_obj <- Pymod$IMSElement(name, isotopes)
        invisible()
    
    
    },
    
    # C++ signature: void IMSElement(libcpp_string & name, double mass)
    init_3 = function(name, mass){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
    
    
        private$py_obj <- Pymod$IMSElement(name, mass)
        invisible()
    
    
    },
    
    # C++ signature: void IMSElement(libcpp_string & name, unsigned int nominal_mass)
    init_4 = function(name, nominal_mass){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
        if(!( (is_scalar_integer(nominal_mass) || is_scalar_double(nominal_mass)) && nominal_mass == as.integer(nominal_mass))){ stop("arg nominal_mass wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
    
    
        private$py_obj <- Pymod$IMSElement(name, as.integer(nominal_mass))
        invisible()
    
    
    },
    
    # C++ signature: void IMSElement()
    # C++ signature: void IMSElement(IMSElement)
    # C++ signature: void IMSElement(libcpp_string & name, IMSIsotopeDistribution & isotopes)
    # C++ signature: void IMSElement(libcpp_string & name, double mass)
    # C++ signature: void IMSElement(libcpp_string & name, unsigned int nominal_mass)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IMSElement")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "IMSIsotopeDistribution")) { self$init_2(...) }
        else if ((length(arg_list)==2) && (is_scalar_character(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$init_3(...) }
        else if ((length(arg_list)==2) && (is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IMSElement" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_string getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(libcpp_string & name)
    setName = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: libcpp_string getSequence()
    getSequence = function(){
    
        py_ans = private$py_obj$getSequence()
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSequence(libcpp_string & sequence)
    setSequence = function(sequence){
    
        if(!(is_scalar_character(sequence))){ stop("arg sequence wrong type") }
    sequence_0 = py_builtin$bytes(sequence,'utf-8')
        private$py_obj$setSequence(sequence)
        invisible()
    },
    
    # C++ signature: unsigned int getNominalMass()
    getNominalMass = function(){
    
        py_ans = private$py_obj$getNominalMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMass(int index)
    getMass = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getMass(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageMass()
    getAverageMass = function(){
    
        py_ans = private$py_obj$getAverageMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getIonMass(int electrons_number)
    getIonMass = function(electrons_number){
    
        if(!( (is_scalar_integer(electrons_number) || is_scalar_double(electrons_number)) && electrons_number == as.integer(electrons_number))){ stop("arg electrons_number wrong type") }
    
        py_ans = private$py_obj$getIonMass(as.integer(electrons_number))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: IMSIsotopeDistribution getIsotopeDistribution()
    getIsotopeDistribution = function(){
    
        py_ans = private$py_obj$getIsotopeDistribution()
        r_ans = IMSIsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setIsotopeDistribution(IMSIsotopeDistribution & isotopes)
    setIsotopeDistribution = function(isotopes){
    
        if(!(is.R6(isotopes) && class(isotopes)[1] == "IMSIsotopeDistribution")){ stop("arg isotopes wrong type") }
    
        private$py_obj$setIsotopeDistribution(isotopes)
        invisible()
    }
)
) 

# R implementation of _IMSIsotopeDistribution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims::IMSIsotopeDistribution_1_1IMSIsotopeDistribution.html
IMSIsotopeDistribution <- R6Class(classname = "IMSIsotopeDistribution",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        ABUNDANCES_SUM_ERROR = function(ABUNDANCES_SUM_ERROR){
    
        if(!missing(ABUNDANCES_SUM_ERROR)){
            if(!(is_scalar_double(ABUNDANCES_SUM_ERROR))){ stop("arg ABUNDANCES_SUM_ERROR wrong type") }
        
        
            private$py_obj$ABUNDANCES_SUM_ERROR <- ABUNDANCES_SUM_ERROR
            } else {
        
                py_ans = private$py_obj$ABUNDANCES_SUM_ERROR
                r_result = py_ans
                return(r_result)
                }
        },
        SIZE = function(SIZE){
    
        if(!missing(SIZE)){
            if(!( (is_scalar_integer(SIZE) || is_scalar_double(SIZE)) && SIZE == as.integer(SIZE))){ stop("arg SIZE wrong type") }
        
        
            private$py_obj$SIZE <- as.integer(SIZE)
            } else {
        
                py_ans = private$py_obj$SIZE
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IMSIsotopeDistribution()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution()
        invisible()
    
    
    },
    
    # C++ signature: void IMSIsotopeDistribution(IMSIsotopeDistribution)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IMSIsotopeDistribution")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IMSIsotopeDistribution(unsigned int nominalMass)
    init_2 = function(nominalMass){
    
        if(!( (is_scalar_integer(nominalMass) || is_scalar_double(nominalMass)) && nominalMass == as.integer(nominalMass))){ stop("arg nominalMass wrong type") }
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution(as.integer(nominalMass))
        invisible()
    
    
    },
    
    # C++ signature: void IMSIsotopeDistribution(double mass)
    init_3 = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution(mass)
        invisible()
    
    
    },
    
    # C++ signature: void IMSIsotopeDistribution(libcpp_vector[IMSIsotopeDistribution_Peak] & peaks, unsigned int nominalMass)
    init_4 = function(peaks, nominalMass){
    
        if(!(is_list(peaks) && all(sapply(peaks,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IMSIsotopeDistribution_Peak")))){ stop("arg peaks wrong type") }
        if(!( (is_scalar_integer(nominalMass) || is_scalar_double(nominalMass)) && nominalMass == as.integer(nominalMass))){ stop("arg nominalMass wrong type") }
        v0 <- r_to_py(peaks)
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution(v0, as.integer(nominalMass))
        invisible()
    
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void IMSIsotopeDistribution()
    # C++ signature: void IMSIsotopeDistribution(IMSIsotopeDistribution)
    # C++ signature: void IMSIsotopeDistribution(unsigned int nominalMass)
    # C++ signature: void IMSIsotopeDistribution(double mass)
    # C++ signature: void IMSIsotopeDistribution(libcpp_vector[IMSIsotopeDistribution_Peak] & peaks, unsigned int nominalMass)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IMSIsotopeDistribution")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_2(...) }
        else if ((length(arg_list)==1) && (is_scalar_double(arg_list[[1]]))) { self$init_3(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IMSIsotopeDistribution_Peak"))) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IMSIsotopeDistribution" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMass(int i)
    getMass = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getMass(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAbundance(int i)
    getAbundance = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getAbundance(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageMass()
    getAverageMass = function(){
    
        py_ans = private$py_obj$getAverageMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNominalMass()
    getNominalMass = function(){
    
        py_ans = private$py_obj$getNominalMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNominalMass(unsigned int nominalMass)
    setNominalMass = function(nominalMass){
    
        if(!( (is_scalar_integer(nominalMass) || is_scalar_double(nominalMass)) && nominalMass == as.integer(nominalMass))){ stop("arg nominalMass wrong type") }
    
        private$py_obj$setNominalMass(as.integer(nominalMass))
        invisible()
    },
    
    # C++ signature: libcpp_vector[double] getMasses()
    getMasses = function(){
    
        py_ans = private$py_obj$getMasses()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getAbundances()
    getAbundances = function(){
    
        py_ans = private$py_obj$getAbundances()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void normalize()
    normalize = function(){
    
        private$py_obj$normalize()
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IMSIsotopeDistribution_Peak
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims::IMSIsotopeDistribution_1_1IMSIsotopeDistribution_Peak.html
IMSIsotopeDistribution_Peak <- R6Class(classname = "IMSIsotopeDistribution_Peak",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mass = function(mass){
    
        if(!missing(mass)){
            if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        
        
            private$py_obj$mass <- mass
            } else {
        
                py_ans = private$py_obj$mass
                r_result = py_ans
                return(r_result)
                }
        },
        abundance = function(abundance){
    
        if(!missing(abundance)){
            if(!(is_scalar_double(abundance))){ stop("arg abundance wrong type") }
        
        
            private$py_obj$abundance <- abundance
            } else {
        
                py_ans = private$py_obj$abundance
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IMSIsotopeDistribution_Peak(double mass, double abundance)
    initialize = function(mass, abundance){
    
    if(missing(abundance)){
         if( "python.builtin.object" %in% class(mass) && class_to_wrap(mass) == IMSIsotopeDistribution_Peak ) { private$py_obj <- mass }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(abundance))){ stop("arg abundance wrong type") }
    
    
    
        private$py_obj <- Pymod$IMSIsotopeDistribution_Peak(mass, abundance)
        invisible()
    }
    
    }
)
) 

# R implementation of _IMSWeights
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims::Weights_1_1IMSWeights.html
IMSWeights <- R6Class(classname = "IMSWeights",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IMSWeights()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IMSWeights()
        invisible()
    
    
    },
    
    # C++ signature: void IMSWeights(IMSWeights)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IMSWeights")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IMSWeights(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IMSWeights()
    # C++ signature: void IMSWeights(IMSWeights)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IMSWeights")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IMSWeights" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned long int getWeight(int i)
    getWeight = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getWeight(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecision(double precision)
    setPrecision = function(precision){
    
        if(!(is_scalar_double(precision))){ stop("arg precision wrong type") }
    
        private$py_obj$setPrecision(precision)
        invisible()
    },
    
    # C++ signature: double getPrecision()
    getPrecision = function(){
    
        py_ans = private$py_obj$getPrecision()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned long int back()
    back = function(){
    
        py_ans = private$py_obj$back()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAlphabetMass(int i)
    getAlphabetMass = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getAlphabetMass(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getParentMass(libcpp_vector[unsigned int] & decomposition)
    getParentMass = function(decomposition){
    
        if(!(is_list(decomposition) && all(sapply(decomposition,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg decomposition wrong type") }
        v0 <- r_to_py(modify_depth(decomposition,1,as.integer))
        py_ans = private$py_obj$getParentMass(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(decomposition <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void swap(int index1, int index2)
    swap = function(index1, index2){
    
        if(!( (is_scalar_integer(index1) || is_scalar_double(index1)) && index1 == as.integer(index1))){ stop("arg index1 wrong type") }
        if(!( (is_scalar_integer(index2) || is_scalar_double(index2)) && index2 == as.integer(index2))){ stop("arg index2 wrong type") }
    
    
        private$py_obj$swap(as.integer(index1), as.integer(index2))
        invisible()
    },
    
    # C++ signature: bool divideByGCD()
    divideByGCD = function(){
    
        py_ans = private$py_obj$divideByGCD()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMinRoundingError()
    getMinRoundingError = function(){
    
        py_ans = private$py_obj$getMinRoundingError()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxRoundingError()
    getMaxRoundingError = function(){
    
        py_ans = private$py_obj$getMaxRoundingError()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ISDGroup
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ISDGroup.html
ISDGroup <- R6Class(classname = "ISDGroup",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ISDGroup()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ISDGroup) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ISDGroup()
        invisible()
    }
    
    }
)
) 

# R implementation of _IdXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IdXMLFile.html
IdXMLFile <- R6Class(classname = "IdXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IdXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IdXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IdXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    load = function(filename, protein_ids, peptide_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
        private$py_obj$load(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String document_id)
    store_0 = function(filename, protein_ids, peptide_ids, document_id){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!((is.R6(document_id) && class(document_id)[1]=="String") || is_scalar_character(document_id))){ stop("arg document_id wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
    
        private$py_obj$`_store_0`(filename, v1, v2, document_id)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    store_1 = function(filename, protein_ids, peptide_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
        private$py_obj$`_store_1`(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String document_id)
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    store = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$store_0(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$store_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _Identification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Identification.html
Identification <- R6Class(classname = "Identification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Identification()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Identification) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Identification()
        invisible()
    }
    
    },
    
    # C++ signature: void setCreationDate(DateTime date)
    setCreationDate = function(date){
    
        if(!(is.R6(date) && class(date)[1] == "DateTime")){ stop("arg date wrong type") }
    
        private$py_obj$setCreationDate(date)
        invisible()
    },
    
    # C++ signature: DateTime getCreationDate()
    getCreationDate = function(){
    
        py_ans = private$py_obj$getCreationDate()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSpectrumIdentifications(libcpp_vector[SpectrumIdentification] & ids)
    setSpectrumIdentifications = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SpectrumIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$setSpectrumIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addSpectrumIdentification(SpectrumIdentification & id)
    addSpectrumIdentification = function(id){
    
        if(!(is.R6(id) && class(id)[1] == "SpectrumIdentification")){ stop("arg id wrong type") }
    
        private$py_obj$addSpectrumIdentification(id)
        invisible()
    },
    
    # C++ signature: libcpp_vector[SpectrumIdentification] getSpectrumIdentifications()
    getSpectrumIdentifications = function(){
    
        py_ans = private$py_obj$getSpectrumIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IdentificationData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IdentificationData.html
IdentificationData <- R6Class(classname = "IdentificationData",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IdentificationData()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IdentificationData) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IdentificationData()
        invisible()
    }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IdentificationDataConverter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IdentificationDataConverter.html
IdentificationDataConverter <- R6Class(classname = "IdentificationDataConverter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IdentificationDataConverter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IdentificationDataConverter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IdentificationDataConverter()
        invisible()
    }
    
    },
    
    # C++ signature: void importIDs(IdentificationData & id_data, const libcpp_vector[ProteinIdentification] & proteins, const libcpp_vector[PeptideIdentification] & peptides)
    importIDs = function(id_data, proteins, peptides){
    
        if(!(is.R6(id_data) && class(id_data)[1] == "IdentificationData")){ stop("arg id_data wrong type") }
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
    
        v1 <- r_to_py(proteins)
        v2 <- r_to_py(peptides)
        private$py_obj$importIDs(id_data, v1, v2)
        
        
        invisible()
    },
    
    # C++ signature: void exportIDs(const IdentificationData & id_data, libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides, bool export_oligonucleotides)
    exportIDs = function(id_data, proteins, peptides, export_oligonucleotides){
    
        if(!(is.R6(id_data) && class(id_data)[1] == "IdentificationData")){ stop("arg id_data wrong type") }
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!( (is_scalar_integer(export_oligonucleotides) || is_scalar_double(export_oligonucleotides)) && export_oligonucleotides == as.integer(export_oligonucleotides))){ stop("arg export_oligonucleotides wrong type") }
    
        v1 <- r_to_py(proteins)
        v2 <- r_to_py(peptides)
    
        private$py_obj$exportIDs(id_data, v1, v2, as.integer(export_oligonucleotides))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_1))
        eval.parent(substitute(peptides <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: MzTab exportMzTab(const IdentificationData & id_data)
    exportMzTab = function(id_data){
    
        if(!(is.R6(id_data) && class(id_data)[1] == "IdentificationData")){ stop("arg id_data wrong type") }
    
        py_ans = private$py_obj$exportMzTab(id_data)
        r_ans = MzTab$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _IdentificationHit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IdentificationHit.html
IdentificationHit <- R6Class(classname = "IdentificationHit",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IdentificationHit()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IdentificationHit) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IdentificationHit()
        invisible()
    }
    
    },
    
    # C++ signature: void setId(String id)
    setId = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setId(id)
        invisible()
    },
    
    # C++ signature: String getId()
    getId = function(){
    
        py_ans = private$py_obj$getId()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCalculatedMassToCharge(double mz)
    setCalculatedMassToCharge = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        private$py_obj$setCalculatedMassToCharge(mz)
        invisible()
    },
    
    # C++ signature: double getCalculatedMassToCharge()
    getCalculatedMassToCharge = function(){
    
        py_ans = private$py_obj$getCalculatedMassToCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setExperimentalMassToCharge(double mz)
    setExperimentalMassToCharge = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        private$py_obj$setExperimentalMassToCharge(mz)
        invisible()
    },
    
    # C++ signature: double getExperimentalMassToCharge()
    getExperimentalMassToCharge = function(){
    
        py_ans = private$py_obj$getExperimentalMassToCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPassThreshold(bool)
    setPassThreshold = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPassThreshold(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getPassThreshold()
    getPassThreshold = function(){
    
        py_ans = private$py_obj$getPassThreshold()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRank(int rank)
    setRank = function(rank){
    
        if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
    
        private$py_obj$setRank(as.integer(rank))
        invisible()
    },
    
    # C++ signature: int getRank()
    getRank = function(){
    
        py_ans = private$py_obj$getRank()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IncludeExcludeTarget
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IncludeExcludeTarget.html
IncludeExcludeTarget <- R6Class(classname = "IncludeExcludeTarget",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IncludeExcludeTarget()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IncludeExcludeTarget()
        invisible()
    
    
    },
    
    # C++ signature: void IncludeExcludeTarget(IncludeExcludeTarget)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IncludeExcludeTarget")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IncludeExcludeTarget(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IncludeExcludeTarget()
    # C++ signature: void IncludeExcludeTarget(IncludeExcludeTarget)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IncludeExcludeTarget")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IncludeExcludeTarget" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setName(const String & name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPeptideRef(const String & peptide_ref)
    setPeptideRef = function(peptide_ref){
    
        if(!((is.R6(peptide_ref) && class(peptide_ref)[1]=="String") || is_scalar_character(peptide_ref))){ stop("arg peptide_ref wrong type") }
    
        private$py_obj$setPeptideRef(peptide_ref)
        invisible()
    },
    
    # C++ signature: String getPeptideRef()
    getPeptideRef = function(){
    
        py_ans = private$py_obj$getPeptideRef()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCompoundRef(const String & compound_ref)
    setCompoundRef = function(compound_ref){
    
        if(!((is.R6(compound_ref) && class(compound_ref)[1]=="String") || is_scalar_character(compound_ref))){ stop("arg compound_ref wrong type") }
    
        private$py_obj$setCompoundRef(compound_ref)
        invisible()
    },
    
    # C++ signature: String getCompoundRef()
    getCompoundRef = function(){
    
        py_ans = private$py_obj$getCompoundRef()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMZ(double mz)
    setPrecursorMZ = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        private$py_obj$setPrecursorMZ(mz)
        invisible()
    },
    
    # C++ signature: double getPrecursorMZ()
    getPrecursorMZ = function(){
    
        py_ans = private$py_obj$getPrecursorMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorCVTermList(CVTermList & list_)
    setPrecursorCVTermList = function(list_){
    
        if(!(is.R6(list_) && class(list_)[1] == "CVTermList")){ stop("arg list_ wrong type") }
    
        private$py_obj$setPrecursorCVTermList(list_)
        invisible()
    },
    
    # C++ signature: void addPrecursorCVTerm(CVTerm & cv_term)
    addPrecursorCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$addPrecursorCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: CVTermList getPrecursorCVTermList()
    getPrecursorCVTermList = function(){
    
        py_ans = private$py_obj$getPrecursorCVTermList()
        r_ans = CVTermList$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setProductMZ(double mz)
    setProductMZ = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        private$py_obj$setProductMZ(mz)
        invisible()
    },
    
    # C++ signature: double getProductMZ()
    getProductMZ = function(){
    
        py_ans = private$py_obj$getProductMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setProductCVTermList(CVTermList & list_)
    setProductCVTermList = function(list_){
    
        if(!(is.R6(list_) && class(list_)[1] == "CVTermList")){ stop("arg list_ wrong type") }
    
        private$py_obj$setProductCVTermList(list_)
        invisible()
    },
    
    # C++ signature: void addProductCVTerm(CVTerm & cv_term)
    addProductCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$addProductCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: CVTermList getProductCVTermList()
    getProductCVTermList = function(){
    
        py_ans = private$py_obj$getProductCVTermList()
        r_ans = CVTermList$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInterpretations(libcpp_vector[CVTermList] & interpretations)
    setInterpretations = function(interpretations){
    
        if(!(is_list(interpretations) && all(sapply(interpretations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTermList")))){ stop("arg interpretations wrong type") }
        v0 <- r_to_py(interpretations)
        private$py_obj$setInterpretations(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(interpretations <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[CVTermList] getInterpretations()
    getInterpretations = function(){
    
        py_ans = private$py_obj$getInterpretations()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addInterpretation(CVTermList & interpretation)
    addInterpretation = function(interpretation){
    
        if(!(is.R6(interpretation) && class(interpretation)[1] == "CVTermList")){ stop("arg interpretation wrong type") }
    
        private$py_obj$addInterpretation(interpretation)
        invisible()
    },
    
    # C++ signature: void setConfigurations(libcpp_vector[Configuration] & configuration)
    setConfigurations = function(configuration){
    
        if(!(is_list(configuration) && all(sapply(configuration,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Configuration")))){ stop("arg configuration wrong type") }
        v0 <- r_to_py(configuration)
        private$py_obj$setConfigurations(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(configuration <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[Configuration] getConfigurations()
    getConfigurations = function(){
    
        py_ans = private$py_obj$getConfigurations()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addConfiguration(Configuration & configuration)
    addConfiguration = function(configuration){
    
        if(!(is.R6(configuration) && class(configuration)[1] == "Configuration")){ stop("arg configuration wrong type") }
    
        private$py_obj$addConfiguration(configuration)
        invisible()
    },
    
    # C++ signature: void setPrediction(CVTermList & prediction)
    setPrediction = function(prediction){
    
        if(!(is.R6(prediction) && class(prediction)[1] == "CVTermList")){ stop("arg prediction wrong type") }
    
        private$py_obj$setPrediction(prediction)
        invisible()
    },
    
    # C++ signature: void addPredictionTerm(CVTerm & prediction)
    addPredictionTerm = function(prediction){
    
        if(!(is.R6(prediction) && class(prediction)[1] == "CVTerm")){ stop("arg prediction wrong type") }
    
        private$py_obj$addPredictionTerm(prediction)
        invisible()
    },
    
    # C++ signature: CVTermList getPrediction()
    getPrediction = function(){
    
        py_ans = private$py_obj$getPrediction()
        r_ans = CVTermList$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setRetentionTime(RetentionTime rt)
    setRetentionTime = function(rt){
    
        if(!(is.R6(rt) && class(rt)[1] == "RetentionTime")){ stop("arg rt wrong type") }
    
        private$py_obj$setRetentionTime(rt)
        invisible()
    },
    
    # C++ signature: RetentionTime getRetentionTime()
    getRetentionTime = function(){
    
        py_ans = private$py_obj$getRetentionTime()
        r_ans = RetentionTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms_0 = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$`_replaceCVTerms_0`(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms_1 = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$`_replaceCVTerms_1`(map_0)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$replaceCVTerms_0(...) }
        else if ((length(arg_list)==1) && (
          is.environment(arg_list[[1]]) && identical(parent.env(arg_list[[1]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[1]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[1]]$keys(),is_scalar_character))
          && all(sapply(arg_list[[1]]$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )) { self$replaceCVTerms_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _InclusionExclusionList
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InclusionExclusionList.html
InclusionExclusionList <- R6Class(classname = "InclusionExclusionList",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InclusionExclusionList()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == InclusionExclusionList) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$InclusionExclusionList()
        invisible()
    }
    
    },
    
    # C++ signature: void writeTargets(libcpp_vector[FASTAEntry] & fasta_entries, const String & out_path, IntList & charges, const String rt_model_path)
    writeTargets_0 = function(fasta_entries, out_path, charges, rt_model_path){
    
        if(!(is_list(fasta_entries) && all(sapply(fasta_entries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg fasta_entries wrong type") }
        if(!((is.R6(out_path) && class(out_path)[1]=="String") || is_scalar_character(out_path))){ stop("arg out_path wrong type") }
        if(!(is_list(charges) && all(sapply(charges), function(inner) inner == as.integer(inner)))){ stop("arg charges wrong type") }
        if(!((is.R6(rt_model_path) && class(rt_model_path)[1]=="String") || is_scalar_character(rt_model_path))){ stop("arg rt_model_path wrong type") }
        v0 <- r_to_py(fasta_entries)
    
        v2 = r_to_py(charges)
    
        private$py_obj$`_writeTargets_0`(v0, out_path, v2, rt_model_path)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(fasta_entries <- byref_0))
        eval.parent(substitute(charges <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void writeTargets(FeatureMap & map_, const String & out_path)
    writeTargets_1 = function(map_, out_path){
    
        if(!(is.R6(map_) && class(map_)[1] == "FeatureMap")){ stop("arg map_ wrong type") }
        if(!((is.R6(out_path) && class(out_path)[1]=="String") || is_scalar_character(out_path))){ stop("arg out_path wrong type") }
    
    
        private$py_obj$`_writeTargets_1`(map_, out_path)
        invisible()
    },
    
    # C++ signature: void writeTargets(libcpp_vector[PeptideIdentification] & pep_ids, const String & out_path, IntList & charges)
    writeTargets_2 = function(pep_ids, out_path, charges){
    
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
        if(!((is.R6(out_path) && class(out_path)[1]=="String") || is_scalar_character(out_path))){ stop("arg out_path wrong type") }
        if(!(is_list(charges) && all(sapply(charges), function(inner) inner == as.integer(inner)))){ stop("arg charges wrong type") }
        v0 <- r_to_py(pep_ids)
    
        v2 = r_to_py(charges)
        private$py_obj$`_writeTargets_2`(v0, out_path, v2)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(pep_ids <- byref_0))
        eval.parent(substitute(charges <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void writeTargets(libcpp_vector[FASTAEntry] & fasta_entries, const String & out_path, IntList & charges, const String rt_model_path)
    # C++ signature: void writeTargets(FeatureMap & map_, const String & out_path)
    # C++ signature: void writeTargets(libcpp_vector[PeptideIdentification] & pep_ids, const String & out_path, IntList & charges)
    writeTargets = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]]), function(inner) inner == as.integer(inner))) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$writeTargets_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$writeTargets_1(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]]), function(inner) inner == as.integer(inner)))) { self$writeTargets_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IndexTriple
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IndexTriple.html
IndexTriple <- R6Class(classname = "IndexTriple",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        feature = function(feature){
    
        if(!missing(feature)){
            if(!( (is_scalar_integer(feature) || is_scalar_double(feature)) && feature == as.integer(feature))){ stop("arg feature wrong type") }
        
        
            private$py_obj$feature <- as.integer(feature)
            } else {
        
                py_ans = private$py_obj$feature
                r_result = py_ans
                return(r_result)
                }
        },
        scan = function(scan){
    
        if(!missing(scan)){
            if(!( (is_scalar_integer(scan) || is_scalar_double(scan)) && scan == as.integer(scan))){ stop("arg scan wrong type") }
        
        
            private$py_obj$scan <- as.integer(scan)
            } else {
        
                py_ans = private$py_obj$scan
                r_result = py_ans
                return(r_result)
                }
        },
        variable = function(variable){
    
        if(!missing(variable)){
            if(!( (is_scalar_integer(variable) || is_scalar_double(variable)) && variable == as.integer(variable))){ stop("arg variable wrong type") }
        
        
            private$py_obj$variable <- as.integer(variable)
            } else {
        
                py_ans = private$py_obj$variable
                r_result = py_ans
                return(r_result)
                }
        },
        rt_probability = function(rt_probability){
    
        if(!missing(rt_probability)){
            if(!(is_scalar_double(rt_probability))){ stop("arg rt_probability wrong type") }
        
        
            private$py_obj$rt_probability <- rt_probability
            } else {
        
                py_ans = private$py_obj$rt_probability
                r_result = py_ans
                return(r_result)
                }
        },
        signal_weight = function(signal_weight){
    
        if(!missing(signal_weight)){
            if(!(is_scalar_double(signal_weight))){ stop("arg signal_weight wrong type") }
        
        
            private$py_obj$signal_weight <- signal_weight
            } else {
        
                py_ans = private$py_obj$signal_weight
                r_result = py_ans
                return(r_result)
                }
        },
        prot_acc = function(prot_acc){
    
        if(!missing(prot_acc)){
            if(!((is.R6(prot_acc) && class(prot_acc)[1]=="String") || is_scalar_character(prot_acc))){ stop("arg prot_acc wrong type") }
        
        
            private$py_obj$prot_acc <- prot_acc
            } else {
        
                py_ans = private$py_obj$prot_acc
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IndexTriple()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IndexTriple) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IndexTriple()
        invisible()
    }
    
    }
)
) 

# R implementation of _IndexedMzMLDecoder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IndexedMzMLDecoder.html
IndexedMzMLDecoder <- R6Class(classname = "IndexedMzMLDecoder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IndexedMzMLDecoder()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IndexedMzMLDecoder()
        invisible()
    
    
    },
    
    # C++ signature: void IndexedMzMLDecoder(IndexedMzMLDecoder)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IndexedMzMLDecoder")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IndexedMzMLDecoder(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IndexedMzMLDecoder()
    # C++ signature: void IndexedMzMLDecoder(IndexedMzMLDecoder)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IndexedMzMLDecoder")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IndexedMzMLDecoder" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: streampos findIndexListOffset(String in_, int buffersize)
    findIndexListOffset = function(in_, buffersize){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!( (is_scalar_integer(buffersize) || is_scalar_double(buffersize)) && buffersize == as.integer(buffersize))){ stop("arg buffersize wrong type") }
    
    
        py_ans = private$py_obj$findIndexListOffset(in_, as.integer(buffersize))
        r_ans = streampos$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _IndexedMzMLFileLoader
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IndexedMzMLFileLoader.html
IndexedMzMLFileLoader <- R6Class(classname = "IndexedMzMLFileLoader",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IndexedMzMLFileLoader()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IndexedMzMLFileLoader) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IndexedMzMLFileLoader()
        invisible()
    }
    
    },
    
    # C++ signature: bool load(String, OnDiscMSExperiment &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "OnDiscMSExperiment")){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$load(in_0, in_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void store(String, OnDiscMSExperiment &)
    store_0 = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "OnDiscMSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_store_0`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, MSExperiment &)
    store_1 = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_store_1`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, OnDiscMSExperiment &)
    # C++ signature: void store(String, MSExperiment &)
    store = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "OnDiscMSExperiment")) { self$store_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment")) { self$store_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    }
)
) 

# R implementation of _IndexedMzMLHandler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IndexedMzMLHandler.html
IndexedMzMLHandler <- R6Class(classname = "IndexedMzMLHandler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IndexedMzMLHandler()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IndexedMzMLHandler()
        invisible()
    
    
    },
    
    # C++ signature: void IndexedMzMLHandler(IndexedMzMLHandler)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IndexedMzMLHandler")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IndexedMzMLHandler(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IndexedMzMLHandler(String filename)
    init_2 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$IndexedMzMLHandler(filename)
        invisible()
    
    
    },
    
    # C++ signature: void IndexedMzMLHandler()
    # C++ signature: void IndexedMzMLHandler(IndexedMzMLHandler)
    # C++ signature: void IndexedMzMLHandler(String filename)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IndexedMzMLHandler")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IndexedMzMLHandler" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void openFile(String filename)
    openFile = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$openFile(filename)
        invisible()
    },
    
    # C++ signature: bool getParsingSuccess()
    getParsingSuccess = function(){
    
        py_ans = private$py_obj$getParsingSuccess()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[_Interfaces_Spectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = Spectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[_Interfaces_Chromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = Chromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum getMSSpectrumById(int id_)
    getMSSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getMSSpectrumById(as.integer(id_))
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getMSSpectrumByNativeId(libcpp_string id_, MSSpectrum & spec)
    getMSSpectrumByNativeId = function(id_, spec){
    
        if(!(is_scalar_character(id_))){ stop("arg id_ wrong type") }
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    id__0 = py_builtin$bytes(id_,'utf-8')
    
        private$py_obj$getMSSpectrumByNativeId(id_, spec)
        invisible()
    },
    
    # C++ signature: MSChromatogram getMSChromatogramById(int id_)
    getMSChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getMSChromatogramById(as.integer(id_))
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getMSChromatogramByNativeId(libcpp_string id_, MSChromatogram & chrom)
    getMSChromatogramByNativeId = function(id_, chrom){
    
        if(!(is_scalar_character(id_))){ stop("arg id_ wrong type") }
        if(!(is.R6(chrom) && class(chrom)[1] == "MSChromatogram")){ stop("arg chrom wrong type") }
    id__0 = py_builtin$bytes(id_,'utf-8')
    
        private$py_obj$getMSChromatogramByNativeId(id_, chrom)
        invisible()
    },
    
    # C++ signature: void setSkipXMLChecks(bool skip)
    setSkipXMLChecks = function(skip){
    
        if(!( (is_scalar_integer(skip) || is_scalar_double(skip)) && skip == as.integer(skip))){ stop("arg skip wrong type") }
    
        private$py_obj$setSkipXMLChecks(as.integer(skip))
        invisible()
    }
)
) 

# R implementation of _InspectInfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InspectInfile.html
InspectInfile <- R6Class(classname = "InspectInfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InspectInfile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$InspectInfile()
        invisible()
    
    
    },
    
    # C++ signature: void InspectInfile(InspectInfile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InspectInfile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$InspectInfile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void InspectInfile()
    # C++ signature: void InspectInfile(InspectInfile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "InspectInfile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "InspectInfile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void store(const String & filename)
    store = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$store(filename)
        invisible()
    },
    
    # C++ signature: void handlePTMs(const String & modification_line, const String & modifications_filename, bool monoisotopic)
    handlePTMs = function(modification_line, modifications_filename, monoisotopic){
    
        if(!((is.R6(modification_line) && class(modification_line)[1]=="String") || is_scalar_character(modification_line))){ stop("arg modification_line wrong type") }
        if(!((is.R6(modifications_filename) && class(modifications_filename)[1]=="String") || is_scalar_character(modifications_filename))){ stop("arg modifications_filename wrong type") }
        if(!( (is_scalar_integer(monoisotopic) || is_scalar_double(monoisotopic)) && monoisotopic == as.integer(monoisotopic))){ stop("arg monoisotopic wrong type") }
    
    
    
        private$py_obj$handlePTMs(modification_line, modifications_filename, as.integer(monoisotopic))
        invisible()
    },
    
    # C++ signature: String getSpectra()
    getSpectra = function(){
    
        py_ans = private$py_obj$getSpectra()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpectra(const String & spectra)
    setSpectra = function(spectra){
    
        if(!((is.R6(spectra) && class(spectra)[1]=="String") || is_scalar_character(spectra))){ stop("arg spectra wrong type") }
    
        private$py_obj$setSpectra(spectra)
        invisible()
    },
    
    # C++ signature: String getDb()
    getDb = function(){
    
        py_ans = private$py_obj$getDb()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDb(const String & db)
    setDb = function(db){
    
        if(!((is.R6(db) && class(db)[1]=="String") || is_scalar_character(db))){ stop("arg db wrong type") }
    
        private$py_obj$setDb(db)
        invisible()
    },
    
    # C++ signature: String getEnzyme()
    getEnzyme = function(){
    
        py_ans = private$py_obj$getEnzyme()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(const String & enzyme)
    setEnzyme = function(enzyme){
    
        if(!((is.R6(enzyme) && class(enzyme)[1]=="String") || is_scalar_character(enzyme))){ stop("arg enzyme wrong type") }
    
        private$py_obj$setEnzyme(enzyme)
        invisible()
    },
    
    # C++ signature: int getModificationsPerPeptide()
    getModificationsPerPeptide = function(){
    
        py_ans = private$py_obj$getModificationsPerPeptide()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setModificationsPerPeptide(int modifications_per_peptide)
    setModificationsPerPeptide = function(modifications_per_peptide){
    
        if(!( (is_scalar_integer(modifications_per_peptide) || is_scalar_double(modifications_per_peptide)) && modifications_per_peptide == as.integer(modifications_per_peptide))){ stop("arg modifications_per_peptide wrong type") }
    
        private$py_obj$setModificationsPerPeptide(as.integer(modifications_per_peptide))
        invisible()
    },
    
    # C++ signature: unsigned int getBlind()
    getBlind = function(){
    
        py_ans = private$py_obj$getBlind()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setBlind(unsigned int blind)
    setBlind = function(blind){
    
        if(!( (is_scalar_integer(blind) || is_scalar_double(blind)) && blind == as.integer(blind))){ stop("arg blind wrong type") }
    
        private$py_obj$setBlind(as.integer(blind))
        invisible()
    },
    
    # C++ signature: float getMaxPTMsize()
    getMaxPTMsize = function(){
    
        py_ans = private$py_obj$getMaxPTMsize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxPTMsize(float maxptmsize)
    setMaxPTMsize = function(maxptmsize){
    
        if(!(is_scalar_double(maxptmsize))){ stop("arg maxptmsize wrong type") }
    
        private$py_obj$setMaxPTMsize(maxptmsize)
        invisible()
    },
    
    # C++ signature: float getPrecursorMassTolerance()
    getPrecursorMassTolerance = function(){
    
        py_ans = private$py_obj$getPrecursorMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassTolerance(float precursor_mass_tolerance)
    setPrecursorMassTolerance = function(precursor_mass_tolerance){
    
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
    
        private$py_obj$setPrecursorMassTolerance(precursor_mass_tolerance)
        invisible()
    },
    
    # C++ signature: float getPeakMassTolerance()
    getPeakMassTolerance = function(){
    
        py_ans = private$py_obj$getPeakMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPeakMassTolerance(float peak_mass_tolerance)
    setPeakMassTolerance = function(peak_mass_tolerance){
    
        if(!(is_scalar_double(peak_mass_tolerance))){ stop("arg peak_mass_tolerance wrong type") }
    
        private$py_obj$setPeakMassTolerance(peak_mass_tolerance)
        invisible()
    },
    
    # C++ signature: unsigned int getMulticharge()
    getMulticharge = function(){
    
        py_ans = private$py_obj$getMulticharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMulticharge(unsigned int multicharge)
    setMulticharge = function(multicharge){
    
        if(!( (is_scalar_integer(multicharge) || is_scalar_double(multicharge)) && multicharge == as.integer(multicharge))){ stop("arg multicharge wrong type") }
    
        private$py_obj$setMulticharge(as.integer(multicharge))
        invisible()
    },
    
    # C++ signature: String getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(const String & instrument)
    setInstrument = function(instrument){
    
        if(!((is.R6(instrument) && class(instrument)[1]=="String") || is_scalar_character(instrument))){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: int getTagCount()
    getTagCount = function(){
    
        py_ans = private$py_obj$getTagCount()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTagCount(int TagCount)
    setTagCount = function(TagCount){
    
        if(!( (is_scalar_integer(TagCount) || is_scalar_double(TagCount)) && TagCount == as.integer(TagCount))){ stop("arg TagCount wrong type") }
    
        private$py_obj$setTagCount(as.integer(TagCount))
        invisible()
    }
)
) 

# R implementation of _InspectOutfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InspectOutfile.html
InspectOutfile <- R6Class(classname = "InspectOutfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InspectOutfile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$InspectOutfile()
        invisible()
    
    
    },
    
    # C++ signature: void InspectOutfile(InspectOutfile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InspectOutfile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$InspectOutfile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void InspectOutfile()
    # C++ signature: void InspectOutfile(InspectOutfile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "InspectOutfile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "InspectOutfile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[size_t] load(const String & result_filename, libcpp_vector[PeptideIdentification] & peptide_identifications, ProteinIdentification & protein_identification, double p_value_threshold, const String & database_filename)
    load = function(result_filename, peptide_identifications, protein_identification, p_value_threshold, database_filename){
    
        if(!((is.R6(result_filename) && class(result_filename)[1]=="String") || is_scalar_character(result_filename))){ stop("arg result_filename wrong type") }
        if(!(is_list(peptide_identifications) && all(sapply(peptide_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_identifications wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_scalar_double(p_value_threshold))){ stop("arg p_value_threshold wrong type") }
        if(!((is.R6(database_filename) && class(database_filename)[1]=="String") || is_scalar_character(database_filename))){ stop("arg database_filename wrong type") }
    
        v1 <- r_to_py(peptide_identifications)
    
    
    
        py_ans = private$py_obj$load(result_filename, v1, protein_identification, p_value_threshold, database_filename)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans <- modify_depth(py_ans,0,as.list)
    
        tryCatch({
        eval.parent(substitute(peptide_identifications <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[size_t] getWantedRecords(const String & result_filename, double p_value_threshold)
    getWantedRecords = function(result_filename, p_value_threshold){
    
        if(!((is.R6(result_filename) && class(result_filename)[1]=="String") || is_scalar_character(result_filename))){ stop("arg result_filename wrong type") }
        if(!(is_scalar_double(p_value_threshold))){ stop("arg p_value_threshold wrong type") }
    
    
        py_ans = private$py_obj$getWantedRecords(result_filename, p_value_threshold)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void compressTrieDB(const String & database_filename, const String & index_filename, libcpp_vector[size_t] & wanted_records, const String & snd_database_filename, const String & snd_index_filename, bool append)
    compressTrieDB = function(database_filename, index_filename, wanted_records, snd_database_filename, snd_index_filename, append){
    
        if(!((is.R6(database_filename) && class(database_filename)[1]=="String") || is_scalar_character(database_filename))){ stop("arg database_filename wrong type") }
        if(!((is.R6(index_filename) && class(index_filename)[1]=="String") || is_scalar_character(index_filename))){ stop("arg index_filename wrong type") }
        if(!(is_list(wanted_records) && all(sapply(wanted_records,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg wanted_records wrong type") }
        if(!((is.R6(snd_database_filename) && class(snd_database_filename)[1]=="String") || is_scalar_character(snd_database_filename))){ stop("arg snd_database_filename wrong type") }
        if(!((is.R6(snd_index_filename) && class(snd_index_filename)[1]=="String") || is_scalar_character(snd_index_filename))){ stop("arg snd_index_filename wrong type") }
        if(!( (is_scalar_integer(append) || is_scalar_double(append)) && append == as.integer(append))){ stop("arg append wrong type") }
    
    
        v2 <- r_to_py(wanted_records)
    
    
    
        private$py_obj$compressTrieDB(database_filename, index_filename, v2, snd_database_filename, snd_index_filename, as.integer(append))
        byref_2 <- py_to_r(v2)
    
        tryCatch({
        eval.parent(substitute(wanted_records <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void generateTrieDB(const String & source_database_filename, const String & database_filename, const String & index_filename, bool append, const String species)
    generateTrieDB = function(source_database_filename, database_filename, index_filename, append, species){
    
        if(!((is.R6(source_database_filename) && class(source_database_filename)[1]=="String") || is_scalar_character(source_database_filename))){ stop("arg source_database_filename wrong type") }
        if(!((is.R6(database_filename) && class(database_filename)[1]=="String") || is_scalar_character(database_filename))){ stop("arg database_filename wrong type") }
        if(!((is.R6(index_filename) && class(index_filename)[1]=="String") || is_scalar_character(index_filename))){ stop("arg index_filename wrong type") }
        if(!( (is_scalar_integer(append) || is_scalar_double(append)) && append == as.integer(append))){ stop("arg append wrong type") }
        if(!((is.R6(species) && class(species)[1]=="String") || is_scalar_character(species))){ stop("arg species wrong type") }
    
    
    
    
    
        private$py_obj$generateTrieDB(source_database_filename, database_filename, index_filename, as.integer(append), species)
        invisible()
    },
    
    # C++ signature: void getACAndACType(String line, String & accession, String & accession_type)
    getACAndACType = function(line, accession, accession_type){
    
        if(!((is.R6(line) && class(line)[1]=="String") || is_scalar_character(line))){ stop("arg line wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        if(!((is.R6(accession_type) && class(accession_type)[1]=="String") || is_scalar_character(accession_type))){ stop("arg accession_type wrong type") }
    
    
    
        private$py_obj$getACAndACType(line, accession, accession_type)
        invisible()
    },
    
    # C++ signature: void getLabels(const String & source_database_filename, String & ac_label, String & sequence_start_label, String & sequence_end_label, String & comment_label, String & species_label)
    getLabels = function(source_database_filename, ac_label, sequence_start_label, sequence_end_label, comment_label, species_label){
    
        if(!((is.R6(source_database_filename) && class(source_database_filename)[1]=="String") || is_scalar_character(source_database_filename))){ stop("arg source_database_filename wrong type") }
        if(!((is.R6(ac_label) && class(ac_label)[1]=="String") || is_scalar_character(ac_label))){ stop("arg ac_label wrong type") }
        if(!((is.R6(sequence_start_label) && class(sequence_start_label)[1]=="String") || is_scalar_character(sequence_start_label))){ stop("arg sequence_start_label wrong type") }
        if(!((is.R6(sequence_end_label) && class(sequence_end_label)[1]=="String") || is_scalar_character(sequence_end_label))){ stop("arg sequence_end_label wrong type") }
        if(!((is.R6(comment_label) && class(comment_label)[1]=="String") || is_scalar_character(comment_label))){ stop("arg comment_label wrong type") }
        if(!((is.R6(species_label) && class(species_label)[1]=="String") || is_scalar_character(species_label))){ stop("arg species_label wrong type") }
    
    
    
    
    
    
        private$py_obj$getLabels(source_database_filename, ac_label, sequence_start_label, sequence_end_label, comment_label, species_label)
        invisible()
    },
    
    # C++ signature: libcpp_vector[size_t] getSequences(const String & database_filename, libcpp_map[size_t,size_t] & wanted_records, libcpp_vector[String] & sequences)
    getSequences = function(database_filename, wanted_records, sequences){
    
        if(!((is.R6(database_filename) && class(database_filename)[1]=="String") || is_scalar_character(database_filename))){ stop("arg database_filename wrong type") }
        if(!(
          is.environment(wanted_records) && identical(parent.env(wanted_records), asNamespace("collections")) && identical(strsplit(capture.output(wanted_records$print())," ")[[1]][1], "dict")
          && all(sapply(wanted_records$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(wanted_records$values(),function(v)  (is_scalar_integer(v) || is_scalar_double(v)) && v == as.integer(v)))
          )){ stop("arg wanted_records wrong type") }
        if(!(is_list(sequences) && all(sapply(sequences),is_scalar_character))){ stop("arg sequences wrong type") }
    
        v1 <- py_dict(as.integer(wanted_records$keys()),as.integer(wanted_records$values()))
        v2 = r_to_py(modify_depth(sequences,1,py_builtin$bytes(sequences,'utf-8')))
        py_ans = private$py_obj$getSequences(database_filename, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- collections::dict(py_to_r(py_builtin$list(v1$values())),py_to_r(py_builtin$list(v1$keys())))
        r_ans <- modify_depth(py_ans,0,as.list)
    
        tryCatch({
        eval.parent(substitute(wanted_records <- byref_1))
        eval.parent(substitute(sequences <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void getExperiment(MSExperiment & exp, String & type_, const String & in_filename)
    getExperiment = function(exp, type_, in_filename){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!((is.R6(type_) && class(type_)[1]=="String") || is_scalar_character(type_))){ stop("arg type_ wrong type") }
        if(!((is.R6(in_filename) && class(in_filename)[1]=="String") || is_scalar_character(in_filename))){ stop("arg in_filename wrong type") }
    
    
    
        private$py_obj$getExperiment(exp, type_, in_filename)
        invisible()
    },
    
    # C++ signature: bool getSearchEngineAndVersion(const String & cmd_output, ProteinIdentification & protein_identification)
    getSearchEngineAndVersion = function(cmd_output, protein_identification){
    
        if(!((is.R6(cmd_output) && class(cmd_output)[1]=="String") || is_scalar_character(cmd_output))){ stop("arg cmd_output wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
    
    
        py_ans = private$py_obj$getSearchEngineAndVersion(cmd_output, protein_identification)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void readOutHeader(const String & filename, const String & header_line, int & spectrum_file_column, int & scan_column, int & peptide_column, int & protein_column, int & charge_column, int & MQ_score_column, int & p_value_column, int & record_number_column, int & DB_file_pos_column, int & spec_file_pos_column, size_t & number_of_columns)
    readOutHeader = function(filename, header_line, spectrum_file_column, scan_column, peptide_column, protein_column, charge_column, MQ_score_column, p_value_column, record_number_column, DB_file_pos_column, spec_file_pos_column, number_of_columns){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(header_line) && class(header_line)[1]=="String") || is_scalar_character(header_line))){ stop("arg header_line wrong type") }
        if(!( (is_scalar_integer(spectrum_file_column) || is_scalar_double(spectrum_file_column)) && spectrum_file_column == as.integer(spectrum_file_column))){ stop("arg spectrum_file_column wrong type") }
        if(!( (is_scalar_integer(scan_column) || is_scalar_double(scan_column)) && scan_column == as.integer(scan_column))){ stop("arg scan_column wrong type") }
        if(!( (is_scalar_integer(peptide_column) || is_scalar_double(peptide_column)) && peptide_column == as.integer(peptide_column))){ stop("arg peptide_column wrong type") }
        if(!( (is_scalar_integer(protein_column) || is_scalar_double(protein_column)) && protein_column == as.integer(protein_column))){ stop("arg protein_column wrong type") }
        if(!( (is_scalar_integer(charge_column) || is_scalar_double(charge_column)) && charge_column == as.integer(charge_column))){ stop("arg charge_column wrong type") }
        if(!( (is_scalar_integer(MQ_score_column) || is_scalar_double(MQ_score_column)) && MQ_score_column == as.integer(MQ_score_column))){ stop("arg MQ_score_column wrong type") }
        if(!( (is_scalar_integer(p_value_column) || is_scalar_double(p_value_column)) && p_value_column == as.integer(p_value_column))){ stop("arg p_value_column wrong type") }
        if(!( (is_scalar_integer(record_number_column) || is_scalar_double(record_number_column)) && record_number_column == as.integer(record_number_column))){ stop("arg record_number_column wrong type") }
        if(!( (is_scalar_integer(DB_file_pos_column) || is_scalar_double(DB_file_pos_column)) && DB_file_pos_column == as.integer(DB_file_pos_column))){ stop("arg DB_file_pos_column wrong type") }
        if(!( (is_scalar_integer(spec_file_pos_column) || is_scalar_double(spec_file_pos_column)) && spec_file_pos_column == as.integer(spec_file_pos_column))){ stop("arg spec_file_pos_column wrong type") }
        if(!( (is_scalar_integer(number_of_columns) || is_scalar_double(number_of_columns)) && number_of_columns == as.integer(number_of_columns))){ stop("arg number_of_columns wrong type") }
    
    
    
    
    
    
    
    
    
    
    
    
    
        private$py_obj$readOutHeader(filename, header_line, as.integer(spectrum_file_column), as.integer(scan_column), as.integer(peptide_column), as.integer(protein_column), as.integer(charge_column), as.integer(MQ_score_column), as.integer(p_value_column), as.integer(record_number_column), as.integer(DB_file_pos_column), as.integer(spec_file_pos_column), as.integer(number_of_columns))
        invisible()
    }
)
) 

# R implementation of _Instrument
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Instrument.html
Instrument <- R6Class(classname = "Instrument",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Instrument()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Instrument) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Instrument()
        invisible()
    }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getVendor()
    getVendor = function(){
    
        py_ans = private$py_obj$getVendor()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setVendor(String vendor)
    setVendor = function(vendor){
    
        if(!((is.R6(vendor) && class(vendor)[1]=="String") || is_scalar_character(vendor))){ stop("arg vendor wrong type") }
    
        private$py_obj$setVendor(vendor)
        invisible()
    },
    
    # C++ signature: String getModel()
    getModel = function(){
    
        py_ans = private$py_obj$getModel()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setModel(String model)
    setModel = function(model){
    
        if(!((is.R6(model) && class(model)[1]=="String") || is_scalar_character(model))){ stop("arg model wrong type") }
    
        private$py_obj$setModel(model)
        invisible()
    },
    
    # C++ signature: String getCustomizations()
    getCustomizations = function(){
    
        py_ans = private$py_obj$getCustomizations()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCustomizations(String customizations)
    setCustomizations = function(customizations){
    
        if(!((is.R6(customizations) && class(customizations)[1]=="String") || is_scalar_character(customizations))){ stop("arg customizations wrong type") }
    
        private$py_obj$setCustomizations(customizations)
        invisible()
    },
    
    # C++ signature: libcpp_vector[IonSource] getIonSources()
    getIonSources = function(){
    
        py_ans = private$py_obj$getIonSources()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setIonSources(libcpp_vector[IonSource] ion_sources)
    setIonSources = function(ion_sources){
    
        if(!(is_list(ion_sources) && all(sapply(ion_sources,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IonSource")))){ stop("arg ion_sources wrong type") }
        v0 <- r_to_py(ion_sources)
        private$py_obj$setIonSources(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[MassAnalyzer] getMassAnalyzers()
    getMassAnalyzers = function(){
    
        py_ans = private$py_obj$getMassAnalyzers()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setMassAnalyzers(libcpp_vector[MassAnalyzer] mass_analyzers)
    setMassAnalyzers = function(mass_analyzers){
    
        if(!(is_list(mass_analyzers) && all(sapply(mass_analyzers,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MassAnalyzer")))){ stop("arg mass_analyzers wrong type") }
        v0 <- r_to_py(mass_analyzers)
        private$py_obj$setMassAnalyzers(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[IonDetector] getIonDetectors()
    getIonDetectors = function(){
    
        py_ans = private$py_obj$getIonDetectors()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setIonDetectors(libcpp_vector[IonDetector] ion_detectors)
    setIonDetectors = function(ion_detectors){
    
        if(!(is_list(ion_detectors) && all(sapply(ion_detectors,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IonDetector")))){ stop("arg ion_detectors wrong type") }
        v0 <- r_to_py(ion_detectors)
        private$py_obj$setIonDetectors(v0)
        
        invisible()
    },
    
    # C++ signature: Software getSoftware()
    getSoftware = function(){
    
        py_ans = private$py_obj$getSoftware()
        r_ans = Software$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSoftware(Software software)
    setSoftware = function(software){
    
        if(!(is.R6(software) && class(software)[1] == "Software")){ stop("arg software wrong type") }
    
        private$py_obj$setSoftware(software)
        invisible()
    },
    
    # C++ signature: IonOpticsType getIonOptics()
    getIonOptics = function(){
    
        py_ans = private$py_obj$getIonOptics()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIonOptics(IonOpticsType ion_optics)
    setIonOptics = function(ion_optics){
    
        if(!(ion_optics %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))){ stop("arg ion_optics wrong type") }
    
        private$py_obj$setIonOptics(as.integer(ion_optics))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _InstrumentSettings
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InstrumentSettings.html
InstrumentSettings <- R6Class(classname = "InstrumentSettings",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InstrumentSettings()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$InstrumentSettings()
        invisible()
    
    
    },
    
    # C++ signature: void InstrumentSettings(InstrumentSettings)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InstrumentSettings")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$InstrumentSettings(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void InstrumentSettings()
    # C++ signature: void InstrumentSettings(InstrumentSettings)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "InstrumentSettings")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "InstrumentSettings" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: Polarity getPolarity()
    getPolarity = function(){
    
        py_ans = private$py_obj$getPolarity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPolarity(Polarity)
    setPolarity = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2, 3))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPolarity(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: ScanMode getScanMode()
    getScanMode = function(){
    
        py_ans = private$py_obj$getScanMode()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScanMode(ScanMode scan_mode)
    setScanMode = function(scan_mode){
    
        if(!(scan_mode %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))){ stop("arg scan_mode wrong type") }
    
        private$py_obj$setScanMode(as.integer(scan_mode))
        invisible()
    },
    
    # C++ signature: bool getZoomScan()
    getZoomScan = function(){
    
        py_ans = private$py_obj$getZoomScan()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setZoomScan(bool zoom_scan)
    setZoomScan = function(zoom_scan){
    
        if(!( (is_scalar_integer(zoom_scan) || is_scalar_double(zoom_scan)) && zoom_scan == as.integer(zoom_scan))){ stop("arg zoom_scan wrong type") }
    
        private$py_obj$setZoomScan(as.integer(zoom_scan))
        invisible()
    },
    
    # C++ signature: libcpp_vector[ScanWindow] getScanWindows()
    getScanWindows = function(){
    
        py_ans = private$py_obj$getScanWindows()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setScanWindows(libcpp_vector[ScanWindow] scan_windows)
    setScanWindows = function(scan_windows){
    
        if(!(is_list(scan_windows) && all(sapply(scan_windows,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ScanWindow")))){ stop("arg scan_windows wrong type") }
        v0 <- r_to_py(scan_windows)
        private$py_obj$setScanWindows(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IntegerDataArray
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::DataArrays_1_1IntegerDataArray.html

# The representation of extra integer data attached to a spectrum or chromatogram.
# Raw data access is proved by `get_peaks` and `set_peaks`, which yields numpy arrays
IntegerDataArray <- R6Class(classname = "IntegerDataArray",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IntegerDataArray()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IntegerDataArray) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IntegerDataArray()
        invisible()
    }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void resize(size_t n)
    resize = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$resize(as.integer(n))
        invisible()
    },
    
    # C++ signature: void reserve(size_t n)
    reserve = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$reserve(as.integer(n))
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void push_back(int)
    push_back = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IntensityBalanceFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IntensityBalanceFilter.html
IntensityBalanceFilter <- R6Class(classname = "IntensityBalanceFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IntensityBalanceFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IntensityBalanceFilter()
        invisible()
    
    
    },
    
    # C++ signature: void IntensityBalanceFilter(IntensityBalanceFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IntensityBalanceFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IntensityBalanceFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IntensityBalanceFilter()
    # C++ signature: void IntensityBalanceFilter(IntensityBalanceFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IntensityBalanceFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IntensityBalanceFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _InternalCalibration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InternalCalibration.html
InternalCalibration <- R6Class(classname = "InternalCalibration",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InternalCalibration()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$InternalCalibration()
        invisible()
    
    
    },
    
    # C++ signature: void InternalCalibration(InternalCalibration)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InternalCalibration")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$InternalCalibration(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void InternalCalibration()
    # C++ signature: void InternalCalibration(InternalCalibration)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "InternalCalibration")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "InternalCalibration" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t fillCalibrants(MSExperiment, libcpp_vector[InternalCalibration_LockMass], double tol_ppm, bool lock_require_mono, bool lock_require_iso, CalibrationData & failed_lock_masses, bool verbose)
    fillCalibrants_0 = function(in_0, in_1, tol_ppm, lock_require_mono, lock_require_iso, failed_lock_masses, verbose){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "InternalCalibration_LockMass")))){ stop("arg in_1 wrong type") }
        if(!(is_scalar_double(tol_ppm))){ stop("arg tol_ppm wrong type") }
        if(!( (is_scalar_integer(lock_require_mono) || is_scalar_double(lock_require_mono)) && lock_require_mono == as.integer(lock_require_mono))){ stop("arg lock_require_mono wrong type") }
        if(!( (is_scalar_integer(lock_require_iso) || is_scalar_double(lock_require_iso)) && lock_require_iso == as.integer(lock_require_iso))){ stop("arg lock_require_iso wrong type") }
        if(!(is.R6(failed_lock_masses) && class(failed_lock_masses)[1] == "CalibrationData")){ stop("arg failed_lock_masses wrong type") }
        if(!( (is_scalar_integer(verbose) || is_scalar_double(verbose)) && verbose == as.integer(verbose))){ stop("arg verbose wrong type") }
    
        v1 <- r_to_py(in_1)
    
    
    
    
    
        py_ans = private$py_obj$`_fillCalibrants_0`(in_0, v1, tol_ppm, as.integer(lock_require_mono), as.integer(lock_require_iso), failed_lock_masses, as.integer(verbose))
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t fillCalibrants(FeatureMap, double)
    fillCalibrants_1 = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$`_fillCalibrants_1`(in_0, in_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t fillCalibrants(libcpp_vector[PeptideIdentification], double)
    fillCalibrants_2 = function(in_0, in_1){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(in_0)
    
        py_ans = private$py_obj$`_fillCalibrants_2`(v0, in_1)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t fillCalibrants(MSExperiment, libcpp_vector[InternalCalibration_LockMass], double tol_ppm, bool lock_require_mono, bool lock_require_iso, CalibrationData & failed_lock_masses, bool verbose)
    # C++ signature: size_t fillCalibrants(FeatureMap, double)
    # C++ signature: size_t fillCalibrants(libcpp_vector[PeptideIdentification], double)
    fillCalibrants = function(...){
        arg_list = list(...)
        if ((length(arg_list)==7) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "InternalCalibration_LockMass"))) && (is_scalar_double(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is.R6(arg_list[[6]]) && class(arg_list[[6]])[1] == "CalibrationData") && ( (is_scalar_integer(arg_list[[7]]) || is_scalar_double(arg_list[[7]])) && arg_list[[7]] == as.integer(arg_list[[7]]))) { self$fillCalibrants_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is_scalar_double(arg_list[[2]]))) { self$fillCalibrants_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is_scalar_double(arg_list[[2]]))) { self$fillCalibrants_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: CalibrationData getCalibrationPoints()
    getCalibrationPoints = function(){
    
        py_ans = private$py_obj$getCalibrationPoints()
        r_ans = CalibrationData$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool calibrate(MSExperiment, libcpp_vector[int], MZTrafoModel_MODELTYPE, double rt_chunk, bool use_RANSAC, double post_ppm_median, double post_ppm_MAD, String file_models, String file_models_plot, String file_residuals, String file_residuals_plot, String rscript_executable)
    calibrate = function(in_0, in_1, in_2, rt_chunk, use_RANSAC, post_ppm_median, post_ppm_MAD, file_models, file_models_plot, file_residuals, file_residuals_plot, rscript_executable){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg in_1 wrong type") }
        if(!(in_2 %in% c(0, 1, 2, 3, 4))){ stop("arg in_2 wrong type") }
        if(!(is_scalar_double(rt_chunk))){ stop("arg rt_chunk wrong type") }
        if(!( (is_scalar_integer(use_RANSAC) || is_scalar_double(use_RANSAC)) && use_RANSAC == as.integer(use_RANSAC))){ stop("arg use_RANSAC wrong type") }
        if(!(is_scalar_double(post_ppm_median))){ stop("arg post_ppm_median wrong type") }
        if(!(is_scalar_double(post_ppm_MAD))){ stop("arg post_ppm_MAD wrong type") }
        if(!((is.R6(file_models) && class(file_models)[1]=="String") || is_scalar_character(file_models))){ stop("arg file_models wrong type") }
        if(!((is.R6(file_models_plot) && class(file_models_plot)[1]=="String") || is_scalar_character(file_models_plot))){ stop("arg file_models_plot wrong type") }
        if(!((is.R6(file_residuals) && class(file_residuals)[1]=="String") || is_scalar_character(file_residuals))){ stop("arg file_residuals wrong type") }
        if(!((is.R6(file_residuals_plot) && class(file_residuals_plot)[1]=="String") || is_scalar_character(file_residuals_plot))){ stop("arg file_residuals_plot wrong type") }
        if(!((is.R6(rscript_executable) && class(rscript_executable)[1]=="String") || is_scalar_character(rscript_executable))){ stop("arg rscript_executable wrong type") }
    
        v1 <- r_to_py(modify_depth(in_1,1,as.integer))
    
    
    
    
    
    
    
    
    
    
        py_ans = private$py_obj$calibrate(in_0, v1, as.integer(in_2), rt_chunk, as.integer(use_RANSAC), post_ppm_median, post_ppm_MAD, file_models, file_models_plot, file_residuals, file_residuals_plot, rscript_executable)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
)
    
    # C++ signature: void applyTransformation(libcpp_vector[Precursor] & pcs, MZTrafoModel & trafo)
    InternalCalibration$applyTransformation = function(pcs, trafo){
    
        if(!(is_list(pcs) && all(sapply(pcs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Precursor")))){ stop("arg pcs wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "MZTrafoModel")){ stop("arg trafo wrong type") }
        v0 <- r_to_py(pcs)
    
        Pymod$InternalCalibration$applyTransformation(v0, trafo)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    }
    
    # C++ signature: void applyTransformation(MSSpectrum & spec, IntList & target_mslvl, MZTrafoModel & trafo)
    InternalCalibration$applyTransformation = function(spec, target_mslvl, trafo){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is_list(target_mslvl) && all(sapply(target_mslvl), function(inner) inner == as.integer(inner)))){ stop("arg target_mslvl wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "MZTrafoModel")){ stop("arg trafo wrong type") }
    
        v1 = r_to_py(target_mslvl)
    
        Pymod$InternalCalibration$applyTransformation(spec, v1, trafo)
    }
    
    # C++ signature: void applyTransformation(MSExperiment & exp, IntList & target_mslvl, MZTrafoModel & trafo)
    InternalCalibration$applyTransformation = function(exp, target_mslvl, trafo){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_list(target_mslvl) && all(sapply(target_mslvl), function(inner) inner == as.integer(inner)))){ stop("arg target_mslvl wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "MZTrafoModel")){ stop("arg trafo wrong type") }
    
        v1 = r_to_py(target_mslvl)
    
        Pymod$InternalCalibration$applyTransformation(exp, v1, trafo)
    } 

# R implementation of _InternalCalibration_LockMass
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InternalCalibration_LockMass.html
InternalCalibration_LockMass <- R6Class(classname = "InternalCalibration_LockMass",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mz = function(mz){
    
        if(!missing(mz)){
            if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        
        
            private$py_obj$mz <- mz
            } else {
        
                py_ans = private$py_obj$mz
                r_result = py_ans
                return(r_result)
                }
        },
        ms_level = function(ms_level){
    
        if(!missing(ms_level)){
            if(!( (is_scalar_integer(ms_level) || is_scalar_double(ms_level)) && ms_level == as.integer(ms_level))){ stop("arg ms_level wrong type") }
        
        
            private$py_obj$ms_level <- as.integer(ms_level)
            } else {
        
                py_ans = private$py_obj$ms_level
                r_result = py_ans
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void InternalCalibration_LockMass(double mz_, int lvl_, int charge_)
    initialize = function(mz_, lvl_, charge_){
    
    if(missing(lvl_) && missing(charge_)){
         if( "python.builtin.object" %in% class(mz_) && class_to_wrap(mz_) == InternalCalibration_LockMass ) { private$py_obj <- mz_ }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(mz_))){ stop("arg mz_ wrong type") }
        if(!( (is_scalar_integer(lvl_) || is_scalar_double(lvl_)) && lvl_ == as.integer(lvl_))){ stop("arg lvl_ wrong type") }
        if(!( (is_scalar_integer(charge_) || is_scalar_double(charge_)) && charge_ == as.integer(charge_))){ stop("arg charge_ wrong type") }
    
    
    
    
        private$py_obj <- Pymod$InternalCalibration_LockMass(mz_, as.integer(lvl_), as.integer(charge_))
        invisible()
    }
    
    }
)
) 

# R implementation of _Internal_MzMLValidator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1Internal_MzMLValidator.html
Internal_MzMLValidator <- R6Class(classname = "Internal_MzMLValidator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Internal_MzMLValidator(CVMappings & mapping, ControlledVocabulary & cv)
    initialize = function(mapping, cv){
    
    if(missing(cv)){
         if( "python.builtin.object" %in% class(mapping) && class_to_wrap(mapping) == Internal_MzMLValidator ) { private$py_obj <- mapping }
         else { stop("arg wrong type") }
      } else {
        if(!(is.R6(mapping) && class(mapping)[1] == "CVMappings")){ stop("arg mapping wrong type") }
        if(!(is.R6(cv) && class(cv)[1] == "ControlledVocabulary")){ stop("arg cv wrong type") }
    
    
    
        private$py_obj <- Pymod$Internal_MzMLValidator(mapping, cv)
        invisible()
    }
    
    }
)
) 

# R implementation of _InterpolationModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1InterpolationModel.html
InterpolationModel <- R6Class(classname = "InterpolationModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void InterpolationModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$InterpolationModel()
        invisible()
    
    
    },
    
    # C++ signature: void InterpolationModel(InterpolationModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InterpolationModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$InterpolationModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void InterpolationModel()
    # C++ signature: void InterpolationModel(InterpolationModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "InterpolationModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "InterpolationModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getIntensity(double coord)
    getIntensity = function(coord){
    
        if(!(is_scalar_double(coord))){ stop("arg coord wrong type") }
    
        py_ans = private$py_obj$getIntensity(coord)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getScalingFactor()
    getScalingFactor = function(){
    
        py_ans = private$py_obj$getScalingFactor()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset(double offset)
    setOffset = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset(offset)
        invisible()
    },
    
    # C++ signature: double getCenter()
    getCenter = function(){
    
        py_ans = private$py_obj$getCenter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSamples()
    setSamples = function(){
    
        private$py_obj$setSamples()
        invisible()
    },
    
    # C++ signature: void setInterpolationStep(double interpolation_step)
    setInterpolationStep = function(interpolation_step){
    
        if(!(is_scalar_double(interpolation_step))){ stop("arg interpolation_step wrong type") }
    
        private$py_obj$setInterpolationStep(interpolation_step)
        invisible()
    },
    
    # C++ signature: void setScalingFactor(double scaling)
    setScalingFactor = function(scaling){
    
        if(!(is_scalar_double(scaling))){ stop("arg scaling wrong type") }
    
        private$py_obj$setScalingFactor(scaling)
        invisible()
    },
    
    # C++ signature: LinearInterpolation getInterpolation()
    getInterpolation = function(){
    
        py_ans = private$py_obj$getInterpolation()
        r_ans = LinearInterpolation$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _IonDetector
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IonDetector.html
IonDetector <- R6Class(classname = "IonDetector",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IonDetector()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IonDetector) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IonDetector()
        invisible()
    }
    
    },
    
    # C++ signature: Type_IonDetector getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setType(Type_IonDetector type_)
    setType = function(type_){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))){ stop("arg type_ wrong type") }
    
        private$py_obj$setType(as.integer(type_))
        invisible()
    },
    
    # C++ signature: AcquisitionMode getAcquisitionMode()
    getAcquisitionMode = function(){
    
        py_ans = private$py_obj$getAcquisitionMode()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAcquisitionMode(AcquisitionMode acquisition_mode)
    setAcquisitionMode = function(acquisition_mode){
    
        if(!(acquisition_mode %in% c(0, 1, 2, 3, 4, 5))){ stop("arg acquisition_mode wrong type") }
    
        private$py_obj$setAcquisitionMode(as.integer(acquisition_mode))
        invisible()
    },
    
    # C++ signature: double getResolution()
    getResolution = function(){
    
        py_ans = private$py_obj$getResolution()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setResolution(double resolution)
    setResolution = function(resolution){
    
        if(!(is_scalar_double(resolution))){ stop("arg resolution wrong type") }
    
        private$py_obj$setResolution(resolution)
        invisible()
    },
    
    # C++ signature: double getADCSamplingFrequency()
    getADCSamplingFrequency = function(){
    
        py_ans = private$py_obj$getADCSamplingFrequency()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setADCSamplingFrequency(double ADC_sampling_frequency)
    setADCSamplingFrequency = function(ADC_sampling_frequency){
    
        if(!(is_scalar_double(ADC_sampling_frequency))){ stop("arg ADC_sampling_frequency wrong type") }
    
        private$py_obj$setADCSamplingFrequency(ADC_sampling_frequency)
        invisible()
    },
    
    # C++ signature: int getOrder()
    getOrder = function(){
    
        py_ans = private$py_obj$getOrder()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOrder(int order)
    setOrder = function(order){
    
        if(!( (is_scalar_integer(order) || is_scalar_double(order)) && order == as.integer(order))){ stop("arg order wrong type") }
    
        private$py_obj$setOrder(as.integer(order))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IonSource
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IonSource.html
IonSource <- R6Class(classname = "IonSource",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IonSource()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IonSource) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IonSource()
        invisible()
    }
    
    },
    
    # C++ signature: Polarity getPolarity()
    getPolarity = function(){
    
        py_ans = private$py_obj$getPolarity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPolarity(Polarity polarity)
    setPolarity = function(polarity){
    
        if(!(polarity %in% c(0, 1, 2, 3))){ stop("arg polarity wrong type") }
    
        private$py_obj$setPolarity(as.integer(polarity))
        invisible()
    },
    
    # C++ signature: InletType getInletType()
    getInletType = function(){
    
        py_ans = private$py_obj$getInletType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInletType(InletType inlet_type)
    setInletType = function(inlet_type){
    
        if(!(inlet_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))){ stop("arg inlet_type wrong type") }
    
        private$py_obj$setInletType(as.integer(inlet_type))
        invisible()
    },
    
    # C++ signature: IonizationMethod getIonizationMethod()
    getIonizationMethod = function(){
    
        py_ans = private$py_obj$getIonizationMethod()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIonizationMethod(IonizationMethod ionization_type)
    setIonizationMethod = function(ionization_type){
    
        if(!(ionization_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52))){ stop("arg ionization_type wrong type") }
    
        private$py_obj$setIonizationMethod(as.integer(ionization_type))
        invisible()
    },
    
    # C++ signature: int getOrder()
    getOrder = function(){
    
        py_ans = private$py_obj$getOrder()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOrder(int order)
    setOrder = function(order){
    
        if(!( (is_scalar_integer(order) || is_scalar_double(order)) && order == as.integer(order))){ stop("arg order wrong type") }
    
        private$py_obj$setOrder(as.integer(order))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _IonType
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IonType.html
IonType <- R6Class(classname = "IonType",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        residue = function(residue){
    
        if(!missing(residue)){
            if(!(residue %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg residue wrong type") }
        
        
            private$py_obj$residue <- as.integer(residue)
            } else {
        
                py_ans = private$py_obj$residue
                r_result = py_ans
                return(r_result)
                }
        },
        loss = function(loss){
    
        if(!missing(loss)){
            if(!(is.R6(loss) && class(loss)[1] == "EmpiricalFormula")){ stop("arg loss wrong type") }
        
        
            private$py_obj$loss <- loss
            } else {
        
                py_ans = private$py_obj$loss
            r_result = EmpiricalFormula$new(py_ans)
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IonType()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IonType()
        invisible()
    
    
    },
    
    # C++ signature: void IonType(IonType)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IonType")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IonType(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IonType(ResidueType residue, EmpiricalFormula l, int charge)
    init_2 = function(residue, l, charge){
    
        if(!(residue %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg residue wrong type") }
        if(!(is.R6(l) && class(l)[1] == "EmpiricalFormula")){ stop("arg l wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
    
    
        private$py_obj <- Pymod$IonType(as.integer(residue), l, as.integer(charge))
        invisible()
    
    
    },
    
    # C++ signature: void IonType()
    # C++ signature: void IonType(IonType)
    # C++ signature: void IonType(ResidueType residue, EmpiricalFormula l, int charge)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IonType")) { self$init_1(...) }
        else if ((length(arg_list)==3) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "EmpiricalFormula") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IonType" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _IsobaricChannelExtractor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsobaricChannelExtractor.html
IsobaricChannelExtractor <- R6Class(classname = "IsobaricChannelExtractor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsobaricChannelExtractor(IsobaricChannelExtractor)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsobaricChannelExtractor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricChannelExtractor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricChannelExtractor(ItraqEightPlexQuantitationMethod * quant_method)
    init_1 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqEightPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricChannelExtractor(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricChannelExtractor(ItraqFourPlexQuantitationMethod * quant_method)
    init_2 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqFourPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricChannelExtractor(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricChannelExtractor(TMTSixPlexQuantitationMethod * quant_method)
    init_3 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTSixPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricChannelExtractor(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricChannelExtractor(TMTTenPlexQuantitationMethod * quant_method)
    init_4 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTTenPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricChannelExtractor(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricChannelExtractor(IsobaricChannelExtractor)
    # C++ signature: void IsobaricChannelExtractor(ItraqEightPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricChannelExtractor(ItraqFourPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricChannelExtractor(TMTSixPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricChannelExtractor(TMTTenPlexQuantitationMethod * quant_method)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsobaricChannelExtractor")) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqEightPlexQuantitationMethod")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqFourPlexQuantitationMethod")) { self$init_2(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTSixPlexQuantitationMethod")) { self$init_3(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTTenPlexQuantitationMethod")) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsobaricChannelExtractor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void extractChannels(MSExperiment & ms_exp_data, ConsensusMap & consensus_map)
    extractChannels = function(ms_exp_data, consensus_map){
    
        if(!(is.R6(ms_exp_data) && class(ms_exp_data)[1] == "MSExperiment")){ stop("arg ms_exp_data wrong type") }
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
    
    
        private$py_obj$extractChannels(ms_exp_data, consensus_map)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IsobaricChannelInformation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::IsobaricQuantitationMethod_1_1IsobaricChannelInformation.html
IsobaricChannelInformation <- R6Class(classname = "IsobaricChannelInformation",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- as.integer(id)
            } else {
        
                py_ans = private$py_obj$id
                r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        center = function(center){
    
        if(!missing(center)){
            if(!(is_scalar_double(center))){ stop("arg center wrong type") }
        
        
            private$py_obj$center <- center
            } else {
        
                py_ans = private$py_obj$center
                r_result = py_ans
                return(r_result)
                }
        },
        channel_id_minus_2 = function(channel_id_minus_2){
    
        if(!missing(channel_id_minus_2)){
            if(!( (is_scalar_integer(channel_id_minus_2) || is_scalar_double(channel_id_minus_2)) && channel_id_minus_2 == as.integer(channel_id_minus_2))){ stop("arg channel_id_minus_2 wrong type") }
        
        
            private$py_obj$channel_id_minus_2 <- as.integer(channel_id_minus_2)
            } else {
        
                py_ans = private$py_obj$channel_id_minus_2
                r_result = py_ans
                return(r_result)
                }
        },
        channel_id_minus_1 = function(channel_id_minus_1){
    
        if(!missing(channel_id_minus_1)){
            if(!( (is_scalar_integer(channel_id_minus_1) || is_scalar_double(channel_id_minus_1)) && channel_id_minus_1 == as.integer(channel_id_minus_1))){ stop("arg channel_id_minus_1 wrong type") }
        
        
            private$py_obj$channel_id_minus_1 <- as.integer(channel_id_minus_1)
            } else {
        
                py_ans = private$py_obj$channel_id_minus_1
                r_result = py_ans
                return(r_result)
                }
        },
        channel_id_plus_1 = function(channel_id_plus_1){
    
        if(!missing(channel_id_plus_1)){
            if(!( (is_scalar_integer(channel_id_plus_1) || is_scalar_double(channel_id_plus_1)) && channel_id_plus_1 == as.integer(channel_id_plus_1))){ stop("arg channel_id_plus_1 wrong type") }
        
        
            private$py_obj$channel_id_plus_1 <- as.integer(channel_id_plus_1)
            } else {
        
                py_ans = private$py_obj$channel_id_plus_1
                r_result = py_ans
                return(r_result)
                }
        },
        channel_id_plus_2 = function(channel_id_plus_2){
    
        if(!missing(channel_id_plus_2)){
            if(!( (is_scalar_integer(channel_id_plus_2) || is_scalar_double(channel_id_plus_2)) && channel_id_plus_2 == as.integer(channel_id_plus_2))){ stop("arg channel_id_plus_2 wrong type") }
        
        
            private$py_obj$channel_id_plus_2 <- as.integer(channel_id_plus_2)
            } else {
        
                py_ans = private$py_obj$channel_id_plus_2
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IsobaricChannelInformation(String name, int id_, String description, double center, int channel_id_minus_2, int channel_id_minus_1, int channel_id_plus_1, int channel_id_plus_2)
    initialize = function(name, id_, description, center, channel_id_minus_2, channel_id_minus_1, channel_id_plus_1, channel_id_plus_2){
    
    if(missing(id_) && missing(description) && missing(center) && missing(channel_id_minus_2) && missing(channel_id_minus_1) && missing(channel_id_plus_1) && missing(channel_id_plus_2)){
         if( "python.builtin.object" %in% class(name) && class_to_wrap(name) == IsobaricChannelInformation ) { private$py_obj <- name }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
        if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        if(!(is_scalar_double(center))){ stop("arg center wrong type") }
        if(!( (is_scalar_integer(channel_id_minus_2) || is_scalar_double(channel_id_minus_2)) && channel_id_minus_2 == as.integer(channel_id_minus_2))){ stop("arg channel_id_minus_2 wrong type") }
        if(!( (is_scalar_integer(channel_id_minus_1) || is_scalar_double(channel_id_minus_1)) && channel_id_minus_1 == as.integer(channel_id_minus_1))){ stop("arg channel_id_minus_1 wrong type") }
        if(!( (is_scalar_integer(channel_id_plus_1) || is_scalar_double(channel_id_plus_1)) && channel_id_plus_1 == as.integer(channel_id_plus_1))){ stop("arg channel_id_plus_1 wrong type") }
        if(!( (is_scalar_integer(channel_id_plus_2) || is_scalar_double(channel_id_plus_2)) && channel_id_plus_2 == as.integer(channel_id_plus_2))){ stop("arg channel_id_plus_2 wrong type") }
    
    
    
    
    
    
    
    
    
        private$py_obj <- Pymod$IsobaricChannelInformation(name, as.integer(id_), description, center, as.integer(channel_id_minus_2), as.integer(channel_id_minus_1), as.integer(channel_id_plus_1), as.integer(channel_id_plus_2))
        invisible()
    }
    
    }
)
) 

# R implementation of _IsobaricIsotopeCorrector
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsobaricIsotopeCorrector.html
IsobaricIsotopeCorrector <- R6Class(classname = "IsobaricIsotopeCorrector",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsobaricIsotopeCorrector()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IsobaricIsotopeCorrector) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IsobaricIsotopeCorrector()
        invisible()
    }
    
    },
    
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, ItraqEightPlexQuantitationMethod * quant_method)
    correctIsotopicImpurities_0 = function(consensus_map_in, consensus_map_out, quant_method){
    
        if(!(is.R6(consensus_map_in) && class(consensus_map_in)[1] == "ConsensusMap")){ stop("arg consensus_map_in wrong type") }
        if(!(is.R6(consensus_map_out) && class(consensus_map_out)[1] == "ConsensusMap")){ stop("arg consensus_map_out wrong type") }
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqEightPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
    
        py_ans = private$py_obj$`_correctIsotopicImpurities_0`(consensus_map_in, consensus_map_out, quant_method)
        r_ans = IsobaricQuantifierStatistics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, ItraqFourPlexQuantitationMethod * quant_method)
    correctIsotopicImpurities_1 = function(consensus_map_in, consensus_map_out, quant_method){
    
        if(!(is.R6(consensus_map_in) && class(consensus_map_in)[1] == "ConsensusMap")){ stop("arg consensus_map_in wrong type") }
        if(!(is.R6(consensus_map_out) && class(consensus_map_out)[1] == "ConsensusMap")){ stop("arg consensus_map_out wrong type") }
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqFourPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
    
        py_ans = private$py_obj$`_correctIsotopicImpurities_1`(consensus_map_in, consensus_map_out, quant_method)
        r_ans = IsobaricQuantifierStatistics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, TMTSixPlexQuantitationMethod * quant_method)
    correctIsotopicImpurities_2 = function(consensus_map_in, consensus_map_out, quant_method){
    
        if(!(is.R6(consensus_map_in) && class(consensus_map_in)[1] == "ConsensusMap")){ stop("arg consensus_map_in wrong type") }
        if(!(is.R6(consensus_map_out) && class(consensus_map_out)[1] == "ConsensusMap")){ stop("arg consensus_map_out wrong type") }
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTSixPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
    
        py_ans = private$py_obj$`_correctIsotopicImpurities_2`(consensus_map_in, consensus_map_out, quant_method)
        r_ans = IsobaricQuantifierStatistics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, TMTTenPlexQuantitationMethod * quant_method)
    correctIsotopicImpurities_3 = function(consensus_map_in, consensus_map_out, quant_method){
    
        if(!(is.R6(consensus_map_in) && class(consensus_map_in)[1] == "ConsensusMap")){ stop("arg consensus_map_in wrong type") }
        if(!(is.R6(consensus_map_out) && class(consensus_map_out)[1] == "ConsensusMap")){ stop("arg consensus_map_out wrong type") }
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTTenPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
    
        py_ans = private$py_obj$`_correctIsotopicImpurities_3`(consensus_map_in, consensus_map_out, quant_method)
        r_ans = IsobaricQuantifierStatistics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, ItraqEightPlexQuantitationMethod * quant_method)
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, ItraqFourPlexQuantitationMethod * quant_method)
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, TMTSixPlexQuantitationMethod * quant_method)
    # C++ signature: IsobaricQuantifierStatistics correctIsotopicImpurities(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out, TMTTenPlexQuantitationMethod * quant_method)
    correctIsotopicImpurities = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ItraqEightPlexQuantitationMethod")) { self$correctIsotopicImpurities_0(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ItraqFourPlexQuantitationMethod")) { self$correctIsotopicImpurities_1(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "TMTSixPlexQuantitationMethod")) { self$correctIsotopicImpurities_2(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "TMTTenPlexQuantitationMethod")) { self$correctIsotopicImpurities_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _IsobaricNormalizer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsobaricNormalizer.html
IsobaricNormalizer <- R6Class(classname = "IsobaricNormalizer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsobaricNormalizer(IsobaricNormalizer)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsobaricNormalizer")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricNormalizer(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricNormalizer(ItraqFourPlexQuantitationMethod * quant_method)
    init_1 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqFourPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricNormalizer(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricNormalizer(ItraqEightPlexQuantitationMethod * quant_method)
    init_2 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqEightPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricNormalizer(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricNormalizer(TMTSixPlexQuantitationMethod * quant_method)
    init_3 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTSixPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricNormalizer(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricNormalizer(TMTTenPlexQuantitationMethod * quant_method)
    init_4 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTTenPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricNormalizer(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricNormalizer(IsobaricNormalizer)
    # C++ signature: void IsobaricNormalizer(ItraqFourPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricNormalizer(ItraqEightPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricNormalizer(TMTSixPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricNormalizer(TMTTenPlexQuantitationMethod * quant_method)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsobaricNormalizer")) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqFourPlexQuantitationMethod")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqEightPlexQuantitationMethod")) { self$init_2(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTSixPlexQuantitationMethod")) { self$init_3(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTTenPlexQuantitationMethod")) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsobaricNormalizer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void normalize(ConsensusMap & consensus_map)
    normalize = function(consensus_map){
    
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
    
        private$py_obj$normalize(consensus_map)
        invisible()
    }
)
) 

# R implementation of _IsobaricQuantifier
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsobaricQuantifier.html
IsobaricQuantifier <- R6Class(classname = "IsobaricQuantifier",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsobaricQuantifier(IsobaricQuantifier)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsobaricQuantifier")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifier(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifier(ItraqFourPlexQuantitationMethod * quant_method)
    init_1 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqFourPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifier(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifier(ItraqEightPlexQuantitationMethod * quant_method)
    init_2 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "ItraqEightPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifier(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifier(TMTSixPlexQuantitationMethod * quant_method)
    init_3 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTSixPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifier(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifier(TMTTenPlexQuantitationMethod * quant_method)
    init_4 = function(quant_method){
    
        if(!(is.R6(quant_method) && class(quant_method)[1] == "TMTTenPlexQuantitationMethod")){ stop("arg quant_method wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifier(quant_method)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifier(IsobaricQuantifier)
    # C++ signature: void IsobaricQuantifier(ItraqFourPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricQuantifier(ItraqEightPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricQuantifier(TMTSixPlexQuantitationMethod * quant_method)
    # C++ signature: void IsobaricQuantifier(TMTTenPlexQuantitationMethod * quant_method)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsobaricQuantifier")) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqFourPlexQuantitationMethod")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqEightPlexQuantitationMethod")) { self$init_2(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTSixPlexQuantitationMethod")) { self$init_3(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTTenPlexQuantitationMethod")) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsobaricQuantifier" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void quantify(ConsensusMap & consensus_map_in, ConsensusMap & consensus_map_out)
    quantify = function(consensus_map_in, consensus_map_out){
    
        if(!(is.R6(consensus_map_in) && class(consensus_map_in)[1] == "ConsensusMap")){ stop("arg consensus_map_in wrong type") }
        if(!(is.R6(consensus_map_out) && class(consensus_map_out)[1] == "ConsensusMap")){ stop("arg consensus_map_out wrong type") }
    
    
        private$py_obj$quantify(consensus_map_in, consensus_map_out)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IsobaricQuantifierStatistics
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsobaricQuantifierStatistics.html
IsobaricQuantifierStatistics <- R6Class(classname = "IsobaricQuantifierStatistics",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        channel_count = function(channel_count){
    
        if(!missing(channel_count)){
            if(!( (is_scalar_integer(channel_count) || is_scalar_double(channel_count)) && channel_count == as.integer(channel_count))){ stop("arg channel_count wrong type") }
        
        
            private$py_obj$channel_count <- as.integer(channel_count)
            } else {
        
                py_ans = private$py_obj$channel_count
                r_result = py_ans
                return(r_result)
                }
        },
        iso_number_ms2_negative = function(iso_number_ms2_negative){
    
        if(!missing(iso_number_ms2_negative)){
            if(!( (is_scalar_integer(iso_number_ms2_negative) || is_scalar_double(iso_number_ms2_negative)) && iso_number_ms2_negative == as.integer(iso_number_ms2_negative))){ stop("arg iso_number_ms2_negative wrong type") }
        
        
            private$py_obj$iso_number_ms2_negative <- as.integer(iso_number_ms2_negative)
            } else {
        
                py_ans = private$py_obj$iso_number_ms2_negative
                r_result = py_ans
                return(r_result)
                }
        },
        iso_number_reporter_negative = function(iso_number_reporter_negative){
    
        if(!missing(iso_number_reporter_negative)){
            if(!( (is_scalar_integer(iso_number_reporter_negative) || is_scalar_double(iso_number_reporter_negative)) && iso_number_reporter_negative == as.integer(iso_number_reporter_negative))){ stop("arg iso_number_reporter_negative wrong type") }
        
        
            private$py_obj$iso_number_reporter_negative <- as.integer(iso_number_reporter_negative)
            } else {
        
                py_ans = private$py_obj$iso_number_reporter_negative
                r_result = py_ans
                return(r_result)
                }
        },
        iso_number_reporter_different = function(iso_number_reporter_different){
    
        if(!missing(iso_number_reporter_different)){
            if(!( (is_scalar_integer(iso_number_reporter_different) || is_scalar_double(iso_number_reporter_different)) && iso_number_reporter_different == as.integer(iso_number_reporter_different))){ stop("arg iso_number_reporter_different wrong type") }
        
        
            private$py_obj$iso_number_reporter_different <- as.integer(iso_number_reporter_different)
            } else {
        
                py_ans = private$py_obj$iso_number_reporter_different
                r_result = py_ans
                return(r_result)
                }
        },
        iso_solution_different_intensity = function(iso_solution_different_intensity){
    
        if(!missing(iso_solution_different_intensity)){
            if(!(is_scalar_double(iso_solution_different_intensity))){ stop("arg iso_solution_different_intensity wrong type") }
        
        
            private$py_obj$iso_solution_different_intensity <- iso_solution_different_intensity
            } else {
        
                py_ans = private$py_obj$iso_solution_different_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        iso_total_intensity_negative = function(iso_total_intensity_negative){
    
        if(!missing(iso_total_intensity_negative)){
            if(!(is_scalar_double(iso_total_intensity_negative))){ stop("arg iso_total_intensity_negative wrong type") }
        
        
            private$py_obj$iso_total_intensity_negative <- iso_total_intensity_negative
            } else {
        
                py_ans = private$py_obj$iso_total_intensity_negative
                r_result = py_ans
                return(r_result)
                }
        },
        number_ms2_total = function(number_ms2_total){
    
        if(!missing(number_ms2_total)){
            if(!( (is_scalar_integer(number_ms2_total) || is_scalar_double(number_ms2_total)) && number_ms2_total == as.integer(number_ms2_total))){ stop("arg number_ms2_total wrong type") }
        
        
            private$py_obj$number_ms2_total <- as.integer(number_ms2_total)
            } else {
        
                py_ans = private$py_obj$number_ms2_total
                r_result = py_ans
                return(r_result)
                }
        },
        number_ms2_empty = function(number_ms2_empty){
    
        if(!missing(number_ms2_empty)){
            if(!( (is_scalar_integer(number_ms2_empty) || is_scalar_double(number_ms2_empty)) && number_ms2_empty == as.integer(number_ms2_empty))){ stop("arg number_ms2_empty wrong type") }
        
        
            private$py_obj$number_ms2_empty <- as.integer(number_ms2_empty)
            } else {
        
                py_ans = private$py_obj$number_ms2_empty
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IsobaricQuantifierStatistics()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IsobaricQuantifierStatistics()
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifierStatistics(IsobaricQuantifierStatistics)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsobaricQuantifierStatistics")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsobaricQuantifierStatistics(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsobaricQuantifierStatistics()
    # C++ signature: void IsobaricQuantifierStatistics(IsobaricQuantifierStatistics)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsobaricQuantifierStatistics")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsobaricQuantifierStatistics" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void reset()
    reset = function(){
    
        private$py_obj$reset()
        invisible()
    }
)
) 

# R implementation of _IsotopeCluster
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeCluster.html
IsotopeCluster <- R6Class(classname = "IsotopeCluster",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        peaks = function(peaks){
    
        if(!missing(peaks)){
            if(!(is.R6(peaks) && class(peaks)[1] == "ChargedIndexSet")){ stop("arg peaks wrong type") }
        
        
            private$py_obj$peaks <- peaks
            } else {
        
                py_ans = private$py_obj$peaks
            r_result = ChargedIndexSet$new(py_ans)
                return(r_result)
                }
        },
        scans = function(scans){
    
        if(!missing(scans)){
            if(!(is_list(scans) && all(sapply(scans,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg scans wrong type") }
        
            v0 <- r_to_py(scans)
            private$py_obj$scans <- v0
            } else {
            
                py_ans = private$py_obj$scans
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IsotopeCluster()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IsotopeCluster) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IsotopeCluster()
        invisible()
    }
    
    }
)
) 

# R implementation of _IsotopeDiffFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeDiffFilter.html
IsotopeDiffFilter <- R6Class(classname = "IsotopeDiffFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeDiffFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IsotopeDiffFilter()
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeDiffFilter(IsotopeDiffFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsotopeDiffFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsotopeDiffFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeDiffFilter()
    # C++ signature: void IsotopeDiffFilter(IsotopeDiffFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsotopeDiffFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsotopeDiffFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IsotopeDistribution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeDistribution.html
IsotopeDistribution <- R6Class(classname = "IsotopeDistribution",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeDistribution()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IsotopeDistribution) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$IsotopeDistribution()
        invisible()
    }
    
    },
    
    # C++ signature: void set(libcpp_vector[Peak1D] & distribution)
    set = function(distribution){
    
        if(!(is_list(distribution) && all(sapply(distribution,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Peak1D")))){ stop("arg distribution wrong type") }
        v0 <- r_to_py(distribution)
        private$py_obj$set(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(distribution <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void insert(double mass, float intensity)
    insert = function(mass, intensity){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
    
    
        private$py_obj$insert(mass, intensity)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Peak1D] & getContainer()
    getContainer = function(){
    
        py_ans = private$py_obj$getContainer()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Peak1D getMostAbundant()
    getMostAbundant = function(){
    
        py_ans = private$py_obj$getMostAbundant()
        r_ans = Peak1D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void renormalize()
    renormalize = function(){
    
        private$py_obj$renormalize()
        invisible()
    },
    
    # C++ signature: void trimRight(double cutoff)
    trimRight = function(cutoff){
    
        if(!(is_scalar_double(cutoff))){ stop("arg cutoff wrong type") }
    
        private$py_obj$trimRight(cutoff)
        invisible()
    },
    
    # C++ signature: void trimLeft(double cutoff)
    trimLeft = function(cutoff){
    
        if(!(is_scalar_double(cutoff))){ stop("arg cutoff wrong type") }
    
        private$py_obj$trimLeft(cutoff)
        invisible()
    },
    
    # C++ signature: void merge(double, double)
    merge = function(in_0, in_1){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$merge(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void resize(unsigned int size)
    resize = function(size){
    
        if(!( (is_scalar_integer(size) || is_scalar_double(size)) && size == as.integer(size))){ stop("arg size wrong type") }
    
        private$py_obj$resize(as.integer(size))
        invisible()
    },
    
    # C++ signature: void trimIntensities(double cutoff)
    trimIntensities = function(cutoff){
    
        if(!(is_scalar_double(cutoff))){ stop("arg cutoff wrong type") }
    
        private$py_obj$trimIntensities(cutoff)
        invisible()
    },
    
    # C++ signature: void sortByIntensity()
    sortByIntensity = function(){
    
        private$py_obj$sortByIntensity()
        invisible()
    },
    
    # C++ signature: void sortByMass()
    sortByMass = function(){
    
        private$py_obj$sortByMass()
        invisible()
    },
    
    # C++ signature: double averageMass()
    averageMass = function(){
    
        py_ans = private$py_obj$averageMass()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IsotopeDistributionCache
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeDistributionCache.html
IsotopeDistributionCache <- R6Class(classname = "IsotopeDistributionCache",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeDistributionCache(double max_mass, double mass_window_width, double intensity_percentage, double intensity_percentage_optional)
    initialize = function(max_mass, mass_window_width, intensity_percentage, intensity_percentage_optional){
    
    if(missing(mass_window_width) && missing(intensity_percentage) && missing(intensity_percentage_optional)){
         if( "python.builtin.object" %in% class(max_mass) && class_to_wrap(max_mass) == IsotopeDistributionCache ) { private$py_obj <- max_mass }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(max_mass))){ stop("arg max_mass wrong type") }
        if(!(is_scalar_double(mass_window_width))){ stop("arg mass_window_width wrong type") }
        if(!(is_scalar_double(intensity_percentage))){ stop("arg intensity_percentage wrong type") }
        if(!(is_scalar_double(intensity_percentage_optional))){ stop("arg intensity_percentage_optional wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$IsotopeDistributionCache(max_mass, mass_window_width, intensity_percentage, intensity_percentage_optional)
        invisible()
    }
    
    },
    
    # C++ signature: TheoreticalIsotopePattern getIsotopeDistribution(double mass)
    getIsotopeDistribution = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        py_ans = private$py_obj$getIsotopeDistribution(mass)
        r_ans = TheoreticalIsotopePattern$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _IsotopeFitter1D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeFitter1D.html
IsotopeFitter1D <- R6Class(classname = "IsotopeFitter1D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeFitter1D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IsotopeFitter1D()
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeFitter1D(IsotopeFitter1D)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsotopeFitter1D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsotopeFitter1D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeFitter1D()
    # C++ signature: void IsotopeFitter1D(IsotopeFitter1D)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsotopeFitter1D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsotopeFitter1D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IsotopeMarker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeMarker.html
IsotopeMarker <- R6Class(classname = "IsotopeMarker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeMarker()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IsotopeMarker()
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeMarker(IsotopeMarker)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsotopeMarker")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsotopeMarker(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeMarker()
    # C++ signature: void IsotopeMarker(IsotopeMarker)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsotopeMarker")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsotopeMarker" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void apply(libcpp_map[double,bool] &, MSSpectrum &)
    apply = function(in_0, in_1){
    
        if(!(
          is.environment(in_0) && identical(parent.env(in_0), asNamespace("collections")) && identical(strsplit(capture.output(in_0$print())," ")[[1]][1], "dict")
          && all(sapply(in_0$keys(),function(k) is_scalar_double(k)))
          && all(sapply(in_0$values(),function(v)  (is_scalar_integer(v) || is_scalar_double(v)) && v == as.integer(v)))
          )){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSSpectrum")){ stop("arg in_1 wrong type") }
        v0 <- py_dict(in_0$keys(),as.integer(in_0$values()))
    
        private$py_obj$apply(v0, in_1)
        byref_0 <- collections::dict(py_to_r(py_builtin$list(v0$values())),py_to_r(py_builtin$list(v0$keys())))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _IsotopeModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeModel.html
IsotopeModel <- R6Class(classname = "IsotopeModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$IsotopeModel()
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeModel(IsotopeModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "IsotopeModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$IsotopeModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void IsotopeModel()
    # C++ signature: void IsotopeModel(IsotopeModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IsotopeModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "IsotopeModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: unsigned int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset(double offset)
    setOffset = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset(offset)
        invisible()
    },
    
    # C++ signature: double getOffset()
    getOffset = function(){
    
        py_ans = private$py_obj$getOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula()
    getFormula = function(){
    
        py_ans = private$py_obj$getFormula()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSamples(EmpiricalFormula & formula)
    setSamples = function(formula){
    
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
    
        private$py_obj$setSamples(formula)
        invisible()
    },
    
    # C++ signature: double getCenter()
    getCenter = function(){
    
        py_ans = private$py_obj$getCenter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: IsotopeDistribution getIsotopeDistribution()
    getIsotopeDistribution = function(){
    
        py_ans = private$py_obj$getIsotopeDistribution()
        r_ans = IsotopeDistribution$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _IsotopePattern
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::FeatureFinderAlgorithmPickedHelperStructs_1_1IsotopePattern.html
IsotopePattern <- R6Class(classname = "IsotopePattern",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        spectrum = function(spectrum){
    
        if(!missing(spectrum)){
            if(!(is_list(spectrum) && all(sapply(spectrum,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg spectrum wrong type") }
        
            v0 <- r_to_py(spectrum)
            private$py_obj$spectrum <- v0
            } else {
            
                py_ans = private$py_obj$spectrum
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_list(intensity) && all(sapply(intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity wrong type") }
        
            v0 <- r_to_py(intensity)
            private$py_obj$intensity <- v0
            } else {
            
                py_ans = private$py_obj$intensity
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        mz_score = function(mz_score){
    
        if(!missing(mz_score)){
            if(!(is_list(mz_score) && all(sapply(mz_score,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz_score wrong type") }
        
            v0 <- r_to_py(mz_score)
            private$py_obj$mz_score <- v0
            } else {
            
                py_ans = private$py_obj$mz_score
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        theoretical_mz = function(theoretical_mz){
    
        if(!missing(theoretical_mz)){
            if(!(is_list(theoretical_mz) && all(sapply(theoretical_mz,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg theoretical_mz wrong type") }
        
            v0 <- r_to_py(theoretical_mz)
            private$py_obj$theoretical_mz <- v0
            } else {
            
                py_ans = private$py_obj$theoretical_mz
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        theoretical_pattern = function(theoretical_pattern){
    
        if(!missing(theoretical_pattern)){
            if(!(is.R6(theoretical_pattern) && class(theoretical_pattern)[1] == "TheoreticalIsotopePattern")){ stop("arg theoretical_pattern wrong type") }
        
        
            private$py_obj$theoretical_pattern <- theoretical_pattern
            } else {
        
                py_ans = private$py_obj$theoretical_pattern
            r_result = TheoreticalIsotopePattern$new(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void IsotopePattern(size_t size)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == IsotopePattern) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!( (is_scalar_integer(size) || is_scalar_double(size)) && size == as.integer(size))){ stop("arg size wrong type") }
    
    
        private$py_obj <- Pymod$IsotopePattern(as.integer(size))
        invisible()
    }
    
    }
)
) 

# R implementation of _IsotopeWavelet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeWavelet.html
IsotopeWavelet <- R6Class(classname = "IsotopeWavelet",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void destroy()
    destroy = function(){
    
        private$py_obj$destroy()
        invisible()
    },
    
    # C++ signature: double getValueByMass(double t, double m, unsigned int z, int mode)
    getValueByMass = function(t, m, z, mode){
    
        if(!(is_scalar_double(t))){ stop("arg t wrong type") }
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
        if(!( (is_scalar_integer(z) || is_scalar_double(z)) && z == as.integer(z))){ stop("arg z wrong type") }
        if(!( (is_scalar_integer(mode) || is_scalar_double(mode)) && mode == as.integer(mode))){ stop("arg mode wrong type") }
    
    
    
    
        py_ans = private$py_obj$getValueByMass(t, m, as.integer(z), as.integer(mode))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getValueByLambda(double lambda_, double tz1)
    getValueByLambda = function(lambda_, tz1){
    
        if(!(is_scalar_double(lambda_))){ stop("arg lambda_ wrong type") }
        if(!(is_scalar_double(tz1))){ stop("arg tz1 wrong type") }
    
    
        py_ans = private$py_obj$getValueByLambda(lambda_, tz1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getValueByLambdaExtrapol(double lambda_, double tz1)
    getValueByLambdaExtrapol = function(lambda_, tz1){
    
        if(!(is_scalar_double(lambda_))){ stop("arg lambda_ wrong type") }
        if(!(is_scalar_double(tz1))){ stop("arg tz1 wrong type") }
    
    
        py_ans = private$py_obj$getValueByLambdaExtrapol(lambda_, tz1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getValueByLambdaExact(double lambda_, double tz1)
    getValueByLambdaExact = function(lambda_, tz1){
    
        if(!(is_scalar_double(lambda_))){ stop("arg lambda_ wrong type") }
        if(!(is_scalar_double(tz1))){ stop("arg tz1 wrong type") }
    
    
        py_ans = private$py_obj$getValueByLambdaExact(lambda_, tz1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getMaxCharge()
    getMaxCharge = function(){
    
        py_ans = private$py_obj$getMaxCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxCharge(unsigned int max_charge)
    setMaxCharge = function(max_charge){
    
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
    
        private$py_obj$setMaxCharge(as.integer(max_charge))
        invisible()
    },
    
    # C++ signature: double getTableSteps()
    getTableSteps = function(){
    
        py_ans = private$py_obj$getTableSteps()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getInvTableSteps()
    getInvTableSteps = function(){
    
        py_ans = private$py_obj$getInvTableSteps()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTableSteps(double table_steps)
    setTableSteps = function(table_steps){
    
        if(!(is_scalar_double(table_steps))){ stop("arg table_steps wrong type") }
    
        private$py_obj$setTableSteps(table_steps)
        invisible()
    },
    
    # C++ signature: double getLambdaL(double m)
    getLambdaL = function(m){
    
        if(!(is_scalar_double(m))){ stop("arg m wrong type") }
    
        py_ans = private$py_obj$getLambdaL(m)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getGammaTableMaxIndex()
    getGammaTableMaxIndex = function(){
    
        py_ans = private$py_obj$getGammaTableMaxIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getExpTableMaxIndex()
    getExpTableMaxIndex = function(){
    
        py_ans = private$py_obj$getExpTableMaxIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float myPow(float a, float b)
    myPow = function(a, b){
    
        if(!(is_scalar_double(a))){ stop("arg a wrong type") }
        if(!(is_scalar_double(b))){ stop("arg b wrong type") }
    
    
        py_ans = private$py_obj$myPow(a, b)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getMzPeakCutOffAtMonoPos(double mass, unsigned int z)
    getMzPeakCutOffAtMonoPos = function(mass, z){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!( (is_scalar_integer(z) || is_scalar_double(z)) && z == as.integer(z))){ stop("arg z wrong type") }
    
    
        py_ans = private$py_obj$getMzPeakCutOffAtMonoPos(mass, as.integer(z))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumPeakCutOff(double mass, unsigned int z)
    getNumPeakCutOff_0 = function(mass, z){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!( (is_scalar_integer(z) || is_scalar_double(z)) && z == as.integer(z))){ stop("arg z wrong type") }
    
    
        py_ans = private$py_obj$`_getNumPeakCutOff_0`(mass, as.integer(z))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumPeakCutOff(double mz)
    getNumPeakCutOff_1 = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$`_getNumPeakCutOff_1`(mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getNumPeakCutOff(double mass, unsigned int z)
    # C++ signature: unsigned int getNumPeakCutOff(double mz)
    getNumPeakCutOff = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getNumPeakCutOff_0(...) }
        else if ((length(arg_list)==1) && (is_scalar_double(arg_list[[1]]))) { self$getNumPeakCutOff_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _IsotopeWaveletTransform[_Peak1D]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1IsotopeWaveletTransform[_Peak1D].html
IsotopeWaveletTransform <- R6Class(classname = "IsotopeWaveletTransform",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void IsotopeWaveletTransform(double min_mz, double max_mz, unsigned int max_charge, size_t max_scan_size, bool hr_data, String intenstype)
    initialize = function(min_mz, max_mz, max_charge, max_scan_size, hr_data, intenstype){
    
    if(missing(max_mz) && missing(max_charge) && missing(max_scan_size) && missing(hr_data) && missing(intenstype)){
         if( "python.builtin.object" %in% class(min_mz) && class_to_wrap(min_mz) == IsotopeWaveletTransform ) { private$py_obj <- min_mz }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(min_mz))){ stop("arg min_mz wrong type") }
        if(!(is_scalar_double(max_mz))){ stop("arg max_mz wrong type") }
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
        if(!( (is_scalar_integer(max_scan_size) || is_scalar_double(max_scan_size)) && max_scan_size == as.integer(max_scan_size))){ stop("arg max_scan_size wrong type") }
        if(!( (is_scalar_integer(hr_data) || is_scalar_double(hr_data)) && hr_data == as.integer(hr_data))){ stop("arg hr_data wrong type") }
        if(!((is.R6(intenstype) && class(intenstype)[1]=="String") || is_scalar_character(intenstype))){ stop("arg intenstype wrong type") }
    
    
    
    
    
    
    
        private$py_obj <- Pymod$IsotopeWaveletTransform(min_mz, max_mz, as.integer(max_charge), as.integer(max_scan_size), as.integer(hr_data), intenstype)
        invisible()
    }
    
    },
    
    # C++ signature: void getTransform(MSSpectrum & c_trans, MSSpectrum & c_ref, unsigned int c)
    getTransform = function(c_trans, c_ref, c){
    
        if(!(is.R6(c_trans) && class(c_trans)[1] == "MSSpectrum")){ stop("arg c_trans wrong type") }
        if(!(is.R6(c_ref) && class(c_ref)[1] == "MSSpectrum")){ stop("arg c_ref wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
    
        private$py_obj$getTransform(c_trans, c_ref, as.integer(c))
        invisible()
    },
    
    # C++ signature: void getTransformHighRes(MSSpectrum & c_trans, MSSpectrum & c_ref, unsigned int c)
    getTransformHighRes = function(c_trans, c_ref, c){
    
        if(!(is.R6(c_trans) && class(c_trans)[1] == "MSSpectrum")){ stop("arg c_trans wrong type") }
        if(!(is.R6(c_ref) && class(c_ref)[1] == "MSSpectrum")){ stop("arg c_ref wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
    
        private$py_obj$getTransformHighRes(c_trans, c_ref, as.integer(c))
        invisible()
    },
    
    # C++ signature: void identifyCharge(MSSpectrum & candidates, MSSpectrum & ref, unsigned int scan_index, unsigned int c, double ampl_cutoff, bool check_PPMs)
    identifyCharge = function(candidates, ref, scan_index, c, ampl_cutoff, check_PPMs){
    
        if(!(is.R6(candidates) && class(candidates)[1] == "MSSpectrum")){ stop("arg candidates wrong type") }
        if(!(is.R6(ref) && class(ref)[1] == "MSSpectrum")){ stop("arg ref wrong type") }
        if(!( (is_scalar_integer(scan_index) || is_scalar_double(scan_index)) && scan_index == as.integer(scan_index))){ stop("arg scan_index wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
        if(!(is_scalar_double(ampl_cutoff))){ stop("arg ampl_cutoff wrong type") }
        if(!( (is_scalar_integer(check_PPMs) || is_scalar_double(check_PPMs)) && check_PPMs == as.integer(check_PPMs))){ stop("arg check_PPMs wrong type") }
    
    
    
    
    
    
        private$py_obj$identifyCharge(candidates, ref, as.integer(scan_index), as.integer(c), ampl_cutoff, as.integer(check_PPMs))
        invisible()
    },
    
    # C++ signature: void initializeScan(MSSpectrum & c_ref, unsigned int c)
    initializeScan = function(c_ref, c){
    
        if(!(is.R6(c_ref) && class(c_ref)[1] == "MSSpectrum")){ stop("arg c_ref wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
        private$py_obj$initializeScan(c_ref, as.integer(c))
        invisible()
    },
    
    # C++ signature: void updateBoxStates(MSExperiment & map_, size_t scan_index, unsigned int RT_interleave, unsigned int RT_votes_cutoff, int front_bound, int end_bound)
    updateBoxStates = function(map_, scan_index, RT_interleave, RT_votes_cutoff, front_bound, end_bound){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
        if(!( (is_scalar_integer(scan_index) || is_scalar_double(scan_index)) && scan_index == as.integer(scan_index))){ stop("arg scan_index wrong type") }
        if(!( (is_scalar_integer(RT_interleave) || is_scalar_double(RT_interleave)) && RT_interleave == as.integer(RT_interleave))){ stop("arg RT_interleave wrong type") }
        if(!( (is_scalar_integer(RT_votes_cutoff) || is_scalar_double(RT_votes_cutoff)) && RT_votes_cutoff == as.integer(RT_votes_cutoff))){ stop("arg RT_votes_cutoff wrong type") }
        if(!( (is_scalar_integer(front_bound) || is_scalar_double(front_bound)) && front_bound == as.integer(front_bound))){ stop("arg front_bound wrong type") }
        if(!( (is_scalar_integer(end_bound) || is_scalar_double(end_bound)) && end_bound == as.integer(end_bound))){ stop("arg end_bound wrong type") }
    
    
    
    
    
    
        private$py_obj$updateBoxStates(map_, as.integer(scan_index), as.integer(RT_interleave), as.integer(RT_votes_cutoff), as.integer(front_bound), as.integer(end_bound))
        invisible()
    },
    
    # C++ signature: FeatureMap mapSeeds2Features(MSExperiment & map_, unsigned int RT_votes_cutoff)
    mapSeeds2Features = function(map_, RT_votes_cutoff){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
        if(!( (is_scalar_integer(RT_votes_cutoff) || is_scalar_double(RT_votes_cutoff)) && RT_votes_cutoff == as.integer(RT_votes_cutoff))){ stop("arg RT_votes_cutoff wrong type") }
    
    
        py_ans = private$py_obj$mapSeeds2Features(map_, as.integer(RT_votes_cutoff))
        r_ans = FeatureMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getLinearInterpolation(double mz_a, double intens_a, double mz_pos, double mz_b, double intens_b)
    getLinearInterpolation = function(mz_a, intens_a, mz_pos, mz_b, intens_b){
    
        if(!(is_scalar_double(mz_a))){ stop("arg mz_a wrong type") }
        if(!(is_scalar_double(intens_a))){ stop("arg intens_a wrong type") }
        if(!(is_scalar_double(mz_pos))){ stop("arg mz_pos wrong type") }
        if(!(is_scalar_double(mz_b))){ stop("arg mz_b wrong type") }
        if(!(is_scalar_double(intens_b))){ stop("arg intens_b wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$getLinearInterpolation(mz_a, intens_a, mz_pos, mz_b, intens_b)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getSigma()
    getSigma = function(){
    
        py_ans = private$py_obj$getSigma()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSigma(double sigma)
    setSigma = function(sigma){
    
        if(!(is_scalar_double(sigma))){ stop("arg sigma wrong type") }
    
        private$py_obj$setSigma(sigma)
        invisible()
    },
    
    # C++ signature: void computeMinSpacing(MSSpectrum & c_ref)
    computeMinSpacing = function(c_ref){
    
        if(!(is.R6(c_ref) && class(c_ref)[1] == "MSSpectrum")){ stop("arg c_ref wrong type") }
    
        private$py_obj$computeMinSpacing(c_ref)
        invisible()
    },
    
    # C++ signature: double getMinSpacing()
    getMinSpacing = function(){
    
        py_ans = private$py_obj$getMinSpacing()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getMaxScanSize()
    getMaxScanSize = function(){
    
        py_ans = private$py_obj$getMaxScanSize()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ItraqConstants
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ItraqConstants.html
ItraqConstants <- R6Class(classname = "ItraqConstants",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ItraqConstants()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ItraqConstants) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ItraqConstants()
        invisible()
    }
    
    },
    
    # C++ signature: StringList getIsotopeMatrixAsStringList(int itraq_type, libcpp_vector[MatrixDouble] & isotope_corrections)
    getIsotopeMatrixAsStringList = function(itraq_type, isotope_corrections){
    
        if(!( (is_scalar_integer(itraq_type) || is_scalar_double(itraq_type)) && itraq_type == as.integer(itraq_type))){ stop("arg itraq_type wrong type") }
        if(!(is_list(isotope_corrections) && all(sapply(isotope_corrections,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MatrixDouble")))){ stop("arg isotope_corrections wrong type") }
    
        v1 <- r_to_py(isotope_corrections)
        py_ans = private$py_obj$getIsotopeMatrixAsStringList(as.integer(itraq_type), v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = modify_depth(py_ans,1,as.character)
    
        tryCatch({
        eval.parent(substitute(isotope_corrections <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void updateIsotopeMatrixFromStringList(int itraq_type, StringList & channels, libcpp_vector[MatrixDouble] & isotope_corrections)
    updateIsotopeMatrixFromStringList = function(itraq_type, channels, isotope_corrections){
    
        if(!( (is_scalar_integer(itraq_type) || is_scalar_double(itraq_type)) && itraq_type == as.integer(itraq_type))){ stop("arg itraq_type wrong type") }
        if(!(is_list(channels) && all(sapply(channels),is_scalar_character))){ stop("arg channels wrong type") }
        if(!(is_list(isotope_corrections) && all(sapply(isotope_corrections,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MatrixDouble")))){ stop("arg isotope_corrections wrong type") }
    
        v1 = r_to_py(modify_depth(channels,1,py_builtin$bytes(channels,'utf-8')))
        v2 <- r_to_py(isotope_corrections)
        private$py_obj$updateIsotopeMatrixFromStringList(as.integer(itraq_type), v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
    
        tryCatch({
        eval.parent(substitute(channels <- byref_1))
        eval.parent(substitute(isotope_corrections <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: MatrixDouble translateIsotopeMatrix(int & itraq_type, libcpp_vector[MatrixDouble] & isotope_corrections)
    translateIsotopeMatrix = function(itraq_type, isotope_corrections){
    
        if(!( (is_scalar_integer(itraq_type) || is_scalar_double(itraq_type)) && itraq_type == as.integer(itraq_type))){ stop("arg itraq_type wrong type") }
        if(!(is_list(isotope_corrections) && all(sapply(isotope_corrections,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MatrixDouble")))){ stop("arg isotope_corrections wrong type") }
    
        v1 <- r_to_py(isotope_corrections)
        py_ans = private$py_obj$translateIsotopeMatrix(as.integer(itraq_type), v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = MatrixDouble$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(isotope_corrections <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _ItraqEightPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ItraqEightPlexQuantitationMethod.html
ItraqEightPlexQuantitationMethod <- R6Class(classname = "ItraqEightPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ItraqEightPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ItraqEightPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void ItraqEightPlexQuantitationMethod(ItraqEightPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ItraqEightPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ItraqEightPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ItraqEightPlexQuantitationMethod()
    # C++ signature: void ItraqEightPlexQuantitationMethod(ItraqEightPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqEightPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ItraqEightPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ItraqFourPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ItraqFourPlexQuantitationMethod.html
ItraqFourPlexQuantitationMethod <- R6Class(classname = "ItraqFourPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ItraqFourPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ItraqFourPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void ItraqFourPlexQuantitationMethod(ItraqFourPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ItraqFourPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ItraqFourPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ItraqFourPlexQuantitationMethod()
    # C++ signature: void ItraqFourPlexQuantitationMethod(ItraqFourPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ItraqFourPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ItraqFourPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _JavaInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1JavaInfo.html
JavaInfo <- R6Class(classname = "JavaInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void JavaInfo()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == JavaInfo) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$JavaInfo()
        invisible()
    }
    
    },
    
    # C++ signature: bool canRun(String java_executable)
    canRun = function(java_executable){
    
        if(!((is.R6(java_executable) && class(java_executable)[1]=="String") || is_scalar_character(java_executable))){ stop("arg java_executable wrong type") }
    
        py_ans = private$py_obj$canRun(java_executable)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _KDTreeFeatureMaps
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1KDTreeFeatureMaps.html
KDTreeFeatureMaps <- R6Class(classname = "KDTreeFeatureMaps",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void KDTreeFeatureMaps()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$KDTreeFeatureMaps()
        invisible()
    
    
    },
    
    # C++ signature: void KDTreeFeatureMaps(libcpp_vector[FeatureMap] & maps, Param & param)
    init_1 = function(maps, param){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
        v0 <- r_to_py(maps)
    
    
        private$py_obj <- Pymod$KDTreeFeatureMaps(v0, param)
        invisible()
    
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void KDTreeFeatureMaps(libcpp_vector[ConsensusMap] & maps, Param & param)
    init_2 = function(maps, param){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
        v0 <- r_to_py(maps)
    
    
        private$py_obj <- Pymod$KDTreeFeatureMaps(v0, param)
        invisible()
    
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void KDTreeFeatureMaps()
    # C++ signature: void KDTreeFeatureMaps(libcpp_vector[FeatureMap] & maps, Param & param)
    # C++ signature: void KDTreeFeatureMaps(libcpp_vector[ConsensusMap] & maps, Param & param)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Param")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Param")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "KDTreeFeatureMaps" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void addMaps(libcpp_vector[FeatureMap] & maps)
    addMaps_0 = function(maps){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg maps wrong type") }
        v0 <- r_to_py(maps)
        private$py_obj$`_addMaps_0`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addMaps(libcpp_vector[ConsensusMap] & maps)
    addMaps_1 = function(maps){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg maps wrong type") }
        v0 <- r_to_py(maps)
        private$py_obj$`_addMaps_1`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addMaps(libcpp_vector[FeatureMap] & maps)
    # C++ signature: void addMaps(libcpp_vector[ConsensusMap] & maps)
    addMaps = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))) { self$addMaps_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))) { self$addMaps_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double rt(size_t i)
    rt = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$rt(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double mz(size_t i)
    mz = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$mz(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float intensity(size_t i)
    intensity = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$intensity(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int charge(size_t i)
    charge = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$charge(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t mapIndex(size_t i)
    mapIndex = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$mapIndex(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t treeSize()
    treeSize = function(){
    
        py_ans = private$py_obj$treeSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t numMaps()
    numMaps = function(){
    
        py_ans = private$py_obj$numMaps()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void optimizeTree()
    optimizeTree = function(){
    
        private$py_obj$optimizeTree()
        invisible()
    },
    
    # C++ signature: void getNeighborhood(size_t index, libcpp_vector[size_t] & result_indices, double rt_tol, double mz_tol, bool mz_ppm, bool include_features_from_same_map, double max_pairwise_log_fc)
    getNeighborhood = function(index, result_indices, rt_tol, mz_tol, mz_ppm, include_features_from_same_map, max_pairwise_log_fc){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_list(result_indices) && all(sapply(result_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg result_indices wrong type") }
        if(!(is_scalar_double(rt_tol))){ stop("arg rt_tol wrong type") }
        if(!(is_scalar_double(mz_tol))){ stop("arg mz_tol wrong type") }
        if(!( (is_scalar_integer(mz_ppm) || is_scalar_double(mz_ppm)) && mz_ppm == as.integer(mz_ppm))){ stop("arg mz_ppm wrong type") }
        if(!( (is_scalar_integer(include_features_from_same_map) || is_scalar_double(include_features_from_same_map)) && include_features_from_same_map == as.integer(include_features_from_same_map))){ stop("arg include_features_from_same_map wrong type") }
        if(!(is_scalar_double(max_pairwise_log_fc))){ stop("arg max_pairwise_log_fc wrong type") }
    
        v1 <- r_to_py(result_indices)
    
    
    
    
    
        private$py_obj$getNeighborhood(as.integer(index), v1, rt_tol, mz_tol, as.integer(mz_ppm), as.integer(include_features_from_same_map), max_pairwise_log_fc)
        byref_1 <- py_to_r(v1)
    
        tryCatch({
        eval.parent(substitute(result_indices <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void queryRegion(double rt_low, double rt_high, double mz_low, double mz_high, libcpp_vector[size_t] & result_indices, size_t ignored_map_index)
    queryRegion = function(rt_low, rt_high, mz_low, mz_high, result_indices, ignored_map_index){
    
        if(!(is_scalar_double(rt_low))){ stop("arg rt_low wrong type") }
        if(!(is_scalar_double(rt_high))){ stop("arg rt_high wrong type") }
        if(!(is_scalar_double(mz_low))){ stop("arg mz_low wrong type") }
        if(!(is_scalar_double(mz_high))){ stop("arg mz_high wrong type") }
        if(!(is_list(result_indices) && all(sapply(result_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg result_indices wrong type") }
        if(!( (is_scalar_integer(ignored_map_index) || is_scalar_double(ignored_map_index)) && ignored_map_index == as.integer(ignored_map_index))){ stop("arg ignored_map_index wrong type") }
    
    
    
    
        v4 <- r_to_py(result_indices)
    
        private$py_obj$queryRegion(rt_low, rt_high, mz_low, mz_high, v4, as.integer(ignored_map_index))
        byref_4 <- py_to_r(v4)
    
        tryCatch({
        eval.parent(substitute(result_indices <- byref_4))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _KDTreeFeatureNode
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1KDTreeFeatureNode.html
KDTreeFeatureNode <- R6Class(classname = "KDTreeFeatureNode",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void KDTreeFeatureNode(KDTreeFeatureNode)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "KDTreeFeatureNode")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$KDTreeFeatureNode(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void KDTreeFeatureNode(KDTreeFeatureMaps * data, size_t idx)
    init_1 = function(data, idx){
    
        if(!(is.R6(data) && class(data)[1] == "KDTreeFeatureMaps")){ stop("arg data wrong type") }
        if(!( (is_scalar_integer(idx) || is_scalar_double(idx)) && idx == as.integer(idx))){ stop("arg idx wrong type") }
    
    
    
        private$py_obj <- Pymod$KDTreeFeatureNode(data, as.integer(idx))
        invisible()
    
    
    },
    
    # C++ signature: void KDTreeFeatureNode(KDTreeFeatureNode)
    # C++ signature: void KDTreeFeatureNode(KDTreeFeatureMaps * data, size_t idx)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "KDTreeFeatureNode")) { self$init_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "KDTreeFeatureMaps") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "KDTreeFeatureNode" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t getIndex()
    getIndex = function(){
    
        py_ans = private$py_obj$getIndex()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _Kernel_MassTrace
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Kernel_MassTrace.html
Kernel_MassTrace <- R6Class(classname = "Kernel_MassTrace",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        fwhm_mz_avg = function(fwhm_mz_avg){
    
        if(!missing(fwhm_mz_avg)){
            if(!(is_scalar_double(fwhm_mz_avg))){ stop("arg fwhm_mz_avg wrong type") }
        
        
            private$py_obj$fwhm_mz_avg <- fwhm_mz_avg
            } else {
        
                py_ans = private$py_obj$fwhm_mz_avg
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Kernel_MassTrace()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Kernel_MassTrace()
        invisible()
    
    
    },
    
    # C++ signature: void Kernel_MassTrace(Kernel_MassTrace &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Kernel_MassTrace")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Kernel_MassTrace(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Kernel_MassTrace()
    # C++ signature: void Kernel_MassTrace(Kernel_MassTrace &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Kernel_MassTrace")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Kernel_MassTrace" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t getSize()
    getSize = function(){
    
        py_ans = private$py_obj$getSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getLabel()
    getLabel = function(){
    
        py_ans = private$py_obj$getLabel()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLabel(String label)
    setLabel = function(label){
    
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
        private$py_obj$setLabel(label)
        invisible()
    },
    
    # C++ signature: double getCentroidMZ()
    getCentroidMZ = function(){
    
        py_ans = private$py_obj$getCentroidMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCentroidRT()
    getCentroidRT = function(){
    
        py_ans = private$py_obj$getCentroidRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCentroidSD()
    getCentroidSD = function(){
    
        py_ans = private$py_obj$getCentroidSD()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getFWHM()
    getFWHM = function(){
    
        py_ans = private$py_obj$getFWHM()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getTraceLength()
    getTraceLength = function(){
    
        py_ans = private$py_obj$getTraceLength()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_pair[size_t,size_t] getFWHMborders()
    getFWHMborders = function(){
    
        py_ans = private$py_obj$getFWHMborders()
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getSmoothedIntensities()
    getSmoothedIntensities = function(){
    
        py_ans = private$py_obj$getSmoothedIntensities()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: double getAverageMS1CycleTime()
    getAverageMS1CycleTime = function(){
    
        py_ans = private$py_obj$getAverageMS1CycleTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeSmoothedPeakArea()
    computeSmoothedPeakArea = function(){
    
        py_ans = private$py_obj$computeSmoothedPeakArea()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computePeakArea()
    computePeakArea = function(){
    
        py_ans = private$py_obj$computePeakArea()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findMaxByIntPeak(bool)
    findMaxByIntPeak = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$findMaxByIntPeak(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t estimateFWHM(bool)
    estimateFWHM = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$estimateFWHM(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeFwhmArea()
    computeFwhmArea = function(){
    
        py_ans = private$py_obj$computeFwhmArea()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeFwhmAreaSmooth()
    computeFwhmAreaSmooth = function(){
    
        py_ans = private$py_obj$computeFwhmAreaSmooth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getIntensity(bool)
    getIntensity = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getIntensity(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxIntensity(bool)
    getMaxIntensity = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMaxIntensity(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: ConvexHull2D getConvexhull()
    getConvexhull = function(){
    
        py_ans = private$py_obj$getConvexhull()
        r_ans = ConvexHull2D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setCentroidSD(double & tmp_sd)
    setCentroidSD = function(tmp_sd){
    
        if(!(is_scalar_double(tmp_sd))){ stop("arg tmp_sd wrong type") }
    
        private$py_obj$setCentroidSD(tmp_sd)
        invisible()
    },
    
    # C++ signature: void setSmoothedIntensities(libcpp_vector[double] & db_vec)
    setSmoothedIntensities = function(db_vec){
    
        if(!(is_list(db_vec) && all(sapply(db_vec,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg db_vec wrong type") }
        v0 <- r_to_py(db_vec)
        private$py_obj$setSmoothedIntensities(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(db_vec <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void updateSmoothedMaxRT()
    updateSmoothedMaxRT = function(){
    
        private$py_obj$updateSmoothedMaxRT()
        invisible()
    },
    
    # C++ signature: void updateWeightedMeanRT()
    updateWeightedMeanRT = function(){
    
        private$py_obj$updateWeightedMeanRT()
        invisible()
    },
    
    # C++ signature: void updateSmoothedWeightedMeanRT()
    updateSmoothedWeightedMeanRT = function(){
    
        private$py_obj$updateSmoothedWeightedMeanRT()
        invisible()
    },
    
    # C++ signature: void updateMedianRT()
    updateMedianRT = function(){
    
        private$py_obj$updateMedianRT()
        invisible()
    },
    
    # C++ signature: void updateMedianMZ()
    updateMedianMZ = function(){
    
        private$py_obj$updateMedianMZ()
        invisible()
    },
    
    # C++ signature: void updateMeanMZ()
    updateMeanMZ = function(){
    
        private$py_obj$updateMeanMZ()
        invisible()
    },
    
    # C++ signature: void updateWeightedMeanMZ()
    updateWeightedMeanMZ = function(){
    
        private$py_obj$updateWeightedMeanMZ()
        invisible()
    },
    
    # C++ signature: void updateWeightedMZsd()
    updateWeightedMZsd = function(){
    
        private$py_obj$updateWeightedMZsd()
        invisible()
    },
    
    # C++ signature: void setQuantMethod(MT_QUANTMETHOD method)
    setQuantMethod = function(method){
    
        if(!(method %in% c(0, 1, 2))){ stop("arg method wrong type") }
    
        private$py_obj$setQuantMethod(as.integer(method))
        invisible()
    },
    
    # C++ signature: MT_QUANTMETHOD getQuantMethod()
    getQuantMethod = function(){
    
        py_ans = private$py_obj$getQuantMethod()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _KroenikFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1KroenikFile.html
KroenikFile <- R6Class(classname = "KroenikFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void KroenikFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == KroenikFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$KroenikFile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(String filename, MSSpectrum & spectrum)
    store = function(filename, spectrum){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
    
        private$py_obj$store(filename, spectrum)
        invisible()
    },
    
    # C++ signature: void load(String filename, FeatureMap & feature_map)
    load = function(filename, feature_map){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(feature_map) && class(feature_map)[1] == "FeatureMap")){ stop("arg feature_map wrong type") }
    
    
        private$py_obj$load(filename, feature_map)
        invisible()
    }
)
) 

# R implementation of _LLMParam
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LLMParam.html
LLMParam <- R6Class(classname = "LLMParam",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        xdim = function(xdim){
    
        if(!missing(xdim)){
            if(!( (is_scalar_integer(xdim) || is_scalar_double(xdim)) && xdim == as.integer(xdim))){ stop("arg xdim wrong type") }
        
        
            private$py_obj$xdim <- as.integer(xdim)
            } else {
        
                py_ans = private$py_obj$xdim
                r_result = py_ans
                return(r_result)
                }
        },
        ydim = function(ydim){
    
        if(!missing(ydim)){
            if(!( (is_scalar_integer(ydim) || is_scalar_double(ydim)) && ydim == as.integer(ydim))){ stop("arg ydim wrong type") }
        
        
            private$py_obj$ydim <- as.integer(ydim)
            } else {
        
                py_ans = private$py_obj$ydim
                r_result = py_ans
                return(r_result)
                }
        },
        radius = function(radius){
    
        if(!missing(radius)){
            if(!(is_scalar_double(radius))){ stop("arg radius wrong type") }
        
        
            private$py_obj$radius <- radius
            } else {
        
                py_ans = private$py_obj$radius
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LLMParam()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LLMParam) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LLMParam()
        invisible()
    }
    
    }
)
) 

# R implementation of _LPWrapper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LPWrapper.html
LPWrapper <- R6Class(classname = "LPWrapper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LPWrapper()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LPWrapper) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LPWrapper()
        invisible()
    }
    
    },
    
    # C++ signature: int addRow(libcpp_vector[int] row_indices, libcpp_vector[double] row_values, const String & name)
    addRow_0 = function(row_indices, row_values, name){
    
        if(!(is_list(row_indices) && all(sapply(row_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg row_indices wrong type") }
        if(!(is_list(row_values) && all(sapply(row_values,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg row_values wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        v0 <- r_to_py(modify_depth(row_indices,1,as.integer))
        v1 <- r_to_py(row_values)
    
        py_ans = private$py_obj$`_addRow_0`(v0, v1, name)
        
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int addRow(libcpp_vector[int] & row_indices, libcpp_vector[double] & row_values, const String & name, double lower_bound, double upper_bound, LPWrapper_Type type_)
    addRow_1 = function(row_indices, row_values, name, lower_bound, upper_bound, type_){
    
        if(!(is_list(row_indices) && all(sapply(row_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg row_indices wrong type") }
        if(!(is_list(row_values) && all(sapply(row_values,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg row_values wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_scalar_double(lower_bound))){ stop("arg lower_bound wrong type") }
        if(!(is_scalar_double(upper_bound))){ stop("arg upper_bound wrong type") }
        if(!(type_ %in% c(0, 1, 2, 3, 4))){ stop("arg type_ wrong type") }
        v0 <- r_to_py(modify_depth(row_indices,1,as.integer))
        v1 <- r_to_py(row_values)
    
    
    
    
        py_ans = private$py_obj$`_addRow_1`(v0, v1, name, lower_bound, upper_bound, as.integer(type_))
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(row_indices <- byref_0))
        eval.parent(substitute(row_values <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: int addRow(libcpp_vector[int] row_indices, libcpp_vector[double] row_values, const String & name)
    # C++ signature: int addRow(libcpp_vector[int] & row_indices, libcpp_vector[double] & row_values, const String & name, double lower_bound, double upper_bound, LPWrapper_Type type_)
    addRow = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$addRow_0(...) }
        else if ((length(arg_list)==6) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]])) && (arg_list[[6]] %in% c(0, 1, 2, 3, 4))) { self$addRow_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: int addColumn()
    addColumn_0 = function(){
    
        py_ans = private$py_obj$`_addColumn_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int addColumn(libcpp_vector[int] column_indices, libcpp_vector[double] column_values, const String & name)
    addColumn_1 = function(column_indices, column_values, name){
    
        if(!(is_list(column_indices) && all(sapply(column_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg column_indices wrong type") }
        if(!(is_list(column_values) && all(sapply(column_values,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg column_values wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        v0 <- r_to_py(modify_depth(column_indices,1,as.integer))
        v1 <- r_to_py(column_values)
    
        py_ans = private$py_obj$`_addColumn_1`(v0, v1, name)
        
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int addColumn(libcpp_vector[int] & column_indices, libcpp_vector[double] & column_values, const String & name, double lower_bound, double upper_bound, LPWrapper_Type type_)
    addColumn_2 = function(column_indices, column_values, name, lower_bound, upper_bound, type_){
    
        if(!(is_list(column_indices) && all(sapply(column_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg column_indices wrong type") }
        if(!(is_list(column_values) && all(sapply(column_values,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg column_values wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_scalar_double(lower_bound))){ stop("arg lower_bound wrong type") }
        if(!(is_scalar_double(upper_bound))){ stop("arg upper_bound wrong type") }
        if(!(type_ %in% c(0, 1, 2, 3, 4))){ stop("arg type_ wrong type") }
        v0 <- r_to_py(modify_depth(column_indices,1,as.integer))
        v1 <- r_to_py(column_values)
    
    
    
    
        py_ans = private$py_obj$`_addColumn_2`(v0, v1, name, lower_bound, upper_bound, as.integer(type_))
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(column_indices <- byref_0))
        eval.parent(substitute(column_values <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: int addColumn()
    # C++ signature: int addColumn(libcpp_vector[int] column_indices, libcpp_vector[double] column_values, const String & name)
    # C++ signature: int addColumn(libcpp_vector[int] & column_indices, libcpp_vector[double] & column_values, const String & name, double lower_bound, double upper_bound, LPWrapper_Type type_)
    addColumn = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$addColumn_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$addColumn_1(...) }
        else if ((length(arg_list)==6) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]])) && (arg_list[[6]] %in% c(0, 1, 2, 3, 4))) { self$addColumn_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void deleteRow(int index)
    deleteRow = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        private$py_obj$deleteRow(as.integer(index))
        invisible()
    },
    
    # C++ signature: void setColumnName(int index, const String & name)
    setColumnName = function(index, name){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
    
        private$py_obj$setColumnName(as.integer(index), name)
        invisible()
    },
    
    # C++ signature: String getColumnName(int index)
    getColumnName = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getColumnName(as.integer(index))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getRowName(int index)
    getRowName = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getRowName(as.integer(index))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getRowIndex(const String & name)
    getRowIndex = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getRowIndex(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getColumnIndex(const String & name)
    getColumnIndex = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getColumnIndex(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getColumnUpperBound(int index)
    getColumnUpperBound = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getColumnUpperBound(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getColumnLowerBound(int index)
    getColumnLowerBound = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getColumnLowerBound(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRowUpperBound(int index)
    getRowUpperBound = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getRowUpperBound(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRowLowerBound(int index)
    getRowLowerBound = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getRowLowerBound(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRowName(int index, const String & name)
    setRowName = function(index, name){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
    
        private$py_obj$setRowName(as.integer(index), name)
        invisible()
    },
    
    # C++ signature: void setColumnBounds(int index, double lower_bound, double upper_bound, LPWrapper_Type type_)
    setColumnBounds = function(index, lower_bound, upper_bound, type_){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_scalar_double(lower_bound))){ stop("arg lower_bound wrong type") }
        if(!(is_scalar_double(upper_bound))){ stop("arg upper_bound wrong type") }
        if(!(type_ %in% c(0, 1, 2, 3, 4))){ stop("arg type_ wrong type") }
    
    
    
    
        private$py_obj$setColumnBounds(as.integer(index), lower_bound, upper_bound, as.integer(type_))
        invisible()
    },
    
    # C++ signature: void setRowBounds(int index, double lower_bound, double upper_bound, LPWrapper_Type type_)
    setRowBounds = function(index, lower_bound, upper_bound, type_){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_scalar_double(lower_bound))){ stop("arg lower_bound wrong type") }
        if(!(is_scalar_double(upper_bound))){ stop("arg upper_bound wrong type") }
        if(!(type_ %in% c(0, 1, 2, 3, 4))){ stop("arg type_ wrong type") }
    
    
    
    
        private$py_obj$setRowBounds(as.integer(index), lower_bound, upper_bound, as.integer(type_))
        invisible()
    },
    
    # C++ signature: void setColumnType(int index, VariableType type_)
    setColumnType = function(index, type_){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(type_ %in% c(0, 1, 2))){ stop("arg type_ wrong type") }
    
    
        private$py_obj$setColumnType(as.integer(index), as.integer(type_))
        invisible()
    },
    
    # C++ signature: VariableType getColumnType(int index)
    getColumnType = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getColumnType(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObjective(int index, double obj_value)
    setObjective = function(index, obj_value){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_scalar_double(obj_value))){ stop("arg obj_value wrong type") }
    
    
        private$py_obj$setObjective(as.integer(index), obj_value)
        invisible()
    },
    
    # C++ signature: double getObjective(int index)
    getObjective = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getObjective(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObjectiveSense(Sense sense)
    setObjectiveSense = function(sense){
    
        if(!(sense %in% c(0, 1))){ stop("arg sense wrong type") }
    
        private$py_obj$setObjectiveSense(as.integer(sense))
        invisible()
    },
    
    # C++ signature: Sense getObjectiveSense()
    getObjectiveSense = function(){
    
        py_ans = private$py_obj$getObjectiveSense()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNumberOfColumns()
    getNumberOfColumns = function(){
    
        py_ans = private$py_obj$getNumberOfColumns()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNumberOfRows()
    getNumberOfRows = function(){
    
        py_ans = private$py_obj$getNumberOfRows()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setElement(int row_index, int column_index, double value)
    setElement = function(row_index, column_index, value){
    
        if(!( (is_scalar_integer(row_index) || is_scalar_double(row_index)) && row_index == as.integer(row_index))){ stop("arg row_index wrong type") }
        if(!( (is_scalar_integer(column_index) || is_scalar_double(column_index)) && column_index == as.integer(column_index))){ stop("arg column_index wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj$setElement(as.integer(row_index), as.integer(column_index), value)
        invisible()
    },
    
    # C++ signature: double getElement(int row_index, int column_index)
    getElement = function(row_index, column_index){
    
        if(!( (is_scalar_integer(row_index) || is_scalar_double(row_index)) && row_index == as.integer(row_index))){ stop("arg row_index wrong type") }
        if(!( (is_scalar_integer(column_index) || is_scalar_double(column_index)) && column_index == as.integer(column_index))){ stop("arg column_index wrong type") }
    
    
        py_ans = private$py_obj$getElement(as.integer(row_index), as.integer(column_index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void readProblem(String filename, String format_)
    readProblem = function(filename, format_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(format_) && class(format_)[1]=="String") || is_scalar_character(format_))){ stop("arg format_ wrong type") }
    
    
        private$py_obj$readProblem(filename, format_)
        invisible()
    },
    
    # C++ signature: void writeProblem(const String & filename, WriteFormat format_)
    writeProblem = function(filename, format_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(format_ %in% c(0, 1, 2))){ stop("arg format_ wrong type") }
    
    
        private$py_obj$writeProblem(filename, as.integer(format_))
        invisible()
    },
    
    # C++ signature: int solve(SolverParam & solver_param, size_t verbose_level)
    solve = function(solver_param, verbose_level){
    
        if(!(is.R6(solver_param) && class(solver_param)[1] == "SolverParam")){ stop("arg solver_param wrong type") }
        if(!( (is_scalar_integer(verbose_level) || is_scalar_double(verbose_level)) && verbose_level == as.integer(verbose_level))){ stop("arg verbose_level wrong type") }
    
    
        py_ans = private$py_obj$solve(solver_param, as.integer(verbose_level))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: SolverStatus getStatus()
    getStatus = function(){
    
        py_ans = private$py_obj$getStatus()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getObjectiveValue()
    getObjectiveValue = function(){
    
        py_ans = private$py_obj$getObjectiveValue()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getColumnValue(int index)
    getColumnValue = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getColumnValue(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNumberOfNonZeroEntriesInRow(int idx)
    getNumberOfNonZeroEntriesInRow = function(idx){
    
        if(!( (is_scalar_integer(idx) || is_scalar_double(idx)) && idx == as.integer(idx))){ stop("arg idx wrong type") }
    
        py_ans = private$py_obj$getNumberOfNonZeroEntriesInRow(as.integer(idx))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getMatrixRow(int idx, libcpp_vector[int] & indexes)
    getMatrixRow = function(idx, indexes){
    
        if(!( (is_scalar_integer(idx) || is_scalar_double(idx)) && idx == as.integer(idx))){ stop("arg idx wrong type") }
        if(!(is_list(indexes) && all(sapply(indexes,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indexes wrong type") }
    
        v1 <- r_to_py(modify_depth(indexes,1,as.integer))
        private$py_obj$getMatrixRow(as.integer(idx), v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(indexes <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setSolver(SOLVER s)
    setSolver = function(s){
    
        if(!(s %in% c(0))){ stop("arg s wrong type") }
    
        private$py_obj$setSolver(as.integer(s))
        invisible()
    },
    
    # C++ signature: SOLVER getSolver()
    getSolver = function(){
    
        py_ans = private$py_obj$getSolver()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _LabeledPairFinder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LabeledPairFinder.html
LabeledPairFinder <- R6Class(classname = "LabeledPairFinder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LabeledPairFinder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LabeledPairFinder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LabeledPairFinder()
        invisible()
    }
    
    },
    
    # C++ signature: void run(libcpp_vector[ConsensusMap] & input_maps, ConsensusMap & result_map)
    run = function(input_maps, result_map){
    
        if(!(is_list(input_maps) && all(sapply(input_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg input_maps wrong type") }
        if(!(is.R6(result_map) && class(result_map)[1] == "ConsensusMap")){ stop("arg result_map wrong type") }
        v0 <- r_to_py(input_maps)
    
        private$py_obj$run(v0, result_map)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(input_maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _LibSVMEncoder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LibSVMEncoder.html
LibSVMEncoder <- R6Class(classname = "LibSVMEncoder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LibSVMEncoder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LibSVMEncoder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LibSVMEncoder()
        invisible()
    }
    
    }
)
)
    
    # C++ signature: libcpp_vector[double] predictPeptideRT(libcpp_vector[String] sequences, const SVMWrapper & svm, const String & allowed_characters, unsigned int maximum_sequence_length)
    LibSVMEncoder$predictPeptideRT = function(sequences, svm, allowed_characters, maximum_sequence_length){
    
        if(!(is_list(sequences) && all(sapply(sequences),is_scalar_character))){ stop("arg sequences wrong type") }
        if(!(is.R6(svm) && class(svm)[1] == "SVMWrapper")){ stop("arg svm wrong type") }
        if(!((is.R6(allowed_characters) && class(allowed_characters)[1]=="String") || is_scalar_character(allowed_characters))){ stop("arg allowed_characters wrong type") }
        if(!( (is_scalar_integer(maximum_sequence_length) || is_scalar_double(maximum_sequence_length)) && maximum_sequence_length == as.integer(maximum_sequence_length))){ stop("arg maximum_sequence_length wrong type") }
        v0 = r_to_py(modify_depth(sequences,1,py_builtin$bytes(sequences,'utf-8')))
    
    
    
        py_ans = Pymod$LibSVMEncoder$predictPeptideRT(v0, svm, allowed_characters, as.integer(maximum_sequence_length))
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    } 

# R implementation of _LightCompound
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1LightCompound.html
LightCompound <- R6Class(classname = "LightCompound",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        rt = function(rt){
    
        if(!missing(rt)){
            if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        
        
            private$py_obj$rt <- rt
            } else {
        
                py_ans = private$py_obj$rt
                r_result = py_ans
                return(r_result)
                }
        },
        drift_time = function(drift_time){
    
        if(!missing(drift_time)){
            if(!(is_scalar_double(drift_time))){ stop("arg drift_time wrong type") }
        
        
            private$py_obj$drift_time <- drift_time
            } else {
        
                py_ans = private$py_obj$drift_time
                r_result = py_ans
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!(is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        sequence_0 = py_builtin$bytes(sequence,'utf-8')
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        protein_refs = function(protein_refs){
    
        if(!missing(protein_refs)){
            if(!(is_list(protein_refs) && all(sapply(protein_refs,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg protein_refs wrong type") }
        
            v0 <- r_to_py(modify_depth(protein_refs,1, function(a) py_builtin$bytes(a, 'utf-8')))
            private$py_obj$protein_refs <- v0
            } else {
            
                py_ans = private$py_obj$protein_refs
            r_result <- modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        peptide_group_label = function(peptide_group_label){
    
        if(!missing(peptide_group_label)){
            if(!(is_scalar_character(peptide_group_label))){ stop("arg peptide_group_label wrong type") }
        
        peptide_group_label_0 = py_builtin$bytes(peptide_group_label,'utf-8')
            private$py_obj$peptide_group_label <- peptide_group_label
            } else {
        
                py_ans = private$py_obj$peptide_group_label
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!(is_scalar_character(id))){ stop("arg id wrong type") }
        
        id_0 = py_builtin$bytes(id,'utf-8')
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        sum_formula = function(sum_formula){
    
        if(!missing(sum_formula)){
            if(!(is_scalar_character(sum_formula))){ stop("arg sum_formula wrong type") }
        
        sum_formula_0 = py_builtin$bytes(sum_formula,'utf-8')
            private$py_obj$sum_formula <- sum_formula
            } else {
        
                py_ans = private$py_obj$sum_formula
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        compound_name = function(compound_name){
    
        if(!missing(compound_name)){
            if(!(is_scalar_character(compound_name))){ stop("arg compound_name wrong type") }
        
        compound_name_0 = py_builtin$bytes(compound_name,'utf-8')
            private$py_obj$compound_name <- compound_name
            } else {
        
                py_ans = private$py_obj$compound_name
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        modifications = function(modifications){
    
        if(!missing(modifications)){
            if(!(is_list(modifications) && all(sapply(modifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightModification")))){ stop("arg modifications wrong type") }
        
            v0 <- r_to_py(modifications)
            private$py_obj$modifications <- v0
            } else {
            
                py_ans = private$py_obj$modifications
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LightCompound()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightCompound()
        invisible()
    
    
    },
    
    # C++ signature: void LightCompound(LightCompound)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightCompound")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightCompound(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightCompound()
    # C++ signature: void LightCompound(LightCompound)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightCompound")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightCompound" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setDriftTime(double d)
    setDriftTime = function(d){
    
        if(!(is_scalar_double(d))){ stop("arg d wrong type") }
    
        private$py_obj$setDriftTime(d)
        invisible()
    },
    
    # C++ signature: double getDriftTime()
    getDriftTime = function(){
    
        py_ans = private$py_obj$getDriftTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getChargeState()
    getChargeState = function(){
    
        py_ans = private$py_obj$getChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isPeptide()
    isPeptide = function(){
    
        py_ans = private$py_obj$isPeptide()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setChargeState(int ch)
    setChargeState = function(ch){
    
        if(!( (is_scalar_integer(ch) || is_scalar_double(ch)) && ch == as.integer(ch))){ stop("arg ch wrong type") }
    
        private$py_obj$setChargeState(as.integer(ch))
        invisible()
    }
)
) 

# R implementation of _MRMTransitionGroup[_MSChromatogram,_LightTransition]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMTransitionGroup[_MSChromatogram,_LightTransition].html
LightMRMTransitionGroupCP <- R6Class(classname = "LightMRMTransitionGroupCP",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LightMRMTransitionGroupCP()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightMRMTransitionGroupCP()
        invisible()
    
    
    },
    
    # C++ signature: void LightMRMTransitionGroupCP(LightMRMTransitionGroupCP &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightMRMTransitionGroupCP")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightMRMTransitionGroupCP(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightMRMTransitionGroupCP()
    # C++ signature: void LightMRMTransitionGroupCP(LightMRMTransitionGroupCP &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightMRMTransitionGroupCP")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightMRMTransitionGroupCP" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTransitionGroupID()
    getTransitionGroupID = function(){
    
        py_ans = private$py_obj$getTransitionGroupID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTransitionGroupID(String tr_gr_id)
    setTransitionGroupID = function(tr_gr_id){
    
        if(!((is.R6(tr_gr_id) && class(tr_gr_id)[1]=="String") || is_scalar_character(tr_gr_id))){ stop("arg tr_gr_id wrong type") }
    
        private$py_obj$setTransitionGroupID(tr_gr_id)
        invisible()
    },
    
    # C++ signature: libcpp_vector[LightTransition] getTransitions()
    getTransitions = function(){
    
        py_ans = private$py_obj$getTransitions()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[LightTransition] getTransitionsMuteable()
    getTransitionsMuteable = function(){
    
        py_ans = private$py_obj$getTransitionsMuteable()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addTransition(LightTransition transition, String key)
    addTransition = function(transition, key){
    
        if(!(is.R6(transition) && class(transition)[1] == "LightTransition")){ stop("arg transition wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addTransition(transition, key)
        invisible()
    },
    
    # C++ signature: LightTransition getTransition(String key)
    getTransition = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getTransition(key)
        r_ans = LightTransition$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasTransition(String key)
    hasTransition = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasTransition(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MSChromatogram] getChromatograms()
    getChromatograms = function(){
    
        py_ans = private$py_obj$getChromatograms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addChromatogram(MSChromatogram chromatogram, String key)
    addChromatogram = function(chromatogram, key){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addChromatogram(chromatogram, key)
        invisible()
    },
    
    # C++ signature: MSChromatogram getChromatogram(String key)
    getChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getChromatogram(key)
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasChromatogram(String key)
    hasChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasChromatogram(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MSChromatogram] getPrecursorChromatograms()
    getPrecursorChromatograms = function(){
    
        py_ans = private$py_obj$getPrecursorChromatograms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addPrecursorChromatogram(MSChromatogram chromatogram, String key)
    addPrecursorChromatogram = function(chromatogram, key){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addPrecursorChromatogram(chromatogram, key)
        invisible()
    },
    
    # C++ signature: MSChromatogram getPrecursorChromatogram(String key)
    getPrecursorChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getPrecursorChromatogram(key)
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasPrecursorChromatogram(String key)
    hasPrecursorChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasPrecursorChromatogram(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MRMFeature] getFeatures()
    getFeatures = function(){
    
        py_ans = private$py_obj$getFeatures()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MRMFeature] getFeaturesMuteable()
    getFeaturesMuteable = function(){
    
        py_ans = private$py_obj$getFeaturesMuteable()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addFeature(MRMFeature feature)
    addFeature = function(feature){
    
        if(!(is.R6(feature) && class(feature)[1] == "MRMFeature")){ stop("arg feature wrong type") }
    
        private$py_obj$addFeature(feature)
        invisible()
    },
    
    # C++ signature: MRMFeature getBestFeature()
    getBestFeature = function(){
    
        py_ans = private$py_obj$getBestFeature()
        r_ans = MRMFeature$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getLibraryIntensity(libcpp_vector[double] result)
    getLibraryIntensity = function(result){
    
        if(!(is_list(result) && all(sapply(result,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg result wrong type") }
        v0 <- r_to_py(result)
        private$py_obj$getLibraryIntensity(v0)
        
        invisible()
    },
    
    # C++ signature: LightMRMTransitionGroupCP subset(libcpp_vector[libcpp_string] tr_ids)
    subset = function(tr_ids){
    
        if(!(is_list(tr_ids) && all(sapply(tr_ids,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg tr_ids wrong type") }
        v0 <- r_to_py(modify_depth(tr_ids,1, function(a) py_builtin$bytes(a, 'utf-8')))
        py_ans = private$py_obj$subset(v0)
        
        r_ans = LightMRMTransitionGroupCP$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool isInternallyConsistent()
    isInternallyConsistent = function(){
    
        py_ans = private$py_obj$isInternallyConsistent()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool chromatogramIdsMatch()
    chromatogramIdsMatch = function(){
    
        py_ans = private$py_obj$chromatogramIdsMatch()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _LightModification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1LightModification.html
LightModification <- R6Class(classname = "LightModification",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        location = function(location){
    
        if(!missing(location)){
            if(!( (is_scalar_integer(location) || is_scalar_double(location)) && location == as.integer(location))){ stop("arg location wrong type") }
        
        
            private$py_obj$location <- as.integer(location)
            } else {
        
                py_ans = private$py_obj$location
                r_result = py_ans
                return(r_result)
                }
        },
        unimod_id = function(unimod_id){
    
        if(!missing(unimod_id)){
            if(!( (is_scalar_integer(unimod_id) || is_scalar_double(unimod_id)) && unimod_id == as.integer(unimod_id))){ stop("arg unimod_id wrong type") }
        
        
            private$py_obj$unimod_id <- as.integer(unimod_id)
            } else {
        
                py_ans = private$py_obj$unimod_id
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LightModification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightModification()
        invisible()
    
    
    },
    
    # C++ signature: void LightModification(LightModification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightModification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightModification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightModification()
    # C++ signature: void LightModification(LightModification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightModification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightModification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _LightProtein
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1LightProtein.html
LightProtein <- R6Class(classname = "LightProtein",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!(is_scalar_character(id))){ stop("arg id wrong type") }
        
        id_0 = py_builtin$bytes(id,'utf-8')
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!(is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        sequence_0 = py_builtin$bytes(sequence,'utf-8')
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = as.character(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LightProtein()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightProtein()
        invisible()
    
    
    },
    
    # C++ signature: void LightProtein(LightProtein)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightProtein")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightProtein(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightProtein()
    # C++ signature: void LightProtein(LightProtein)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightProtein")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightProtein" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _LightTargetedExperiment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1LightTargetedExperiment.html
LightTargetedExperiment <- R6Class(classname = "LightTargetedExperiment",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        transitions = function(transitions){
    
        if(!missing(transitions)){
            if(!(is_list(transitions) && all(sapply(transitions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightTransition")))){ stop("arg transitions wrong type") }
        
            v0 <- r_to_py(transitions)
            private$py_obj$transitions <- v0
            } else {
            
                py_ans = private$py_obj$transitions
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        compounds = function(compounds){
    
        if(!missing(compounds)){
            if(!(is_list(compounds) && all(sapply(compounds,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightCompound")))){ stop("arg compounds wrong type") }
        
            v0 <- r_to_py(compounds)
            private$py_obj$compounds <- v0
            } else {
            
                py_ans = private$py_obj$compounds
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        proteins = function(proteins){
    
        if(!missing(proteins)){
            if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightProtein")))){ stop("arg proteins wrong type") }
        
            v0 <- r_to_py(proteins)
            private$py_obj$proteins <- v0
            } else {
            
                py_ans = private$py_obj$proteins
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LightTargetedExperiment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightTargetedExperiment()
        invisible()
    
    
    },
    
    # C++ signature: void LightTargetedExperiment(LightTargetedExperiment &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightTargetedExperiment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightTargetedExperiment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightTargetedExperiment()
    # C++ signature: void LightTargetedExperiment(LightTargetedExperiment &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightTargetedExperiment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightTargetedExperiment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[LightTransition] getTransitions()
    getTransitions = function(){
    
        py_ans = private$py_obj$getTransitions()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[LightCompound] getCompounds()
    getCompounds = function(){
    
        py_ans = private$py_obj$getCompounds()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[LightProtein] getProteins()
    getProteins = function(){
    
        py_ans = private$py_obj$getProteins()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: LightCompound getCompoundByRef(libcpp_string & ref)
    getCompoundByRef = function(ref){
    
        if(!(is_scalar_character(ref))){ stop("arg ref wrong type") }
    ref_0 = py_builtin$bytes(ref,'utf-8')
        py_ans = private$py_obj$getCompoundByRef(ref)
        r_ans = LightCompound$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: LightCompound getPeptideByRef(libcpp_string & ref)
    getPeptideByRef = function(ref){
    
        if(!(is_scalar_character(ref))){ stop("arg ref wrong type") }
    ref_0 = py_builtin$bytes(ref,'utf-8')
        py_ans = private$py_obj$getPeptideByRef(ref)
        r_ans = LightCompound$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _LightTransition
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1LightTransition.html
LightTransition <- R6Class(classname = "LightTransition",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        transition_name = function(transition_name){
    
        if(!missing(transition_name)){
            if(!(is_scalar_character(transition_name))){ stop("arg transition_name wrong type") }
        
        transition_name_0 = py_builtin$bytes(transition_name,'utf-8')
            private$py_obj$transition_name <- transition_name
            } else {
        
                py_ans = private$py_obj$transition_name
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        peptide_ref = function(peptide_ref){
    
        if(!missing(peptide_ref)){
            if(!(is_scalar_character(peptide_ref))){ stop("arg peptide_ref wrong type") }
        
        peptide_ref_0 = py_builtin$bytes(peptide_ref,'utf-8')
            private$py_obj$peptide_ref <- peptide_ref
            } else {
        
                py_ans = private$py_obj$peptide_ref
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        library_intensity = function(library_intensity){
    
        if(!missing(library_intensity)){
            if(!(is_scalar_double(library_intensity))){ stop("arg library_intensity wrong type") }
        
        
            private$py_obj$library_intensity <- library_intensity
            } else {
        
                py_ans = private$py_obj$library_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        product_mz = function(product_mz){
    
        if(!missing(product_mz)){
            if(!(is_scalar_double(product_mz))){ stop("arg product_mz wrong type") }
        
        
            private$py_obj$product_mz <- product_mz
            } else {
        
                py_ans = private$py_obj$product_mz
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_mz = function(precursor_mz){
    
        if(!missing(precursor_mz)){
            if(!(is_scalar_double(precursor_mz))){ stop("arg precursor_mz wrong type") }
        
        
            private$py_obj$precursor_mz <- precursor_mz
            } else {
        
                py_ans = private$py_obj$precursor_mz
                r_result = py_ans
                return(r_result)
                }
        },
        fragment_charge = function(fragment_charge){
    
        if(!missing(fragment_charge)){
            if(!( (is_scalar_integer(fragment_charge) || is_scalar_double(fragment_charge)) && fragment_charge == as.integer(fragment_charge))){ stop("arg fragment_charge wrong type") }
        
        
            private$py_obj$fragment_charge <- as.integer(fragment_charge)
            } else {
        
                py_ans = private$py_obj$fragment_charge
                r_result = py_ans
                return(r_result)
                }
        },
        decoy = function(decoy){
    
        if(!missing(decoy)){
            if(!( (is_scalar_integer(decoy) || is_scalar_double(decoy)) && decoy == as.integer(decoy))){ stop("arg decoy wrong type") }
        
        
            private$py_obj$decoy <- as.integer(decoy)
            } else {
        
                py_ans = private$py_obj$decoy
                r_result = py_ans
                return(r_result)
                }
        },
        detecting_transition = function(detecting_transition){
    
        if(!missing(detecting_transition)){
            if(!( (is_scalar_integer(detecting_transition) || is_scalar_double(detecting_transition)) && detecting_transition == as.integer(detecting_transition))){ stop("arg detecting_transition wrong type") }
        
        
            private$py_obj$detecting_transition <- as.integer(detecting_transition)
            } else {
        
                py_ans = private$py_obj$detecting_transition
                r_result = py_ans
                return(r_result)
                }
        },
        quantifying_transition = function(quantifying_transition){
    
        if(!missing(quantifying_transition)){
            if(!( (is_scalar_integer(quantifying_transition) || is_scalar_double(quantifying_transition)) && quantifying_transition == as.integer(quantifying_transition))){ stop("arg quantifying_transition wrong type") }
        
        
            private$py_obj$quantifying_transition <- as.integer(quantifying_transition)
            } else {
        
                py_ans = private$py_obj$quantifying_transition
                r_result = py_ans
                return(r_result)
                }
        },
        identifying_transition = function(identifying_transition){
    
        if(!missing(identifying_transition)){
            if(!( (is_scalar_integer(identifying_transition) || is_scalar_double(identifying_transition)) && identifying_transition == as.integer(identifying_transition))){ stop("arg identifying_transition wrong type") }
        
        
            private$py_obj$identifying_transition <- as.integer(identifying_transition)
            } else {
        
                py_ans = private$py_obj$identifying_transition
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void LightTransition()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LightTransition()
        invisible()
    
    
    },
    
    # C++ signature: void LightTransition(LightTransition)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LightTransition")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LightTransition(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LightTransition()
    # C++ signature: void LightTransition(LightTransition)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightTransition")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LightTransition" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: int getProductChargeState()
    getProductChargeState = function(){
    
        py_ans = private$py_obj$getProductChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isProductChargeStateSet()
    isProductChargeStateSet = function(){
    
        py_ans = private$py_obj$isProductChargeStateSet()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getNativeID()
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getPeptideRef()
    getPeptideRef = function(){
    
        py_ans = private$py_obj$getPeptideRef()
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getLibraryIntensity()
    getLibraryIntensity = function(){
    
        py_ans = private$py_obj$getLibraryIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLibraryIntensity(double l)
    setLibraryIntensity = function(l){
    
        if(!(is_scalar_double(l))){ stop("arg l wrong type") }
    
        private$py_obj$setLibraryIntensity(l)
        invisible()
    },
    
    # C++ signature: double getProductMZ()
    getProductMZ = function(){
    
        py_ans = private$py_obj$getProductMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPrecursorMZ()
    getPrecursorMZ = function(){
    
        py_ans = private$py_obj$getPrecursorMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getCompoundRef()
    getCompoundRef = function(){
    
        py_ans = private$py_obj$getCompoundRef()
    r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDetectingTransition(bool d)
    setDetectingTransition = function(d){
    
        if(!( (is_scalar_integer(d) || is_scalar_double(d)) && d == as.integer(d))){ stop("arg d wrong type") }
    
        private$py_obj$setDetectingTransition(as.integer(d))
        invisible()
    },
    
    # C++ signature: bool isDetectingTransition()
    isDetectingTransition = function(){
    
        py_ans = private$py_obj$isDetectingTransition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuantifyingTransition(bool q)
    setQuantifyingTransition = function(q){
    
        if(!( (is_scalar_integer(q) || is_scalar_double(q)) && q == as.integer(q))){ stop("arg q wrong type") }
    
        private$py_obj$setQuantifyingTransition(as.integer(q))
        invisible()
    },
    
    # C++ signature: bool isQuantifyingTransition()
    isQuantifyingTransition = function(){
    
        py_ans = private$py_obj$isQuantifyingTransition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifyingTransition(bool i)
    setIdentifyingTransition = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        private$py_obj$setIdentifyingTransition(as.integer(i))
        invisible()
    },
    
    # C++ signature: bool isIdentifyingTransition()
    isIdentifyingTransition = function(){
    
        py_ans = private$py_obj$isIdentifyingTransition()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _LinearInterpolation[double,double]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1LinearInterpolation[double,double].html
LinearInterpolation <- R6Class(classname = "LinearInterpolation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LinearInterpolation()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LinearInterpolation()
        invisible()
    
    
    },
    
    # C++ signature: void LinearInterpolation(LinearInterpolation)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LinearInterpolation")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LinearInterpolation(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LinearInterpolation(double scale, double offset)
    init_2 = function(scale, offset){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
    
    
        private$py_obj <- Pymod$LinearInterpolation(scale, offset)
        invisible()
    
    
    },
    
    # C++ signature: void LinearInterpolation()
    # C++ signature: void LinearInterpolation(LinearInterpolation)
    # C++ signature: void LinearInterpolation(double scale, double offset)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LinearInterpolation")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LinearInterpolation" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double value(double arg_pos)
    value = function(arg_pos){
    
        if(!(is_scalar_double(arg_pos))){ stop("arg arg_pos wrong type") }
    
        py_ans = private$py_obj$value(arg_pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addValue(double arg_pos, double arg_value)
    addValue = function(arg_pos, arg_value){
    
        if(!(is_scalar_double(arg_pos))){ stop("arg arg_pos wrong type") }
        if(!(is_scalar_double(arg_value))){ stop("arg arg_value wrong type") }
    
    
        private$py_obj$addValue(arg_pos, arg_value)
        invisible()
    },
    
    # C++ signature: double derivative(double arg_pos)
    derivative = function(arg_pos){
    
        if(!(is_scalar_double(arg_pos))){ stop("arg arg_pos wrong type") }
    
        py_ans = private$py_obj$derivative(arg_pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getData()
    getData = function(){
    
        py_ans = private$py_obj$getData()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setData(libcpp_vector[double] & data)
    setData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$setData(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double key2index(double pos)
    key2index = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$key2index(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double index2key(double pos)
    index2key = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$index2key(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getScale()
    getScale = function(){
    
        py_ans = private$py_obj$getScale()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScale(double & scale)
    setScale = function(scale){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
    
        private$py_obj$setScale(scale)
        invisible()
    },
    
    # C++ signature: double getOffset()
    getOffset = function(){
    
        py_ans = private$py_obj$getOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOffset(double & offset)
    setOffset = function(offset){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
    
        private$py_obj$setOffset(offset)
        invisible()
    },
    
    # C++ signature: void setMapping(double & scale, double & inside, double & outside)
    setMapping_0 = function(scale, inside, outside){
    
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(inside))){ stop("arg inside wrong type") }
        if(!(is_scalar_double(outside))){ stop("arg outside wrong type") }
    
    
    
        private$py_obj$`_setMapping_0`(scale, inside, outside)
        invisible()
    },
    
    # C++ signature: void setMapping(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping_1 = function(inside_low, outside_low, inside_high, outside_high){
    
        if(!(is_scalar_double(inside_low))){ stop("arg inside_low wrong type") }
        if(!(is_scalar_double(outside_low))){ stop("arg outside_low wrong type") }
        if(!(is_scalar_double(inside_high))){ stop("arg inside_high wrong type") }
        if(!(is_scalar_double(outside_high))){ stop("arg outside_high wrong type") }
    
    
    
    
        private$py_obj$`_setMapping_1`(inside_low, outside_low, inside_high, outside_high)
        invisible()
    },
    
    # C++ signature: void setMapping(double & scale, double & inside, double & outside)
    # C++ signature: void setMapping(double & inside_low, double & outside_low, double & inside_high, double & outside_high)
    setMapping = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$setMapping_0(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$setMapping_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getInsideReferencePoint()
    getInsideReferencePoint = function(){
    
        py_ans = private$py_obj$getInsideReferencePoint()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getOutsideReferencePoint()
    getOutsideReferencePoint = function(){
    
        py_ans = private$py_obj$getOutsideReferencePoint()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMin()
    supportMin = function(){
    
        py_ans = private$py_obj$supportMin()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double supportMax()
    supportMax = function(){
    
        py_ans = private$py_obj$supportMax()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _LinearResampler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LinearResampler.html
LinearResampler <- R6Class(classname = "LinearResampler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LinearResampler()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LinearResampler) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LinearResampler()
        invisible()
    }
    
    },
    
    # C++ signature: void raster(MSSpectrum & input)
    raster = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "MSSpectrum")){ stop("arg input wrong type") }
    
        private$py_obj$raster(input)
        invisible()
    },
    
    # C++ signature: void rasterExperiment(MSExperiment & input)
    rasterExperiment = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
    
        private$py_obj$rasterExperiment(input)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _LinearResamplerAlign
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LinearResamplerAlign.html
LinearResamplerAlign <- R6Class(classname = "LinearResamplerAlign",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void raster(MSSpectrum & input)
    raster = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "MSSpectrum")){ stop("arg input wrong type") }
    
        private$py_obj$raster(input)
        invisible()
    },
    
    # C++ signature: void rasterExperiment(MSExperiment & input)
    rasterExperiment = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
    
        private$py_obj$rasterExperiment(input)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _LocalLinearMap
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LocalLinearMap.html
LocalLinearMap <- R6Class(classname = "LocalLinearMap",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LocalLinearMap()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == LocalLinearMap) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$LocalLinearMap()
        invisible()
    }
    
    },
    
    # C++ signature: LLMParam getLLMParam()
    getLLMParam = function(){
    
        py_ans = private$py_obj$getLLMParam()
        r_ans = LLMParam$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getCodebooks()
    getCodebooks = function(){
    
        py_ans = private$py_obj$getCodebooks()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getMatrixA()
    getMatrixA = function(){
    
        py_ans = private$py_obj$getMatrixA()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] getVectorWout()
    getVectorWout = function(){
    
        py_ans = private$py_obj$getVectorWout()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void normalizeVector(libcpp_vector[double] & aaIndexVariables)
    normalizeVector = function(aaIndexVariables){
    
        if(!(is_list(aaIndexVariables) && all(sapply(aaIndexVariables,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg aaIndexVariables wrong type") }
        v0 <- r_to_py(aaIndexVariables)
        private$py_obj$normalizeVector(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(aaIndexVariables <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _LowessSmoothing
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1LowessSmoothing.html
LowessSmoothing <- R6Class(classname = "LowessSmoothing",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void LowessSmoothing()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$LowessSmoothing()
        invisible()
    
    
    },
    
    # C++ signature: void LowessSmoothing(LowessSmoothing)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "LowessSmoothing")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$LowessSmoothing(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void LowessSmoothing()
    # C++ signature: void LowessSmoothing(LowessSmoothing)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LowessSmoothing")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "LowessSmoothing" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void smoothData(libcpp_vector[double] x, libcpp_vector[double] y, libcpp_vector[double] & y_smoothed)
    smoothData = function(x, y, y_smoothed){
    
        if(!(is_list(x) && all(sapply(x,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x wrong type") }
        if(!(is_list(y) && all(sapply(y,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg y wrong type") }
        if(!(is_list(y_smoothed) && all(sapply(y_smoothed,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg y_smoothed wrong type") }
        v0 <- r_to_py(x)
        v1 <- r_to_py(y)
        v2 <- r_to_py(y_smoothed)
        private$py_obj$smoothData(v0, v1, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        
        
    
        tryCatch({
        eval.parent(substitute(y_smoothed <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MRMAssay
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMAssay.html
MRMAssay <- R6Class(classname = "MRMAssay",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMAssay()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMAssay) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMAssay()
        invisible()
    }
    
    },
    
    # C++ signature: void reannotateTransitions(TargetedExperiment & exp, double precursor_mz_threshold, double product_mz_threshold, libcpp_vector[String] fragment_types, libcpp_vector[size_t] fragment_charges, bool enable_specific_losses, bool enable_unspecific_losses, int round_decPow)
    reannotateTransitions = function(exp, precursor_mz_threshold, product_mz_threshold, fragment_types, fragment_charges, enable_specific_losses, enable_unspecific_losses, round_decPow){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(precursor_mz_threshold))){ stop("arg precursor_mz_threshold wrong type") }
        if(!(is_scalar_double(product_mz_threshold))){ stop("arg product_mz_threshold wrong type") }
        if(!(is_list(fragment_types) && all(sapply(fragment_types),is_scalar_character))){ stop("arg fragment_types wrong type") }
        if(!(is_list(fragment_charges) && all(sapply(fragment_charges,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg fragment_charges wrong type") }
        if(!( (is_scalar_integer(enable_specific_losses) || is_scalar_double(enable_specific_losses)) && enable_specific_losses == as.integer(enable_specific_losses))){ stop("arg enable_specific_losses wrong type") }
        if(!( (is_scalar_integer(enable_unspecific_losses) || is_scalar_double(enable_unspecific_losses)) && enable_unspecific_losses == as.integer(enable_unspecific_losses))){ stop("arg enable_unspecific_losses wrong type") }
        if(!( (is_scalar_integer(round_decPow) || is_scalar_double(round_decPow)) && round_decPow == as.integer(round_decPow))){ stop("arg round_decPow wrong type") }
    
    
    
        v3 = r_to_py(modify_depth(fragment_types,1,py_builtin$bytes(fragment_types,'utf-8')))
        v4 <- r_to_py(fragment_charges)
    
    
    
        private$py_obj$reannotateTransitions(exp, precursor_mz_threshold, product_mz_threshold, v3, v4, as.integer(enable_specific_losses), as.integer(enable_unspecific_losses), as.integer(round_decPow))
        
        invisible()
    },
    
    # C++ signature: void restrictTransitions(TargetedExperiment & exp, double lower_mz_limit, double upper_mz_limit, libcpp_vector[libcpp_pair[double,double]] swathes)
    restrictTransitions = function(exp, lower_mz_limit, upper_mz_limit, swathes){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(lower_mz_limit))){ stop("arg lower_mz_limit wrong type") }
        if(!(is_scalar_double(upper_mz_limit))){ stop("arg upper_mz_limit wrong type") }
        if(!(is_list(swathes) && all(sapply(swathes,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg swathes wrong type") }
    
    
    
        v3 <- r_to_py(swathes)
        private$py_obj$restrictTransitions(exp, lower_mz_limit, upper_mz_limit, v3)
        
        invisible()
    },
    
    # C++ signature: void detectingTransitions(TargetedExperiment & exp, int min_transitions, int max_transitions)
    detectingTransitions = function(exp, min_transitions, max_transitions){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!( (is_scalar_integer(min_transitions) || is_scalar_double(min_transitions)) && min_transitions == as.integer(min_transitions))){ stop("arg min_transitions wrong type") }
        if(!( (is_scalar_integer(max_transitions) || is_scalar_double(max_transitions)) && max_transitions == as.integer(max_transitions))){ stop("arg max_transitions wrong type") }
    
    
    
        private$py_obj$detectingTransitions(exp, as.integer(min_transitions), as.integer(max_transitions))
        invisible()
    },
    
    # C++ signature: void detectingTransitionsCompound(TargetedExperiment & exp, int min_transitions, int max_transitions)
    detectingTransitionsCompound = function(exp, min_transitions, max_transitions){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!( (is_scalar_integer(min_transitions) || is_scalar_double(min_transitions)) && min_transitions == as.integer(min_transitions))){ stop("arg min_transitions wrong type") }
        if(!( (is_scalar_integer(max_transitions) || is_scalar_double(max_transitions)) && max_transitions == as.integer(max_transitions))){ stop("arg max_transitions wrong type") }
    
    
    
        private$py_obj$detectingTransitionsCompound(exp, as.integer(min_transitions), as.integer(max_transitions))
        invisible()
    },
    
    # C++ signature: void uisTransitions(TargetedExperiment & exp, libcpp_vector[String] fragment_types, libcpp_vector[size_t] fragment_charges, bool enable_specific_losses, bool enable_unspecific_losses, bool enable_ms2_precursors, double mz_threshold, libcpp_vector[libcpp_pair[double,double]] swathes, int round_decPow, size_t max_num_alternative_localizations, int shuffle_seed)
    uisTransitions = function(exp, fragment_types, fragment_charges, enable_specific_losses, enable_unspecific_losses, enable_ms2_precursors, mz_threshold, swathes, round_decPow, max_num_alternative_localizations, shuffle_seed){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!(is_list(fragment_types) && all(sapply(fragment_types),is_scalar_character))){ stop("arg fragment_types wrong type") }
        if(!(is_list(fragment_charges) && all(sapply(fragment_charges,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg fragment_charges wrong type") }
        if(!( (is_scalar_integer(enable_specific_losses) || is_scalar_double(enable_specific_losses)) && enable_specific_losses == as.integer(enable_specific_losses))){ stop("arg enable_specific_losses wrong type") }
        if(!( (is_scalar_integer(enable_unspecific_losses) || is_scalar_double(enable_unspecific_losses)) && enable_unspecific_losses == as.integer(enable_unspecific_losses))){ stop("arg enable_unspecific_losses wrong type") }
        if(!( (is_scalar_integer(enable_ms2_precursors) || is_scalar_double(enable_ms2_precursors)) && enable_ms2_precursors == as.integer(enable_ms2_precursors))){ stop("arg enable_ms2_precursors wrong type") }
        if(!(is_scalar_double(mz_threshold))){ stop("arg mz_threshold wrong type") }
        if(!(is_list(swathes) && all(sapply(swathes,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg swathes wrong type") }
        if(!( (is_scalar_integer(round_decPow) || is_scalar_double(round_decPow)) && round_decPow == as.integer(round_decPow))){ stop("arg round_decPow wrong type") }
        if(!( (is_scalar_integer(max_num_alternative_localizations) || is_scalar_double(max_num_alternative_localizations)) && max_num_alternative_localizations == as.integer(max_num_alternative_localizations))){ stop("arg max_num_alternative_localizations wrong type") }
        if(!( (is_scalar_integer(shuffle_seed) || is_scalar_double(shuffle_seed)) && shuffle_seed == as.integer(shuffle_seed))){ stop("arg shuffle_seed wrong type") }
    
        v1 = r_to_py(modify_depth(fragment_types,1,py_builtin$bytes(fragment_types,'utf-8')))
        v2 <- r_to_py(fragment_charges)
    
    
    
    
        v7 <- r_to_py(swathes)
    
    
    
        private$py_obj$uisTransitions(exp, v1, v2, as.integer(enable_specific_losses), as.integer(enable_unspecific_losses), as.integer(enable_ms2_precursors), mz_threshold, v7, as.integer(round_decPow), as.integer(max_num_alternative_localizations), as.integer(shuffle_seed))
        
        
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MRMDecoy
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMDecoy.html
MRMDecoy <- R6Class(classname = "MRMDecoy",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMDecoy()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMDecoy) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMDecoy()
        invisible()
    }
    
    },
    
    # C++ signature: void generateDecoys(TargetedExperiment & exp, TargetedExperiment & dec, String method, double aim_decoy_fraction, bool switchKR, String decoy_tag, int max_attempts, double identity_threshold, double precursor_mz_shift, double product_mz_shift, double product_mz_threshold, libcpp_vector[String] fragment_types, libcpp_vector[size_t] fragment_charges, bool enable_specific_losses, bool enable_unspecific_losses, int round_decPow)
    generateDecoys = function(exp, dec, method, aim_decoy_fraction, switchKR, decoy_tag, max_attempts, identity_threshold, precursor_mz_shift, product_mz_shift, product_mz_threshold, fragment_types, fragment_charges, enable_specific_losses, enable_unspecific_losses, round_decPow){
    
        if(!(is.R6(exp) && class(exp)[1] == "TargetedExperiment")){ stop("arg exp wrong type") }
        if(!(is.R6(dec) && class(dec)[1] == "TargetedExperiment")){ stop("arg dec wrong type") }
        if(!((is.R6(method) && class(method)[1]=="String") || is_scalar_character(method))){ stop("arg method wrong type") }
        if(!(is_scalar_double(aim_decoy_fraction))){ stop("arg aim_decoy_fraction wrong type") }
        if(!( (is_scalar_integer(switchKR) || is_scalar_double(switchKR)) && switchKR == as.integer(switchKR))){ stop("arg switchKR wrong type") }
        if(!((is.R6(decoy_tag) && class(decoy_tag)[1]=="String") || is_scalar_character(decoy_tag))){ stop("arg decoy_tag wrong type") }
        if(!( (is_scalar_integer(max_attempts) || is_scalar_double(max_attempts)) && max_attempts == as.integer(max_attempts))){ stop("arg max_attempts wrong type") }
        if(!(is_scalar_double(identity_threshold))){ stop("arg identity_threshold wrong type") }
        if(!(is_scalar_double(precursor_mz_shift))){ stop("arg precursor_mz_shift wrong type") }
        if(!(is_scalar_double(product_mz_shift))){ stop("arg product_mz_shift wrong type") }
        if(!(is_scalar_double(product_mz_threshold))){ stop("arg product_mz_threshold wrong type") }
        if(!(is_list(fragment_types) && all(sapply(fragment_types),is_scalar_character))){ stop("arg fragment_types wrong type") }
        if(!(is_list(fragment_charges) && all(sapply(fragment_charges,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg fragment_charges wrong type") }
        if(!( (is_scalar_integer(enable_specific_losses) || is_scalar_double(enable_specific_losses)) && enable_specific_losses == as.integer(enable_specific_losses))){ stop("arg enable_specific_losses wrong type") }
        if(!( (is_scalar_integer(enable_unspecific_losses) || is_scalar_double(enable_unspecific_losses)) && enable_unspecific_losses == as.integer(enable_unspecific_losses))){ stop("arg enable_unspecific_losses wrong type") }
        if(!( (is_scalar_integer(round_decPow) || is_scalar_double(round_decPow)) && round_decPow == as.integer(round_decPow))){ stop("arg round_decPow wrong type") }
    
    
    
    
    
    
    
    
    
    
    
        v11 = r_to_py(modify_depth(fragment_types,1,py_builtin$bytes(fragment_types,'utf-8')))
        v12 <- r_to_py(fragment_charges)
    
    
    
        private$py_obj$generateDecoys(exp, dec, method, aim_decoy_fraction, as.integer(switchKR), decoy_tag, as.integer(max_attempts), identity_threshold, precursor_mz_shift, product_mz_shift, product_mz_threshold, v11, v12, as.integer(enable_specific_losses), as.integer(enable_unspecific_losses), as.integer(round_decPow))
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[size_t] findFixedResidues(const String & sequence, bool keepN, bool keepC, const String & keep_const_pattern)
    findFixedResidues = function(sequence, keepN, keepC, keep_const_pattern){
    
        if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        if(!( (is_scalar_integer(keepN) || is_scalar_double(keepN)) && keepN == as.integer(keepN))){ stop("arg keepN wrong type") }
        if(!( (is_scalar_integer(keepC) || is_scalar_double(keepC)) && keepC == as.integer(keepC))){ stop("arg keepC wrong type") }
        if(!((is.R6(keep_const_pattern) && class(keep_const_pattern)[1]=="String") || is_scalar_character(keep_const_pattern))){ stop("arg keep_const_pattern wrong type") }
    
    
    
    
        py_ans = private$py_obj$findFixedResidues(sequence, as.integer(keepN), as.integer(keepC), keep_const_pattern)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MRMFP_ComponentGroupParams
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFP_ComponentGroupParams.html
MRMFP_ComponentGroupParams <- R6Class(classname = "MRMFP_ComponentGroupParams",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_group_name = function(component_group_name){
    
        if(!missing(component_group_name)){
            if(!((is.R6(component_group_name) && class(component_group_name)[1]=="String") || is_scalar_character(component_group_name))){ stop("arg component_group_name wrong type") }
        
        
            private$py_obj$component_group_name <- component_group_name
            } else {
        
                py_ans = private$py_obj$component_group_name
            r_result = py_ans
                return(r_result)
                }
        },
        params = function(params){
    
        if(!missing(params)){
            if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        
        
            private$py_obj$params <- params
            } else {
        
                py_ans = private$py_obj$params
            r_result = Param$new(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFP_ComponentGroupParams()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFP_ComponentGroupParams()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFP_ComponentGroupParams(MRMFP_ComponentGroupParams &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFP_ComponentGroupParams")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFP_ComponentGroupParams(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFP_ComponentGroupParams()
    # C++ signature: void MRMFP_ComponentGroupParams(MRMFP_ComponentGroupParams &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFP_ComponentGroupParams")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFP_ComponentGroupParams" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFP_ComponentParams
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFP_ComponentParams.html
MRMFP_ComponentParams <- R6Class(classname = "MRMFP_ComponentParams",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_name = function(component_name){
    
        if(!missing(component_name)){
            if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
        
        
            private$py_obj$component_name <- component_name
            } else {
        
                py_ans = private$py_obj$component_name
            r_result = py_ans
                return(r_result)
                }
        },
        component_group_name = function(component_group_name){
    
        if(!missing(component_group_name)){
            if(!((is.R6(component_group_name) && class(component_group_name)[1]=="String") || is_scalar_character(component_group_name))){ stop("arg component_group_name wrong type") }
        
        
            private$py_obj$component_group_name <- component_group_name
            } else {
        
                py_ans = private$py_obj$component_group_name
            r_result = py_ans
                return(r_result)
                }
        },
        params = function(params){
    
        if(!missing(params)){
            if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        
        
            private$py_obj$params <- params
            } else {
        
                py_ans = private$py_obj$params
            r_result = Param$new(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFP_ComponentParams()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFP_ComponentParams()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFP_ComponentParams(MRMFP_ComponentParams &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFP_ComponentParams")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFP_ComponentParams(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFP_ComponentParams()
    # C++ signature: void MRMFP_ComponentParams(MRMFP_ComponentParams &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFP_ComponentParams")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFP_ComponentParams" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFQC_ComponentGroupPairQCs
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFQC_ComponentGroupPairQCs.html
MRMFQC_ComponentGroupPairQCs <- R6Class(classname = "MRMFQC_ComponentGroupPairQCs",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_group_name = function(component_group_name){
    
        if(!missing(component_group_name)){
            if(!((is.R6(component_group_name) && class(component_group_name)[1]=="String") || is_scalar_character(component_group_name))){ stop("arg component_group_name wrong type") }
        
        
            private$py_obj$component_group_name <- component_group_name
            } else {
        
                py_ans = private$py_obj$component_group_name
            r_result = py_ans
                return(r_result)
                }
        },
        resolution_pair_name = function(resolution_pair_name){
    
        if(!missing(resolution_pair_name)){
            if(!((is.R6(resolution_pair_name) && class(resolution_pair_name)[1]=="String") || is_scalar_character(resolution_pair_name))){ stop("arg resolution_pair_name wrong type") }
        
        
            private$py_obj$resolution_pair_name <- resolution_pair_name
            } else {
        
                py_ans = private$py_obj$resolution_pair_name
            r_result = py_ans
                return(r_result)
                }
        },
        resolution_l = function(resolution_l){
    
        if(!missing(resolution_l)){
            if(!(is_scalar_double(resolution_l))){ stop("arg resolution_l wrong type") }
        
        
            private$py_obj$resolution_l <- resolution_l
            } else {
        
                py_ans = private$py_obj$resolution_l
                r_result = py_ans
                return(r_result)
                }
        },
        resolution_u = function(resolution_u){
    
        if(!missing(resolution_u)){
            if(!(is_scalar_double(resolution_u))){ stop("arg resolution_u wrong type") }
        
        
            private$py_obj$resolution_u <- resolution_u
            } else {
        
                py_ans = private$py_obj$resolution_u
                r_result = py_ans
                return(r_result)
                }
        },
        rt_diff_l = function(rt_diff_l){
    
        if(!missing(rt_diff_l)){
            if(!(is_scalar_double(rt_diff_l))){ stop("arg rt_diff_l wrong type") }
        
        
            private$py_obj$rt_diff_l <- rt_diff_l
            } else {
        
                py_ans = private$py_obj$rt_diff_l
                r_result = py_ans
                return(r_result)
                }
        },
        rt_diff_u = function(rt_diff_u){
    
        if(!missing(rt_diff_u)){
            if(!(is_scalar_double(rt_diff_u))){ stop("arg rt_diff_u wrong type") }
        
        
            private$py_obj$rt_diff_u <- rt_diff_u
            } else {
        
                py_ans = private$py_obj$rt_diff_u
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFQC_ComponentGroupPairQCs()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentGroupPairQCs()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentGroupPairQCs(MRMFQC_ComponentGroupPairQCs &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFQC_ComponentGroupPairQCs")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentGroupPairQCs(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentGroupPairQCs()
    # C++ signature: void MRMFQC_ComponentGroupPairQCs(MRMFQC_ComponentGroupPairQCs &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFQC_ComponentGroupPairQCs")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFQC_ComponentGroupPairQCs" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFQC_ComponentGroupQCs
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFQC_ComponentGroupQCs.html
MRMFQC_ComponentGroupQCs <- R6Class(classname = "MRMFQC_ComponentGroupQCs",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_group_name = function(component_group_name){
    
        if(!missing(component_group_name)){
            if(!((is.R6(component_group_name) && class(component_group_name)[1]=="String") || is_scalar_character(component_group_name))){ stop("arg component_group_name wrong type") }
        
        
            private$py_obj$component_group_name <- component_group_name
            } else {
        
                py_ans = private$py_obj$component_group_name
            r_result = py_ans
                return(r_result)
                }
        },
        retention_time_l = function(retention_time_l){
    
        if(!missing(retention_time_l)){
            if(!(is_scalar_double(retention_time_l))){ stop("arg retention_time_l wrong type") }
        
        
            private$py_obj$retention_time_l <- retention_time_l
            } else {
        
                py_ans = private$py_obj$retention_time_l
                r_result = py_ans
                return(r_result)
                }
        },
        retention_time_u = function(retention_time_u){
    
        if(!missing(retention_time_u)){
            if(!(is_scalar_double(retention_time_u))){ stop("arg retention_time_u wrong type") }
        
        
            private$py_obj$retention_time_u <- retention_time_u
            } else {
        
                py_ans = private$py_obj$retention_time_u
                r_result = py_ans
                return(r_result)
                }
        },
        intensity_l = function(intensity_l){
    
        if(!missing(intensity_l)){
            if(!(is_scalar_double(intensity_l))){ stop("arg intensity_l wrong type") }
        
        
            private$py_obj$intensity_l <- intensity_l
            } else {
        
                py_ans = private$py_obj$intensity_l
                r_result = py_ans
                return(r_result)
                }
        },
        intensity_u = function(intensity_u){
    
        if(!missing(intensity_u)){
            if(!(is_scalar_double(intensity_u))){ stop("arg intensity_u wrong type") }
        
        
            private$py_obj$intensity_u <- intensity_u
            } else {
        
                py_ans = private$py_obj$intensity_u
                r_result = py_ans
                return(r_result)
                }
        },
        overall_quality_l = function(overall_quality_l){
    
        if(!missing(overall_quality_l)){
            if(!(is_scalar_double(overall_quality_l))){ stop("arg overall_quality_l wrong type") }
        
        
            private$py_obj$overall_quality_l <- overall_quality_l
            } else {
        
                py_ans = private$py_obj$overall_quality_l
                r_result = py_ans
                return(r_result)
                }
        },
        overall_quality_u = function(overall_quality_u){
    
        if(!missing(overall_quality_u)){
            if(!(is_scalar_double(overall_quality_u))){ stop("arg overall_quality_u wrong type") }
        
        
            private$py_obj$overall_quality_u <- overall_quality_u
            } else {
        
                py_ans = private$py_obj$overall_quality_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_heavy_l = function(n_heavy_l){
    
        if(!missing(n_heavy_l)){
            if(!( (is_scalar_integer(n_heavy_l) || is_scalar_double(n_heavy_l)) && n_heavy_l == as.integer(n_heavy_l))){ stop("arg n_heavy_l wrong type") }
        
        
            private$py_obj$n_heavy_l <- as.integer(n_heavy_l)
            } else {
        
                py_ans = private$py_obj$n_heavy_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_heavy_u = function(n_heavy_u){
    
        if(!missing(n_heavy_u)){
            if(!( (is_scalar_integer(n_heavy_u) || is_scalar_double(n_heavy_u)) && n_heavy_u == as.integer(n_heavy_u))){ stop("arg n_heavy_u wrong type") }
        
        
            private$py_obj$n_heavy_u <- as.integer(n_heavy_u)
            } else {
        
                py_ans = private$py_obj$n_heavy_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_light_l = function(n_light_l){
    
        if(!missing(n_light_l)){
            if(!( (is_scalar_integer(n_light_l) || is_scalar_double(n_light_l)) && n_light_l == as.integer(n_light_l))){ stop("arg n_light_l wrong type") }
        
        
            private$py_obj$n_light_l <- as.integer(n_light_l)
            } else {
        
                py_ans = private$py_obj$n_light_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_light_u = function(n_light_u){
    
        if(!missing(n_light_u)){
            if(!( (is_scalar_integer(n_light_u) || is_scalar_double(n_light_u)) && n_light_u == as.integer(n_light_u))){ stop("arg n_light_u wrong type") }
        
        
            private$py_obj$n_light_u <- as.integer(n_light_u)
            } else {
        
                py_ans = private$py_obj$n_light_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_detecting_l = function(n_detecting_l){
    
        if(!missing(n_detecting_l)){
            if(!( (is_scalar_integer(n_detecting_l) || is_scalar_double(n_detecting_l)) && n_detecting_l == as.integer(n_detecting_l))){ stop("arg n_detecting_l wrong type") }
        
        
            private$py_obj$n_detecting_l <- as.integer(n_detecting_l)
            } else {
        
                py_ans = private$py_obj$n_detecting_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_detecting_u = function(n_detecting_u){
    
        if(!missing(n_detecting_u)){
            if(!( (is_scalar_integer(n_detecting_u) || is_scalar_double(n_detecting_u)) && n_detecting_u == as.integer(n_detecting_u))){ stop("arg n_detecting_u wrong type") }
        
        
            private$py_obj$n_detecting_u <- as.integer(n_detecting_u)
            } else {
        
                py_ans = private$py_obj$n_detecting_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_quantifying_l = function(n_quantifying_l){
    
        if(!missing(n_quantifying_l)){
            if(!( (is_scalar_integer(n_quantifying_l) || is_scalar_double(n_quantifying_l)) && n_quantifying_l == as.integer(n_quantifying_l))){ stop("arg n_quantifying_l wrong type") }
        
        
            private$py_obj$n_quantifying_l <- as.integer(n_quantifying_l)
            } else {
        
                py_ans = private$py_obj$n_quantifying_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_quantifying_u = function(n_quantifying_u){
    
        if(!missing(n_quantifying_u)){
            if(!( (is_scalar_integer(n_quantifying_u) || is_scalar_double(n_quantifying_u)) && n_quantifying_u == as.integer(n_quantifying_u))){ stop("arg n_quantifying_u wrong type") }
        
        
            private$py_obj$n_quantifying_u <- as.integer(n_quantifying_u)
            } else {
        
                py_ans = private$py_obj$n_quantifying_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_identifying_l = function(n_identifying_l){
    
        if(!missing(n_identifying_l)){
            if(!( (is_scalar_integer(n_identifying_l) || is_scalar_double(n_identifying_l)) && n_identifying_l == as.integer(n_identifying_l))){ stop("arg n_identifying_l wrong type") }
        
        
            private$py_obj$n_identifying_l <- as.integer(n_identifying_l)
            } else {
        
                py_ans = private$py_obj$n_identifying_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_identifying_u = function(n_identifying_u){
    
        if(!missing(n_identifying_u)){
            if(!( (is_scalar_integer(n_identifying_u) || is_scalar_double(n_identifying_u)) && n_identifying_u == as.integer(n_identifying_u))){ stop("arg n_identifying_u wrong type") }
        
        
            private$py_obj$n_identifying_u <- as.integer(n_identifying_u)
            } else {
        
                py_ans = private$py_obj$n_identifying_u
                r_result = py_ans
                return(r_result)
                }
        },
        n_transitions_l = function(n_transitions_l){
    
        if(!missing(n_transitions_l)){
            if(!( (is_scalar_integer(n_transitions_l) || is_scalar_double(n_transitions_l)) && n_transitions_l == as.integer(n_transitions_l))){ stop("arg n_transitions_l wrong type") }
        
        
            private$py_obj$n_transitions_l <- as.integer(n_transitions_l)
            } else {
        
                py_ans = private$py_obj$n_transitions_l
                r_result = py_ans
                return(r_result)
                }
        },
        n_transitions_u = function(n_transitions_u){
    
        if(!missing(n_transitions_u)){
            if(!( (is_scalar_integer(n_transitions_u) || is_scalar_double(n_transitions_u)) && n_transitions_u == as.integer(n_transitions_u))){ stop("arg n_transitions_u wrong type") }
        
        
            private$py_obj$n_transitions_u <- as.integer(n_transitions_u)
            } else {
        
                py_ans = private$py_obj$n_transitions_u
                r_result = py_ans
                return(r_result)
                }
        },
        ion_ratio_pair_name_1 = function(ion_ratio_pair_name_1){
    
        if(!missing(ion_ratio_pair_name_1)){
            if(!((is.R6(ion_ratio_pair_name_1) && class(ion_ratio_pair_name_1)[1]=="String") || is_scalar_character(ion_ratio_pair_name_1))){ stop("arg ion_ratio_pair_name_1 wrong type") }
        
        
            private$py_obj$ion_ratio_pair_name_1 <- ion_ratio_pair_name_1
            } else {
        
                py_ans = private$py_obj$ion_ratio_pair_name_1
            r_result = py_ans
                return(r_result)
                }
        },
        ion_ratio_pair_name_2 = function(ion_ratio_pair_name_2){
    
        if(!missing(ion_ratio_pair_name_2)){
            if(!((is.R6(ion_ratio_pair_name_2) && class(ion_ratio_pair_name_2)[1]=="String") || is_scalar_character(ion_ratio_pair_name_2))){ stop("arg ion_ratio_pair_name_2 wrong type") }
        
        
            private$py_obj$ion_ratio_pair_name_2 <- ion_ratio_pair_name_2
            } else {
        
                py_ans = private$py_obj$ion_ratio_pair_name_2
            r_result = py_ans
                return(r_result)
                }
        },
        ion_ratio_l = function(ion_ratio_l){
    
        if(!missing(ion_ratio_l)){
            if(!(is_scalar_double(ion_ratio_l))){ stop("arg ion_ratio_l wrong type") }
        
        
            private$py_obj$ion_ratio_l <- ion_ratio_l
            } else {
        
                py_ans = private$py_obj$ion_ratio_l
                r_result = py_ans
                return(r_result)
                }
        },
        ion_ratio_u = function(ion_ratio_u){
    
        if(!missing(ion_ratio_u)){
            if(!(is_scalar_double(ion_ratio_u))){ stop("arg ion_ratio_u wrong type") }
        
        
            private$py_obj$ion_ratio_u <- ion_ratio_u
            } else {
        
                py_ans = private$py_obj$ion_ratio_u
                r_result = py_ans
                return(r_result)
                }
        },
        ion_ratio_feature_name = function(ion_ratio_feature_name){
    
        if(!missing(ion_ratio_feature_name)){
            if(!((is.R6(ion_ratio_feature_name) && class(ion_ratio_feature_name)[1]=="String") || is_scalar_character(ion_ratio_feature_name))){ stop("arg ion_ratio_feature_name wrong type") }
        
        
            private$py_obj$ion_ratio_feature_name <- ion_ratio_feature_name
            } else {
        
                py_ans = private$py_obj$ion_ratio_feature_name
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFQC_ComponentGroupQCs()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentGroupQCs()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentGroupQCs(MRMFQC_ComponentGroupQCs &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFQC_ComponentGroupQCs")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentGroupQCs(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentGroupQCs()
    # C++ signature: void MRMFQC_ComponentGroupQCs(MRMFQC_ComponentGroupQCs &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFQC_ComponentGroupQCs")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFQC_ComponentGroupQCs" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFQC_ComponentQCs
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFQC_ComponentQCs.html
MRMFQC_ComponentQCs <- R6Class(classname = "MRMFQC_ComponentQCs",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_name = function(component_name){
    
        if(!missing(component_name)){
            if(!((is.R6(component_name) && class(component_name)[1]=="String") || is_scalar_character(component_name))){ stop("arg component_name wrong type") }
        
        
            private$py_obj$component_name <- component_name
            } else {
        
                py_ans = private$py_obj$component_name
            r_result = py_ans
                return(r_result)
                }
        },
        retention_time_l = function(retention_time_l){
    
        if(!missing(retention_time_l)){
            if(!(is_scalar_double(retention_time_l))){ stop("arg retention_time_l wrong type") }
        
        
            private$py_obj$retention_time_l <- retention_time_l
            } else {
        
                py_ans = private$py_obj$retention_time_l
                r_result = py_ans
                return(r_result)
                }
        },
        retention_time_u = function(retention_time_u){
    
        if(!missing(retention_time_u)){
            if(!(is_scalar_double(retention_time_u))){ stop("arg retention_time_u wrong type") }
        
        
            private$py_obj$retention_time_u <- retention_time_u
            } else {
        
                py_ans = private$py_obj$retention_time_u
                r_result = py_ans
                return(r_result)
                }
        },
        intensity_l = function(intensity_l){
    
        if(!missing(intensity_l)){
            if(!(is_scalar_double(intensity_l))){ stop("arg intensity_l wrong type") }
        
        
            private$py_obj$intensity_l <- intensity_l
            } else {
        
                py_ans = private$py_obj$intensity_l
                r_result = py_ans
                return(r_result)
                }
        },
        intensity_u = function(intensity_u){
    
        if(!missing(intensity_u)){
            if(!(is_scalar_double(intensity_u))){ stop("arg intensity_u wrong type") }
        
        
            private$py_obj$intensity_u <- intensity_u
            } else {
        
                py_ans = private$py_obj$intensity_u
                r_result = py_ans
                return(r_result)
                }
        },
        overall_quality_l = function(overall_quality_l){
    
        if(!missing(overall_quality_l)){
            if(!(is_scalar_double(overall_quality_l))){ stop("arg overall_quality_l wrong type") }
        
        
            private$py_obj$overall_quality_l <- overall_quality_l
            } else {
        
                py_ans = private$py_obj$overall_quality_l
                r_result = py_ans
                return(r_result)
                }
        },
        overall_quality_u = function(overall_quality_u){
    
        if(!missing(overall_quality_u)){
            if(!(is_scalar_double(overall_quality_u))){ stop("arg overall_quality_u wrong type") }
        
        
            private$py_obj$overall_quality_u <- overall_quality_u
            } else {
        
                py_ans = private$py_obj$overall_quality_u
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFQC_ComponentQCs()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentQCs()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentQCs(MRMFQC_ComponentQCs &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFQC_ComponentQCs")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFQC_ComponentQCs(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFQC_ComponentQCs()
    # C++ signature: void MRMFQC_ComponentQCs(MRMFQC_ComponentQCs &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFQC_ComponentQCs")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFQC_ComponentQCs" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFeature
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeature.html
MRMFeature <- R6Class(classname = "MRMFeature",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeature()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeature()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeature(MRMFeature &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeature")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeature(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeature()
    # C++ signature: void MRMFeature(MRMFeature &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeature")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeature" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: OpenSwath_Scores getScores()
    getScores = function(){
    
        py_ans = private$py_obj$getScores()
        r_ans = OpenSwath_Scores$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setScores(OpenSwath_Scores s)
    setScores = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "OpenSwath_Scores")){ stop("arg s wrong type") }
    
        private$py_obj$setScores(s)
        invisible()
    },
    
    # C++ signature: Feature getFeature(String key)
    getFeature = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getFeature(key)
        r_ans = Feature$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addFeature(Feature & f, String key)
    addFeature = function(f, key){
    
        if(!(is.R6(f) && class(f)[1] == "Feature")){ stop("arg f wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addFeature(f, key)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Feature] getFeatures()
    getFeatures = function(){
    
        py_ans = private$py_obj$getFeatures()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void getFeatureIDs(libcpp_vector[String] & result)
    getFeatureIDs = function(result){
    
        if(!(is_list(result) && all(sapply(result),is_scalar_character))){ stop("arg result wrong type") }
        v0 = r_to_py(modify_depth(result,1,py_builtin$bytes(result,'utf-8')))
        private$py_obj$getFeatureIDs(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(result <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: Feature getPrecursorFeature(String key)
    getPrecursorFeature = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getPrecursorFeature(key)
        r_ans = Feature$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addPrecursorFeature(Feature & f, String key)
    addPrecursorFeature = function(f, key){
    
        if(!(is.R6(f) && class(f)[1] == "Feature")){ stop("arg f wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addPrecursorFeature(f, key)
        invisible()
    },
    
    # C++ signature: void getPrecursorFeatureIDs(libcpp_vector[String] & result)
    getPrecursorFeatureIDs = function(result){
    
        if(!(is_list(result) && all(sapply(result),is_scalar_character))){ stop("arg result wrong type") }
        v0 = r_to_py(modify_depth(result,1,py_builtin$bytes(result,'utf-8')))
        private$py_obj$getPrecursorFeatureIDs(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(result <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: float getQuality(size_t index)
    getQuality = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getQuality(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuality(size_t index, float q)
    setQuality = function(index, q){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
    
        private$py_obj$setQuality(as.integer(index), q)
        invisible()
    },
    
    # C++ signature: float getOverallQuality()
    getOverallQuality = function(){
    
        py_ans = private$py_obj$getOverallQuality()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOverallQuality(float q)
    setOverallQuality = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setOverallQuality(q)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Feature] getSubordinates()
    getSubordinates = function(){
    
        py_ans = private$py_obj$getSubordinates()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSubordinates(libcpp_vector[Feature])
    setSubordinates = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Feature")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setSubordinates(v0)
        
        invisible()
    },
    
    # C++ signature: bool encloses(double rt, double mz)
    encloses = function(rt, mz){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
    
        py_ans = private$py_obj$encloses(rt, mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: ConvexHull2D getConvexHull()
    getConvexHull = function(){
    
        py_ans = private$py_obj$getConvexHull()
        r_ans = ConvexHull2D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[ConvexHull2D] getConvexHulls()
    getConvexHulls = function(){
    
        py_ans = private$py_obj$getConvexHulls()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setConvexHulls(libcpp_vector[ConvexHull2D])
    setConvexHulls = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConvexHull2D")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setConvexHulls(v0)
        
        invisible()
    },
    
    # C++ signature: float getWidth()
    getWidth = function(){
    
        py_ans = private$py_obj$getWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWidth(float q)
    setWidth = function(q){
    
        if(!(is_scalar_double(q))){ stop("arg q wrong type") }
    
        private$py_obj$setWidth(q)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int q)
    setCharge = function(q){
    
        if(!( (is_scalar_integer(q) || is_scalar_double(q)) && q == as.integer(q))){ stop("arg q wrong type") }
    
        private$py_obj$setCharge(as.integer(q))
        invisible()
    },
    
    # C++ signature: AnnotationState getAnnotationState()
    getAnnotationState = function(){
    
        py_ans = private$py_obj$getAnnotationState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification] & peptides)
    setPeptideIdentifications = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$setPeptideIdentifications(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _MRMFeatureFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeatureFilter.html
MRMFeatureFilter <- R6Class(classname = "MRMFeatureFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeatureFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeatureFilter()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureFilter(MRMFeatureFilter &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeatureFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeatureFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureFilter()
    # C++ signature: void MRMFeatureFilter(MRMFeatureFilter &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeatureFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeatureFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void FilterFeatureMap(FeatureMap features, MRMFeatureQC filter_criteria, TargetedExperiment transitions)
    FilterFeatureMap = function(features, filter_criteria, transitions){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(filter_criteria) && class(filter_criteria)[1] == "MRMFeatureQC")){ stop("arg filter_criteria wrong type") }
        if(!(is.R6(transitions) && class(transitions)[1] == "TargetedExperiment")){ stop("arg transitions wrong type") }
    
    
    
        private$py_obj$FilterFeatureMap(features, filter_criteria, transitions)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MRMFeatureFinderScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeatureFinderScoring.html
MRMFeatureFinderScoring <- R6Class(classname = "MRMFeatureFinderScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeatureFinderScoring()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMFeatureFinderScoring) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMFeatureFinderScoring()
        invisible()
    }
    
    },
    
    # C++ signature: void pickExperiment(MSExperiment & chromatograms, FeatureMap & output, TargetedExperiment & transition_exp_, TransformationDescription trafo, MSExperiment & swath_map)
    pickExperiment = function(chromatograms, output, transition_exp_, trafo, swath_map){
    
        if(!(is.R6(chromatograms) && class(chromatograms)[1] == "MSExperiment")){ stop("arg chromatograms wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!(is.R6(transition_exp_) && class(transition_exp_)[1] == "TargetedExperiment")){ stop("arg transition_exp_ wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "TransformationDescription")){ stop("arg trafo wrong type") }
        if(!(is.R6(swath_map) && class(swath_map)[1] == "MSExperiment")){ stop("arg swath_map wrong type") }
    
    
    
    
    
        private$py_obj$pickExperiment(chromatograms, output, transition_exp_, trafo, swath_map)
        invisible()
    },
    
    # C++ signature: void setStrictFlag(bool flag)
    setStrictFlag = function(flag){
    
        if(!( (is_scalar_integer(flag) || is_scalar_double(flag)) && flag == as.integer(flag))){ stop("arg flag wrong type") }
    
        private$py_obj$setStrictFlag(as.integer(flag))
        invisible()
    },
    
    # C++ signature: void setMS1Map(shared_ptr[SpectrumAccessOpenMS] ms1_map)
    setMS1Map_0 = function(ms1_map){
    
        if(!(all(class(ms1_map) == c('SpectrumAccessOpenMS','R6')))){ stop("arg ms1_map wrong type") }
        input_ms1_map <- r_to_py(ms1_map)
        private$py_obj$`_setMS1Map_0`(input_ms1_map)
        invisible()
    },
    
    # C++ signature: void setMS1Map(shared_ptr[SpectrumAccessOpenMSCached] ms1_map)
    setMS1Map_1 = function(ms1_map){
    
        if(!(all(class(ms1_map) == c('SpectrumAccessOpenMSCached','R6')))){ stop("arg ms1_map wrong type") }
        input_ms1_map <- r_to_py(ms1_map)
        private$py_obj$`_setMS1Map_1`(input_ms1_map)
        invisible()
    },
    
    # C++ signature: void setMS1Map(shared_ptr[SpectrumAccessOpenMS] ms1_map)
    # C++ signature: void setMS1Map(shared_ptr[SpectrumAccessOpenMSCached] ms1_map)
    setMS1Map = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMS','R6')))) { self$setMS1Map_0(...) }
        else if ((length(arg_list)==1) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMSCached','R6')))) { self$setMS1Map_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void scorePeakgroups(LightMRMTransitionGroupCP transition_group, TransformationDescription trafo, libcpp_vector[SwathMap] swath_maps, FeatureMap & output, bool ms1only)
    scorePeakgroups = function(transition_group, trafo, swath_maps, output, ms1only){
    
        if(!(is.R6(transition_group) && class(transition_group)[1] == "LightMRMTransitionGroupCP")){ stop("arg transition_group wrong type") }
        if(!(is.R6(trafo) && class(trafo)[1] == "TransformationDescription")){ stop("arg trafo wrong type") }
        if(!(is_list(swath_maps) && all(sapply(swath_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg swath_maps wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(ms1only) || is_scalar_double(ms1only)) && ms1only == as.integer(ms1only))){ stop("arg ms1only wrong type") }
    
    
        v2 <- r_to_py(swath_maps)
    
    
        private$py_obj$scorePeakgroups(transition_group, trafo, v2, output, as.integer(ms1only))
        
        invisible()
    },
    
    # C++ signature: void prepareProteinPeptideMaps_(LightTargetedExperiment & transition_exp)
    prepareProteinPeptideMaps_ = function(transition_exp){
    
        if(!(is.R6(transition_exp) && class(transition_exp)[1] == "LightTargetedExperiment")){ stop("arg transition_exp wrong type") }
    
        private$py_obj$prepareProteinPeptideMaps_(transition_exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MRMFeaturePicker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeaturePicker.html
MRMFeaturePicker <- R6Class(classname = "MRMFeaturePicker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeaturePicker()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeaturePicker()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeaturePicker(MRMFeaturePicker &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeaturePicker")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeaturePicker(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeaturePicker()
    # C++ signature: void MRMFeaturePicker(MRMFeaturePicker &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeaturePicker")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeaturePicker" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFeaturePickerFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeaturePickerFile.html
MRMFeaturePickerFile <- R6Class(classname = "MRMFeaturePickerFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeaturePickerFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeaturePickerFile()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeaturePickerFile(MRMFeaturePickerFile &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeaturePickerFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeaturePickerFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeaturePickerFile()
    # C++ signature: void MRMFeaturePickerFile(MRMFeaturePickerFile &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeaturePickerFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeaturePickerFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, libcpp_vector[MRMFP_ComponentParams] & cp_list, libcpp_vector[MRMFP_ComponentGroupParams] & cgp_list)
    load = function(filename, cp_list, cgp_list){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(cp_list) && all(sapply(cp_list,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MRMFP_ComponentParams")))){ stop("arg cp_list wrong type") }
        if(!(is_list(cgp_list) && all(sapply(cgp_list,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MRMFP_ComponentGroupParams")))){ stop("arg cgp_list wrong type") }
    
        v1 <- r_to_py(cp_list)
        v2 <- r_to_py(cgp_list)
        private$py_obj$load(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(cp_list <- byref_1))
        eval.parent(substitute(cgp_list <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _MRMFeatureQC
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeatureQC.html
MRMFeatureQC <- R6Class(classname = "MRMFeatureQC",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        component_qcs = function(component_qcs){
    
        if(!missing(component_qcs)){
            if(!(is_list(component_qcs) && all(sapply(component_qcs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MRMFQC_ComponentQCs")))){ stop("arg component_qcs wrong type") }
        
            v0 <- r_to_py(component_qcs)
            private$py_obj$component_qcs <- v0
            } else {
            
                py_ans = private$py_obj$component_qcs
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        component_group_qcs = function(component_group_qcs){
    
        if(!missing(component_group_qcs)){
            if(!(is_list(component_group_qcs) && all(sapply(component_group_qcs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MRMFQC_ComponentGroupQCs")))){ stop("arg component_group_qcs wrong type") }
        
            v0 <- r_to_py(component_group_qcs)
            private$py_obj$component_group_qcs <- v0
            } else {
            
                py_ans = private$py_obj$component_group_qcs
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        component_group_pair_qcs = function(component_group_pair_qcs){
    
        if(!missing(component_group_pair_qcs)){
            if(!(is_list(component_group_pair_qcs) && all(sapply(component_group_pair_qcs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MRMFQC_ComponentGroupPairQCs")))){ stop("arg component_group_pair_qcs wrong type") }
        
            v0 <- r_to_py(component_group_pair_qcs)
            private$py_obj$component_group_pair_qcs <- v0
            } else {
            
                py_ans = private$py_obj$component_group_pair_qcs
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MRMFeatureQC()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeatureQC()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureQC(MRMFeatureQC &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeatureQC")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeatureQC(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureQC()
    # C++ signature: void MRMFeatureQC(MRMFeatureQC &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeatureQC")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeatureQC" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _MRMFeatureQCFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFeatureQCFile.html
MRMFeatureQCFile <- R6Class(classname = "MRMFeatureQCFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFeatureQCFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFeatureQCFile()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureQCFile(MRMFeatureQCFile &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFeatureQCFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFeatureQCFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFeatureQCFile()
    # C++ signature: void MRMFeatureQCFile(MRMFeatureQCFile &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFeatureQCFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFeatureQCFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, MRMFeatureQC & mrmfqc, const bool is_component_group)
    load = function(filename, mrmfqc, is_component_group){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(mrmfqc) && class(mrmfqc)[1] == "MRMFeatureQC")){ stop("arg mrmfqc wrong type") }
        if(!( (is_scalar_integer(is_component_group) || is_scalar_double(is_component_group)) && is_component_group == as.integer(is_component_group))){ stop("arg is_component_group wrong type") }
    
    
    
        private$py_obj$load(filename, mrmfqc, as.integer(is_component_group))
        invisible()
    }
)
) 

# R implementation of _MRMFragmentSelection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMFragmentSelection.html
MRMFragmentSelection <- R6Class(classname = "MRMFragmentSelection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMFragmentSelection()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMFragmentSelection()
        invisible()
    
    
    },
    
    # C++ signature: void MRMFragmentSelection(MRMFragmentSelection)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMFragmentSelection")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMFragmentSelection(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMFragmentSelection()
    # C++ signature: void MRMFragmentSelection(MRMFragmentSelection)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMFragmentSelection")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMFragmentSelection" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void selectFragments(libcpp_vector[Peak1D] & selected_peaks, MSSpectrum & spec)
    selectFragments = function(selected_peaks, spec){
    
        if(!(is_list(selected_peaks) && all(sapply(selected_peaks,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Peak1D")))){ stop("arg selected_peaks wrong type") }
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        v0 <- r_to_py(selected_peaks)
    
        private$py_obj$selectFragments(v0, spec)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(selected_peaks <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MRMIonSeries
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMIonSeries.html
MRMIonSeries <- R6Class(classname = "MRMIonSeries",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMIonSeries()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMIonSeries) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMIonSeries()
        invisible()
    }
    
    },
    
    # C++ signature: void annotateTransitionCV(ReactionMonitoringTransition & tr, String annotation)
    annotateTransitionCV = function(tr, annotation){
    
        if(!(is.R6(tr) && class(tr)[1] == "ReactionMonitoringTransition")){ stop("arg tr wrong type") }
        if(!((is.R6(annotation) && class(annotation)[1]=="String") || is_scalar_character(annotation))){ stop("arg annotation wrong type") }
    
    
        private$py_obj$annotateTransitionCV(tr, annotation)
        invisible()
    },
    
    # C++ signature: void annotateTransition(ReactionMonitoringTransition & tr, Peptide peptide, double precursor_mz_threshold, double product_mz_threshold, bool enable_reannotation, libcpp_vector[String] fragment_types, libcpp_vector[size_t] fragment_charges, bool enable_specific_losses, bool enable_unspecific_losses, int round_decPow)
    annotateTransition = function(tr, peptide, precursor_mz_threshold, product_mz_threshold, enable_reannotation, fragment_types, fragment_charges, enable_specific_losses, enable_unspecific_losses, round_decPow){
    
        if(!(is.R6(tr) && class(tr)[1] == "ReactionMonitoringTransition")){ stop("arg tr wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "Peptide")){ stop("arg peptide wrong type") }
        if(!(is_scalar_double(precursor_mz_threshold))){ stop("arg precursor_mz_threshold wrong type") }
        if(!(is_scalar_double(product_mz_threshold))){ stop("arg product_mz_threshold wrong type") }
        if(!( (is_scalar_integer(enable_reannotation) || is_scalar_double(enable_reannotation)) && enable_reannotation == as.integer(enable_reannotation))){ stop("arg enable_reannotation wrong type") }
        if(!(is_list(fragment_types) && all(sapply(fragment_types),is_scalar_character))){ stop("arg fragment_types wrong type") }
        if(!(is_list(fragment_charges) && all(sapply(fragment_charges,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg fragment_charges wrong type") }
        if(!( (is_scalar_integer(enable_specific_losses) || is_scalar_double(enable_specific_losses)) && enable_specific_losses == as.integer(enable_specific_losses))){ stop("arg enable_specific_losses wrong type") }
        if(!( (is_scalar_integer(enable_unspecific_losses) || is_scalar_double(enable_unspecific_losses)) && enable_unspecific_losses == as.integer(enable_unspecific_losses))){ stop("arg enable_unspecific_losses wrong type") }
        if(!( (is_scalar_integer(round_decPow) || is_scalar_double(round_decPow)) && round_decPow == as.integer(round_decPow))){ stop("arg round_decPow wrong type") }
    
    
    
    
    
        v5 = r_to_py(modify_depth(fragment_types,1,py_builtin$bytes(fragment_types,'utf-8')))
        v6 <- r_to_py(fragment_charges)
    
    
    
        private$py_obj$annotateTransition(tr, peptide, precursor_mz_threshold, product_mz_threshold, as.integer(enable_reannotation), v5, v6, as.integer(enable_specific_losses), as.integer(enable_unspecific_losses), as.integer(round_decPow))
        
        invisible()
    }
)
) 

# R implementation of _MRMMapping
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMMapping.html
MRMMapping <- R6Class(classname = "MRMMapping",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMMapping()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMMapping) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMMapping()
        invisible()
    }
    
    },
    
    # C++ signature: void mapExperiment(MSExperiment input_chromatograms, TargetedExperiment targeted_exp, MSExperiment & output)
    mapExperiment = function(input_chromatograms, targeted_exp, output){
    
        if(!(is.R6(input_chromatograms) && class(input_chromatograms)[1] == "MSExperiment")){ stop("arg input_chromatograms wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
    
    
    
        private$py_obj$mapExperiment(input_chromatograms, targeted_exp, output)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MRMRTNormalizer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMRTNormalizer.html
MRMRTNormalizer <- R6Class(classname = "MRMRTNormalizer",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: bool chauvenet(libcpp_vector[double] residuals, int pos)
    MRMRTNormalizer$chauvenet = function(residuals, pos){
    
        if(!(is_list(residuals) && all(sapply(residuals,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg residuals wrong type") }
        if(!( (is_scalar_integer(pos) || is_scalar_double(pos)) && pos == as.integer(pos))){ stop("arg pos wrong type") }
        v0 <- r_to_py(residuals)
    
        py_ans = Pymod$MRMRTNormalizer$chauvenet(v0, as.integer(pos))
        
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: double chauvenet_probability(libcpp_vector[double] residuals, int pos)
    MRMRTNormalizer$chauvenet_probability = function(residuals, pos){
    
        if(!(is_list(residuals) && all(sapply(residuals,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg residuals wrong type") }
        if(!( (is_scalar_integer(pos) || is_scalar_double(pos)) && pos == as.integer(pos))){ stop("arg pos wrong type") }
        v0 <- r_to_py(residuals)
    
        py_ans = Pymod$MRMRTNormalizer$chauvenet_probability(v0, as.integer(pos))
        
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool computeBinnedCoverage(libcpp_pair[double,double] rtRange, libcpp_vector[libcpp_pair[double,double]] & pairs, int nrBins, int minPeptidesPerBin, int minBinsFilled)
    MRMRTNormalizer$computeBinnedCoverage = function(rtRange, pairs, nrBins, minPeptidesPerBin, minBinsFilled){
    
        if(!(is_list(rtRange) && length(rtRange) == 2 && is_scalar_double(rtRange[[1]]) && is_scalar_double(rtRange[[2]]))){ stop("arg rtRange wrong type") }
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg pairs wrong type") }
        if(!( (is_scalar_integer(nrBins) || is_scalar_double(nrBins)) && nrBins == as.integer(nrBins))){ stop("arg nrBins wrong type") }
        if(!( (is_scalar_integer(minPeptidesPerBin) || is_scalar_double(minPeptidesPerBin)) && minPeptidesPerBin == as.integer(minPeptidesPerBin))){ stop("arg minPeptidesPerBin wrong type") }
        if(!( (is_scalar_integer(minBinsFilled) || is_scalar_double(minBinsFilled)) && minBinsFilled == as.integer(minBinsFilled))){ stop("arg minBinsFilled wrong type") }
        v0 = r_to_py(list(rtRange[[1]],rtRange[[2]]))
        v1 <- r_to_py(pairs)
    
    
    
        py_ans = Pymod$MRMRTNormalizer$computeBinnedCoverage(v0, v1, as.integer(nrBins), as.integer(minPeptidesPerBin), as.integer(minBinsFilled))
        byref_1 <- py_to_r(v1)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: libcpp_vector[libcpp_pair[double,double]] removeOutliersIterative(libcpp_vector[libcpp_pair[double,double]] & pairs, double rsq_limit, double coverage_limit, bool use_chauvenet, libcpp_string outlier_detection_method)
    MRMRTNormalizer$removeOutliersIterative = function(pairs, rsq_limit, coverage_limit, use_chauvenet, outlier_detection_method){
    
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg pairs wrong type") }
        if(!(is_scalar_double(rsq_limit))){ stop("arg rsq_limit wrong type") }
        if(!(is_scalar_double(coverage_limit))){ stop("arg coverage_limit wrong type") }
        if(!( (is_scalar_integer(use_chauvenet) || is_scalar_double(use_chauvenet)) && use_chauvenet == as.integer(use_chauvenet))){ stop("arg use_chauvenet wrong type") }
        if(!(is_scalar_character(outlier_detection_method))){ stop("arg outlier_detection_method wrong type") }
        v0 <- r_to_py(pairs)
    
    
    
    outlier_detection_method_4 = py_builtin$bytes(outlier_detection_method,'utf-8')
        py_ans = Pymod$MRMRTNormalizer$removeOutliersIterative(v0, rsq_limit, coverage_limit, as.integer(use_chauvenet), outlier_detection_method)
        byref_0 <- py_to_r(v0)
        r_ans <- py_ans
        return(r_ans)
    }
    
    # C++ signature: libcpp_vector[libcpp_pair[double,double]] removeOutliersRANSAC(libcpp_vector[libcpp_pair[double,double]] & pairs, double rsq_limit, double coverage_limit, size_t max_iterations, double max_rt_threshold, size_t sampling_size)
    MRMRTNormalizer$removeOutliersRANSAC = function(pairs, rsq_limit, coverage_limit, max_iterations, max_rt_threshold, sampling_size){
    
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg pairs wrong type") }
        if(!(is_scalar_double(rsq_limit))){ stop("arg rsq_limit wrong type") }
        if(!(is_scalar_double(coverage_limit))){ stop("arg coverage_limit wrong type") }
        if(!( (is_scalar_integer(max_iterations) || is_scalar_double(max_iterations)) && max_iterations == as.integer(max_iterations))){ stop("arg max_iterations wrong type") }
        if(!(is_scalar_double(max_rt_threshold))){ stop("arg max_rt_threshold wrong type") }
        if(!( (is_scalar_integer(sampling_size) || is_scalar_double(sampling_size)) && sampling_size == as.integer(sampling_size))){ stop("arg sampling_size wrong type") }
        v0 <- r_to_py(pairs)
    
    
    
    
    
        py_ans = Pymod$MRMRTNormalizer$removeOutliersRANSAC(v0, rsq_limit, coverage_limit, as.integer(max_iterations), max_rt_threshold, as.integer(sampling_size))
        byref_0 <- py_to_r(v0)
        r_ans <- py_ans
        return(r_ans)
    } 

# R implementation of _MRMScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1MRMScoring.html
MRMScoring <- R6Class(classname = "MRMScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: double calcXcorrCoelutionScore()
    calcXcorrCoelutionScore = function(){
    
        py_ans = private$py_obj$calcXcorrCoelutionScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcXcorrCoelutionWeightedScore(libcpp_vector[double] & normalized_library_intensity)
    calcXcorrCoelutionWeightedScore = function(normalized_library_intensity){
    
        if(!(is_list(normalized_library_intensity) && all(sapply(normalized_library_intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg normalized_library_intensity wrong type") }
        v0 <- r_to_py(normalized_library_intensity)
        py_ans = private$py_obj$calcXcorrCoelutionWeightedScore(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(normalized_library_intensity <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] calcSeparateXcorrContrastCoelutionScore()
    calcSeparateXcorrContrastCoelutionScore = function(){
    
        py_ans = private$py_obj$calcSeparateXcorrContrastCoelutionScore()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: double calcXcorrPrecursorContrastCoelutionScore()
    calcXcorrPrecursorContrastCoelutionScore = function(){
    
        py_ans = private$py_obj$calcXcorrPrecursorContrastCoelutionScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcXcorrShapeScore()
    calcXcorrShapeScore = function(){
    
        py_ans = private$py_obj$calcXcorrShapeScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcXcorrShapeWeightedScore(libcpp_vector[double] & normalized_library_intensity)
    calcXcorrShapeWeightedScore = function(normalized_library_intensity){
    
        if(!(is_list(normalized_library_intensity) && all(sapply(normalized_library_intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg normalized_library_intensity wrong type") }
        v0 <- r_to_py(normalized_library_intensity)
        py_ans = private$py_obj$calcXcorrShapeWeightedScore(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(normalized_library_intensity <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] calcSeparateXcorrContrastShapeScore()
    calcSeparateXcorrContrastShapeScore = function(){
    
        py_ans = private$py_obj$calcSeparateXcorrContrastShapeScore()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: double calcXcorrPrecursorContrastShapeScore()
    calcXcorrPrecursorContrastShapeScore = function(){
    
        py_ans = private$py_obj$calcXcorrPrecursorContrastShapeScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcRTScore(LightCompound & peptide, double normalized_experimental_rt)
    calcRTScore = function(peptide, normalized_experimental_rt){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "LightCompound")){ stop("arg peptide wrong type") }
        if(!(is_scalar_double(normalized_experimental_rt))){ stop("arg normalized_experimental_rt wrong type") }
    
    
        py_ans = private$py_obj$calcRTScore(peptide, normalized_experimental_rt)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcMIScore()
    calcMIScore = function(){
    
        py_ans = private$py_obj$calcMIScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcMIWeightedScore(const libcpp_vector[double] & normalized_library_intensity)
    calcMIWeightedScore = function(normalized_library_intensity){
    
        if(!(is_list(normalized_library_intensity) && all(sapply(normalized_library_intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg normalized_library_intensity wrong type") }
        v0 <- r_to_py(normalized_library_intensity)
        py_ans = private$py_obj$calcMIWeightedScore(v0)
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcMIPrecursorScore()
    calcMIPrecursorScore = function(){
    
        py_ans = private$py_obj$calcMIPrecursorScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcMIPrecursorContrastScore()
    calcMIPrecursorContrastScore = function(){
    
        py_ans = private$py_obj$calcMIPrecursorContrastScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calcMIPrecursorCombinedScore()
    calcMIPrecursorCombinedScore = function(){
    
        py_ans = private$py_obj$calcMIPrecursorCombinedScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[double] calcSeparateMIContrastScore()
    calcSeparateMIContrastScore = function(){
    
        py_ans = private$py_obj$calcSeparateMIContrastScore()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[libcpp_vector[double]] getMIMatrix()
    getMIMatrix = function(){
    
        py_ans = private$py_obj$getMIMatrix()
        r_ans <- modify_depth(py_ans,1,as.list)
        return(r_ans)
    }
)
) 

# R implementation of _MRMTransitionGroup[_MSChromatogram,_ReactionMonitoringTransition]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMTransitionGroup[_MSChromatogram,_ReactionMonitoringTransition].html
MRMTransitionGroupCP <- R6Class(classname = "MRMTransitionGroupCP",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMTransitionGroupCP()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MRMTransitionGroupCP()
        invisible()
    
    
    },
    
    # C++ signature: void MRMTransitionGroupCP(MRMTransitionGroupCP &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MRMTransitionGroupCP")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MRMTransitionGroupCP(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MRMTransitionGroupCP()
    # C++ signature: void MRMTransitionGroupCP(MRMTransitionGroupCP &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMTransitionGroupCP")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MRMTransitionGroupCP" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTransitionGroupID()
    getTransitionGroupID = function(){
    
        py_ans = private$py_obj$getTransitionGroupID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTransitionGroupID(String tr_gr_id)
    setTransitionGroupID = function(tr_gr_id){
    
        if(!((is.R6(tr_gr_id) && class(tr_gr_id)[1]=="String") || is_scalar_character(tr_gr_id))){ stop("arg tr_gr_id wrong type") }
    
        private$py_obj$setTransitionGroupID(tr_gr_id)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ReactionMonitoringTransition] getTransitions()
    getTransitions = function(){
    
        py_ans = private$py_obj$getTransitions()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[ReactionMonitoringTransition] getTransitionsMuteable()
    getTransitionsMuteable = function(){
    
        py_ans = private$py_obj$getTransitionsMuteable()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addTransition(ReactionMonitoringTransition transition, String key)
    addTransition = function(transition, key){
    
        if(!(is.R6(transition) && class(transition)[1] == "ReactionMonitoringTransition")){ stop("arg transition wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addTransition(transition, key)
        invisible()
    },
    
    # C++ signature: ReactionMonitoringTransition getTransition(String key)
    getTransition = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getTransition(key)
        r_ans = ReactionMonitoringTransition$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasTransition(String key)
    hasTransition = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasTransition(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MSChromatogram] getChromatograms()
    getChromatograms = function(){
    
        py_ans = private$py_obj$getChromatograms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addChromatogram(MSChromatogram chromatogram, String key)
    addChromatogram = function(chromatogram, key){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addChromatogram(chromatogram, key)
        invisible()
    },
    
    # C++ signature: MSChromatogram getChromatogram(String key)
    getChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getChromatogram(key)
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasChromatogram(String key)
    hasChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasChromatogram(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MSChromatogram] getPrecursorChromatograms()
    getPrecursorChromatograms = function(){
    
        py_ans = private$py_obj$getPrecursorChromatograms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addPrecursorChromatogram(MSChromatogram chromatogram, String key)
    addPrecursorChromatogram = function(chromatogram, key){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
    
        private$py_obj$addPrecursorChromatogram(chromatogram, key)
        invisible()
    },
    
    # C++ signature: MSChromatogram getPrecursorChromatogram(String key)
    getPrecursorChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getPrecursorChromatogram(key)
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasPrecursorChromatogram(String key)
    hasPrecursorChromatogram = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$hasPrecursorChromatogram(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MRMFeature] getFeatures()
    getFeatures = function(){
    
        py_ans = private$py_obj$getFeatures()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MRMFeature] getFeaturesMuteable()
    getFeaturesMuteable = function(){
    
        py_ans = private$py_obj$getFeaturesMuteable()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addFeature(MRMFeature feature)
    addFeature = function(feature){
    
        if(!(is.R6(feature) && class(feature)[1] == "MRMFeature")){ stop("arg feature wrong type") }
    
        private$py_obj$addFeature(feature)
        invisible()
    },
    
    # C++ signature: MRMFeature getBestFeature()
    getBestFeature = function(){
    
        py_ans = private$py_obj$getBestFeature()
        r_ans = MRMFeature$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getLibraryIntensity(libcpp_vector[double] result)
    getLibraryIntensity = function(result){
    
        if(!(is_list(result) && all(sapply(result,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg result wrong type") }
        v0 <- r_to_py(result)
        private$py_obj$getLibraryIntensity(v0)
        
        invisible()
    },
    
    # C++ signature: MRMTransitionGroupCP subset(libcpp_vector[libcpp_string] tr_ids)
    subset = function(tr_ids){
    
        if(!(is_list(tr_ids) && all(sapply(tr_ids,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg tr_ids wrong type") }
        v0 <- r_to_py(modify_depth(tr_ids,1, function(a) py_builtin$bytes(a, 'utf-8')))
        py_ans = private$py_obj$subset(v0)
        
        r_ans = MRMTransitionGroupCP$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool isInternallyConsistent()
    isInternallyConsistent = function(){
    
        py_ans = private$py_obj$isInternallyConsistent()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool chromatogramIdsMatch()
    chromatogramIdsMatch = function(){
    
        py_ans = private$py_obj$chromatogramIdsMatch()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MRMTransitionGroupPicker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MRMTransitionGroupPicker.html
MRMTransitionGroupPicker <- R6Class(classname = "MRMTransitionGroupPicker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MRMTransitionGroupPicker()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MRMTransitionGroupPicker) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MRMTransitionGroupPicker()
        invisible()
    }
    
    },
    
    # C++ signature: void pickTransitionGroup(LightMRMTransitionGroupCP transition_group)
    pickTransitionGroup_0 = function(transition_group){
    
        if(!(is.R6(transition_group) && class(transition_group)[1] == "LightMRMTransitionGroupCP")){ stop("arg transition_group wrong type") }
    
        private$py_obj$`_pickTransitionGroup_0`(transition_group)
        invisible()
    },
    
    # C++ signature: void pickTransitionGroup(MRMTransitionGroupCP transition_group)
    pickTransitionGroup_1 = function(transition_group){
    
        if(!(is.R6(transition_group) && class(transition_group)[1] == "MRMTransitionGroupCP")){ stop("arg transition_group wrong type") }
    
        private$py_obj$`_pickTransitionGroup_1`(transition_group)
        invisible()
    },
    
    # C++ signature: void pickTransitionGroup(LightMRMTransitionGroupCP transition_group)
    # C++ signature: void pickTransitionGroup(MRMTransitionGroupCP transition_group)
    pickTransitionGroup = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "LightMRMTransitionGroupCP")) { self$pickTransitionGroup_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MRMTransitionGroupCP")) { self$pickTransitionGroup_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: MRMFeature createMRMFeature(LightMRMTransitionGroupCP transition_group, libcpp_vector[MSChromatogram] & picked_chroms, libcpp_vector[MSChromatogram] & smoothed_chroms, const int chr_idx, const int peak_idx)
    createMRMFeature = function(transition_group, picked_chroms, smoothed_chroms, chr_idx, peak_idx){
    
        if(!(is.R6(transition_group) && class(transition_group)[1] == "LightMRMTransitionGroupCP")){ stop("arg transition_group wrong type") }
        if(!(is_list(picked_chroms) && all(sapply(picked_chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg picked_chroms wrong type") }
        if(!(is_list(smoothed_chroms) && all(sapply(smoothed_chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg smoothed_chroms wrong type") }
        if(!( (is_scalar_integer(chr_idx) || is_scalar_double(chr_idx)) && chr_idx == as.integer(chr_idx))){ stop("arg chr_idx wrong type") }
        if(!( (is_scalar_integer(peak_idx) || is_scalar_double(peak_idx)) && peak_idx == as.integer(peak_idx))){ stop("arg peak_idx wrong type") }
    
        v1 <- r_to_py(picked_chroms)
        v2 <- r_to_py(smoothed_chroms)
    
    
        py_ans = private$py_obj$createMRMFeature(transition_group, v1, v2, as.integer(chr_idx), as.integer(peak_idx))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = MRMFeature$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(picked_chroms <- byref_1))
        eval.parent(substitute(smoothed_chroms <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void remove_overlapping_features(libcpp_vector[MSChromatogram] & picked_chroms, double best_left, double best_right)
    remove_overlapping_features = function(picked_chroms, best_left, best_right){
    
        if(!(is_list(picked_chroms) && all(sapply(picked_chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg picked_chroms wrong type") }
        if(!(is_scalar_double(best_left))){ stop("arg best_left wrong type") }
        if(!(is_scalar_double(best_right))){ stop("arg best_right wrong type") }
        v0 <- r_to_py(picked_chroms)
    
    
        private$py_obj$remove_overlapping_features(v0, best_left, best_right)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(picked_chroms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void findLargestPeak(libcpp_vector[MSChromatogram] & picked_chroms, int & chr_idx, int & peak_idx)
    findLargestPeak = function(picked_chroms, chr_idx, peak_idx){
    
        if(!(is_list(picked_chroms) && all(sapply(picked_chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg picked_chroms wrong type") }
        if(!( (is_scalar_integer(chr_idx) || is_scalar_double(chr_idx)) && chr_idx == as.integer(chr_idx))){ stop("arg chr_idx wrong type") }
        if(!( (is_scalar_integer(peak_idx) || is_scalar_double(peak_idx)) && peak_idx == as.integer(peak_idx))){ stop("arg peak_idx wrong type") }
        v0 <- r_to_py(picked_chroms)
    
    
        private$py_obj$findLargestPeak(v0, as.integer(chr_idx), as.integer(peak_idx))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(picked_chroms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void findWidestPeakIndices(libcpp_vector[MSChromatogram] & picked_chroms, int & chrom_idx, int & point_idx)
    findWidestPeakIndices = function(picked_chroms, chrom_idx, point_idx){
    
        if(!(is_list(picked_chroms) && all(sapply(picked_chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg picked_chroms wrong type") }
        if(!( (is_scalar_integer(chrom_idx) || is_scalar_double(chrom_idx)) && chrom_idx == as.integer(chrom_idx))){ stop("arg chrom_idx wrong type") }
        if(!( (is_scalar_integer(point_idx) || is_scalar_double(point_idx)) && point_idx == as.integer(point_idx))){ stop("arg point_idx wrong type") }
        v0 <- r_to_py(picked_chroms)
    
    
        private$py_obj$findWidestPeakIndices(v0, as.integer(chrom_idx), as.integer(point_idx))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(picked_chroms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MS2File
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MS2File.html
MS2File <- R6Class(classname = "MS2File",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MS2File()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MS2File) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MS2File()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & exp)
    load = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$load(filename, exp)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MSChromatogram
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSChromatogram.html

# The representation of a chromatogram.
# Raw data access is proved by `get_peaks` and `set_peaks`, which yields numpy arrays
# Iterations yields access to underlying peak objects but is slower
# Extra data arrays can be accessed through getFloatDataArrays / getIntegerDataArrays / getStringDataArrays
# See help(ChromatogramSettings) for information about meta-information
# -----
# Usage:
# precursor = chromatogram.getPrecursor()
# product = chromatogram.getProduct()
# rt, intensities = chromatogram.get_peaks()
# -----
MSChromatogram <- R6Class(classname = "MSChromatogram",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSChromatogram()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSChromatogram()
        invisible()
    
    
    },
    
    # C++ signature: void MSChromatogram(MSChromatogram &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSChromatogram")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSChromatogram(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSChromatogram()
    # C++ signature: void MSChromatogram(MSChromatogram &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSChromatogram" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMZ()
# returns the mz of the product entry, makes sense especially for MRM scans
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void reserve(size_t n)
    reserve = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$reserve(as.integer(n))
        invisible()
    },
    
    # C++ signature: void updateRanges()
    updateRanges = function(){
    
        private$py_obj$updateRanges()
        invisible()
    },
    
    # C++ signature: void clear(int)
    clear = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$clear(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: void push_back(ChromatogramPeak)
# Append a peak
    push_back = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ChromatogramPeak")){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(in_0)
        invisible()
    },
    
    # C++ signature: bool isSorted()
    isSorted = function(){
    
        py_ans = private$py_obj$isSorted()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void sortByIntensity(bool reverse)
    sortByIntensity = function(reverse){
    
        if(!( (is_scalar_integer(reverse) || is_scalar_double(reverse)) && reverse == as.integer(reverse))){ stop("arg reverse wrong type") }
    
        private$py_obj$sortByIntensity(as.integer(reverse))
        invisible()
    },
    
    # C++ signature: void sortByPosition()
    sortByPosition = function(){
    
        private$py_obj$sortByPosition()
        invisible()
    },
    
    # C++ signature: int findNearest(double)
    findNearest = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$findNearest(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[FloatDataArray] getFloatDataArrays()
    getFloatDataArrays = function(){
    
        py_ans = private$py_obj$getFloatDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IntegerDataArray] getIntegerDataArrays()
    getIntegerDataArrays = function(){
    
        py_ans = private$py_obj$getIntegerDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[StringDataArray] getStringDataArrays()
    getStringDataArrays = function(){
    
        py_ans = private$py_obj$getStringDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setFloatDataArrays(libcpp_vector[FloatDataArray] fda)
    setFloatDataArrays = function(fda){
    
        if(!(is_list(fda) && all(sapply(fda,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FloatDataArray")))){ stop("arg fda wrong type") }
        v0 <- r_to_py(fda)
        private$py_obj$setFloatDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: void setIntegerDataArrays(libcpp_vector[IntegerDataArray] ida)
    setIntegerDataArrays = function(ida){
    
        if(!(is_list(ida) && all(sapply(ida,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IntegerDataArray")))){ stop("arg ida wrong type") }
        v0 <- r_to_py(ida)
        private$py_obj$setIntegerDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: void setStringDataArrays(libcpp_vector[StringDataArray] sda)
    setStringDataArrays = function(sda){
    
        if(!(is_list(sda) && all(sapply(sda,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "StringDataArray")))){ stop("arg sda wrong type") }
        v0 <- r_to_py(sda)
        private$py_obj$setStringDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: Product getProduct()
# Access to the product ion
    getProduct = function(){
    
        py_ans = private$py_obj$getProduct()
        r_ans = Product$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setProduct(Product p)
# Set the product ion
    setProduct = function(p){
    
        if(!(is.R6(p) && class(p)[1] == "Product")){ stop("arg p wrong type") }
    
        private$py_obj$setProduct(p)
        invisible()
    },
    
    # C++ signature: String getNativeID()
# returns the native identifier for the spectrum, used by the acquisition software.
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeID(String native_id)
# sets the native identifier for the spectrum, used by the acquisition software.
    setNativeID = function(native_id){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
    
        private$py_obj$setNativeID(native_id)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: InstrumentSettings getInstrumentSettings()
    getInstrumentSettings = function(){
    
        py_ans = private$py_obj$getInstrumentSettings()
        r_ans = InstrumentSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrumentSettings(InstrumentSettings instrument_settings)
    setInstrumentSettings = function(instrument_settings){
    
        if(!(is.R6(instrument_settings) && class(instrument_settings)[1] == "InstrumentSettings")){ stop("arg instrument_settings wrong type") }
    
        private$py_obj$setInstrumentSettings(instrument_settings)
        invisible()
    },
    
    # C++ signature: AcquisitionInfo getAcquisitionInfo()
    getAcquisitionInfo = function(){
    
        py_ans = private$py_obj$getAcquisitionInfo()
        r_ans = AcquisitionInfo$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAcquisitionInfo(AcquisitionInfo acquisition_info)
    setAcquisitionInfo = function(acquisition_info){
    
        if(!(is.R6(acquisition_info) && class(acquisition_info)[1] == "AcquisitionInfo")){ stop("arg acquisition_info wrong type") }
    
        private$py_obj$setAcquisitionInfo(acquisition_info)
        invisible()
    },
    
    # C++ signature: SourceFile getSourceFile()
    getSourceFile = function(){
    
        py_ans = private$py_obj$getSourceFile()
        r_ans = SourceFile$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSourceFile(SourceFile source_file)
    setSourceFile = function(source_file){
    
        if(!(is.R6(source_file) && class(source_file)[1] == "SourceFile")){ stop("arg source_file wrong type") }
    
        private$py_obj$setSourceFile(source_file)
        invisible()
    },
    
    # C++ signature: Precursor getPrecursor()
    getPrecursor = function(){
    
        py_ans = private$py_obj$getPrecursor()
        r_ans = Precursor$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPrecursor(Precursor precursor)
    setPrecursor = function(precursor){
    
        if(!(is.R6(precursor) && class(precursor)[1] == "Precursor")){ stop("arg precursor wrong type") }
    
        private$py_obj$setPrecursor(precursor)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: void setChromatogramType(ChromatogramType type)
    setChromatogramType = function(type){
    
        if(!(type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type wrong type") }
    
        private$py_obj$setChromatogramType(as.integer(type))
        invisible()
    },
    
    # C++ signature: ChromatogramType getChromatogramType()
    getChromatogramType = function(){
    
        py_ans = private$py_obj$getChromatogramType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    },
    
    # C++ signature: DPosition1 getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = DPosition1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition1 getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = DPosition1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMinInt()
    getMinInt = function(){
    
        py_ans = private$py_obj$getMinInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxInt()
    getMaxInt = function(){
    
        py_ans = private$py_obj$getMaxInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearRanges()
    clearRanges = function(){
    
        private$py_obj$clearRanges()
        invisible()
    }
)
) 

# R implementation of _MSDGroup
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSDGroup.html
MSDGroup <- R6Class(classname = "MSDGroup",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        },
        isd_group = function(isd_group){
    
        if(!missing(isd_group)){
            if(!(is.R6(isd_group) && class(isd_group)[1] == "ISDGroup")){ stop("arg isd_group wrong type") }
        
        
            private$py_obj$isd_group <- isd_group
            } else {
        
            if (is.null(private$py_obj$isd_group)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$isd_group ; if( is.null(py_ans) ) { return(NULL) }
            r_result = ISDGroup$new(py_ans)
                return(r_result)
                }
            }
        },
        number_of_decoy = function(number_of_decoy){
    
        if(!missing(number_of_decoy)){
            if(!( (is_scalar_integer(number_of_decoy) || is_scalar_double(number_of_decoy)) && number_of_decoy == as.integer(number_of_decoy))){ stop("arg number_of_decoy wrong type") }
        
        
            private$py_obj$number_of_decoy <- as.integer(number_of_decoy)
            } else {
        
                py_ans = private$py_obj$number_of_decoy
                r_result = py_ans
                return(r_result)
                }
        },
        number_of_target = function(number_of_target){
    
        if(!missing(number_of_target)){
            if(!( (is_scalar_integer(number_of_target) || is_scalar_double(number_of_target)) && number_of_target == as.integer(number_of_target))){ stop("arg number_of_target wrong type") }
        
        
            private$py_obj$number_of_target <- as.integer(number_of_target)
            } else {
        
                py_ans = private$py_obj$number_of_target
                r_result = py_ans
                return(r_result)
                }
        },
        number_of_target_plus_decoy = function(number_of_target_plus_decoy){
    
        if(!missing(number_of_target_plus_decoy)){
            if(!( (is_scalar_integer(number_of_target_plus_decoy) || is_scalar_double(number_of_target_plus_decoy)) && number_of_target_plus_decoy == as.integer(number_of_target_plus_decoy))){ stop("arg number_of_target_plus_decoy wrong type") }
        
        
            private$py_obj$number_of_target_plus_decoy <- as.integer(number_of_target_plus_decoy)
            } else {
        
                py_ans = private$py_obj$number_of_target_plus_decoy
                r_result = py_ans
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        
        
            private$py_obj$intensity <- intensity
            } else {
        
                py_ans = private$py_obj$intensity
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MSDGroup()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MSDGroup) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MSDGroup()
        invisible()
    }
    
    }
)
) 

# R implementation of _MSDataAggregatingConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSDataAggregatingConsumer.html
MSDataAggregatingConsumer <- R6Class(classname = "MSDataAggregatingConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram &)
    consumeChromatogram = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSChromatogram")){ stop("arg in_0 wrong type") }
    
        private$py_obj$consumeChromatogram(in_0)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    }
)
) 

# R implementation of _MSDataCachedConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSDataCachedConsumer.html
MSDataCachedConsumer <- R6Class(classname = "MSDataCachedConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSDataCachedConsumer(String filename)
    init_0 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$MSDataCachedConsumer(filename)
        invisible()
    
    
    },
    
    # C++ signature: void MSDataCachedConsumer(String filename, bool clear)
    init_1 = function(filename, clear){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(clear) || is_scalar_double(clear)) && clear == as.integer(clear))){ stop("arg clear wrong type") }
    
    
    
        private$py_obj <- Pymod$MSDataCachedConsumer(filename, as.integer(clear))
        invisible()
    
    
    },
    
    # C++ signature: void MSDataCachedConsumer(String filename)
    # C++ signature: void MSDataCachedConsumer(String filename, bool clear)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSDataCachedConsumer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    }
)
) 

# R implementation of _MSDataSqlConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSDataSqlConsumer.html
MSDataSqlConsumer <- R6Class(classname = "MSDataSqlConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSDataSqlConsumer(String filename, bool clearData, int buffer_size)
    initialize = function(filename, clearData, buffer_size){
    
    if(missing(clearData) && missing(buffer_size)){
         if( "python.builtin.object" %in% class(filename) && class_to_wrap(filename) == MSDataSqlConsumer ) { private$py_obj <- filename }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(clearData) || is_scalar_double(clearData)) && clearData == as.integer(clearData))){ stop("arg clearData wrong type") }
        if(!( (is_scalar_integer(buffer_size) || is_scalar_double(buffer_size)) && buffer_size == as.integer(buffer_size))){ stop("arg buffer_size wrong type") }
    
    
    
    
        private$py_obj <- Pymod$MSDataSqlConsumer(filename, as.integer(clearData), as.integer(buffer_size))
        invisible()
    }
    
    },
    
    # C++ signature: void flush()
    flush = function(){
    
        private$py_obj$flush()
        invisible()
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    }
)
) 

# R implementation of _MSDataStoringConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSDataStoringConsumer.html
MSDataStoringConsumer <- R6Class(classname = "MSDataStoringConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSDataStoringConsumer()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MSDataStoringConsumer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MSDataStoringConsumer()
        invisible()
    }
    
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram &)
    consumeChromatogram = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSChromatogram")){ stop("arg in_0 wrong type") }
    
        private$py_obj$consumeChromatogram(in_0)
        invisible()
    },
    
    # C++ signature: MSExperiment getData()
    getData = function(){
    
        py_ans = private$py_obj$getData()
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _MSExperiment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSExperiment.html

# In-Memory representation of a mass spectrometry experiment.
# -----
# Contains the data and metadata of an experiment performed with an MS (or
# HPLC and MS). This representation of an MS experiment is organized as list
# of spectra and chromatograms and provides an in-memory representation of
# popular mass-spectrometric file formats such as mzXML or mzML. The
# meta-data associated with an experiment is contained in
# ExperimentalSettings (by inheritance) while the raw data (as well as
# spectra and chromatogram level meta data) is stored in objects of type
# MSSpectrum and MSChromatogram, which are accessible through the getSpectrum
# and getChromatogram functions.
# -----
# Spectra can be accessed by direct iteration or by getSpectrum(),
# while chromatograms are accessed through getChromatogram().
# See help(ExperimentalSettings) for information about meta-data.
# -----
# Usage:
# exp = MSExperiment()
# MzMLFile().load(path_to_file, exp)
# for spectrum in exp:
# print(spectrum.size()) # prints number of peaks
# mz, intensities = spectrum.get_peaks()
# -----
MSExperiment <- R6Class(classname = "MSExperiment",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSExperiment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSExperiment()
        invisible()
    
    
    },
    
    # C++ signature: void MSExperiment(MSExperiment &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSExperiment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSExperiment()
    # C++ signature: void MSExperiment(MSExperiment &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSExperiment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: ExperimentalSettings getExperimentalSettings()
    getExperimentalSettings = function(){
    
        py_ans = private$py_obj$getExperimentalSettings()
        r_ans = ExperimentalSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addSpectrum(MSSpectrum spec)
    addSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$addSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void setSpectra(libcpp_vector[MSSpectrum] & spectra)
    setSpectra = function(spectra){
    
        if(!(is_list(spectra) && all(sapply(spectra,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg spectra wrong type") }
        v0 <- r_to_py(spectra)
        private$py_obj$setSpectra(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(spectra <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[MSSpectrum] getSpectra()
    getSpectra = function(){
    
        py_ans = private$py_obj$getSpectra()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addChromatogram(MSChromatogram chromatogram)
    addChromatogram = function(chromatogram){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
    
        private$py_obj$addChromatogram(chromatogram)
        invisible()
    },
    
    # C++ signature: void setChromatograms(libcpp_vector[MSChromatogram] chromatograms)
    setChromatograms = function(chromatograms){
    
        if(!(is_list(chromatograms) && all(sapply(chromatograms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg chromatograms wrong type") }
        v0 <- r_to_py(chromatograms)
        private$py_obj$setChromatograms(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[MSChromatogram] getChromatograms()
    getChromatograms = function(){
    
        py_ans = private$py_obj$getChromatograms()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: MSChromatogram getTIC()
    getTIC = function(){
    
        py_ans = private$py_obj$getTIC()
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void clear(bool clear_meta_data)
    clear = function(clear_meta_data){
    
        if(!( (is_scalar_integer(clear_meta_data) || is_scalar_double(clear_meta_data)) && clear_meta_data == as.integer(clear_meta_data))){ stop("arg clear_meta_data wrong type") }
    
        private$py_obj$clear(as.integer(clear_meta_data))
        invisible()
    },
    
    # C++ signature: void updateRanges()
    updateRanges_0 = function(){
    
        private$py_obj$`_updateRanges_0`()
        invisible()
    },
    
    # C++ signature: void updateRanges(int msLevel)
    updateRanges_1 = function(msLevel){
    
        if(!( (is_scalar_integer(msLevel) || is_scalar_double(msLevel)) && msLevel == as.integer(msLevel))){ stop("arg msLevel wrong type") }
    
        private$py_obj$`_updateRanges_1`(as.integer(msLevel))
        invisible()
    },
    
    # C++ signature: void updateRanges()
    # C++ signature: void updateRanges(int msLevel)
    updateRanges = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$updateRanges_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$updateRanges_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void reserveSpaceSpectra(size_t s)
    reserveSpaceSpectra = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$reserveSpaceSpectra(as.integer(s))
        invisible()
    },
    
    # C++ signature: void reserveSpaceChromatograms(size_t s)
    reserveSpaceChromatograms = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$reserveSpaceChromatograms(as.integer(s))
        invisible()
    },
    
    # C++ signature: double getMinMZ()
    getMinMZ = function(){
    
        py_ans = private$py_obj$getMinMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxMZ()
    getMaxMZ = function(){
    
        py_ans = private$py_obj$getMaxMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMinRT()
    getMinRT = function(){
    
        py_ans = private$py_obj$getMinRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxRT()
    getMaxRT = function(){
    
        py_ans = private$py_obj$getMaxRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned long int getSize()
    getSize = function(){
    
        py_ans = private$py_obj$getSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void resize(size_t s)
    resize = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$resize(as.integer(s))
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void reserve(size_t s)
    reserve = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$reserve(as.integer(s))
        invisible()
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void sortSpectra(bool sort_mz)
    sortSpectra_0 = function(sort_mz){
    
        if(!( (is_scalar_integer(sort_mz) || is_scalar_double(sort_mz)) && sort_mz == as.integer(sort_mz))){ stop("arg sort_mz wrong type") }
    
        private$py_obj$`_sortSpectra_0`(as.integer(sort_mz))
        invisible()
    },
    
    # C++ signature: void sortSpectra()
    sortSpectra_1 = function(){
    
        private$py_obj$`_sortSpectra_1`()
        invisible()
    },
    
    # C++ signature: void sortSpectra(bool sort_mz)
    # C++ signature: void sortSpectra()
    sortSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$sortSpectra_0(...) }
        else if (length(arg_list)==0) { self$sortSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void sortChromatograms(bool sort_rt)
    sortChromatograms_0 = function(sort_rt){
    
        if(!( (is_scalar_integer(sort_rt) || is_scalar_double(sort_rt)) && sort_rt == as.integer(sort_rt))){ stop("arg sort_rt wrong type") }
    
        private$py_obj$`_sortChromatograms_0`(as.integer(sort_rt))
        invisible()
    },
    
    # C++ signature: void sortChromatograms()
    sortChromatograms_1 = function(){
    
        private$py_obj$`_sortChromatograms_1`()
        invisible()
    },
    
    # C++ signature: void sortChromatograms(bool sort_rt)
    # C++ signature: void sortChromatograms()
    sortChromatograms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$sortChromatograms_0(...) }
        else if (length(arg_list)==0) { self$sortChromatograms_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool isSorted(bool check_mz)
    isSorted_0 = function(check_mz){
    
        if(!( (is_scalar_integer(check_mz) || is_scalar_double(check_mz)) && check_mz == as.integer(check_mz))){ stop("arg check_mz wrong type") }
    
        py_ans = private$py_obj$`_isSorted_0`(as.integer(check_mz))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isSorted()
    isSorted_1 = function(){
    
        py_ans = private$py_obj$`_isSorted_1`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isSorted(bool check_mz)
    # C++ signature: bool isSorted()
    isSorted = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$isSorted_0(...) }
        else if (length(arg_list)==0) { self$isSorted_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & toFill)
    getPrimaryMSRunPath = function(toFill){
    
        if(!(is_list(toFill) && all(sapply(toFill),is_scalar_character))){ stop("arg toFill wrong type") }
        v0 = r_to_py(modify_depth(toFill,1,py_builtin$bytes(toFill,'utf-8')))
        private$py_obj$getPrimaryMSRunPath(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(toFill <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void swap(MSExperiment)
    swap = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
    
        private$py_obj$swap(in_0)
        invisible()
    },
    
    # C++ signature: void reset()
    reset = function(){
    
        private$py_obj$reset()
        invisible()
    },
    
    # C++ signature: bool clearMetaDataArrays()
    clearMetaDataArrays = function(){
    
        py_ans = private$py_obj$clearMetaDataArrays()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[SourceFile] getSourceFiles()
    getSourceFiles = function(){
    
        py_ans = private$py_obj$getSourceFiles()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSourceFiles(libcpp_vector[SourceFile] source_files)
    setSourceFiles = function(source_files){
    
        if(!(is_list(source_files) && all(sapply(source_files,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SourceFile")))){ stop("arg source_files wrong type") }
        v0 <- r_to_py(source_files)
        private$py_obj$setSourceFiles(v0)
        
        invisible()
    },
    
    # C++ signature: DateTime getDateTime()
    getDateTime = function(){
    
        py_ans = private$py_obj$getDateTime()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDateTime(DateTime date_time)
    setDateTime = function(date_time){
    
        if(!(is.R6(date_time) && class(date_time)[1] == "DateTime")){ stop("arg date_time wrong type") }
    
        private$py_obj$setDateTime(date_time)
        invisible()
    },
    
    # C++ signature: Sample getSample()
    getSample = function(){
    
        py_ans = private$py_obj$getSample()
        r_ans = Sample$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSample(Sample sample)
    setSample = function(sample){
    
        if(!(is.R6(sample) && class(sample)[1] == "Sample")){ stop("arg sample wrong type") }
    
        private$py_obj$setSample(sample)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ContactPerson] getContacts()
    getContacts = function(){
    
        py_ans = private$py_obj$getContacts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setContacts(libcpp_vector[ContactPerson] contacts)
    setContacts = function(contacts){
    
        if(!(is_list(contacts) && all(sapply(contacts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ContactPerson")))){ stop("arg contacts wrong type") }
        v0 <- r_to_py(contacts)
        private$py_obj$setContacts(v0)
        
        invisible()
    },
    
    # C++ signature: Instrument getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
        r_ans = Instrument$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(Instrument instrument)
    setInstrument = function(instrument){
    
        if(!(is.R6(instrument) && class(instrument)[1] == "Instrument")){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: HPLC getHPLC()
    getHPLC = function(){
    
        py_ans = private$py_obj$getHPLC()
        r_ans = HPLC$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setHPLC(HPLC hplc)
    setHPLC = function(hplc){
    
        if(!(is.R6(hplc) && class(hplc)[1] == "HPLC")){ stop("arg hplc wrong type") }
    
        private$py_obj$setHPLC(hplc)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinIdentification] getProteinIdentifications()
    getProteinIdentifications = function(){
    
        py_ans = private$py_obj$getProteinIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProteinIdentifications(libcpp_vector[ProteinIdentification] protein_identifications)
    setProteinIdentifications = function(protein_identifications){
    
        if(!(is_list(protein_identifications) && all(sapply(protein_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_identifications wrong type") }
        v0 <- r_to_py(protein_identifications)
        private$py_obj$setProteinIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: String getFractionIdentifier()
    getFractionIdentifier = function(){
    
        py_ans = private$py_obj$getFractionIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFractionIdentifier(String fraction_identifier)
    setFractionIdentifier = function(fraction_identifier){
    
        if(!((is.R6(fraction_identifier) && class(fraction_identifier)[1]=="String") || is_scalar_character(fraction_identifier))){ stop("arg fraction_identifier wrong type") }
    
        private$py_obj$setFractionIdentifier(fraction_identifier)
        invisible()
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    },
    
    # C++ signature: DPosition2 getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition2 getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = as.list(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMinInt()
    getMinInt = function(){
    
        py_ans = private$py_obj$getMinInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxInt()
    getMaxInt = function(){
    
        py_ans = private$py_obj$getMaxInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearRanges()
    clearRanges = function(){
    
        private$py_obj$clearRanges()
        invisible()
    }
)
) 

# R implementation of _MSNumpressCoder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSNumpressCoder.html
MSNumpressCoder <- R6Class(classname = "MSNumpressCoder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSNumpressCoder()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSNumpressCoder()
        invisible()
    
    
    },
    
    # C++ signature: void MSNumpressCoder(MSNumpressCoder)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSNumpressCoder")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSNumpressCoder(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSNumpressCoder()
    # C++ signature: void MSNumpressCoder(MSNumpressCoder)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSNumpressCoder")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSNumpressCoder" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void encodeNP(libcpp_vector[double] in_, String & result, bool zlib_compression, NumpressConfig config)
    encodeNP = function(in_, result, zlib_compression, config){
    
        if(!(is_list(in_) && all(sapply(in_,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_ wrong type") }
        if(!((is.R6(result) && class(result)[1]=="String") || is_scalar_character(result))){ stop("arg result wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
        v0 <- r_to_py(in_)
    
    
    
        private$py_obj$encodeNP(v0, result, as.integer(zlib_compression), config)
        
        invisible()
    },
    
    # C++ signature: void decodeNP(const String & in_, libcpp_vector[double] & out, bool zlib_compression, NumpressConfig config)
    decodeNP = function(in_, out, zlib_compression, config){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg out wrong type") }
        if(!( (is_scalar_integer(zlib_compression) || is_scalar_double(zlib_compression)) && zlib_compression == as.integer(zlib_compression))){ stop("arg zlib_compression wrong type") }
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
    
        v1 <- r_to_py(out)
    
    
        private$py_obj$decodeNP(in_, v1, as.integer(zlib_compression), config)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void encodeNPRaw(libcpp_vector[double] in_, String & result, NumpressConfig config)
    encodeNPRaw = function(in_, result, config){
    
        if(!(is_list(in_) && all(sapply(in_,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_ wrong type") }
        if(!((is.R6(result) && class(result)[1]=="String") || is_scalar_character(result))){ stop("arg result wrong type") }
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
        v0 <- r_to_py(in_)
    
    
        private$py_obj$encodeNPRaw(v0, result, config)
        
        invisible()
    },
    
    # C++ signature: void decodeNPRaw(const String & in_, libcpp_vector[double] & out, NumpressConfig config)
    decodeNPRaw = function(in_, out, config){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(is_list(out) && all(sapply(out,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg out wrong type") }
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
    
        v1 <- r_to_py(out)
    
        private$py_obj$decodeNPRaw(in_, v1, config)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(out <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _MSPFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSPFile.html
MSPFile <- R6Class(classname = "MSPFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSPFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MSPFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MSPFile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(String filename, MSExperiment & exp)
    store = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$store(filename, exp)
        invisible()
    },
    
    # C++ signature: void load(String filename, libcpp_vector[PeptideIdentification] & ids, MSExperiment & exp)
    load = function(filename, ids, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        v1 <- r_to_py(ids)
    
        private$py_obj$load(filename, v1, exp)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _MSPGenericFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSPGenericFile.html
MSPGenericFile <- R6Class(classname = "MSPGenericFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSPGenericFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSPGenericFile()
        invisible()
    
    
    },
    
    # C++ signature: void MSPGenericFile(MSPGenericFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSPGenericFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSPGenericFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSPGenericFile(const String & filename, MSExperiment & library)
    init_2 = function(filename, library){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(library) && class(library)[1] == "MSExperiment")){ stop("arg library wrong type") }
    
    
    
        private$py_obj <- Pymod$MSPGenericFile(filename, library)
        invisible()
    
    
    },
    
    # C++ signature: void MSPGenericFile()
    # C++ signature: void MSPGenericFile(MSPGenericFile)
    # C++ signature: void MSPGenericFile(const String & filename, MSExperiment & library)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSPGenericFile")) { self$init_1(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSPGenericFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & library)
    load = function(filename, library){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(library) && class(library)[1] == "MSExperiment")){ stop("arg library wrong type") }
    
    
        private$py_obj$load(filename, library)
        invisible()
    },
    
    # C++ signature: void getDefaultParameters(Param & params)
    getDefaultParameters = function(params){
    
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
    
        private$py_obj$getDefaultParameters(params)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MSQuantifications
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSQuantifications.html
MSQuantifications <- R6Class(classname = "MSQuantifications",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSQuantifications()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSQuantifications()
        invisible()
    
    
    },
    
    # C++ signature: void MSQuantifications(MSQuantifications)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSQuantifications")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSQuantifications(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSQuantifications(FeatureMap fm, ExperimentalSettings & es, libcpp_vector[DataProcessing] & dps)
    init_2 = function(fm, es, dps){
    
        if(!(is.R6(fm) && class(fm)[1] == "FeatureMap")){ stop("arg fm wrong type") }
        if(!(is.R6(es) && class(es)[1] == "ExperimentalSettings")){ stop("arg es wrong type") }
        if(!(is_list(dps) && all(sapply(dps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "DataProcessing")))){ stop("arg dps wrong type") }
    
    
        v2 <- r_to_py(dps)
    
        private$py_obj <- Pymod$MSQuantifications(fm, es, v2)
        invisible()
    
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void MSQuantifications()
    # C++ signature: void MSQuantifications(MSQuantifications)
    # C++ signature: void MSQuantifications(FeatureMap fm, ExperimentalSettings & es, libcpp_vector[DataProcessing] & dps)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSQuantifications")) { self$init_1(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ExperimentalSettings") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "DataProcessing")))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSQuantifications" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[DataProcessing] getDataProcessingList()
    getDataProcessingList = function(){
    
        py_ans = private$py_obj$getDataProcessingList()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[Assay] getAssays()
    getAssays = function(){
    
        py_ans = private$py_obj$getAssays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[ConsensusMap] getConsensusMaps()
    getConsensusMaps = function(){
    
        py_ans = private$py_obj$getConsensusMaps()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setConsensusMaps(libcpp_vector[ConsensusMap])
    setConsensusMaps = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setConsensusMaps(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[FeatureMap] getFeatureMaps()
    getFeatureMaps = function(){
    
        py_ans = private$py_obj$getFeatureMaps()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: AnalysisSummary getAnalysisSummary()
    getAnalysisSummary = function(){
    
        py_ans = private$py_obj$getAnalysisSummary()
        r_ans = AnalysisSummary$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessingList(libcpp_vector[DataProcessing] dpl)
    setDataProcessingList = function(dpl){
    
        if(!(is_list(dpl) && all(sapply(dpl,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "DataProcessing")))){ stop("arg dpl wrong type") }
        v0 <- r_to_py(dpl)
        private$py_obj$setDataProcessingList(v0)
        
        invisible()
    },
    
    # C++ signature: void setAnalysisSummaryQuantType(QUANT_TYPES r)
    setAnalysisSummaryQuantType = function(r){
    
        if(!(r %in% c(0, 1, 2, 3))){ stop("arg r wrong type") }
    
        private$py_obj$setAnalysisSummaryQuantType(as.integer(r))
        invisible()
    },
    
    # C++ signature: void addConsensusMap(ConsensusMap m)
    addConsensusMap = function(m){
    
        if(!(is.R6(m) && class(m)[1] == "ConsensusMap")){ stop("arg m wrong type") }
    
        private$py_obj$addConsensusMap(m)
        invisible()
    },
    
    # C++ signature: void assignUIDs()
    assignUIDs = function(){
    
        private$py_obj$assignUIDs()
        invisible()
    },
    
    # C++ signature: libcpp_vector[SourceFile] getSourceFiles()
    getSourceFiles = function(){
    
        py_ans = private$py_obj$getSourceFiles()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSourceFiles(libcpp_vector[SourceFile] source_files)
    setSourceFiles = function(source_files){
    
        if(!(is_list(source_files) && all(sapply(source_files,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SourceFile")))){ stop("arg source_files wrong type") }
        v0 <- r_to_py(source_files)
        private$py_obj$setSourceFiles(v0)
        
        invisible()
    },
    
    # C++ signature: DateTime getDateTime()
    getDateTime = function(){
    
        py_ans = private$py_obj$getDateTime()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDateTime(DateTime date_time)
    setDateTime = function(date_time){
    
        if(!(is.R6(date_time) && class(date_time)[1] == "DateTime")){ stop("arg date_time wrong type") }
    
        private$py_obj$setDateTime(date_time)
        invisible()
    },
    
    # C++ signature: Sample getSample()
    getSample = function(){
    
        py_ans = private$py_obj$getSample()
        r_ans = Sample$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSample(Sample sample)
    setSample = function(sample){
    
        if(!(is.R6(sample) && class(sample)[1] == "Sample")){ stop("arg sample wrong type") }
    
        private$py_obj$setSample(sample)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ContactPerson] getContacts()
    getContacts = function(){
    
        py_ans = private$py_obj$getContacts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setContacts(libcpp_vector[ContactPerson] contacts)
    setContacts = function(contacts){
    
        if(!(is_list(contacts) && all(sapply(contacts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ContactPerson")))){ stop("arg contacts wrong type") }
        v0 <- r_to_py(contacts)
        private$py_obj$setContacts(v0)
        
        invisible()
    },
    
    # C++ signature: Instrument getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
        r_ans = Instrument$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(Instrument instrument)
    setInstrument = function(instrument){
    
        if(!(is.R6(instrument) && class(instrument)[1] == "Instrument")){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: HPLC getHPLC()
    getHPLC = function(){
    
        py_ans = private$py_obj$getHPLC()
        r_ans = HPLC$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setHPLC(HPLC hplc)
    setHPLC = function(hplc){
    
        if(!(is.R6(hplc) && class(hplc)[1] == "HPLC")){ stop("arg hplc wrong type") }
    
        private$py_obj$setHPLC(hplc)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinIdentification] getProteinIdentifications()
    getProteinIdentifications = function(){
    
        py_ans = private$py_obj$getProteinIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProteinIdentifications(libcpp_vector[ProteinIdentification] protein_identifications)
    setProteinIdentifications = function(protein_identifications){
    
        if(!(is_list(protein_identifications) && all(sapply(protein_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_identifications wrong type") }
        v0 <- r_to_py(protein_identifications)
        private$py_obj$setProteinIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: String getFractionIdentifier()
    getFractionIdentifier = function(){
    
        py_ans = private$py_obj$getFractionIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFractionIdentifier(String fraction_identifier)
    setFractionIdentifier = function(fraction_identifier){
    
        if(!((is.R6(fraction_identifier) && class(fraction_identifier)[1]=="String") || is_scalar_character(fraction_identifier))){ stop("arg fraction_identifier wrong type") }
    
        private$py_obj$setFractionIdentifier(fraction_identifier)
        invisible()
    },
    
    # C++ signature: void setIdentifier(String id)
    setIdentifier = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        private$py_obj$setIdentifier(id)
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFileType(String file_name)
    setLoadedFileType = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFileType(file_name)
        invisible()
    },
    
    # C++ signature: int getLoadedFileType()
    getLoadedFileType = function(){
    
        py_ans = private$py_obj$getLoadedFileType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLoadedFilePath(String file_name)
    setLoadedFilePath = function(file_name){
    
        if(!((is.R6(file_name) && class(file_name)[1]=="String") || is_scalar_character(file_name))){ stop("arg file_name wrong type") }
    
        private$py_obj$setLoadedFilePath(file_name)
        invisible()
    },
    
    # C++ signature: String getLoadedFilePath()
    getLoadedFilePath = function(){
    
        py_ans = private$py_obj$getLoadedFilePath()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _MSSim
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSSim.html
MSSim <- R6Class(classname = "MSSim",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSSim()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MSSim) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MSSim()
        invisible()
    }
    
    },
    
    # C++ signature: void simulate(shared_ptr[SimRandomNumberGenerator] rnd_gen, libcpp_vector[libcpp_vector[SimProtein]] peptides)
    simulate = function(rnd_gen, peptides){
    
        if(!(all(class(rnd_gen) == c('SimRandomNumberGenerator','R6')))){ stop("arg rnd_gen wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "SimProtein")))))){ stop("arg peptides wrong type") }
        input_rnd_gen <- r_to_py(rnd_gen)
        v1 <- r_to_py(peptides)
        private$py_obj$simulate(input_rnd_gen, v1)
        
        invisible()
    },
    
    # C++ signature: MSExperiment getExperiment()
    getExperiment = function(){
    
        py_ans = private$py_obj$getExperiment()
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: FeatureMap getSimulatedFeatures()
    getSimulatedFeatures = function(){
    
        py_ans = private$py_obj$getSimulatedFeatures()
        r_ans = FeatureMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: ConsensusMap getChargeConsensus()
    getChargeConsensus = function(){
    
        py_ans = private$py_obj$getChargeConsensus()
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: FeatureMap getContaminants()
    getContaminants = function(){
    
        py_ans = private$py_obj$getContaminants()
        r_ans = FeatureMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: ConsensusMap getLabelingConsensus()
    getLabelingConsensus = function(){
    
        py_ans = private$py_obj$getLabelingConsensus()
        r_ans = ConsensusMap$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSExperiment getPeakMap()
    getPeakMap = function(){
    
        py_ans = private$py_obj$getPeakMap()
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getIdentifications(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides)
    getIdentifications = function(proteins, peptides){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(peptides)
        private$py_obj$getIdentifications(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getMS2Identifications(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides)
    getMS2Identifications = function(proteins, peptides){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(peptides)
        private$py_obj$getMS2Identifications(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getFeatureIdentifications(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides)
    getFeatureIdentifications = function(proteins, peptides){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(peptides)
        private$py_obj$getFeatureIdentifications(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _MSSpectrum
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSSpectrum.html

# The representation of a 1D spectrum.
# Raw data access is proved by `get_peaks` and `set_peaks`, which yields numpy arrays
# Iterations yields access to underlying peak objects but is slower
# Extra data arrays can be accessed through getFloatDataArrays / getIntegerDataArrays / getStringDataArrays
# See help(SpectrumSettings) for information about meta-information
# -----
# Usage:
# ms_level = spectrum.getMSLevel()
# rt = spectrum.getRT()
# mz, intensities = spectrum.get_peaks()
# -----
MSSpectrum <- R6Class(classname = "MSSpectrum",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSSpectrum()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MSSpectrum()
        invisible()
    
    
    },
    
    # C++ signature: void MSSpectrum(MSSpectrum &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MSSpectrum(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MSSpectrum()
    # C++ signature: void MSSpectrum(MSSpectrum &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MSSpectrum" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: double getDriftTime()
    getDriftTime = function(){
    
        py_ans = private$py_obj$getDriftTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDriftTime(double)
    setDriftTime = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setDriftTime(in_0)
        invisible()
    },
    
    # C++ signature: unsigned int getMSLevel()
    getMSLevel = function(){
    
        py_ans = private$py_obj$getMSLevel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMSLevel(unsigned int)
    setMSLevel = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMSLevel(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void reserve(size_t n)
    reserve = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$reserve(as.integer(n))
        invisible()
    },
    
    # C++ signature: void updateRanges()
    updateRanges = function(){
    
        private$py_obj$updateRanges()
        invisible()
    },
    
    # C++ signature: void clear(bool clear_meta_data)
# Clears all data (and meta data if clear_meta_data is true)
    clear = function(clear_meta_data){
    
        if(!( (is_scalar_integer(clear_meta_data) || is_scalar_double(clear_meta_data)) && clear_meta_data == as.integer(clear_meta_data))){ stop("arg clear_meta_data wrong type") }
    
        private$py_obj$clear(as.integer(clear_meta_data))
        invisible()
    },
    
    # C++ signature: void push_back(Peak1D)
# Append a peak
    push_back = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Peak1D")){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(in_0)
        invisible()
    },
    
    # C++ signature: bool isSorted()
    isSorted = function(){
    
        py_ans = private$py_obj$isSorted()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int findNearest(double)
    findNearest_0 = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_findNearest_0`(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int findNearest(double, double)
    findNearest_1 = function(in_0, in_1){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$`_findNearest_1`(in_0, in_1)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int findNearest(double, double, double)
    findNearest_2 = function(in_0, in_1, in_2){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        if(!(is_scalar_double(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        py_ans = private$py_obj$`_findNearest_2`(in_0, in_1, in_2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int findNearest(double)
    # C++ signature: int findNearest(double, double)
    # C++ signature: int findNearest(double, double, double)
    findNearest = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_scalar_double(arg_list[[1]]))) { self$findNearest_0(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$findNearest_1(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$findNearest_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: int findHighestInWindow(double, double, double)
    findHighestInWindow = function(in_0, in_1, in_2){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        if(!(is_scalar_double(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        py_ans = private$py_obj$findHighestInWindow(in_0, in_1, in_2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum select(libcpp_vector[size_t] & indices)
    select = function(indices){
    
        if(!(is_list(indices) && all(sapply(indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indices wrong type") }
        v0 <- r_to_py(indices)
        py_ans = private$py_obj$select(v0)
        byref_0 <- py_to_r(v0)
        r_ans = MSSpectrum$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(indices <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double getTIC()
    getTIC = function(){
    
        py_ans = private$py_obj$getTIC()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void sortByIntensity(bool reverse)
    sortByIntensity = function(reverse){
    
        if(!( (is_scalar_integer(reverse) || is_scalar_double(reverse)) && reverse == as.integer(reverse))){ stop("arg reverse wrong type") }
    
        private$py_obj$sortByIntensity(as.integer(reverse))
        invisible()
    },
    
    # C++ signature: void sortByPosition()
    sortByPosition = function(){
    
        private$py_obj$sortByPosition()
        invisible()
    },
    
    # C++ signature: libcpp_vector[FloatDataArray] getFloatDataArrays()
    getFloatDataArrays = function(){
    
        py_ans = private$py_obj$getFloatDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IntegerDataArray] getIntegerDataArrays()
    getIntegerDataArrays = function(){
    
        py_ans = private$py_obj$getIntegerDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[StringDataArray] getStringDataArrays()
    getStringDataArrays = function(){
    
        py_ans = private$py_obj$getStringDataArrays()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setFloatDataArrays(libcpp_vector[FloatDataArray] fda)
    setFloatDataArrays = function(fda){
    
        if(!(is_list(fda) && all(sapply(fda,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FloatDataArray")))){ stop("arg fda wrong type") }
        v0 <- r_to_py(fda)
        private$py_obj$setFloatDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: void setIntegerDataArrays(libcpp_vector[IntegerDataArray] ida)
    setIntegerDataArrays = function(ida){
    
        if(!(is_list(ida) && all(sapply(ida,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IntegerDataArray")))){ stop("arg ida wrong type") }
        v0 <- r_to_py(ida)
        private$py_obj$setIntegerDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: void setStringDataArrays(libcpp_vector[StringDataArray] sda)
    setStringDataArrays = function(sda){
    
        if(!(is_list(sda) && all(sapply(sda,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "StringDataArray")))){ stop("arg sda wrong type") }
        v0 <- r_to_py(sda)
        private$py_obj$setStringDataArrays(v0)
        
        invisible()
    },
    
    # C++ signature: void unify(SpectrumSettings)
    unify = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumSettings")){ stop("arg in_0 wrong type") }
    
        private$py_obj$unify(in_0)
        invisible()
    },
    
    # C++ signature: int getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setType(SpectrumType)
    setType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2, 3))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getNativeID()
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeID(String)
    setNativeID = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setNativeID(in_0)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String)
    setComment = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setComment(in_0)
        invisible()
    },
    
    # C++ signature: InstrumentSettings getInstrumentSettings()
    getInstrumentSettings = function(){
    
        py_ans = private$py_obj$getInstrumentSettings()
        r_ans = InstrumentSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrumentSettings(InstrumentSettings)
    setInstrumentSettings = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InstrumentSettings")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setInstrumentSettings(in_0)
        invisible()
    },
    
    # C++ signature: AcquisitionInfo getAcquisitionInfo()
    getAcquisitionInfo = function(){
    
        py_ans = private$py_obj$getAcquisitionInfo()
        r_ans = AcquisitionInfo$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAcquisitionInfo(AcquisitionInfo)
    setAcquisitionInfo = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AcquisitionInfo")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setAcquisitionInfo(in_0)
        invisible()
    },
    
    # C++ signature: SourceFile getSourceFile()
    getSourceFile = function(){
    
        py_ans = private$py_obj$getSourceFile()
        r_ans = SourceFile$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSourceFile(SourceFile)
    setSourceFile = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SourceFile")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSourceFile(in_0)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Precursor] getPrecursors()
    getPrecursors = function(){
    
        py_ans = private$py_obj$getPrecursors()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPrecursors(libcpp_vector[Precursor])
    setPrecursors = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Precursor")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPrecursors(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Product] getProducts()
    getProducts = function(){
    
        py_ans = private$py_obj$getProducts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProducts(libcpp_vector[Product])
    setProducts = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Product")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setProducts(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification])
    setPeptideIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPeptideIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    },
    
    # C++ signature: DPosition1 getMin()
    getMin = function(){
    
        py_ans = private$py_obj$getMin()
        r_ans = DPosition1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: DPosition1 getMax()
    getMax = function(){
    
        py_ans = private$py_obj$getMax()
        r_ans = DPosition1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getMinInt()
    getMinInt = function(){
    
        py_ans = private$py_obj$getMinInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxInt()
    getMaxInt = function(){
    
        py_ans = private$py_obj$getMaxInt()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearRanges()
    clearRanges = function(){
    
        private$py_obj$clearRanges()
        invisible()
    }
)
) 

# R implementation of _MSstatsFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MSstatsFile.html
MSstatsFile <- R6Class(classname = "MSstatsFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MSstatsFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MSstatsFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MSstatsFile()
        invisible()
    }
    
    },
    
    # C++ signature: void storeLFQ(String & filename, ConsensusMap & consensus_map, ExperimentalDesign & design, StringList & reannotate_filenames, bool is_isotope_label_type, String & bioreplicate, String & condition, String & retention_time_summarization_method)
    storeLFQ = function(filename, consensus_map, design, reannotate_filenames, is_isotope_label_type, bioreplicate, condition, retention_time_summarization_method){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
        if(!(is.R6(design) && class(design)[1] == "ExperimentalDesign")){ stop("arg design wrong type") }
        if(!(is_list(reannotate_filenames) && all(sapply(reannotate_filenames),is_scalar_character))){ stop("arg reannotate_filenames wrong type") }
        if(!( (is_scalar_integer(is_isotope_label_type) || is_scalar_double(is_isotope_label_type)) && is_isotope_label_type == as.integer(is_isotope_label_type))){ stop("arg is_isotope_label_type wrong type") }
        if(!((is.R6(bioreplicate) && class(bioreplicate)[1]=="String") || is_scalar_character(bioreplicate))){ stop("arg bioreplicate wrong type") }
        if(!((is.R6(condition) && class(condition)[1]=="String") || is_scalar_character(condition))){ stop("arg condition wrong type") }
        if(!((is.R6(retention_time_summarization_method) && class(retention_time_summarization_method)[1]=="String") || is_scalar_character(retention_time_summarization_method))){ stop("arg retention_time_summarization_method wrong type") }
    
    
    
        v3 = r_to_py(modify_depth(reannotate_filenames,1,py_builtin$bytes(reannotate_filenames,'utf-8')))
    
    
    
    
        private$py_obj$storeLFQ(filename, consensus_map, design, v3, as.integer(is_isotope_label_type), bioreplicate, condition, retention_time_summarization_method)
        byref_3 <- modify_depth(py_to_r(v3),1,as.character)
    
        tryCatch({
        eval.parent(substitute(reannotate_filenames <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void storeISO(String & filename, ConsensusMap & consensus_map, ExperimentalDesign & design, StringList & reannotate_filenames, String & bioreplicate, String & condition, String & mixture, String & retention_time_summarization_method)
    storeISO = function(filename, consensus_map, design, reannotate_filenames, bioreplicate, condition, mixture, retention_time_summarization_method){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
        if(!(is.R6(design) && class(design)[1] == "ExperimentalDesign")){ stop("arg design wrong type") }
        if(!(is_list(reannotate_filenames) && all(sapply(reannotate_filenames),is_scalar_character))){ stop("arg reannotate_filenames wrong type") }
        if(!((is.R6(bioreplicate) && class(bioreplicate)[1]=="String") || is_scalar_character(bioreplicate))){ stop("arg bioreplicate wrong type") }
        if(!((is.R6(condition) && class(condition)[1]=="String") || is_scalar_character(condition))){ stop("arg condition wrong type") }
        if(!((is.R6(mixture) && class(mixture)[1]=="String") || is_scalar_character(mixture))){ stop("arg mixture wrong type") }
        if(!((is.R6(retention_time_summarization_method) && class(retention_time_summarization_method)[1]=="String") || is_scalar_character(retention_time_summarization_method))){ stop("arg retention_time_summarization_method wrong type") }
    
    
    
        v3 = r_to_py(modify_depth(reannotate_filenames,1,py_builtin$bytes(reannotate_filenames,'utf-8')))
    
    
    
    
        private$py_obj$storeISO(filename, consensus_map, design, v3, bioreplicate, condition, mixture, retention_time_summarization_method)
        byref_3 <- modify_depth(py_to_r(v3),1,as.character)
    
        tryCatch({
        eval.parent(substitute(reannotate_filenames <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _MZTrafoModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MZTrafoModel.html
MZTrafoModel <- R6Class(classname = "MZTrafoModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MZTrafoModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MZTrafoModel()
        invisible()
    
    
    },
    
    # C++ signature: void MZTrafoModel(MZTrafoModel &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MZTrafoModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MZTrafoModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MZTrafoModel(bool)
    init_2 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MZTrafoModel(as.integer(in_0))
        invisible()
    
    
    },
    
    # C++ signature: void MZTrafoModel()
    # C++ signature: void MZTrafoModel(MZTrafoModel &)
    # C++ signature: void MZTrafoModel(bool)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MZTrafoModel")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MZTrafoModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isTrained()
    isTrained = function(){
    
        py_ans = private$py_obj$isTrained()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double predict(double)
    predict = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$predict(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool train(CalibrationData, MZTrafoModel_MODELTYPE, bool, double, double)
    train_0 = function(in_0, in_1, in_2, in_3, in_4){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "CalibrationData")){ stop("arg in_0 wrong type") }
        if(!(in_1 %in% c(0, 1, 2, 3, 4))){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
        if(!(is_scalar_double(in_3))){ stop("arg in_3 wrong type") }
        if(!(is_scalar_double(in_4))){ stop("arg in_4 wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$`_train_0`(in_0, as.integer(in_1), as.integer(in_2), in_3, in_4)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool train(libcpp_vector[double], libcpp_vector[double], libcpp_vector[double], MZTrafoModel_MODELTYPE, bool)
    train_1 = function(in_0, in_1, in_2, in_3, in_4){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg in_2 wrong type") }
        if(!(in_3 %in% c(0, 1, 2, 3, 4))){ stop("arg in_3 wrong type") }
        if(!( (is_scalar_integer(in_4) || is_scalar_double(in_4)) && in_4 == as.integer(in_4))){ stop("arg in_4 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
        v2 <- r_to_py(in_2)
    
    
        py_ans = private$py_obj$`_train_1`(v0, v1, v2, as.integer(in_3), as.integer(in_4))
        
        
        
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool train(CalibrationData, MZTrafoModel_MODELTYPE, bool, double, double)
    # C++ signature: bool train(libcpp_vector[double], libcpp_vector[double], libcpp_vector[double], MZTrafoModel_MODELTYPE, bool)
    train = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "CalibrationData") && (arg_list[[2]] %in% c(0, 1, 2, 3, 4)) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]]))) { self$train_0(...) }
        else if ((length(arg_list)==5) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (arg_list[[4]] %in% c(0, 1, 2, 3, 4)) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$train_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getCoefficients(double & intercept, double & slope, double & power)
    getCoefficients = function(intercept, slope, power){
    
        if(!(is_scalar_double(intercept))){ stop("arg intercept wrong type") }
        if(!(is_scalar_double(slope))){ stop("arg slope wrong type") }
        if(!(is_scalar_double(power))){ stop("arg power wrong type") }
    
    
    
        private$py_obj$getCoefficients(intercept, slope, power)
        invisible()
    },
    
    # C++ signature: void setCoefficients(MZTrafoModel)
    setCoefficients_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MZTrafoModel")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setCoefficients_0`(in_0)
        invisible()
    },
    
    # C++ signature: void setCoefficients(double, double, double)
    setCoefficients_1 = function(in_0, in_1, in_2){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        if(!(is_scalar_double(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        private$py_obj$`_setCoefficients_1`(in_0, in_1, in_2)
        invisible()
    },
    
    # C++ signature: void setCoefficients(MZTrafoModel)
    # C++ signature: void setCoefficients(double, double, double)
    setCoefficients = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MZTrafoModel")) { self$setCoefficients_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$setCoefficients_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    }
)
)
    
    # C++ signature: libcpp_string enumToName(MZTrafoModel_MODELTYPE mt)
    MZTrafoModel$enumToName = function(mt){
    
        if(!(mt %in% c(0, 1, 2, 3, 4))){ stop("arg mt wrong type") }
    
        py_ans = Pymod$MZTrafoModel$enumToName(as.integer(mt))
        r_ans = as.character(py_ans)
        return(r_ans)
    }
    
    # C++ signature: size_t findNearest(libcpp_vector[MZTrafoModel] & tms, double rt)
    MZTrafoModel$findNearest = function(tms, rt){
    
        if(!(is_list(tms) && all(sapply(tms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MZTrafoModel")))){ stop("arg tms wrong type") }
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        v0 <- r_to_py(tms)
    
        py_ans = Pymod$MZTrafoModel$findNearest(v0, rt)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool isValidModel(MZTrafoModel & trafo)
    MZTrafoModel$isValidModel = function(trafo){
    
        if(!(is.R6(trafo) && class(trafo)[1] == "MZTrafoModel")){ stop("arg trafo wrong type") }
    
        py_ans = Pymod$MZTrafoModel$isValidModel(trafo)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: MZTrafoModel_MODELTYPE nameToEnum(libcpp_string name)
    MZTrafoModel$nameToEnum = function(name){
    
        if(!(is_scalar_character(name))){ stop("arg name wrong type") }
    name_0 = py_builtin$bytes(name,'utf-8')
        py_ans = Pymod$MZTrafoModel$nameToEnum(name)
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: void setCoefficientLimits(double offset, double scale, double power)
    MZTrafoModel$setCoefficientLimits = function(offset, scale, power){
    
        if(!(is_scalar_double(offset))){ stop("arg offset wrong type") }
        if(!(is_scalar_double(scale))){ stop("arg scale wrong type") }
        if(!(is_scalar_double(power))){ stop("arg power wrong type") }
    
    
    
        Pymod$MZTrafoModel$setCoefficientLimits(offset, scale, power)
    }
    
    # C++ signature: void setRANSACParams(RANSACParam p)
    MZTrafoModel$setRANSACParams = function(p){
    
        if(!(is.R6(p) && class(p)[1] == "RANSACParam")){ stop("arg p wrong type") }
    
        Pymod$MZTrafoModel$setRANSACParams(p)
    } 

# R implementation of _MapAlignmentAlgorithmIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentAlgorithmIdentification.html
MapAlignmentAlgorithmIdentification <- R6Class(classname = "MapAlignmentAlgorithmIdentification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentAlgorithmIdentification()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentAlgorithmIdentification) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentAlgorithmIdentification()
        invisible()
    }
    
    },
    
    # C++ signature: void align(libcpp_vector[MSExperiment] &, libcpp_vector[TransformationDescription] &, int)
    align_0 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSExperiment")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription")))){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
    
        private$py_obj$`_align_0`(v0, v1, as.integer(in_2))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void align(libcpp_vector[FeatureMap] &, libcpp_vector[TransformationDescription] &, int)
    align_1 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription")))){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
    
        private$py_obj$`_align_1`(v0, v1, as.integer(in_2))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void align(libcpp_vector[ConsensusMap] &, libcpp_vector[TransformationDescription] &, int)
    align_2 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription")))){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
    
        private$py_obj$`_align_2`(v0, v1, as.integer(in_2))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void align(libcpp_vector[MSExperiment] &, libcpp_vector[TransformationDescription] &, int)
    # C++ signature: void align(libcpp_vector[FeatureMap] &, libcpp_vector[TransformationDescription] &, int)
    # C++ signature: void align(libcpp_vector[ConsensusMap] &, libcpp_vector[TransformationDescription] &, int)
    align = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSExperiment"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription"))) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$align_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription"))) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$align_1(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription"))) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$align_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setReference(MSExperiment &)
    setReference_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setReference_0`(in_0)
        invisible()
    },
    
    # C++ signature: void setReference(FeatureMap &)
    setReference_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setReference_1`(in_0)
        invisible()
    },
    
    # C++ signature: void setReference(ConsensusMap &)
    setReference_2 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setReference_2`(in_0)
        invisible()
    },
    
    # C++ signature: void setReference(libcpp_vector[PeptideIdentification] &)
    setReference_3 = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$`_setReference_3`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setReference(MSExperiment &)
    # C++ signature: void setReference(FeatureMap &)
    # C++ signature: void setReference(ConsensusMap &)
    # C++ signature: void setReference(libcpp_vector[PeptideIdentification] &)
    setReference = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment")) { self$setReference_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap")) { self$setReference_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap")) { self$setReference_2(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$setReference_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MapAlignmentAlgorithmKD
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentAlgorithmKD.html
MapAlignmentAlgorithmKD <- R6Class(classname = "MapAlignmentAlgorithmKD",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentAlgorithmKD(size_t num_maps, Param & param)
    initialize = function(num_maps, param){
    
    if(missing(param)){
         if( "python.builtin.object" %in% class(num_maps) && class_to_wrap(num_maps) == MapAlignmentAlgorithmKD ) { private$py_obj <- num_maps }
         else { stop("arg wrong type") }
      } else {
        if(!( (is_scalar_integer(num_maps) || is_scalar_double(num_maps)) && num_maps == as.integer(num_maps))){ stop("arg num_maps wrong type") }
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
    
    
        private$py_obj <- Pymod$MapAlignmentAlgorithmKD(as.integer(num_maps), param)
        invisible()
    }
    
    },
    
    # C++ signature: void addRTFitData(KDTreeFeatureMaps & kd_data)
    addRTFitData = function(kd_data){
    
        if(!(is.R6(kd_data) && class(kd_data)[1] == "KDTreeFeatureMaps")){ stop("arg kd_data wrong type") }
    
        private$py_obj$addRTFitData(kd_data)
        invisible()
    },
    
    # C++ signature: void fitLOWESS()
    fitLOWESS = function(){
    
        private$py_obj$fitLOWESS()
        invisible()
    },
    
    # C++ signature: void transform(KDTreeFeatureMaps & kd_data)
    transform = function(kd_data){
    
        if(!(is.R6(kd_data) && class(kd_data)[1] == "KDTreeFeatureMaps")){ stop("arg kd_data wrong type") }
    
        private$py_obj$transform(kd_data)
        invisible()
    }
)
) 

# R implementation of _MapAlignmentAlgorithmPoseClustering
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentAlgorithmPoseClustering.html
MapAlignmentAlgorithmPoseClustering <- R6Class(classname = "MapAlignmentAlgorithmPoseClustering",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentAlgorithmPoseClustering()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentAlgorithmPoseClustering) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentAlgorithmPoseClustering()
        invisible()
    }
    
    },
    
    # C++ signature: void align(FeatureMap, TransformationDescription &)
    align_0 = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_align_0`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void align(MSExperiment, TransformationDescription &)
    align_1 = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_align_1`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void align(FeatureMap, TransformationDescription &)
    # C++ signature: void align(MSExperiment, TransformationDescription &)
    align = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription")) { self$align_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription")) { self$align_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setReference(FeatureMap)
    setReference_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setReference_0`(in_0)
        invisible()
    },
    
    # C++ signature: void setReference(MSExperiment)
    setReference_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_setReference_1`(in_0)
        invisible()
    },
    
    # C++ signature: void setReference(FeatureMap)
    # C++ signature: void setReference(MSExperiment)
    setReference = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap")) { self$setReference_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment")) { self$setReference_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MapAlignmentAlgorithmSpectrumAlignment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentAlgorithmSpectrumAlignment.html
MapAlignmentAlgorithmSpectrumAlignment <- R6Class(classname = "MapAlignmentAlgorithmSpectrumAlignment",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentAlgorithmSpectrumAlignment()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentAlgorithmSpectrumAlignment) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentAlgorithmSpectrumAlignment()
        invisible()
    }
    
    },
    
    # C++ signature: void align(libcpp_vector[MSExperiment] &, libcpp_vector[TransformationDescription] &)
    align = function(in_0, in_1){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSExperiment")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TransformationDescription")))){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
        private$py_obj$align(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MapAlignmentEvaluationAlgorithmPrecision
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentEvaluationAlgorithmPrecision.html
MapAlignmentEvaluationAlgorithmPrecision <- R6Class(classname = "MapAlignmentEvaluationAlgorithmPrecision",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentEvaluationAlgorithmPrecision()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentEvaluationAlgorithmPrecision) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentEvaluationAlgorithmPrecision()
        invisible()
    }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    }
)
) 

# R implementation of _MapAlignmentEvaluationAlgorithmRecall
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentEvaluationAlgorithmRecall.html
MapAlignmentEvaluationAlgorithmRecall <- R6Class(classname = "MapAlignmentEvaluationAlgorithmRecall",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentEvaluationAlgorithmRecall()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentEvaluationAlgorithmRecall) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentEvaluationAlgorithmRecall()
        invisible()
    }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    }
)
) 

# R implementation of _MapAlignmentTransformer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapAlignmentTransformer.html
MapAlignmentTransformer <- R6Class(classname = "MapAlignmentTransformer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MapAlignmentTransformer()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MapAlignmentTransformer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MapAlignmentTransformer()
        invisible()
    }
    
    },
    
    # C++ signature: void transformRetentionTimes(MSExperiment &, TransformationDescription &, bool)
    transformRetentionTimes_0 = function(in_0, in_1, in_2){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        private$py_obj$`_transformRetentionTimes_0`(in_0, in_1, as.integer(in_2))
        invisible()
    },
    
    # C++ signature: void transformRetentionTimes(FeatureMap &, TransformationDescription &, bool)
    transformRetentionTimes_1 = function(in_0, in_1, in_2){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "FeatureMap")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        private$py_obj$`_transformRetentionTimes_1`(in_0, in_1, as.integer(in_2))
        invisible()
    },
    
    # C++ signature: void transformRetentionTimes(ConsensusMap &, TransformationDescription &, bool)
    transformRetentionTimes_2 = function(in_0, in_1, in_2){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ConsensusMap")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
    
    
    
        private$py_obj$`_transformRetentionTimes_2`(in_0, in_1, as.integer(in_2))
        invisible()
    },
    
    # C++ signature: void transformRetentionTimes(libcpp_vector[PeptideIdentification] &, TransformationDescription &, bool)
    transformRetentionTimes_3 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(in_2) || is_scalar_double(in_2)) && in_2 == as.integer(in_2))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
    
    
        private$py_obj$`_transformRetentionTimes_3`(v0, in_1, as.integer(in_2))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void transformRetentionTimes(MSExperiment &, TransformationDescription &, bool)
    # C++ signature: void transformRetentionTimes(FeatureMap &, TransformationDescription &, bool)
    # C++ signature: void transformRetentionTimes(ConsensusMap &, TransformationDescription &, bool)
    # C++ signature: void transformRetentionTimes(libcpp_vector[PeptideIdentification] &, TransformationDescription &, bool)
    transformRetentionTimes = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$transformRetentionTimes_0(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$transformRetentionTimes_1(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$transformRetentionTimes_2(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TransformationDescription") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$transformRetentionTimes_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _MapConversion
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MapConversion.html
MapConversion <- R6Class(classname = "MapConversion",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void convert(unsigned long int input_map_index, FeatureMap input_map, ConsensusMap & output_map, size_t n)
    convert_0 = function(input_map_index, input_map, output_map, n){
    
        if(!( (is_scalar_integer(input_map_index) || is_scalar_double(input_map_index)) && input_map_index == as.integer(input_map_index))){ stop("arg input_map_index wrong type") }
        if(!(is.R6(input_map) && class(input_map)[1] == "FeatureMap")){ stop("arg input_map wrong type") }
        if(!(is.R6(output_map) && class(output_map)[1] == "ConsensusMap")){ stop("arg output_map wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
    
    
    
        private$py_obj$`_convert_0`(as.integer(input_map_index), input_map, output_map, as.integer(n))
        invisible()
    },
    
    # C++ signature: void convert(unsigned long int input_map_index, MSExperiment & input_map, ConsensusMap & output_map, size_t n)
    convert_1 = function(input_map_index, input_map, output_map, n){
    
        if(!( (is_scalar_integer(input_map_index) || is_scalar_double(input_map_index)) && input_map_index == as.integer(input_map_index))){ stop("arg input_map_index wrong type") }
        if(!(is.R6(input_map) && class(input_map)[1] == "MSExperiment")){ stop("arg input_map wrong type") }
        if(!(is.R6(output_map) && class(output_map)[1] == "ConsensusMap")){ stop("arg output_map wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
    
    
    
        private$py_obj$`_convert_1`(as.integer(input_map_index), input_map, output_map, as.integer(n))
        invisible()
    },
    
    # C++ signature: void convert(ConsensusMap input_map, bool keep_uids, FeatureMap & output_map)
    convert_2 = function(input_map, keep_uids, output_map){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "ConsensusMap")){ stop("arg input_map wrong type") }
        if(!( (is_scalar_integer(keep_uids) || is_scalar_double(keep_uids)) && keep_uids == as.integer(keep_uids))){ stop("arg keep_uids wrong type") }
        if(!(is.R6(output_map) && class(output_map)[1] == "FeatureMap")){ stop("arg output_map wrong type") }
    
    
    
        private$py_obj$`_convert_2`(input_map, as.integer(keep_uids), output_map)
        invisible()
    },
    
    # C++ signature: void convert(unsigned long int input_map_index, FeatureMap input_map, ConsensusMap & output_map, size_t n)
    # C++ signature: void convert(unsigned long int input_map_index, MSExperiment & input_map, ConsensusMap & output_map, size_t n)
    # C++ signature: void convert(ConsensusMap input_map, bool keep_uids, FeatureMap & output_map)
    convert = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ConsensusMap") && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$convert_0(...) }
        else if ((length(arg_list)==4) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment") && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ConsensusMap") && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$convert_1(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "FeatureMap")) { self$convert_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _MarkerMower
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MarkerMower.html
MarkerMower <- R6Class(classname = "MarkerMower",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MarkerMower()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MarkerMower) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MarkerMower()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void insertmarker(PeakMarker * peak_marker)
    insertmarker = function(peak_marker){
    
        if(!(is.R6(peak_marker) && class(peak_marker)[1] == "PeakMarker")){ stop("arg peak_marker wrong type") }
    
        private$py_obj$insertmarker(peak_marker)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MascotGenericFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MascotGenericFile.html
MascotGenericFile <- R6Class(classname = "MascotGenericFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MascotGenericFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MascotGenericFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MascotGenericFile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(const String & filename, MSExperiment & experiment)
    store = function(filename, experiment){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
    
    
        private$py_obj$store(filename, experiment)
        invisible()
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & exp)
    load = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$load(filename, exp)
        invisible()
    },
    
    # C++ signature: libcpp_pair[String,String] getHTTPPeakListEnclosure(const String & filename)
    getHTTPPeakListEnclosure = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$getHTTPPeakListEnclosure(filename)
        out1 = String$new(py_ans[[1]])
        out2 = String$new(py_ans[[2]])
        r_ans = list(out1, out2)
        return(r_ans)
    },
    
    # C++ signature: void updateMembers_()
    updateMembers_ = function(){
    
        private$py_obj$updateMembers_()
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MascotInfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MascotInfile.html
MascotInfile <- R6Class(classname = "MascotInfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MascotInfile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MascotInfile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MascotInfile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(const String & filename, MSSpectrum & spec, double mz, double retention_time, String search_title)
    store_0 = function(filename, spec, mz, retention_time, search_title){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        if(!(is_scalar_double(retention_time))){ stop("arg retention_time wrong type") }
        if(!((is.R6(search_title) && class(search_title)[1]=="String") || is_scalar_character(search_title))){ stop("arg search_title wrong type") }
    
    
    
    
    
        private$py_obj$`_store_0`(filename, spec, mz, retention_time, search_title)
        invisible()
    },
    
    # C++ signature: void store(const String & filename, MSExperiment & experiment, String search_title)
    store_1 = function(filename, experiment, search_title){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!((is.R6(search_title) && class(search_title)[1]=="String") || is_scalar_character(search_title))){ stop("arg search_title wrong type") }
    
    
    
        private$py_obj$`_store_1`(filename, experiment, search_title)
        invisible()
    },
    
    # C++ signature: void store(const String & filename, MSSpectrum & spec, double mz, double retention_time, String search_title)
    # C++ signature: void store(const String & filename, MSExperiment & experiment, String search_title)
    store = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ((is.R6(arg_list[[5]]) && class(arg_list[[5]])[1]=="String") || is_scalar_character(arg_list[[5]]))) { self$store_0(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "MSExperiment") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$store_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & exp)
    load = function(filename, exp){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$load(filename, exp)
        invisible()
    },
    
    # C++ signature: String getBoundary()
    getBoundary = function(){
    
        py_ans = private$py_obj$getBoundary()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setBoundary(const String & boundary)
    setBoundary = function(boundary){
    
        if(!((is.R6(boundary) && class(boundary)[1]=="String") || is_scalar_character(boundary))){ stop("arg boundary wrong type") }
    
        private$py_obj$setBoundary(boundary)
        invisible()
    },
    
    # C++ signature: String getDB()
    getDB = function(){
    
        py_ans = private$py_obj$getDB()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDB(const String & db)
    setDB = function(db){
    
        if(!((is.R6(db) && class(db)[1]=="String") || is_scalar_character(db))){ stop("arg db wrong type") }
    
        private$py_obj$setDB(db)
        invisible()
    },
    
    # C++ signature: String getSearchType()
    getSearchType = function(){
    
        py_ans = private$py_obj$getSearchType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSearchType(const String & search_type)
    setSearchType = function(search_type){
    
        if(!((is.R6(search_type) && class(search_type)[1]=="String") || is_scalar_character(search_type))){ stop("arg search_type wrong type") }
    
        private$py_obj$setSearchType(search_type)
        invisible()
    },
    
    # C++ signature: String getHits()
    getHits = function(){
    
        py_ans = private$py_obj$getHits()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setHits(const String & hits)
    setHits = function(hits){
    
        if(!((is.R6(hits) && class(hits)[1]=="String") || is_scalar_character(hits))){ stop("arg hits wrong type") }
    
        private$py_obj$setHits(hits)
        invisible()
    },
    
    # C++ signature: String getCleavage()
    getCleavage = function(){
    
        py_ans = private$py_obj$getCleavage()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCleavage(const String & cleavage)
    setCleavage = function(cleavage){
    
        if(!((is.R6(cleavage) && class(cleavage)[1]=="String") || is_scalar_character(cleavage))){ stop("arg cleavage wrong type") }
    
        private$py_obj$setCleavage(cleavage)
        invisible()
    },
    
    # C++ signature: String getMassType()
    getMassType = function(){
    
        py_ans = private$py_obj$getMassType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMassType(const String & mass_type)
    setMassType = function(mass_type){
    
        if(!((is.R6(mass_type) && class(mass_type)[1]=="String") || is_scalar_character(mass_type))){ stop("arg mass_type wrong type") }
    
        private$py_obj$setMassType(mass_type)
        invisible()
    },
    
    # C++ signature: libcpp_vector[String] getModifications()
    getModifications = function(){
    
        py_ans = private$py_obj$getModifications()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setModifications(libcpp_vector[String] & mods)
    setModifications = function(mods){
    
        if(!(is_list(mods) && all(sapply(mods),is_scalar_character))){ stop("arg mods wrong type") }
        v0 = r_to_py(modify_depth(mods,1,py_builtin$bytes(mods,'utf-8')))
        private$py_obj$setModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[String] getVariableModifications()
    getVariableModifications = function(){
    
        py_ans = private$py_obj$getVariableModifications()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setVariableModifications(libcpp_vector[String] & mods)
    setVariableModifications = function(mods){
    
        if(!(is_list(mods) && all(sapply(mods),is_scalar_character))){ stop("arg mods wrong type") }
        v0 = r_to_py(modify_depth(mods,1,py_builtin$bytes(mods,'utf-8')))
        private$py_obj$setVariableModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getInstrument()
    getInstrument = function(){
    
        py_ans = private$py_obj$getInstrument()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInstrument(const String & instrument)
    setInstrument = function(instrument){
    
        if(!((is.R6(instrument) && class(instrument)[1]=="String") || is_scalar_character(instrument))){ stop("arg instrument wrong type") }
    
        private$py_obj$setInstrument(instrument)
        invisible()
    },
    
    # C++ signature: unsigned int getMissedCleavages()
    getMissedCleavages = function(){
    
        py_ans = private$py_obj$getMissedCleavages()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMissedCleavages(unsigned int missed_cleavages)
    setMissedCleavages = function(missed_cleavages){
    
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
    
        private$py_obj$setMissedCleavages(as.integer(missed_cleavages))
        invisible()
    },
    
    # C++ signature: float getPrecursorMassTolerance()
    getPrecursorMassTolerance = function(){
    
        py_ans = private$py_obj$getPrecursorMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassTolerance(float precursor_mass_tolerance)
    setPrecursorMassTolerance = function(precursor_mass_tolerance){
    
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
    
        private$py_obj$setPrecursorMassTolerance(precursor_mass_tolerance)
        invisible()
    },
    
    # C++ signature: float getPeakMassTolerance()
    getPeakMassTolerance = function(){
    
        py_ans = private$py_obj$getPeakMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPeakMassTolerance(float ion_mass_tolerance)
    setPeakMassTolerance = function(ion_mass_tolerance){
    
        if(!(is_scalar_double(ion_mass_tolerance))){ stop("arg ion_mass_tolerance wrong type") }
    
        private$py_obj$setPeakMassTolerance(ion_mass_tolerance)
        invisible()
    },
    
    # C++ signature: String getTaxonomy()
    getTaxonomy = function(){
    
        py_ans = private$py_obj$getTaxonomy()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTaxonomy(const String & taxonomy)
    setTaxonomy = function(taxonomy){
    
        if(!((is.R6(taxonomy) && class(taxonomy)[1]=="String") || is_scalar_character(taxonomy))){ stop("arg taxonomy wrong type") }
    
        private$py_obj$setTaxonomy(taxonomy)
        invisible()
    },
    
    # C++ signature: String getFormVersion()
    getFormVersion = function(){
    
        py_ans = private$py_obj$getFormVersion()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFormVersion(const String & form_version)
    setFormVersion = function(form_version){
    
        if(!((is.R6(form_version) && class(form_version)[1]=="String") || is_scalar_character(form_version))){ stop("arg form_version wrong type") }
    
        private$py_obj$setFormVersion(form_version)
        invisible()
    },
    
    # C++ signature: String getCharges()
    getCharges = function(){
    
        py_ans = private$py_obj$getCharges()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharges(libcpp_vector[int] & charges)
    setCharges = function(charges){
    
        if(!(is_list(charges) && all(sapply(charges,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg charges wrong type") }
        v0 <- r_to_py(modify_depth(charges,1,as.integer))
        private$py_obj$setCharges(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(charges <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MascotXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MascotXMLFile.html
MascotXMLFile <- R6Class(classname = "MascotXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MascotXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MascotXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MascotXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, ProteinIdentification & protein_identification, libcpp_vector[PeptideIdentification] & id_data, SpectrumMetaDataLookup & rt_mapping)
    load = function(filename, protein_identification, id_data, rt_mapping){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_list(id_data) && all(sapply(id_data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg id_data wrong type") }
        if(!(is.R6(rt_mapping) && class(rt_mapping)[1] == "SpectrumMetaDataLookup")){ stop("arg rt_mapping wrong type") }
    
    
        v2 <- r_to_py(id_data)
    
        private$py_obj$load(filename, protein_identification, v2, rt_mapping)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id_data <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void initializeLookup(SpectrumMetaDataLookup & lookup, MSExperiment & experiment, const String & scan_regex)
    initializeLookup = function(lookup, experiment, scan_regex){
    
        if(!(is.R6(lookup) && class(lookup)[1] == "SpectrumMetaDataLookup")){ stop("arg lookup wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!((is.R6(scan_regex) && class(scan_regex)[1]=="String") || is_scalar_character(scan_regex))){ stop("arg scan_regex wrong type") }
    
    
    
        private$py_obj$initializeLookup(lookup, experiment, scan_regex)
        invisible()
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MassAnalyzer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MassAnalyzer.html
MassAnalyzer <- R6Class(classname = "MassAnalyzer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MassAnalyzer()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MassAnalyzer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MassAnalyzer()
        invisible()
    }
    
    },
    
    # C++ signature: AnalyzerType getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setType(AnalyzerType type)
    setType = function(type){
    
        if(!(type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))){ stop("arg type wrong type") }
    
        private$py_obj$setType(as.integer(type))
        invisible()
    },
    
    # C++ signature: ResolutionMethod getResolutionMethod()
    getResolutionMethod = function(){
    
        py_ans = private$py_obj$getResolutionMethod()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setResolutionMethod(ResolutionMethod resolution_method)
    setResolutionMethod = function(resolution_method){
    
        if(!(resolution_method %in% c(0, 1, 2, 3, 4))){ stop("arg resolution_method wrong type") }
    
        private$py_obj$setResolutionMethod(as.integer(resolution_method))
        invisible()
    },
    
    # C++ signature: ResolutionType getResolutionType()
    getResolutionType = function(){
    
        py_ans = private$py_obj$getResolutionType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setResolutionType(ResolutionType resolution_type)
    setResolutionType = function(resolution_type){
    
        if(!(resolution_type %in% c(0, 1, 2, 3))){ stop("arg resolution_type wrong type") }
    
        private$py_obj$setResolutionType(as.integer(resolution_type))
        invisible()
    },
    
    # C++ signature: ScanDirection getScanDirection()
    getScanDirection = function(){
    
        py_ans = private$py_obj$getScanDirection()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScanDirection(ScanDirection scan_direction)
    setScanDirection = function(scan_direction){
    
        if(!(scan_direction %in% c(0, 1, 2, 3))){ stop("arg scan_direction wrong type") }
    
        private$py_obj$setScanDirection(as.integer(scan_direction))
        invisible()
    },
    
    # C++ signature: ScanLaw getScanLaw()
    getScanLaw = function(){
    
        py_ans = private$py_obj$getScanLaw()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScanLaw(ScanLaw scan_law)
    setScanLaw = function(scan_law){
    
        if(!(scan_law %in% c(0, 1, 2, 3, 4))){ stop("arg scan_law wrong type") }
    
        private$py_obj$setScanLaw(as.integer(scan_law))
        invisible()
    },
    
    # C++ signature: ReflectronState getReflectronState()
    getReflectronState = function(){
    
        py_ans = private$py_obj$getReflectronState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setReflectronState(ReflectronState reflecton_state)
    setReflectronState = function(reflecton_state){
    
        if(!(reflecton_state %in% c(0, 1, 2, 3, 4))){ stop("arg reflecton_state wrong type") }
    
        private$py_obj$setReflectronState(as.integer(reflecton_state))
        invisible()
    },
    
    # C++ signature: double getResolution()
    getResolution = function(){
    
        py_ans = private$py_obj$getResolution()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setResolution(double resolution)
    setResolution = function(resolution){
    
        if(!(is_scalar_double(resolution))){ stop("arg resolution wrong type") }
    
        private$py_obj$setResolution(resolution)
        invisible()
    },
    
    # C++ signature: double getAccuracy()
    getAccuracy = function(){
    
        py_ans = private$py_obj$getAccuracy()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAccuracy(double accuracy)
    setAccuracy = function(accuracy){
    
        if(!(is_scalar_double(accuracy))){ stop("arg accuracy wrong type") }
    
        private$py_obj$setAccuracy(accuracy)
        invisible()
    },
    
    # C++ signature: double getScanRate()
    getScanRate = function(){
    
        py_ans = private$py_obj$getScanRate()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScanRate(double scan_rate)
    setScanRate = function(scan_rate){
    
        if(!(is_scalar_double(scan_rate))){ stop("arg scan_rate wrong type") }
    
        private$py_obj$setScanRate(scan_rate)
        invisible()
    },
    
    # C++ signature: double getScanTime()
    getScanTime = function(){
    
        py_ans = private$py_obj$getScanTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScanTime(double scan_time)
    setScanTime = function(scan_time){
    
        if(!(is_scalar_double(scan_time))){ stop("arg scan_time wrong type") }
    
        private$py_obj$setScanTime(scan_time)
        invisible()
    },
    
    # C++ signature: double getTOFTotalPathLength()
    getTOFTotalPathLength = function(){
    
        py_ans = private$py_obj$getTOFTotalPathLength()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTOFTotalPathLength(double TOF_total_path_length)
    setTOFTotalPathLength = function(TOF_total_path_length){
    
        if(!(is_scalar_double(TOF_total_path_length))){ stop("arg TOF_total_path_length wrong type") }
    
        private$py_obj$setTOFTotalPathLength(TOF_total_path_length)
        invisible()
    },
    
    # C++ signature: double getIsolationWidth()
    getIsolationWidth = function(){
    
        py_ans = private$py_obj$getIsolationWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsolationWidth(double isolation_width)
    setIsolationWidth = function(isolation_width){
    
        if(!(is_scalar_double(isolation_width))){ stop("arg isolation_width wrong type") }
    
        private$py_obj$setIsolationWidth(isolation_width)
        invisible()
    },
    
    # C++ signature: int getFinalMSExponent()
    getFinalMSExponent = function(){
    
        py_ans = private$py_obj$getFinalMSExponent()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFinalMSExponent(int final_MS_exponent)
    setFinalMSExponent = function(final_MS_exponent){
    
        if(!( (is_scalar_integer(final_MS_exponent) || is_scalar_double(final_MS_exponent)) && final_MS_exponent == as.integer(final_MS_exponent))){ stop("arg final_MS_exponent wrong type") }
    
        private$py_obj$setFinalMSExponent(as.integer(final_MS_exponent))
        invisible()
    },
    
    # C++ signature: double getMagneticFieldStrength()
    getMagneticFieldStrength = function(){
    
        py_ans = private$py_obj$getMagneticFieldStrength()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMagneticFieldStrength(double magnetic_field_strength)
    setMagneticFieldStrength = function(magnetic_field_strength){
    
        if(!(is_scalar_double(magnetic_field_strength))){ stop("arg magnetic_field_strength wrong type") }
    
        private$py_obj$setMagneticFieldStrength(magnetic_field_strength)
        invisible()
    },
    
    # C++ signature: int getOrder()
    getOrder = function(){
    
        py_ans = private$py_obj$getOrder()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOrder(int order)
    setOrder = function(order){
    
        if(!( (is_scalar_integer(order) || is_scalar_double(order)) && order == as.integer(order))){ stop("arg order wrong type") }
    
        private$py_obj$setOrder(as.integer(order))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _MassDecomposition
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MassDecomposition.html
MassDecomposition <- R6Class(classname = "MassDecomposition",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MassDecomposition()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MassDecomposition()
        invisible()
    
    
    },
    
    # C++ signature: void MassDecomposition(MassDecomposition)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MassDecomposition")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MassDecomposition(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MassDecomposition(const String & deco)
    init_2 = function(deco){
    
        if(!((is.R6(deco) && class(deco)[1]=="String") || is_scalar_character(deco))){ stop("arg deco wrong type") }
    
    
        private$py_obj <- Pymod$MassDecomposition(deco)
        invisible()
    
    
    },
    
    # C++ signature: void MassDecomposition()
    # C++ signature: void MassDecomposition(MassDecomposition)
    # C++ signature: void MassDecomposition(const String & deco)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MassDecomposition")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MassDecomposition" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String toExpandedString()
    toExpandedString = function(){
    
        py_ans = private$py_obj$toExpandedString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfMaxAA()
    getNumberOfMaxAA = function(){
    
        py_ans = private$py_obj$getNumberOfMaxAA()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool containsTag(const String & tag)
    containsTag = function(tag){
    
        if(!((is.R6(tag) && class(tag)[1]=="String") || is_scalar_character(tag))){ stop("arg tag wrong type") }
    
        py_ans = private$py_obj$containsTag(tag)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool compatible(MassDecomposition & deco)
    compatible = function(deco){
    
        if(!(is.R6(deco) && class(deco)[1] == "MassDecomposition")){ stop("arg deco wrong type") }
    
        py_ans = private$py_obj$compatible(deco)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MassDecompositionAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MassDecompositionAlgorithm.html
MassDecompositionAlgorithm <- R6Class(classname = "MassDecompositionAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MassDecompositionAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MassDecompositionAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MassDecompositionAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: void getDecompositions(libcpp_vector[MassDecomposition] & decomps, double weight)
    getDecompositions = function(decomps, weight){
    
        if(!(is_list(decomps) && all(sapply(decomps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MassDecomposition")))){ stop("arg decomps wrong type") }
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
        v0 <- r_to_py(decomps)
    
        private$py_obj$getDecompositions(v0, weight)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(decomps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MassExplainer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MassExplainer.html
MassExplainer <- R6Class(classname = "MassExplainer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MassExplainer()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MassExplainer()
        invisible()
    
    
    },
    
    # C++ signature: void MassExplainer(libcpp_vector[Adduct] adduct_base)
    init_1 = function(adduct_base){
    
        if(!(is_list(adduct_base) && all(sapply(adduct_base,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Adduct")))){ stop("arg adduct_base wrong type") }
        v0 <- r_to_py(adduct_base)
    
        private$py_obj <- Pymod$MassExplainer(v0)
        invisible()
    
        
    
    },
    
    # C++ signature: void MassExplainer(int q_min, int q_max, int max_span, double thresh_logp)
    init_2 = function(q_min, q_max, max_span, thresh_logp){
    
        if(!( (is_scalar_integer(q_min) || is_scalar_double(q_min)) && q_min == as.integer(q_min))){ stop("arg q_min wrong type") }
        if(!( (is_scalar_integer(q_max) || is_scalar_double(q_max)) && q_max == as.integer(q_max))){ stop("arg q_max wrong type") }
        if(!( (is_scalar_integer(max_span) || is_scalar_double(max_span)) && max_span == as.integer(max_span))){ stop("arg max_span wrong type") }
        if(!(is_scalar_double(thresh_logp))){ stop("arg thresh_logp wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$MassExplainer(as.integer(q_min), as.integer(q_max), as.integer(max_span), thresh_logp)
        invisible()
    
    
    },
    
    # C++ signature: void MassExplainer()
    # C++ signature: void MassExplainer(libcpp_vector[Adduct] adduct_base)
    # C++ signature: void MassExplainer(int q_min, int q_max, int max_span, double thresh_logp)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Adduct")))) { self$init_1(...) }
        else if ((length(arg_list)==4) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MassExplainer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setAdductBase(libcpp_vector[Adduct] adduct_base)
    setAdductBase = function(adduct_base){
    
        if(!(is_list(adduct_base) && all(sapply(adduct_base,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Adduct")))){ stop("arg adduct_base wrong type") }
        v0 <- r_to_py(adduct_base)
        private$py_obj$setAdductBase(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Adduct] getAdductBase()
    getAdductBase = function(){
    
        py_ans = private$py_obj$getAdductBase()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: Compomer getCompomerById(size_t id)
    getCompomerById = function(id){
    
        if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getCompomerById(as.integer(id))
        r_ans = Compomer$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void compute()
    compute = function(){
    
        private$py_obj$compute()
        invisible()
    }
)
) 

# R implementation of _MassTrace
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::FeatureFinderAlgorithmPickedHelperStructs_1_1MassTrace.html
MassTrace <- R6Class(classname = "MassTrace",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        max_rt = function(max_rt){
    
        if(!missing(max_rt)){
            if(!(is_scalar_double(max_rt))){ stop("arg max_rt wrong type") }
        
        
            private$py_obj$max_rt <- max_rt
            } else {
        
                py_ans = private$py_obj$max_rt
                r_result = py_ans
                return(r_result)
                }
        },
        theoretical_int = function(theoretical_int){
    
        if(!missing(theoretical_int)){
            if(!(is_scalar_double(theoretical_int))){ stop("arg theoretical_int wrong type") }
        
        
            private$py_obj$theoretical_int <- theoretical_int
            } else {
        
                py_ans = private$py_obj$theoretical_int
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: ConvexHull2D getConvexhull()
    getConvexhull = function(){
    
        py_ans = private$py_obj$getConvexhull()
        r_ans = ConvexHull2D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void updateMaximum()
    updateMaximum = function(){
    
        private$py_obj$updateMaximum()
        invisible()
    },
    
    # C++ signature: double getAvgMZ()
    getAvgMZ = function(){
    
        py_ans = private$py_obj$getAvgMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid()
    isValid = function(){
    
        py_ans = private$py_obj$isValid()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MassTraceDetection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MassTraceDetection.html
MassTraceDetection <- R6Class(classname = "MassTraceDetection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MassTraceDetection()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MassTraceDetection) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MassTraceDetection()
        invisible()
    }
    
    },
    
    # C++ signature: void run(MSExperiment & input_map, libcpp_vector[Kernel_MassTrace] & traces, size_t max_traces)
    run = function(input_map, traces, max_traces){
    
        if(!(is.R6(input_map) && class(input_map)[1] == "MSExperiment")){ stop("arg input_map wrong type") }
        if(!(is_list(traces) && all(sapply(traces,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Kernel_MassTrace")))){ stop("arg traces wrong type") }
        if(!( (is_scalar_integer(max_traces) || is_scalar_double(max_traces)) && max_traces == as.integer(max_traces))){ stop("arg max_traces wrong type") }
    
        v1 <- r_to_py(traces)
    
        private$py_obj$run(input_map, v1, as.integer(max_traces))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(traces <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MassTraces
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::FeatureFinderAlgorithmPickedHelperStructs_1_1MassTraces.html
MassTraces <- R6Class(classname = "MassTraces",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        max_trace = function(max_trace){
    
        if(!missing(max_trace)){
            if(!( (is_scalar_integer(max_trace) || is_scalar_double(max_trace)) && max_trace == as.integer(max_trace))){ stop("arg max_trace wrong type") }
        
        
            private$py_obj$max_trace <- as.integer(max_trace)
            } else {
        
                py_ans = private$py_obj$max_trace
                r_result = py_ans
                return(r_result)
                }
        },
        baseline = function(baseline){
    
        if(!missing(baseline)){
            if(!(is_scalar_double(baseline))){ stop("arg baseline wrong type") }
        
        
            private$py_obj$baseline <- baseline
            } else {
        
                py_ans = private$py_obj$baseline
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MassTraces()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MassTraces) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MassTraces()
        invisible()
    }
    
    },
    
    # C++ signature: size_t getPeakCount()
    getPeakCount = function(){
    
        py_ans = private$py_obj$getPeakCount()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(double seed_mz, double trace_tolerance)
    isValid = function(seed_mz, trace_tolerance){
    
        if(!(is_scalar_double(seed_mz))){ stop("arg seed_mz wrong type") }
        if(!(is_scalar_double(trace_tolerance))){ stop("arg trace_tolerance wrong type") }
    
    
        py_ans = private$py_obj$isValid(seed_mz, trace_tolerance)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getTheoreticalmaxPosition()
    getTheoreticalmaxPosition = function(){
    
        py_ans = private$py_obj$getTheoreticalmaxPosition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void updateBaseline()
    updateBaseline = function(){
    
        private$py_obj$updateBaseline()
        invisible()
    },
    
    # C++ signature: libcpp_pair[double,double] getRTBounds()
    getRTBounds = function(){
    
        py_ans = private$py_obj$getRTBounds()
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    }
)
) 

# R implementation of _MasstraceCorrelator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MasstraceCorrelator.html
MasstraceCorrelator <- R6Class(classname = "MasstraceCorrelator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MasstraceCorrelator()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MasstraceCorrelator) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MasstraceCorrelator()
        invisible()
    }
    
    },
    
    # C++ signature: void createPseudoSpectra(const ConsensusMap & map_, MSExperiment & pseudo_spectra, size_t min_peak_nr, double min_correlation, int max_lag, double max_rt_apex_difference)
    createPseudoSpectra = function(map_, pseudo_spectra, min_peak_nr, min_correlation, max_lag, max_rt_apex_difference){
    
        if(!(is.R6(map_) && class(map_)[1] == "ConsensusMap")){ stop("arg map_ wrong type") }
        if(!(is.R6(pseudo_spectra) && class(pseudo_spectra)[1] == "MSExperiment")){ stop("arg pseudo_spectra wrong type") }
        if(!( (is_scalar_integer(min_peak_nr) || is_scalar_double(min_peak_nr)) && min_peak_nr == as.integer(min_peak_nr))){ stop("arg min_peak_nr wrong type") }
        if(!(is_scalar_double(min_correlation))){ stop("arg min_correlation wrong type") }
        if(!( (is_scalar_integer(max_lag) || is_scalar_double(max_lag)) && max_lag == as.integer(max_lag))){ stop("arg max_lag wrong type") }
        if(!(is_scalar_double(max_rt_apex_difference))){ stop("arg max_rt_apex_difference wrong type") }
    
    
    
    
    
    
        private$py_obj$createPseudoSpectra(map_, pseudo_spectra, as.integer(min_peak_nr), min_correlation, as.integer(max_lag), max_rt_apex_difference)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _Matrix[double]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Matrix[double].html
MatrixDouble <- R6Class(classname = "MatrixDouble",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MatrixDouble()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MatrixDouble()
        invisible()
    
    
    },
    
    # C++ signature: void MatrixDouble(MatrixDouble)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MatrixDouble")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MatrixDouble(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MatrixDouble(size_t rows, size_t cols, double value)
    init_2 = function(rows, cols, value){
    
        if(!( (is_scalar_integer(rows) || is_scalar_double(rows)) && rows == as.integer(rows))){ stop("arg rows wrong type") }
        if(!( (is_scalar_integer(cols) || is_scalar_double(cols)) && cols == as.integer(cols))){ stop("arg cols wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
    
        private$py_obj <- Pymod$MatrixDouble(as.integer(rows), as.integer(cols), value)
        invisible()
    
    
    },
    
    # C++ signature: void MatrixDouble()
    # C++ signature: void MatrixDouble(MatrixDouble)
    # C++ signature: void MatrixDouble(size_t rows, size_t cols, double value)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MatrixDouble")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MatrixDouble" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getValue(size_t i, size_t j)
    getValue = function(i, j){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
    
    
        py_ans = private$py_obj$getValue(as.integer(i), as.integer(j))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setValue(size_t i, size_t j, double value)
    setValue = function(i, j, value){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj$setValue(as.integer(i), as.integer(j), value)
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void resize(size_t i, size_t j, double value)
    resize_0 = function(i, j, value){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
        if(!( (is_scalar_integer(j) || is_scalar_double(j)) && j == as.integer(j))){ stop("arg j wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
    
        private$py_obj$`_resize_0`(as.integer(i), as.integer(j), value)
        invisible()
    },
    
    # C++ signature: void resize(libcpp_pair[size_t,size_t] & size_pair, double value)
    resize_1 = function(size_pair, value){
    
        if(!(is_list(size_pair) && length(size_pair) == 2 &&  (is_scalar_integer(size_pair[[1]]) || is_scalar_double(size_pair[[1]])) && size_pair[[1]] == as.integer(size_pair[[1]]) &&  (is_scalar_integer(size_pair[[2]]) || is_scalar_double(size_pair[[2]])) && size_pair[[2]] == as.integer(size_pair[[2]]))){ stop("arg size_pair wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
        v0 = r_to_py(list(as.integer(size_pair[[1]]),as.integer(size_pair[[2]])))
    
        private$py_obj$`_resize_1`(v0, value)
        byref_0 = list(py_to_r(v0[0]), py_to_r(v0[1]))
    
        tryCatch({
        eval.parent(substitute(size_pair <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void resize(size_t i, size_t j, double value)
    # C++ signature: void resize(libcpp_pair[size_t,size_t] & size_pair, double value)
    resize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$resize_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && length(arg_list[[1]]) == 2 &&  (is_scalar_integer(arg_list[[1]][[1]]) || is_scalar_double(arg_list[[1]][[1]])) && arg_list[[1]][[1]] == as.integer(arg_list[[1]][[1]]) &&  (is_scalar_integer(arg_list[[1]][[2]]) || is_scalar_double(arg_list[[1]][[2]])) && arg_list[[1]][[2]] == as.integer(arg_list[[1]][[2]])) && (is_scalar_double(arg_list[[2]]))) { self$resize_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t rows()
    rows = function(){
    
        py_ans = private$py_obj$rows()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t cols()
    cols = function(){
    
        py_ans = private$py_obj$cols()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_pair[size_t,size_t] sizePair()
    sizePair = function(){
    
        py_ans = private$py_obj$sizePair()
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    },
    
    # C++ signature: size_t index(size_t row, size_t col)
    index = function(row, col){
    
        if(!( (is_scalar_integer(row) || is_scalar_double(row)) && row == as.integer(row))){ stop("arg row wrong type") }
        if(!( (is_scalar_integer(col) || is_scalar_double(col)) && col == as.integer(col))){ stop("arg col wrong type") }
    
    
        py_ans = private$py_obj$index(as.integer(row), as.integer(col))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_pair[size_t,size_t] indexPair(size_t index)
    indexPair = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$indexPair(as.integer(index))
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    },
    
    # C++ signature: size_t colIndex(size_t index)
    colIndex = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$colIndex(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t rowIndex(size_t index)
    rowIndex = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$rowIndex(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MetaInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaInfo.html
MetaInfo <- R6Class(classname = "MetaInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaInfo()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaInfo()
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfo(MetaInfo)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaInfo")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaInfo(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfo()
    # C++ signature: void MetaInfo(MetaInfo)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaInfo")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaInfo" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: DataValue getValue(String name)
    getValue_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_getValue_0`(name)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getValue(unsigned int index)
    getValue_1 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getValue_1`(as.integer(index))
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getValue(String name, DataValue default_value)
    getValue_2 = function(name, default_value){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(default_value) && class(default_value)[1] == "DataValue")){ stop("arg default_value wrong type") }
    
    
        py_ans = private$py_obj$`_getValue_2`(name, default_value)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getValue(unsigned int index, DataValue default_value)
    getValue_3 = function(index, default_value){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is.R6(default_value) && class(default_value)[1] == "DataValue")){ stop("arg default_value wrong type") }
    
    
        py_ans = private$py_obj$`_getValue_3`(as.integer(index), default_value)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getValue(String name)
    # C++ signature: DataValue getValue(unsigned int index)
    # C++ signature: DataValue getValue(String name, DataValue default_value)
    # C++ signature: DataValue getValue(unsigned int index, DataValue default_value)
    getValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getValue_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getValue_1(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$getValue_2(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$getValue_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool exists(String name)
    exists_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_exists_0`(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool exists(unsigned int index)
    exists_1 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_exists_1`(as.integer(index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool exists(String name)
    # C++ signature: bool exists(unsigned int index)
    exists = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$exists_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$exists_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setValue(String name, DataValue value)
    setValue_0 = function(name, value){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
    
    
        private$py_obj$`_setValue_0`(name, value)
        invisible()
    },
    
    # C++ signature: void setValue(unsigned int index, DataValue value)
    setValue_1 = function(index, value){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
    
    
        private$py_obj$`_setValue_1`(as.integer(index), value)
        invisible()
    },
    
    # C++ signature: void setValue(String name, DataValue value)
    # C++ signature: void setValue(unsigned int index, DataValue value)
    setValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setValue_0(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeValue(String name)
    removeValue_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$`_removeValue_0`(name)
        invisible()
    },
    
    # C++ signature: void removeValue(unsigned int index)
    removeValue_1 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        private$py_obj$`_removeValue_1`(as.integer(index))
        invisible()
    },
    
    # C++ signature: void removeValue(String name)
    # C++ signature: void removeValue(unsigned int index)
    removeValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$removeValue_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$removeValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getKeysAsIntegers(libcpp_vector[unsigned int] & keys)
    getKeysAsIntegers = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg keys wrong type") }
        v0 <- r_to_py(modify_depth(keys,1,as.integer))
        private$py_obj$getKeysAsIntegers(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry registry()
    registry = function(){
    
        py_ans = private$py_obj$registry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _MetaInfoDescription
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaInfoDescription.html
MetaInfoDescription <- R6Class(classname = "MetaInfoDescription",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaInfoDescription()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaInfoDescription()
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoDescription(MetaInfoDescription)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaInfoDescription")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaInfoDescription(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoDescription()
    # C++ signature: void MetaInfoDescription(MetaInfoDescription)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaInfoDescription")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaInfoDescription" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _MetaInfoInterface
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaInfoInterface.html

# Interface for classes that can store arbitrary meta information
# (Type-Name-Value tuples).
# -----
# MetaInfoInterface is a base class for all classes that use one MetaInfo
# object as member.  If you want to add meta information to a class, let it
# publicly inherit the MetaInfoInterface.  Meta information is an array of
# Type-Name-Value tuples.
# -----
# Usage:
# k = []
# exp.getKeys(k) # explore available key-value pairs
# exp.getMetaValue("someMetaName")
# -----
MetaInfoInterface <- R6Class(classname = "MetaInfoInterface",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaInfoInterface()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaInfoInterface()
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoInterface(MetaInfoInterface)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaInfoInterface")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaInfoInterface(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoInterface()
    # C++ signature: void MetaInfoInterface(MetaInfoInterface)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaInfoInterface")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaInfoInterface" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _MetaInfoRegistry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaInfoRegistry.html
MetaInfoRegistry <- R6Class(classname = "MetaInfoRegistry",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaInfoRegistry()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaInfoRegistry()
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoRegistry(MetaInfoRegistry)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaInfoRegistry")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaInfoRegistry(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaInfoRegistry()
    # C++ signature: void MetaInfoRegistry(MetaInfoRegistry)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaInfoRegistry")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaInfoRegistry" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: unsigned int registerName(const String & name, const String & description, const String & unit)
    registerName = function(name, description, unit){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        if(!((is.R6(unit) && class(unit)[1]=="String") || is_scalar_character(unit))){ stop("arg unit wrong type") }
    
    
    
        py_ans = private$py_obj$registerName(name, description, unit)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDescription(unsigned int index, const String & description)
    setDescription_0 = function(index, description){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
    
    
        private$py_obj$`_setDescription_0`(as.integer(index), description)
        invisible()
    },
    
    # C++ signature: void setDescription(const String & name, const String & description)
    setDescription_1 = function(name, description){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
    
    
        private$py_obj$`_setDescription_1`(name, description)
        invisible()
    },
    
    # C++ signature: void setDescription(unsigned int index, const String & description)
    # C++ signature: void setDescription(const String & name, const String & description)
    setDescription = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setDescription_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setDescription_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setUnit(unsigned int index, const String & unit)
    setUnit_0 = function(index, unit){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!((is.R6(unit) && class(unit)[1]=="String") || is_scalar_character(unit))){ stop("arg unit wrong type") }
    
    
        private$py_obj$`_setUnit_0`(as.integer(index), unit)
        invisible()
    },
    
    # C++ signature: void setUnit(const String & name, const String & unit)
    setUnit_1 = function(name, unit){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(unit) && class(unit)[1]=="String") || is_scalar_character(unit))){ stop("arg unit wrong type") }
    
    
        private$py_obj$`_setUnit_1`(name, unit)
        invisible()
    },
    
    # C++ signature: void setUnit(unsigned int index, const String & unit)
    # C++ signature: void setUnit(const String & name, const String & unit)
    setUnit = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setUnit_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setUnit_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: unsigned int getIndex(const String & name)
    getIndex = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getIndex(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getName(unsigned int index)
    getName = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$getName(as.integer(index))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getDescription(unsigned int index)
    getDescription_0 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getDescription_0`(as.integer(index))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getDescription(const String & name)
    getDescription_1 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_getDescription_1`(name)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getDescription(unsigned int index)
    # C++ signature: String getDescription(const String & name)
    getDescription = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getDescription_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getDescription_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getUnit(unsigned int index)
    getUnit_0 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getUnit_0`(as.integer(index))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getUnit(const String & name)
    getUnit_1 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_getUnit_1`(name)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getUnit(unsigned int index)
    # C++ signature: String getUnit(const String & name)
    getUnit = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getUnit_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getUnit_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _MetaboTargetedAssay
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaboTargetedAssay.html
MetaboTargetedAssay <- R6Class(classname = "MetaboTargetedAssay",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaboTargetedAssay()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MetaboTargetedAssay) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MetaboTargetedAssay()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[MetaboTargetedAssay] extractMetaboTargetedAssay(MSExperiment & spectra, FeatureMapping_FeatureToMs2Indices & feature_ms2_index, double & precursor_rt_tol, double & precursor_mz_distance, double & cosine_sim_threshold, double & transition_threshold, double & min_fragment_mz, double & max_fragment_mz, bool & method_consensus_spectrum, bool & exclude_ms2_precursor, unsigned int & file_counter)
    extractMetaboTargetedAssay = function(spectra, feature_ms2_index, precursor_rt_tol, precursor_mz_distance, cosine_sim_threshold, transition_threshold, min_fragment_mz, max_fragment_mz, method_consensus_spectrum, exclude_ms2_precursor, file_counter){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is.R6(feature_ms2_index) && class(feature_ms2_index)[1] == "FeatureMapping_FeatureToMs2Indices")){ stop("arg feature_ms2_index wrong type") }
        if(!(is_scalar_double(precursor_rt_tol))){ stop("arg precursor_rt_tol wrong type") }
        if(!(is_scalar_double(precursor_mz_distance))){ stop("arg precursor_mz_distance wrong type") }
        if(!(is_scalar_double(cosine_sim_threshold))){ stop("arg cosine_sim_threshold wrong type") }
        if(!(is_scalar_double(transition_threshold))){ stop("arg transition_threshold wrong type") }
        if(!(is_scalar_double(min_fragment_mz))){ stop("arg min_fragment_mz wrong type") }
        if(!(is_scalar_double(max_fragment_mz))){ stop("arg max_fragment_mz wrong type") }
        if(!( (is_scalar_integer(method_consensus_spectrum) || is_scalar_double(method_consensus_spectrum)) && method_consensus_spectrum == as.integer(method_consensus_spectrum))){ stop("arg method_consensus_spectrum wrong type") }
        if(!( (is_scalar_integer(exclude_ms2_precursor) || is_scalar_double(exclude_ms2_precursor)) && exclude_ms2_precursor == as.integer(exclude_ms2_precursor))){ stop("arg exclude_ms2_precursor wrong type") }
        if(!( (is_scalar_integer(file_counter) || is_scalar_double(file_counter)) && file_counter == as.integer(file_counter))){ stop("arg file_counter wrong type") }
    
    
    
    
    
    
    
    
    
    
    
        py_ans = private$py_obj$extractMetaboTargetedAssay(spectra, feature_ms2_index, precursor_rt_tol, precursor_mz_distance, cosine_sim_threshold, transition_threshold, min_fragment_mz, max_fragment_mz, as.integer(method_consensus_spectrum), as.integer(exclude_ms2_precursor), as.integer(file_counter))
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[MetaboTargetedAssay] extractMetaboTargetedAssayFragmentAnnotation(libcpp_vector[MetaboTargetedAssay_CompoundSpectrumPair] & v_cmp_spec, double & transition_threshold, double & min_fragment_mz, double & max_fragment_mz, bool & use_exact_mass, bool & exclude_ms2_precursor, unsigned int & file_counter)
    extractMetaboTargetedAssayFragmentAnnotation = function(v_cmp_spec, transition_threshold, min_fragment_mz, max_fragment_mz, use_exact_mass, exclude_ms2_precursor, file_counter){
    
        if(!(is_list(v_cmp_spec) && all(sapply(v_cmp_spec,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MetaboTargetedAssay_CompoundSpectrumPair")))){ stop("arg v_cmp_spec wrong type") }
        if(!(is_scalar_double(transition_threshold))){ stop("arg transition_threshold wrong type") }
        if(!(is_scalar_double(min_fragment_mz))){ stop("arg min_fragment_mz wrong type") }
        if(!(is_scalar_double(max_fragment_mz))){ stop("arg max_fragment_mz wrong type") }
        if(!( (is_scalar_integer(use_exact_mass) || is_scalar_double(use_exact_mass)) && use_exact_mass == as.integer(use_exact_mass))){ stop("arg use_exact_mass wrong type") }
        if(!( (is_scalar_integer(exclude_ms2_precursor) || is_scalar_double(exclude_ms2_precursor)) && exclude_ms2_precursor == as.integer(exclude_ms2_precursor))){ stop("arg exclude_ms2_precursor wrong type") }
        if(!( (is_scalar_integer(file_counter) || is_scalar_double(file_counter)) && file_counter == as.integer(file_counter))){ stop("arg file_counter wrong type") }
        v0 <- r_to_py(v_cmp_spec)
    
    
    
    
    
    
        py_ans = private$py_obj$extractMetaboTargetedAssayFragmentAnnotation(v0, transition_threshold, min_fragment_mz, max_fragment_mz, as.integer(use_exact_mass), as.integer(exclude_ms2_precursor), as.integer(file_counter))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(v_cmp_spec <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _MetaboTargetedAssay_CompoundSpectrumPair
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaboTargetedAssay_CompoundSpectrumPair.html
MetaboTargetedAssay_CompoundSpectrumPair <- R6Class(classname = "MetaboTargetedAssay_CompoundSpectrumPair",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaboTargetedAssay_CompoundSpectrumPair()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MetaboTargetedAssay_CompoundSpectrumPair) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MetaboTargetedAssay_CompoundSpectrumPair()
        invisible()
    }
    
    }
)
) 

# R implementation of _MetaboliteFeatureDeconvolution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaboliteFeatureDeconvolution.html
MetaboliteFeatureDeconvolution <- R6Class(classname = "MetaboliteFeatureDeconvolution",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaboliteFeatureDeconvolution()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaboliteFeatureDeconvolution()
        invisible()
    
    
    },
    
    # C++ signature: void MetaboliteFeatureDeconvolution(MetaboliteFeatureDeconvolution)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaboliteFeatureDeconvolution")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaboliteFeatureDeconvolution(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaboliteFeatureDeconvolution()
    # C++ signature: void MetaboliteFeatureDeconvolution(MetaboliteFeatureDeconvolution)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaboliteFeatureDeconvolution")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaboliteFeatureDeconvolution" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void compute(FeatureMap & fm_in, FeatureMap & fm_out, ConsensusMap & cons_map, ConsensusMap & cons_map_p)
    compute = function(fm_in, fm_out, cons_map, cons_map_p){
    
        if(!(is.R6(fm_in) && class(fm_in)[1] == "FeatureMap")){ stop("arg fm_in wrong type") }
        if(!(is.R6(fm_out) && class(fm_out)[1] == "FeatureMap")){ stop("arg fm_out wrong type") }
        if(!(is.R6(cons_map) && class(cons_map)[1] == "ConsensusMap")){ stop("arg cons_map wrong type") }
        if(!(is.R6(cons_map_p) && class(cons_map_p)[1] == "ConsensusMap")){ stop("arg cons_map_p wrong type") }
    
    
    
    
        private$py_obj$compute(fm_in, fm_out, cons_map, cons_map_p)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MetaboliteSpectralMatching
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MetaboliteSpectralMatching.html
MetaboliteSpectralMatching <- R6Class(classname = "MetaboliteSpectralMatching",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MetaboliteSpectralMatching()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MetaboliteSpectralMatching()
        invisible()
    
    
    },
    
    # C++ signature: void MetaboliteSpectralMatching(MetaboliteSpectralMatching)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MetaboliteSpectralMatching")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MetaboliteSpectralMatching(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MetaboliteSpectralMatching()
    # C++ signature: void MetaboliteSpectralMatching(MetaboliteSpectralMatching)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MetaboliteSpectralMatching")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MetaboliteSpectralMatching" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void run(MSExperiment & exp, MSExperiment & speclib, MzTab & mz_tab)
    run = function(exp, speclib, mz_tab){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is.R6(speclib) && class(speclib)[1] == "MSExperiment")){ stop("arg speclib wrong type") }
        if(!(is.R6(mz_tab) && class(mz_tab)[1] == "MzTab")){ stop("arg mz_tab wrong type") }
    
    
    
        private$py_obj$run(exp, speclib, mz_tab)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
)
    
    # C++ signature: double computeHyperScore(double fragment_mass_error, bool fragment_mass_tolerance_unit_ppm, MSSpectrum exp_spectrum, MSSpectrum db_spectrum, libcpp_vector[PeptideHit_PeakAnnotation] & annotations, double mz_lower_bound)
    MetaboliteSpectralMatching$computeHyperScore = function(fragment_mass_error, fragment_mass_tolerance_unit_ppm, exp_spectrum, db_spectrum, annotations, mz_lower_bound){
    
        if(!(is_scalar_double(fragment_mass_error))){ stop("arg fragment_mass_error wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(is.R6(exp_spectrum) && class(exp_spectrum)[1] == "MSSpectrum")){ stop("arg exp_spectrum wrong type") }
        if(!(is.R6(db_spectrum) && class(db_spectrum)[1] == "MSSpectrum")){ stop("arg db_spectrum wrong type") }
        if(!(is_list(annotations) && all(sapply(annotations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_PeakAnnotation")))){ stop("arg annotations wrong type") }
        if(!(is_scalar_double(mz_lower_bound))){ stop("arg mz_lower_bound wrong type") }
    
    
    
    
        v4 <- r_to_py(annotations)
    
        py_ans = Pymod$MetaboliteSpectralMatching$computeHyperScore(fragment_mass_error, as.integer(fragment_mass_tolerance_unit_ppm), exp_spectrum, db_spectrum, v4, mz_lower_bound)
        byref_4 <- map(py_to_r(v4),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
            r_ans = py_ans
        return(r_ans)
    } 

# R implementation of _Modification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Modification.html
Modification <- R6Class(classname = "Modification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Modification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Modification()
        invisible()
    
    
    },
    
    # C++ signature: void Modification(Modification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Modification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Modification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Modification()
    # C++ signature: void Modification(Modification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Modification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Modification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getReagentName()
    getReagentName = function(){
    
        py_ans = private$py_obj$getReagentName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setReagentName(const String & reagent_name)
    setReagentName = function(reagent_name){
    
        if(!((is.R6(reagent_name) && class(reagent_name)[1]=="String") || is_scalar_character(reagent_name))){ stop("arg reagent_name wrong type") }
    
        private$py_obj$setReagentName(reagent_name)
        invisible()
    },
    
    # C++ signature: double getMass()
    getMass = function(){
    
        py_ans = private$py_obj$getMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMass(double mass)
    setMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setMass(mass)
        invisible()
    },
    
    # C++ signature: Modification_SpecificityType getSpecificityType()
    getSpecificityType = function(){
    
        py_ans = private$py_obj$getSpecificityType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpecificityType(Modification_SpecificityType & specificity_type)
    setSpecificityType = function(specificity_type){
    
        if(!(specificity_type %in% c(0, 1, 2, 3, 4, 5))){ stop("arg specificity_type wrong type") }
    
        private$py_obj$setSpecificityType(as.integer(specificity_type))
        invisible()
    },
    
    # C++ signature: String getAffectedAminoAcids()
    getAffectedAminoAcids = function(){
    
        py_ans = private$py_obj$getAffectedAminoAcids()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAffectedAminoAcids(const String & affected_amino_acids)
    setAffectedAminoAcids = function(affected_amino_acids){
    
        if(!((is.R6(affected_amino_acids) && class(affected_amino_acids)[1]=="String") || is_scalar_character(affected_amino_acids))){ stop("arg affected_amino_acids wrong type") }
    
        private$py_obj$setAffectedAminoAcids(affected_amino_acids)
        invisible()
    },
    
    # C++ signature: String getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(const String & comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ModificationDefinition
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ModificationDefinition.html
ModificationDefinition <- R6Class(classname = "ModificationDefinition",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ModificationDefinition()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ModificationDefinition()
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(ModificationDefinition)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ModificationDefinition")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ModificationDefinition(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(const String & mod)
    init_2 = function(mod){
    
        if(!((is.R6(mod) && class(mod)[1]=="String") || is_scalar_character(mod))){ stop("arg mod wrong type") }
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod)
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(const String & mod, bool fixed)
    init_3 = function(mod, fixed){
    
        if(!((is.R6(mod) && class(mod)[1]=="String") || is_scalar_character(mod))){ stop("arg mod wrong type") }
        if(!( (is_scalar_integer(fixed) || is_scalar_double(fixed)) && fixed == as.integer(fixed))){ stop("arg fixed wrong type") }
    
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod, as.integer(fixed))
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(const String & mod, bool fixed, unsigned int max_occur)
    init_4 = function(mod, fixed, max_occur){
    
        if(!((is.R6(mod) && class(mod)[1]=="String") || is_scalar_character(mod))){ stop("arg mod wrong type") }
        if(!( (is_scalar_integer(fixed) || is_scalar_double(fixed)) && fixed == as.integer(fixed))){ stop("arg fixed wrong type") }
        if(!( (is_scalar_integer(max_occur) || is_scalar_double(max_occur)) && max_occur == as.integer(max_occur))){ stop("arg max_occur wrong type") }
    
    
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod, as.integer(fixed), as.integer(max_occur))
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(ResidueModification & mod)
    init_5 = function(mod){
    
        if(!(is.R6(mod) && class(mod)[1] == "ResidueModification")){ stop("arg mod wrong type") }
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod)
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(ResidueModification & mod, bool fixed)
    init_6 = function(mod, fixed){
    
        if(!(is.R6(mod) && class(mod)[1] == "ResidueModification")){ stop("arg mod wrong type") }
        if(!( (is_scalar_integer(fixed) || is_scalar_double(fixed)) && fixed == as.integer(fixed))){ stop("arg fixed wrong type") }
    
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod, as.integer(fixed))
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition(ResidueModification & mod, bool fixed, unsigned int max_occur)
    init_7 = function(mod, fixed, max_occur){
    
        if(!(is.R6(mod) && class(mod)[1] == "ResidueModification")){ stop("arg mod wrong type") }
        if(!( (is_scalar_integer(fixed) || is_scalar_double(fixed)) && fixed == as.integer(fixed))){ stop("arg fixed wrong type") }
        if(!( (is_scalar_integer(max_occur) || is_scalar_double(max_occur)) && max_occur == as.integer(max_occur))){ stop("arg max_occur wrong type") }
    
    
    
    
        private$py_obj <- Pymod$ModificationDefinition(mod, as.integer(fixed), as.integer(max_occur))
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinition()
    # C++ signature: void ModificationDefinition(ModificationDefinition)
    # C++ signature: void ModificationDefinition(const String & mod)
    # C++ signature: void ModificationDefinition(const String & mod, bool fixed)
    # C++ signature: void ModificationDefinition(const String & mod, bool fixed, unsigned int max_occur)
    # C++ signature: void ModificationDefinition(ResidueModification & mod)
    # C++ signature: void ModificationDefinition(ResidueModification & mod, bool fixed)
    # C++ signature: void ModificationDefinition(ResidueModification & mod, bool fixed, unsigned int max_occur)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ModificationDefinition")) { self$init_1(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_2(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_3(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_4(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ResidueModification")) { self$init_5(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ResidueModification") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_6(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ResidueModification") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_7(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ModificationDefinition" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setFixedModification(bool fixed)
    setFixedModification = function(fixed){
    
        if(!( (is_scalar_integer(fixed) || is_scalar_double(fixed)) && fixed == as.integer(fixed))){ stop("arg fixed wrong type") }
    
        private$py_obj$setFixedModification(as.integer(fixed))
        invisible()
    },
    
    # C++ signature: bool isFixedModification()
    isFixedModification = function(){
    
        py_ans = private$py_obj$isFixedModification()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxOccurrences(unsigned int num)
    setMaxOccurrences = function(num){
    
        if(!( (is_scalar_integer(num) || is_scalar_double(num)) && num == as.integer(num))){ stop("arg num wrong type") }
    
        private$py_obj$setMaxOccurrences(as.integer(num))
        invisible()
    },
    
    # C++ signature: unsigned int getMaxOccurrences()
    getMaxOccurrences = function(){
    
        py_ans = private$py_obj$getMaxOccurrences()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getModificationName()
    getModificationName = function(){
    
        py_ans = private$py_obj$getModificationName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setModification(const String & modification)
    setModification = function(modification){
    
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
        private$py_obj$setModification(modification)
        invisible()
    },
    
    # C++ signature: ResidueModification getModification()
    getModification = function(){
    
        py_ans = private$py_obj$getModification()
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _ModificationDefinitionsSet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ModificationDefinitionsSet.html
ModificationDefinitionsSet <- R6Class(classname = "ModificationDefinitionsSet",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ModificationDefinitionsSet()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ModificationDefinitionsSet()
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinitionsSet(ModificationDefinitionsSet rhs)
    init_1 = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "ModificationDefinitionsSet")){ stop("arg rhs wrong type") }
    
    
        private$py_obj <- Pymod$ModificationDefinitionsSet(rhs)
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinitionsSet(StringList fixed_modifications, StringList variable_modifications)
    init_2 = function(fixed_modifications, variable_modifications){
    
        if(!(is_list(fixed_modifications) && all(sapply(fixed_modifications),is_scalar_character))){ stop("arg fixed_modifications wrong type") }
        if(!(is_list(variable_modifications) && all(sapply(variable_modifications),is_scalar_character))){ stop("arg variable_modifications wrong type") }
        v0 = r_to_py(modify_depth(fixed_modifications,1,py_builtin$bytes(fixed_modifications,'utf-8')))
        v1 = r_to_py(modify_depth(variable_modifications,1,py_builtin$bytes(variable_modifications,'utf-8')))
    
        private$py_obj <- Pymod$ModificationDefinitionsSet(v0, v1)
        invisible()
    
    
    },
    
    # C++ signature: void ModificationDefinitionsSet()
    # C++ signature: void ModificationDefinitionsSet(ModificationDefinitionsSet rhs)
    # C++ signature: void ModificationDefinitionsSet(StringList fixed_modifications, StringList variable_modifications)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ModificationDefinitionsSet")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ModificationDefinitionsSet" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setMaxModifications(size_t max_mod)
    setMaxModifications = function(max_mod){
    
        if(!( (is_scalar_integer(max_mod) || is_scalar_double(max_mod)) && max_mod == as.integer(max_mod))){ stop("arg max_mod wrong type") }
    
        private$py_obj$setMaxModifications(as.integer(max_mod))
        invisible()
    },
    
    # C++ signature: size_t getMaxModifications()
    getMaxModifications = function(){
    
        py_ans = private$py_obj$getMaxModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfModifications()
    getNumberOfModifications = function(){
    
        py_ans = private$py_obj$getNumberOfModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfFixedModifications()
    getNumberOfFixedModifications = function(){
    
        py_ans = private$py_obj$getNumberOfFixedModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfVariableModifications()
    getNumberOfVariableModifications = function(){
    
        py_ans = private$py_obj$getNumberOfVariableModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addModification(ModificationDefinition & mod_def)
    addModification = function(mod_def){
    
        if(!(is.R6(mod_def) && class(mod_def)[1] == "ModificationDefinition")){ stop("arg mod_def wrong type") }
    
        private$py_obj$addModification(mod_def)
        invisible()
    },
    
    # C++ signature: void setModifications(libcpp_set[ModificationDefinition] & mod_defs)
    setModifications_0 = function(mod_defs){
    
        if(!(
              is_list(mod_defs) && all(sapply(mod_defs,function(el) is.R6(el) && class(el)[1] == "ModificationDefinition")) && length(mod_defs) == py_to_r(py_builtin$len(py_builtin$set(mod_defs)))
              )){ stop("arg mod_defs wrong type") }
        py$v0 <- lapply(mod_defs,function(item0) item0$.__enclos_env__$private$py_obj)
        py_run_string("v0 = set(v0)")
        private$py_obj$`_setModifications_0`(py$v0)
        byref_0 <- py_eval("list(v0)")
        byref_0 <- lapply(byref_0,function(x) ModificationDefinition$new(x))
        py_run_string("del v0; gc.collect()")
    
        tryCatch({
        eval.parent(substitute(mod_defs <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setModifications(const String & fixed_modifications, String & variable_modifications)
    setModifications_1 = function(fixed_modifications, variable_modifications){
    
        if(!((is.R6(fixed_modifications) && class(fixed_modifications)[1]=="String") || is_scalar_character(fixed_modifications))){ stop("arg fixed_modifications wrong type") }
        if(!((is.R6(variable_modifications) && class(variable_modifications)[1]=="String") || is_scalar_character(variable_modifications))){ stop("arg variable_modifications wrong type") }
    
    
        private$py_obj$`_setModifications_1`(fixed_modifications, variable_modifications)
        invisible()
    },
    
    # C++ signature: void setModifications(StringList & fixed_modifications, StringList & variable_modifications)
    setModifications_2 = function(fixed_modifications, variable_modifications){
    
        if(!(is_list(fixed_modifications) && all(sapply(fixed_modifications),is_scalar_character))){ stop("arg fixed_modifications wrong type") }
        if(!(is_list(variable_modifications) && all(sapply(variable_modifications),is_scalar_character))){ stop("arg variable_modifications wrong type") }
        v0 = r_to_py(modify_depth(fixed_modifications,1,py_builtin$bytes(fixed_modifications,'utf-8')))
        v1 = r_to_py(modify_depth(variable_modifications,1,py_builtin$bytes(variable_modifications,'utf-8')))
        private$py_obj$`_setModifications_2`(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(fixed_modifications <- byref_0))
        eval.parent(substitute(variable_modifications <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setModifications(libcpp_set[ModificationDefinition] & mod_defs)
    # C++ signature: void setModifications(const String & fixed_modifications, String & variable_modifications)
    # C++ signature: void setModifications(StringList & fixed_modifications, StringList & variable_modifications)
    setModifications = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (
              is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(el) is.R6(el) && class(el)[1] == "ModificationDefinition")) && length(arg_list[[1]]) == py_to_r(py_builtin$len(py_builtin$set(arg_list[[1]])))
              )) { self$setModifications_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setModifications_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character))) { self$setModifications_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_set[ModificationDefinition] getModifications()
    getModifications = function(){
    
        py_ans = private$py_obj$getModifications()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) ModificationDefinition$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[ModificationDefinition] getFixedModifications()
    getFixedModifications = function(){
    
        py_ans = private$py_obj$getFixedModifications()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) ModificationDefinition$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[ModificationDefinition] getVariableModifications()
    getVariableModifications = function(){
    
        py_ans = private$py_obj$getVariableModifications()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) ModificationDefinition$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: void getModificationNames(StringList & fixed_modifications, StringList & variable_modifications)
    getModificationNames_0 = function(fixed_modifications, variable_modifications){
    
        if(!(is_list(fixed_modifications) && all(sapply(fixed_modifications),is_scalar_character))){ stop("arg fixed_modifications wrong type") }
        if(!(is_list(variable_modifications) && all(sapply(variable_modifications),is_scalar_character))){ stop("arg variable_modifications wrong type") }
        v0 = r_to_py(modify_depth(fixed_modifications,1,py_builtin$bytes(fixed_modifications,'utf-8')))
        v1 = r_to_py(modify_depth(variable_modifications,1,py_builtin$bytes(variable_modifications,'utf-8')))
        private$py_obj$`_getModificationNames_0`(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(fixed_modifications <- byref_0))
        eval.parent(substitute(variable_modifications <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_set[String] getModificationNames()
    getModificationNames_1 = function(){
    
        py_ans = private$py_obj$`_getModificationNames_1`()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void getModificationNames(StringList & fixed_modifications, StringList & variable_modifications)
    # C++ signature: libcpp_set[String] getModificationNames()
    getModificationNames = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character))) { self$getModificationNames_0(...) }
        else if (length(arg_list)==0) { self$getModificationNames_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_set[String] getFixedModificationNames()
    getFixedModificationNames = function(){
    
        py_ans = private$py_obj$getFixedModificationNames()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[String] getVariableModificationNames()
    getVariableModificationNames = function(){
    
        py_ans = private$py_obj$getVariableModificationNames()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: bool isCompatible(AASequence & peptide)
    isCompatible = function(peptide){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
    
        py_ans = private$py_obj$isCompatible(peptide)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void inferFromPeptides(libcpp_vector[PeptideIdentification] & peptides)
    inferFromPeptides = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$inferFromPeptides(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _ModificationsDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ModificationsDB.html
ModificationsDB <- R6Class(classname = "ModificationsDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: size_t getNumberOfModifications()
    getNumberOfModifications = function(){
    
        py_ans = private$py_obj$getNumberOfModifications()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void searchModifications(libcpp_set[const ResidueModification *] & mods, const String & mod_name, const String & residue, TermSpecificity term_spec)
    searchModifications = function(mods, mod_name, residue, term_spec){
    
        if(!(
              is_list(mods) && all(sapply(mods,function(el) is.R6(el) && class(el)[1] == "ResidueModification")) && length(mods) == py_to_r(py_builtin$len(py_builtin$set(mods)))
              )){ stop("arg mods wrong type") }
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
        py$v0 <- lapply(mods,function(item0) item0$.__enclos_env__$private$py_obj)
        py_run_string("v0 = set(v0)")
    
    
    
        private$py_obj$searchModifications(py$v0, mod_name, residue, as.integer(term_spec))
        byref_0 <- py_eval("list(v0)")
        byref_0 <- lapply(byref_0,function(x) ResidueModification$new(x))
        py_run_string("del v0; gc.collect()")
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: const ResidueModification * getModification(size_t index)
    getModification_0 = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$`_getModification_0`(as.integer(index)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(const String & mod_name)
    getModification_1 = function(mod_name){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
    
        py_ans = private$py_obj$`_getModification_1`(mod_name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(const String & mod_name, const String & residue, TermSpecificity term_spec)
    getModification_2 = function(mod_name, residue, term_spec){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
    
    
    
        py_ans = private$py_obj$`_getModification_2`(mod_name, residue, as.integer(term_spec)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const ResidueModification * getModification(size_t index)
    # C++ signature: const ResidueModification * getModification(const String & mod_name)
    # C++ signature: const ResidueModification * getModification(const String & mod_name, const String & residue, TermSpecificity term_spec)
    getModification = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getModification_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getModification_1(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (arg_list[[3]] %in% c(0, 1, 2, 3, 4, 5))) { self$getModification_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool has(String modification)
    has = function(modification){
    
        if(!((is.R6(modification) && class(modification)[1]=="String") || is_scalar_character(modification))){ stop("arg modification wrong type") }
    
        py_ans = private$py_obj$has(modification)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addModification(ResidueModification * new_mod)
    addModification = function(new_mod){
    
        if(!(is.R6(new_mod) && class(new_mod)[1] == "ResidueModification")){ stop("arg new_mod wrong type") }
    
        private$py_obj$addModification(new_mod)
        invisible()
    },
    
    # C++ signature: size_t findModificationIndex(const String & mod_name)
    findModificationIndex = function(mod_name){
    
        if(!((is.R6(mod_name) && class(mod_name)[1]=="String") || is_scalar_character(mod_name))){ stop("arg mod_name wrong type") }
    
        py_ans = private$py_obj$findModificationIndex(mod_name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void searchModificationsByDiffMonoMass(libcpp_vector[String] & mods, double mass, double max_error, const String & residue, TermSpecificity term_spec)
    searchModificationsByDiffMonoMass = function(mods, mass, max_error, residue, term_spec){
    
        if(!(is_list(mods) && all(sapply(mods),is_scalar_character))){ stop("arg mods wrong type") }
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(max_error))){ stop("arg max_error wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
        v0 = r_to_py(modify_depth(mods,1,py_builtin$bytes(mods,'utf-8')))
    
    
    
    
        private$py_obj$searchModificationsByDiffMonoMass(v0, mass, max_error, residue, as.integer(term_spec))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(mods <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: const ResidueModification * getBestModificationByDiffMonoMass(double mass, double max_error, const String & residue, TermSpecificity term_spec)
    getBestModificationByDiffMonoMass = function(mass, max_error, residue, term_spec){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(max_error))){ stop("arg max_error wrong type") }
        if(!((is.R6(residue) && class(residue)[1]=="String") || is_scalar_character(residue))){ stop("arg residue wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
    
    
    
    
        py_ans = private$py_obj$getBestModificationByDiffMonoMass(mass, max_error, residue, as.integer(term_spec)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getAllSearchModifications(libcpp_vector[String] & modifications)
    getAllSearchModifications = function(modifications){
    
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character))){ stop("arg modifications wrong type") }
        v0 = r_to_py(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$getAllSearchModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(modifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool isInstantiated()
    isInstantiated = function(){
    
        py_ans = private$py_obj$isInstantiated()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ModifiedPeptideGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ModifiedPeptideGenerator.html
ModifiedPeptideGenerator <- R6Class(classname = "ModifiedPeptideGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ModifiedPeptideGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ModifiedPeptideGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void ModifiedPeptideGenerator(ModifiedPeptideGenerator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ModifiedPeptideGenerator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ModifiedPeptideGenerator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ModifiedPeptideGenerator()
    # C++ signature: void ModifiedPeptideGenerator(ModifiedPeptideGenerator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ModifiedPeptideGenerator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ModifiedPeptideGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _ModifiedPeptideGenerator_MapToResidueType
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ModifiedPeptideGenerator_MapToResidueType.html
ModifiedPeptideGenerator_MapToResidueType <- R6Class(classname = "ModifiedPeptideGenerator_MapToResidueType",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ModifiedPeptideGenerator_MapToResidueType()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ModifiedPeptideGenerator_MapToResidueType) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ModifiedPeptideGenerator_MapToResidueType()
        invisible()
    }
    
    }
)
) 

# R implementation of _MorpheusScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MorpheusScore.html
MorpheusScore <- R6Class(classname = "MorpheusScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: MorpheusScore_Result compute(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, const MSSpectrum & exp_spectrum, const MSSpectrum & theo_spectrum)
    compute = function(fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, exp_spectrum, theo_spectrum){
    
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(is.R6(exp_spectrum) && class(exp_spectrum)[1] == "MSSpectrum")){ stop("arg exp_spectrum wrong type") }
        if(!(is.R6(theo_spectrum) && class(theo_spectrum)[1] == "MSSpectrum")){ stop("arg theo_spectrum wrong type") }
    
    
    
    
        py_ans = private$py_obj$compute(fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), exp_spectrum, theo_spectrum)
        r_ans = MorpheusScore_Result$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _MorpheusScore_Result
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MorpheusScore_Result.html
MorpheusScore_Result <- R6Class(classname = "MorpheusScore_Result",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        matches = function(matches){
    
        if(!missing(matches)){
            if(!( (is_scalar_integer(matches) || is_scalar_double(matches)) && matches == as.integer(matches))){ stop("arg matches wrong type") }
        
        
            private$py_obj$matches <- as.integer(matches)
            } else {
        
                py_ans = private$py_obj$matches
                r_result = py_ans
                return(r_result)
                }
        },
        n_peaks = function(n_peaks){
    
        if(!missing(n_peaks)){
            if(!( (is_scalar_integer(n_peaks) || is_scalar_double(n_peaks)) && n_peaks == as.integer(n_peaks))){ stop("arg n_peaks wrong type") }
        
        
            private$py_obj$n_peaks <- as.integer(n_peaks)
            } else {
        
                py_ans = private$py_obj$n_peaks
                r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        MIC = function(MIC){
    
        if(!missing(MIC)){
            if(!(is_scalar_double(MIC))){ stop("arg MIC wrong type") }
        
        
            private$py_obj$MIC <- MIC
            } else {
        
                py_ans = private$py_obj$MIC
                r_result = py_ans
                return(r_result)
                }
        },
        TIC = function(TIC){
    
        if(!missing(TIC)){
            if(!(is_scalar_double(TIC))){ stop("arg TIC wrong type") }
        
        
            private$py_obj$TIC <- TIC
            } else {
        
                py_ans = private$py_obj$TIC
                r_result = py_ans
                return(r_result)
                }
        },
        err = function(err){
    
        if(!missing(err)){
            if(!(is_scalar_double(err))){ stop("arg err wrong type") }
        
        
            private$py_obj$err <- err
            } else {
        
                py_ans = private$py_obj$err
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MorpheusScore_Result()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MorpheusScore_Result) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MorpheusScore_Result()
        invisible()
    }
    
    }
)
) 

# R implementation of _MorphologicalFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MorphologicalFilter.html
MorphologicalFilter <- R6Class(classname = "MorphologicalFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MorphologicalFilter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MorphologicalFilter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MorphologicalFilter()
        invisible()
    }
    
    },
    
    # C++ signature: void filter(MSSpectrum & spectrum)
    filter = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$filter(spectrum)
        invisible()
    },
    
    # C++ signature: void filterExperiment(MSExperiment & exp)
    filterExperiment = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterExperiment(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MsInspectFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MsInspectFile.html
MsInspectFile <- R6Class(classname = "MsInspectFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MsInspectFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MsInspectFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MsInspectFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, FeatureMap & feature_map)
    load = function(filename, feature_map){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(feature_map) && class(feature_map)[1] == "FeatureMap")){ stop("arg feature_map wrong type") }
    
    
        private$py_obj$load(filename, feature_map)
        invisible()
    },
    
    # C++ signature: void store(const String & filename, MSSpectrum & spectrum)
    store = function(filename, spectrum){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
    
        private$py_obj$store(filename, spectrum)
        invisible()
    }
)
) 

# R implementation of _MultiplexDeltaMasses
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MultiplexDeltaMasses.html
MultiplexDeltaMasses <- R6Class(classname = "MultiplexDeltaMasses",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MultiplexDeltaMasses()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MultiplexDeltaMasses()
        invisible()
    
    
    },
    
    # C++ signature: void MultiplexDeltaMasses(libcpp_vector[MultiplexDeltaMasses_DeltaMass] & dm)
    init_1 = function(dm){
    
        if(!(is_list(dm) && all(sapply(dm,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MultiplexDeltaMasses_DeltaMass")))){ stop("arg dm wrong type") }
        v0 <- r_to_py(dm)
    
        private$py_obj <- Pymod$MultiplexDeltaMasses(v0)
        invisible()
    
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void MultiplexDeltaMasses()
    # C++ signature: void MultiplexDeltaMasses(libcpp_vector[MultiplexDeltaMasses_DeltaMass] & dm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MultiplexDeltaMasses_DeltaMass")))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MultiplexDeltaMasses" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[MultiplexDeltaMasses_DeltaMass] getDeltaMasses()
    getDeltaMasses = function(){
    
        py_ans = private$py_obj$getDeltaMasses()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    }
)
) 

# R implementation of _MultiplexDeltaMassesGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MultiplexDeltaMassesGenerator.html
MultiplexDeltaMassesGenerator <- R6Class(classname = "MultiplexDeltaMassesGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MultiplexDeltaMassesGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MultiplexDeltaMassesGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void MultiplexDeltaMassesGenerator(String labels, int missed_cleavages, libcpp_map[String,double] label_mass_shift)
    init_1 = function(labels, missed_cleavages, label_mass_shift){
    
        if(!((is.R6(labels) && class(labels)[1]=="String") || is_scalar_character(labels))){ stop("arg labels wrong type") }
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
        if(!(
          is.environment(label_mass_shift) && identical(parent.env(label_mass_shift), asNamespace("collections")) && identical(strsplit(capture.output(label_mass_shift$print())," ")[[1]][1], "dict")
          && all(sapply(label_mass_shift$keys(),function(k) (is.R6(k) && class(k)[1]=="String") || is_scalar_character(k)))
          && all(sapply(label_mass_shift$values(),function(v) is_scalar_double(v)))
          )){ stop("arg label_mass_shift wrong type") }
    
    
        v2 <- py_dict(label_mass_shift$keys(),label_mass_shift$values())
    
        private$py_obj <- Pymod$MultiplexDeltaMassesGenerator(labels, as.integer(missed_cleavages), v2)
        invisible()
    
    
    },
    
    # C++ signature: void MultiplexDeltaMassesGenerator()
    # C++ signature: void MultiplexDeltaMassesGenerator(String labels, int missed_cleavages, libcpp_map[String,double] label_mass_shift)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (
          is.environment(arg_list[[3]]) && identical(parent.env(arg_list[[3]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[3]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[3]]$keys(),function(k) (is.R6(k) && class(k)[1]=="String") || is_scalar_character(k)))
          && all(sapply(arg_list[[3]]$values(),function(v) is_scalar_double(v)))
          )) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MultiplexDeltaMassesGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void generateKnockoutDeltaMasses()
    generateKnockoutDeltaMasses = function(){
    
        private$py_obj$generateKnockoutDeltaMasses()
        invisible()
    },
    
    # C++ signature: libcpp_vector[MultiplexDeltaMasses] getDeltaMassesList()
    getDeltaMassesList = function(){
    
        py_ans = private$py_obj$getDeltaMassesList()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: String getLabelShort(String label)
    getLabelShort = function(label){
    
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
        py_ans = private$py_obj$getLabelShort(label)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getLabelLong(String label)
    getLabelLong = function(label){
    
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
        py_ans = private$py_obj$getLabelLong(label)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _MultiplexDeltaMassesGenerator_Label
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MultiplexDeltaMassesGenerator_Label.html
MultiplexDeltaMassesGenerator_Label <- R6Class(classname = "MultiplexDeltaMassesGenerator_Label",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        short_name = function(short_name){
    
        if(!missing(short_name)){
            if(!((is.R6(short_name) && class(short_name)[1]=="String") || is_scalar_character(short_name))){ stop("arg short_name wrong type") }
        
        
            private$py_obj$short_name <- short_name
            } else {
        
                py_ans = private$py_obj$short_name
            r_result = py_ans
                return(r_result)
                }
        },
        long_name = function(long_name){
    
        if(!missing(long_name)){
            if(!((is.R6(long_name) && class(long_name)[1]=="String") || is_scalar_character(long_name))){ stop("arg long_name wrong type") }
        
        
            private$py_obj$long_name <- long_name
            } else {
        
                py_ans = private$py_obj$long_name
            r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        delta_mass = function(delta_mass){
    
        if(!missing(delta_mass)){
            if(!(is_scalar_double(delta_mass))){ stop("arg delta_mass wrong type") }
        
        
            private$py_obj$delta_mass <- delta_mass
            } else {
        
                py_ans = private$py_obj$delta_mass
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MultiplexDeltaMassesGenerator_Label(String sn, String ln, String d, double dm)
    initialize = function(sn, ln, d, dm){
    
    if(missing(ln) && missing(d) && missing(dm)){
         if( "python.builtin.object" %in% class(sn) && class_to_wrap(sn) == MultiplexDeltaMassesGenerator_Label ) { private$py_obj <- sn }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(sn) && class(sn)[1]=="String") || is_scalar_character(sn))){ stop("arg sn wrong type") }
        if(!((is.R6(ln) && class(ln)[1]=="String") || is_scalar_character(ln))){ stop("arg ln wrong type") }
        if(!((is.R6(d) && class(d)[1]=="String") || is_scalar_character(d))){ stop("arg d wrong type") }
        if(!(is_scalar_double(dm))){ stop("arg dm wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$MultiplexDeltaMassesGenerator_Label(sn, ln, d, dm)
        invisible()
    }
    
    }
)
) 

# R implementation of _MultiplexDeltaMasses_DeltaMass
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MultiplexDeltaMasses_DeltaMass.html
MultiplexDeltaMasses_DeltaMass <- R6Class(classname = "MultiplexDeltaMasses_DeltaMass",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        delta_mass = function(delta_mass){
    
        if(!missing(delta_mass)){
            if(!(is_scalar_double(delta_mass))){ stop("arg delta_mass wrong type") }
        
        
            private$py_obj$delta_mass <- delta_mass
            } else {
        
                py_ans = private$py_obj$delta_mass
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void MultiplexDeltaMasses_DeltaMass(double dm, String l)
    initialize = function(dm, l){
    
    if(missing(l)){
         if( "python.builtin.object" %in% class(dm) && class_to_wrap(dm) == MultiplexDeltaMasses_DeltaMass ) { private$py_obj <- dm }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(dm))){ stop("arg dm wrong type") }
        if(!((is.R6(l) && class(l)[1]=="String") || is_scalar_character(l))){ stop("arg l wrong type") }
    
    
    
        private$py_obj <- Pymod$MultiplexDeltaMasses_DeltaMass(dm, l)
        invisible()
    }
    
    }
)
) 

# R implementation of _MultiplexIsotopicPeakPattern
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MultiplexIsotopicPeakPattern.html
MultiplexIsotopicPeakPattern <- R6Class(classname = "MultiplexIsotopicPeakPattern",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MultiplexIsotopicPeakPattern(int c, int ppp, MultiplexDeltaMasses ms, int msi)
    initialize = function(c, ppp, ms, msi){
    
    if(missing(ppp) && missing(ms) && missing(msi)){
         if( "python.builtin.object" %in% class(c) && class_to_wrap(c) == MultiplexIsotopicPeakPattern ) { private$py_obj <- c }
         else { stop("arg wrong type") }
      } else {
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
        if(!( (is_scalar_integer(ppp) || is_scalar_double(ppp)) && ppp == as.integer(ppp))){ stop("arg ppp wrong type") }
        if(!(is.R6(ms) && class(ms)[1] == "MultiplexDeltaMasses")){ stop("arg ms wrong type") }
        if(!( (is_scalar_integer(msi) || is_scalar_double(msi)) && msi == as.integer(msi))){ stop("arg msi wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$MultiplexIsotopicPeakPattern(as.integer(c), as.integer(ppp), ms, as.integer(msi))
        invisible()
    }
    
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getPeaksPerPeptide()
    getPeaksPerPeptide = function(){
    
        py_ans = private$py_obj$getPeaksPerPeptide()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MultiplexDeltaMasses getMassShifts()
    getMassShifts = function(){
    
        py_ans = private$py_obj$getMassShifts()
        r_ans = MultiplexDeltaMasses$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: int getMassShiftIndex()
    getMassShiftIndex = function(){
    
        py_ans = private$py_obj$getMassShiftIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getMassShiftCount()
    getMassShiftCount = function(){
    
        py_ans = private$py_obj$getMassShiftCount()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMassShiftAt(int i)
    getMassShiftAt = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getMassShiftAt(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZShiftAt(int i)
    getMZShiftAt = function(i){
    
        if(!( (is_scalar_integer(i) || is_scalar_double(i)) && i == as.integer(i))){ stop("arg i wrong type") }
    
        py_ans = private$py_obj$getMZShiftAt(as.integer(i))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getMZShiftCount()
    getMZShiftCount = function(){
    
        py_ans = private$py_obj$getMZShiftCount()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _MzDataFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzDataFile.html
MzDataFile <- R6Class(classname = "MzDataFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzDataFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzDataFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzDataFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String &, MSExperiment &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(const String &, MSExperiment &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    },
    
    # C++ signature: bool isSemanticallyValid(const String & filename, StringList & errors, StringList & warnings)
    isSemanticallyValid = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$isSemanticallyValid(filename, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(errors <- byref_1))
        eval.parent(substitute(warnings <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MzIdentMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzIdentMLFile.html
MzIdentMLFile <- R6Class(classname = "MzIdentMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzIdentMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzIdentMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzIdentMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & poid, libcpp_vector[PeptideIdentification] & peid)
    load = function(filename, poid, peid){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(poid) && all(sapply(poid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg poid wrong type") }
        if(!(is_list(peid) && all(sapply(peid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peid wrong type") }
    
        v1 <- r_to_py(poid)
        v2 <- r_to_py(peid)
        private$py_obj$load(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(poid <- byref_1))
        eval.parent(substitute(peid <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & poid, libcpp_vector[PeptideIdentification] & peid)
    store = function(filename, poid, peid){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(poid) && all(sapply(poid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg poid wrong type") }
        if(!(is_list(peid) && all(sapply(peid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peid wrong type") }
    
        v1 <- r_to_py(poid)
        v2 <- r_to_py(peid)
        private$py_obj$store(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(poid <- byref_1))
        eval.parent(substitute(peid <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool isSemanticallyValid(String filename, StringList errors, StringList warnings)
    isSemanticallyValid = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$isSemanticallyValid(filename, v1, v2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MzMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzMLFile.html
MzMLFile <- R6Class(classname = "MzMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment &)
    load = function(filename, in_1){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(filename, in_1)
        invisible()
    },
    
    # C++ signature: void store(const String & filename, MSExperiment &)
    store = function(filename, in_1){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(filename, in_1)
        invisible()
    },
    
    # C++ signature: void storeBuffer(String & output, MSExperiment exp)
    storeBuffer = function(output, exp){
    
        if(!((is.R6(output) && class(output)[1]=="String") || is_scalar_character(output))){ stop("arg output wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$storeBuffer(output, exp)
        invisible()
    },
    
    # C++ signature: void loadBuffer(const String & input, MSExperiment & exp)
    loadBuffer = function(input, exp){
    
        if(!((is.R6(input) && class(input)[1]=="String") || is_scalar_character(input))){ stop("arg input wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
    
        private$py_obj$loadBuffer(input, exp)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    },
    
    # C++ signature: bool isSemanticallyValid(const String & filename, StringList & errors, StringList & warnings)
    isSemanticallyValid = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$isSemanticallyValid(filename, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(errors <- byref_1))
        eval.parent(substitute(warnings <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _MzMLSpectrumDecoder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzMLSpectrumDecoder.html
MzMLSpectrumDecoder <- R6Class(classname = "MzMLSpectrumDecoder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzMLSpectrumDecoder()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$MzMLSpectrumDecoder()
        invisible()
    
    
    },
    
    # C++ signature: void MzMLSpectrumDecoder(MzMLSpectrumDecoder)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MzMLSpectrumDecoder")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$MzMLSpectrumDecoder(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void MzMLSpectrumDecoder()
    # C++ signature: void MzMLSpectrumDecoder(MzMLSpectrumDecoder)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MzMLSpectrumDecoder")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MzMLSpectrumDecoder" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void domParseChromatogram(String in_, shared_ptr[_Interfaces_Chromatogram] & cptr)
    domParseChromatogram = function(in_, cptr){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(all(class(cptr) == c('Chromatogram','R6')))){ stop("arg cptr wrong type") }
    
        input_cptr <- r_to_py(cptr)
        private$py_obj$domParseChromatogram(in_, input_cptr)
        byref_1 = Chromatogram$new(input_cptr)
    
        tryCatch({
        eval.parent(substitute(cptr <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void domParseSpectrum(String in_, shared_ptr[_Interfaces_Spectrum] & cptr)
    domParseSpectrum = function(in_, cptr){
    
        if(!((is.R6(in_) && class(in_)[1]=="String") || is_scalar_character(in_))){ stop("arg in_ wrong type") }
        if(!(all(class(cptr) == c('Spectrum','R6')))){ stop("arg cptr wrong type") }
    
        input_cptr <- r_to_py(cptr)
        private$py_obj$domParseSpectrum(in_, input_cptr)
        byref_1 = Spectrum$new(input_cptr)
    
        tryCatch({
        eval.parent(substitute(cptr <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setSkipXMLChecks(bool only)
    setSkipXMLChecks = function(only){
    
        if(!( (is_scalar_integer(only) || is_scalar_double(only)) && only == as.integer(only))){ stop("arg only wrong type") }
    
        private$py_obj$setSkipXMLChecks(as.integer(only))
        invisible()
    }
)
) 

# R implementation of _MzMLSqliteHandler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1MzMLSqliteHandler.html
MzMLSqliteHandler <- R6Class(classname = "MzMLSqliteHandler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzMLSqliteHandler(String filename)
    init_0 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$MzMLSqliteHandler(filename)
        invisible()
    
    
    },
    
    # C++ signature: void MzMLSqliteHandler(MzMLSqliteHandler h)
    init_1 = function(h){
    
        if(!(is.R6(h) && class(h)[1] == "MzMLSqliteHandler")){ stop("arg h wrong type") }
    
    
        private$py_obj <- Pymod$MzMLSqliteHandler(h)
        invisible()
    
    
    },
    
    # C++ signature: void MzMLSqliteHandler(String filename)
    # C++ signature: void MzMLSqliteHandler(MzMLSqliteHandler h)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MzMLSqliteHandler")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MzMLSqliteHandler" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void readExperiment(MSExperiment & exp, bool meta_only)
    readExperiment = function(exp, meta_only){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!( (is_scalar_integer(meta_only) || is_scalar_double(meta_only)) && meta_only == as.integer(meta_only))){ stop("arg meta_only wrong type") }
    
    
        private$py_obj$readExperiment(exp, as.integer(meta_only))
        invisible()
    },
    
    # C++ signature: void readSpectra(libcpp_vector[MSSpectrum] & exp, libcpp_vector[int] indices, bool meta_only)
    readSpectra = function(exp, indices, meta_only){
    
        if(!(is_list(exp) && all(sapply(exp,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg exp wrong type") }
        if(!(is_list(indices) && all(sapply(indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indices wrong type") }
        if(!( (is_scalar_integer(meta_only) || is_scalar_double(meta_only)) && meta_only == as.integer(meta_only))){ stop("arg meta_only wrong type") }
        v0 <- r_to_py(exp)
        v1 <- r_to_py(modify_depth(indices,1,as.integer))
    
        private$py_obj$readSpectra(v0, v1, as.integer(meta_only))
        
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(exp <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void readChromatograms(libcpp_vector[MSChromatogram] & exp, libcpp_vector[int] indices, bool meta_only)
    readChromatograms = function(exp, indices, meta_only){
    
        if(!(is_list(exp) && all(sapply(exp,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg exp wrong type") }
        if(!(is_list(indices) && all(sapply(indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indices wrong type") }
        if(!( (is_scalar_integer(meta_only) || is_scalar_double(meta_only)) && meta_only == as.integer(meta_only))){ stop("arg meta_only wrong type") }
        v0 <- r_to_py(exp)
        v1 <- r_to_py(modify_depth(indices,1,as.integer))
    
        private$py_obj$readChromatograms(v0, v1, as.integer(meta_only))
        
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(exp <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setConfig(bool write_full_meta, bool use_lossy_compression, double linear_abs_mass_acc)
    setConfig = function(write_full_meta, use_lossy_compression, linear_abs_mass_acc){
    
        if(!( (is_scalar_integer(write_full_meta) || is_scalar_double(write_full_meta)) && write_full_meta == as.integer(write_full_meta))){ stop("arg write_full_meta wrong type") }
        if(!( (is_scalar_integer(use_lossy_compression) || is_scalar_double(use_lossy_compression)) && use_lossy_compression == as.integer(use_lossy_compression))){ stop("arg use_lossy_compression wrong type") }
        if(!(is_scalar_double(linear_abs_mass_acc))){ stop("arg linear_abs_mass_acc wrong type") }
    
    
    
        private$py_obj$setConfig(as.integer(write_full_meta), as.integer(use_lossy_compression), linear_abs_mass_acc)
        invisible()
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraIndicesbyRT(double RT, double deltaRT, libcpp_vector[int] indices)
    getSpectraIndicesbyRT = function(RT, deltaRT, indices){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
        if(!(is_list(indices) && all(sapply(indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indices wrong type") }
    
    
        v2 <- r_to_py(modify_depth(indices,1,as.integer))
        py_ans = private$py_obj$getSpectraIndicesbyRT(RT, deltaRT, v2)
        
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void writeExperiment(MSExperiment exp)
    writeExperiment = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$writeExperiment(exp)
        invisible()
    },
    
    # C++ signature: void createTables()
    createTables = function(){
    
        private$py_obj$createTables()
        invisible()
    },
    
    # C++ signature: void writeSpectra(libcpp_vector[MSSpectrum] spectra)
    writeSpectra = function(spectra){
    
        if(!(is_list(spectra) && all(sapply(spectra,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg spectra wrong type") }
        v0 <- r_to_py(spectra)
        private$py_obj$writeSpectra(v0)
        
        invisible()
    },
    
    # C++ signature: void writeChromatograms(libcpp_vector[MSChromatogram] chroms)
    writeChromatograms = function(chroms){
    
        if(!(is_list(chroms) && all(sapply(chroms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSChromatogram")))){ stop("arg chroms wrong type") }
        v0 <- r_to_py(chroms)
        private$py_obj$writeChromatograms(v0)
        
        invisible()
    },
    
    # C++ signature: void writeRunLevelInformation(MSExperiment exp, bool write_full_meta, int run_id)
    writeRunLevelInformation = function(exp, write_full_meta, run_id){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!( (is_scalar_integer(write_full_meta) || is_scalar_double(write_full_meta)) && write_full_meta == as.integer(write_full_meta))){ stop("arg write_full_meta wrong type") }
        if(!( (is_scalar_integer(run_id) || is_scalar_double(run_id)) && run_id == as.integer(run_id))){ stop("arg run_id wrong type") }
    
    
    
        private$py_obj$writeRunLevelInformation(exp, as.integer(write_full_meta), as.integer(run_id))
        invisible()
    }
)
) 

# R implementation of _MzMLSwathFileConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzMLSwathFileConsumer.html
MzMLSwathFileConsumer <- R6Class(classname = "MzMLSwathFileConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzMLSwathFileConsumer(String cachedir, String basename, size_t nr_ms1_spectra, libcpp_vector[int] nr_ms2_spectra)
    init_0 = function(cachedir, basename, nr_ms1_spectra, nr_ms2_spectra){
    
        if(!((is.R6(cachedir) && class(cachedir)[1]=="String") || is_scalar_character(cachedir))){ stop("arg cachedir wrong type") }
        if(!((is.R6(basename) && class(basename)[1]=="String") || is_scalar_character(basename))){ stop("arg basename wrong type") }
        if(!( (is_scalar_integer(nr_ms1_spectra) || is_scalar_double(nr_ms1_spectra)) && nr_ms1_spectra == as.integer(nr_ms1_spectra))){ stop("arg nr_ms1_spectra wrong type") }
        if(!(is_list(nr_ms2_spectra) && all(sapply(nr_ms2_spectra,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg nr_ms2_spectra wrong type") }
    
    
    
        v3 <- r_to_py(modify_depth(nr_ms2_spectra,1,as.integer))
    
        private$py_obj <- Pymod$MzMLSwathFileConsumer(cachedir, basename, as.integer(nr_ms1_spectra), v3)
        invisible()
    
        
    
    },
    
    # C++ signature: void MzMLSwathFileConsumer(libcpp_vector[SwathMap] known_window_boundaries, String cachedir, String basename, size_t nr_ms1_spectra, libcpp_vector[int] nr_ms2_spectra)
    init_1 = function(known_window_boundaries, cachedir, basename, nr_ms1_spectra, nr_ms2_spectra){
    
        if(!(is_list(known_window_boundaries) && all(sapply(known_window_boundaries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg known_window_boundaries wrong type") }
        if(!((is.R6(cachedir) && class(cachedir)[1]=="String") || is_scalar_character(cachedir))){ stop("arg cachedir wrong type") }
        if(!((is.R6(basename) && class(basename)[1]=="String") || is_scalar_character(basename))){ stop("arg basename wrong type") }
        if(!( (is_scalar_integer(nr_ms1_spectra) || is_scalar_double(nr_ms1_spectra)) && nr_ms1_spectra == as.integer(nr_ms1_spectra))){ stop("arg nr_ms1_spectra wrong type") }
        if(!(is_list(nr_ms2_spectra) && all(sapply(nr_ms2_spectra,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg nr_ms2_spectra wrong type") }
        v0 <- r_to_py(known_window_boundaries)
    
    
    
        v4 <- r_to_py(modify_depth(nr_ms2_spectra,1,as.integer))
    
        private$py_obj <- Pymod$MzMLSwathFileConsumer(v0, cachedir, basename, as.integer(nr_ms1_spectra), v4)
        invisible()
    
        
        
    
    },
    
    # C++ signature: void MzMLSwathFileConsumer(String cachedir, String basename, size_t nr_ms1_spectra, libcpp_vector[int] nr_ms2_spectra)
    # C++ signature: void MzMLSwathFileConsumer(libcpp_vector[SwathMap] known_window_boundaries, String cachedir, String basename, size_t nr_ms1_spectra, libcpp_vector[int] nr_ms2_spectra)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))) { self$init_0(...) }
        else if ((length(arg_list)==5) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && (is_list(arg_list[[5]]) && all(sapply(arg_list[[5]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "MzMLSwathFileConsumer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setExpectedSize(size_t s, size_t c)
    setExpectedSize = function(s, c){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(s), as.integer(c))
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void retrieveSwathMaps(libcpp_vector[SwathMap] & maps)
    retrieveSwathMaps = function(maps){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg maps wrong type") }
        v0 <- r_to_py(maps)
        private$py_obj$retrieveSwathMaps(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    }
)
) 

# R implementation of _MzQuantMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzQuantMLFile.html
MzQuantMLFile <- R6Class(classname = "MzQuantMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzQuantMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzQuantMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzQuantMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, MSQuantifications &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSQuantifications")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, MSQuantifications &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSQuantifications")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool isSemanticallyValid(String filename, StringList & errors, StringList & warnings)
    isSemanticallyValid = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$isSemanticallyValid(filename, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(errors <- byref_1))
        eval.parent(substitute(warnings <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _MzTab
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzTab.html
MzTab <- R6Class(classname = "MzTab",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzTab()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzTab) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzTab()
        invisible()
    }
    
    }
)
) 

# R implementation of _MzTabFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzTabFile.html
MzTabFile <- R6Class(classname = "MzTabFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzTabFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzTabFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzTabFile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(String filename, MzTab & mz_tab)
    store = function(filename, mz_tab){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(mz_tab) && class(mz_tab)[1] == "MzTab")){ stop("arg mz_tab wrong type") }
    
    
        private$py_obj$store(filename, mz_tab)
        invisible()
    },
    
    # C++ signature: void load(String filename, MzTab & mz_tab)
    load = function(filename, mz_tab){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(mz_tab) && class(mz_tab)[1] == "MzTab")){ stop("arg mz_tab wrong type") }
    
    
        private$py_obj$load(filename, mz_tab)
        invisible()
    }
)
) 

# R implementation of _MzXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1MzXMLFile.html
MzXMLFile <- R6Class(classname = "MzXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void MzXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == MzXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$MzXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, MSExperiment &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, MSExperiment &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSExperiment")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions)
    setOptions = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setOptions(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _NASequence
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NASequence.html

# Representation of an RNA sequence
# This class represents nucleic acid sequences in OpenMS. An NASequence
# instance primarily contains a sequence of ribonucleotides.
NASequence <- R6Class(classname = "NASequence",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void NASequence()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == NASequence) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$NASequence()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[const Ribonucleotide *] getSequence()
    getSequence = function(){
    
        py_ans = private$py_obj$getSequence()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSequence(const libcpp_vector[const Ribonucleotide *] & seq)
    setSequence = function(seq){
    
        if(!(is_list(seq) && all(sapply(seq,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Ribonucleotide")))){ stop("arg seq wrong type") }
        v0 <- r_to_py(seq)
        private$py_obj$setSequence(v0)
        
        invisible()
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFivePrimeMod(const Ribonucleotide * modification)
    setFivePrimeMod = function(modification){
    
        if(!(is.R6(modification) && class(modification)[1] == "Ribonucleotide")){ stop("arg modification wrong type") }
    
        private$py_obj$setFivePrimeMod(modification)
        invisible()
    },
    
    # C++ signature: const Ribonucleotide * getFivePrimeMod()
    getFivePrimeMod = function(){
    
        py_ans = private$py_obj$getFivePrimeMod() ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Ribonucleotide$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setThreePrimeMod(const Ribonucleotide * modification)
    setThreePrimeMod = function(modification){
    
        if(!(is.R6(modification) && class(modification)[1] == "Ribonucleotide")){ stop("arg modification wrong type") }
    
        private$py_obj$setThreePrimeMod(modification)
        invisible()
    },
    
    # C++ signature: const Ribonucleotide * getThreePrimeMod()
    getThreePrimeMod = function(){
    
        py_ans = private$py_obj$getThreePrimeMod() ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Ribonucleotide$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Ribonucleotide * get(size_t index)
    get = function(index){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
    
        py_ans = private$py_obj$get(as.integer(index)) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Ribonucleotide$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void set(size_t index, const Ribonucleotide * r)
    set = function(index, r){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is.R6(r) && class(r)[1] == "Ribonucleotide")){ stop("arg r wrong type") }
    
    
        private$py_obj$set(as.integer(index), r)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getFormula()
# convenience function with ResidueType=Full and charge = 0 by default
    getFormula_0 = function(){
    
        py_ans = private$py_obj$`_getFormula_0`()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula(NASFragmentType type_, int charge)
    getFormula_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getFormula_1`(as.integer(type_), as.integer(charge))
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula()
        # convenience function with ResidueType=Full and charge = 0 by default

    # C++ signature: EmpiricalFormula getFormula(NASFragmentType type_, int charge)
    getFormula = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getFormula_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getFormula_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getAverageWeight()
    getAverageWeight_0 = function(){
    
        py_ans = private$py_obj$`_getAverageWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight(NASFragmentType type_, int charge)
    getAverageWeight_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getAverageWeight_1`(as.integer(type_), as.integer(charge))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight()
    # C++ signature: double getAverageWeight(NASFragmentType type_, int charge)
    getAverageWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getAverageWeight_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getAverageWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double getMonoWeight()
    getMonoWeight_0 = function(){
    
        py_ans = private$py_obj$`_getMonoWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight(NASFragmentType type_, int charge)
    getMonoWeight_1 = function(type_, charge){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
        py_ans = private$py_obj$`_getMonoWeight_1`(as.integer(type_), as.integer(charge))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight()
    # C++ signature: double getMonoWeight(NASFragmentType type_, int charge)
    getMonoWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getMonoWeight_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getMonoWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: NASequence getPrefix(size_t length)
    getPrefix = function(length){
    
        if(!( (is_scalar_integer(length) || is_scalar_double(length)) && length == as.integer(length))){ stop("arg length wrong type") }
    
        py_ans = private$py_obj$getPrefix(as.integer(length))
        r_ans = NASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: NASequence getSuffix(size_t length)
    getSuffix = function(length){
    
        if(!( (is_scalar_integer(length) || is_scalar_double(length)) && length == as.integer(length))){ stop("arg length wrong type") }
    
        py_ans = private$py_obj$getSuffix(as.integer(length))
        r_ans = NASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: NASequence getSubsequence(size_t start, size_t length)
    getSubsequence = function(start, length){
    
        if(!( (is_scalar_integer(start) || is_scalar_double(start)) && start == as.integer(start))){ stop("arg start wrong type") }
        if(!( (is_scalar_integer(length) || is_scalar_double(length)) && length == as.integer(length))){ stop("arg length wrong type") }
    
    
        py_ans = private$py_obj$getSubsequence(as.integer(start), as.integer(length))
        r_ans = NASequence$new(py_ans)
        return(r_ans)
    }
)
)
    
    # C++ signature: NASequence fromString(const String & s)
    NASequence$fromString = function(s){
    
        if(!((is.R6(s) && class(s)[1]=="String") || is_scalar_character(s))){ stop("arg s wrong type") }
    
        py_ans = Pymod$NASequence$fromString(s)
        r_ans = NASequence$new(py_ans)
        return(r_ans)
    } 

# R implementation of _NLargest
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NLargest.html
NLargest <- R6Class(classname = "NLargest",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void NLargest()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == NLargest) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$NLargest()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _NeutralLossDiffFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NeutralLossDiffFilter.html
NeutralLossDiffFilter <- R6Class(classname = "NeutralLossDiffFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void NeutralLossDiffFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$NeutralLossDiffFilter()
        invisible()
    
    
    },
    
    # C++ signature: void NeutralLossDiffFilter(NeutralLossDiffFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "NeutralLossDiffFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$NeutralLossDiffFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void NeutralLossDiffFilter()
    # C++ signature: void NeutralLossDiffFilter(NeutralLossDiffFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "NeutralLossDiffFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "NeutralLossDiffFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _NeutralLossMarker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NeutralLossMarker.html
NeutralLossMarker <- R6Class(classname = "NeutralLossMarker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void NeutralLossMarker()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$NeutralLossMarker()
        invisible()
    
    
    },
    
    # C++ signature: void NeutralLossMarker(NeutralLossMarker)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "NeutralLossMarker")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$NeutralLossMarker(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void NeutralLossMarker()
    # C++ signature: void NeutralLossMarker(NeutralLossMarker)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "NeutralLossMarker")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "NeutralLossMarker" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void apply(libcpp_map[double,bool] &, MSSpectrum &)
    apply = function(in_0, in_1){
    
        if(!(
          is.environment(in_0) && identical(parent.env(in_0), asNamespace("collections")) && identical(strsplit(capture.output(in_0$print())," ")[[1]][1], "dict")
          && all(sapply(in_0$keys(),function(k) is_scalar_double(k)))
          && all(sapply(in_0$values(),function(v)  (is_scalar_integer(v) || is_scalar_double(v)) && v == as.integer(v)))
          )){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSSpectrum")){ stop("arg in_1 wrong type") }
        v0 <- py_dict(in_0$keys(),as.integer(in_0$values()))
    
        private$py_obj$apply(v0, in_1)
        byref_0 <- collections::dict(py_to_r(py_builtin$list(v0$values())),py_to_r(py_builtin$list(v0$keys())))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _NoiseEstimator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NoiseEstimator.html
NoiseEstimator <- R6Class(classname = "NoiseEstimator",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        nr_windows = function(nr_windows){
    
        if(!missing(nr_windows)){
            if(!( (is_scalar_integer(nr_windows) || is_scalar_double(nr_windows)) && nr_windows == as.integer(nr_windows))){ stop("arg nr_windows wrong type") }
        
        
            private$py_obj$nr_windows <- as.integer(nr_windows)
            } else {
        
                py_ans = private$py_obj$nr_windows
                r_result = py_ans
                return(r_result)
                }
        },
        mz_start = function(mz_start){
    
        if(!missing(mz_start)){
            if(!(is_scalar_double(mz_start))){ stop("arg mz_start wrong type") }
        
        
            private$py_obj$mz_start <- mz_start
            } else {
        
                py_ans = private$py_obj$mz_start
                r_result = py_ans
                return(r_result)
                }
        },
        window_length = function(window_length){
    
        if(!missing(window_length)){
            if(!(is_scalar_double(window_length))){ stop("arg window_length wrong type") }
        
        
            private$py_obj$window_length <- window_length
            } else {
        
                py_ans = private$py_obj$window_length
                r_result = py_ans
                return(r_result)
                }
        },
        result_windows_even = function(result_windows_even){
    
        if(!missing(result_windows_even)){
            if(!(is_list(result_windows_even) && all(sapply(result_windows_even,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg result_windows_even wrong type") }
        
            v0 <- r_to_py(result_windows_even)
            private$py_obj$result_windows_even <- v0
            } else {
            
                py_ans = private$py_obj$result_windows_even
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        result_windows_odd = function(result_windows_odd){
    
        if(!missing(result_windows_odd)){
            if(!(is_list(result_windows_odd) && all(sapply(result_windows_odd,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg result_windows_odd wrong type") }
        
            v0 <- r_to_py(result_windows_odd)
            private$py_obj$result_windows_odd <- v0
            } else {
            
                py_ans = private$py_obj$result_windows_odd
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void NoiseEstimator(double nr_windows_, double mz_start_, double win_len_)
    initialize = function(nr_windows_, mz_start_, win_len_){
    
    if(missing(mz_start_) && missing(win_len_)){
         if( "python.builtin.object" %in% class(nr_windows_) && class_to_wrap(nr_windows_) == NoiseEstimator ) { private$py_obj <- nr_windows_ }
         else { stop("arg wrong type") }
      } else {
        if(!(is_scalar_double(nr_windows_))){ stop("arg nr_windows_ wrong type") }
        if(!(is_scalar_double(mz_start_))){ stop("arg mz_start_ wrong type") }
        if(!(is_scalar_double(win_len_))){ stop("arg win_len_ wrong type") }
    
    
    
    
        private$py_obj <- Pymod$NoiseEstimator(nr_windows_, mz_start_, win_len_)
        invisible()
    }
    
    },
    
    # C++ signature: double get_noise_value(double mz)
    get_noise_value = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$get_noise_value(mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double get_noise_even(double mz)
    get_noise_even = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$get_noise_even(mz)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double get_noise_odd(double mz)
    get_noise_odd = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$get_noise_odd(mz)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _NonNegativeLeastSquaresSolver
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NonNegativeLeastSquaresSolver.html
NonNegativeLeastSquaresSolver <- R6Class(classname = "NonNegativeLeastSquaresSolver",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: int solve(MatrixDouble & A, MatrixDouble & b, MatrixDouble & x)
    solve = function(A, b, x){
    
        if(!(is.R6(A) && class(A)[1] == "MatrixDouble")){ stop("arg A wrong type") }
        if(!(is.R6(b) && class(b)[1] == "MatrixDouble")){ stop("arg b wrong type") }
        if(!(is.R6(x) && class(x)[1] == "MatrixDouble")){ stop("arg x wrong type") }
    
    
    
        py_ans = private$py_obj$solve(A, b, x)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _NoopMSDataWritingConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NoopMSDataWritingConsumer.html
NoopMSDataWritingConsumer <- R6Class(classname = "NoopMSDataWritingConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void NoopMSDataWritingConsumer(String filename)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == NoopMSDataWritingConsumer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$NoopMSDataWritingConsumer(filename)
        invisible()
    }
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    },
    
    # C++ signature: void addDataProcessing(DataProcessing d)
    addDataProcessing = function(d){
    
        if(!(is.R6(d) && class(d)[1] == "DataProcessing")){ stop("arg d wrong type") }
    
        private$py_obj$addDataProcessing(d)
        invisible()
    },
    
    # C++ signature: size_t getNrSpectraWritten()
    getNrSpectraWritten = function(){
    
        py_ans = private$py_obj$getNrSpectraWritten()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatogramsWritten()
    getNrChromatogramsWritten = function(){
    
        py_ans = private$py_obj$getNrChromatogramsWritten()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _Normalizer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Normalizer.html
Normalizer <- R6Class(classname = "Normalizer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Normalizer()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Normalizer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Normalizer()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _NumpressConfig
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1NumpressConfig.html
NumpressConfig <- R6Class(classname = "NumpressConfig",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        numpressFixedPoint = function(numpressFixedPoint){
    
        if(!missing(numpressFixedPoint)){
            if(!(is_scalar_double(numpressFixedPoint))){ stop("arg numpressFixedPoint wrong type") }
        
        
            private$py_obj$numpressFixedPoint <- numpressFixedPoint
            } else {
        
                py_ans = private$py_obj$numpressFixedPoint
                r_result = py_ans
                return(r_result)
                }
        },
        numpressErrorTolerance = function(numpressErrorTolerance){
    
        if(!missing(numpressErrorTolerance)){
            if(!(is_scalar_double(numpressErrorTolerance))){ stop("arg numpressErrorTolerance wrong type") }
        
        
            private$py_obj$numpressErrorTolerance <- numpressErrorTolerance
            } else {
        
                py_ans = private$py_obj$numpressErrorTolerance
                r_result = py_ans
                return(r_result)
                }
        },
        np_compression = function(np_compression){
    
        if(!missing(np_compression)){
            if(!(np_compression %in% c(0, 1, 2, 3, 4))){ stop("arg np_compression wrong type") }
        
        
            private$py_obj$np_compression <- as.integer(np_compression)
            } else {
        
                py_ans = private$py_obj$np_compression
                r_result = py_ans
                return(r_result)
                }
        },
        estimate_fixed_point = function(estimate_fixed_point){
    
        if(!missing(estimate_fixed_point)){
            if(!( (is_scalar_integer(estimate_fixed_point) || is_scalar_double(estimate_fixed_point)) && estimate_fixed_point == as.integer(estimate_fixed_point))){ stop("arg estimate_fixed_point wrong type") }
        
        
            private$py_obj$estimate_fixed_point <- as.integer(estimate_fixed_point)
            } else {
        
                py_ans = private$py_obj$estimate_fixed_point
                r_result = py_ans
                return(r_result)
                }
        },
        linear_fp_mass_acc = function(linear_fp_mass_acc){
    
        if(!missing(linear_fp_mass_acc)){
            if(!(is_scalar_double(linear_fp_mass_acc))){ stop("arg linear_fp_mass_acc wrong type") }
        
        
            private$py_obj$linear_fp_mass_acc <- linear_fp_mass_acc
            } else {
        
                py_ans = private$py_obj$linear_fp_mass_acc
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void NumpressConfig()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$NumpressConfig()
        invisible()
    
    
    },
    
    # C++ signature: void NumpressConfig(NumpressConfig)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "NumpressConfig")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$NumpressConfig(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void NumpressConfig()
    # C++ signature: void NumpressConfig(NumpressConfig)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "NumpressConfig")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "NumpressConfig" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setCompression(const String & compression)
    setCompression = function(compression){
    
        if(!((is.R6(compression) && class(compression)[1]=="String") || is_scalar_character(compression))){ stop("arg compression wrong type") }
    
        private$py_obj$setCompression(compression)
        invisible()
    }
)
) 

# R implementation of _OMSSACSVFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OMSSACSVFile.html
OMSSACSVFile <- R6Class(classname = "OMSSACSVFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OMSSACSVFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OMSSACSVFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OMSSACSVFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, ProteinIdentification & protein_identification, libcpp_vector[PeptideIdentification] & id_data)
    load = function(filename, protein_identification, id_data){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_list(id_data) && all(sapply(id_data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg id_data wrong type") }
    
    
        v2 <- r_to_py(id_data)
        private$py_obj$load(filename, protein_identification, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id_data <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _OMSSAXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OMSSAXMLFile.html
OMSSAXMLFile <- R6Class(classname = "OMSSAXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OMSSAXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OMSSAXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OMSSAXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, ProteinIdentification & protein_identification, libcpp_vector[PeptideIdentification] & id_data, bool load_proteins, bool load_empty_hits)
    load = function(filename, protein_identification, id_data, load_proteins, load_empty_hits){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_list(id_data) && all(sapply(id_data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg id_data wrong type") }
        if(!( (is_scalar_integer(load_proteins) || is_scalar_double(load_proteins)) && load_proteins == as.integer(load_proteins))){ stop("arg load_proteins wrong type") }
        if(!( (is_scalar_integer(load_empty_hits) || is_scalar_double(load_empty_hits)) && load_empty_hits == as.integer(load_empty_hits))){ stop("arg load_empty_hits wrong type") }
    
    
        v2 <- r_to_py(id_data)
    
    
        private$py_obj$load(filename, protein_identification, v2, as.integer(load_proteins), as.integer(load_empty_hits))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id_data <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setModificationDefinitionsSet(ModificationDefinitionsSet rhs)
    setModificationDefinitionsSet = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "ModificationDefinitionsSet")){ stop("arg rhs wrong type") }
    
        private$py_obj$setModificationDefinitionsSet(rhs)
        invisible()
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _OPXLDataStructs
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OPXLDataStructs.html
OPXLDataStructs <- R6Class(classname = "OPXLDataStructs",cloneable = FALSE,

    private = list(py_obj = NA)

) 

# R implementation of _OPXLHelper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OPXLHelper.html
OPXLHelper <- R6Class(classname = "OPXLHelper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OPXLHelper(OPXLHelper)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OPXLHelper")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OPXLHelper(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OPXLHelper()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$OPXLHelper()
        invisible()
    
    
    },
    
    # C++ signature: void OPXLHelper(OPXLHelper)
    # C++ signature: void OPXLHelper()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OPXLHelper")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OPXLHelper" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[XLPrecursor] enumerateCrossLinksAndMasses(libcpp_vector[AASeqWithMass] peptides, double cross_link_mass_light, DoubleList cross_link_mass_mono_link, StringList cross_link_residue1, StringList cross_link_residue2, libcpp_vector[double] & spectrum_precursors, libcpp_vector[int] & precursor_correction_positions, double precursor_mass_tolerance, bool precursor_mass_tolerance_unit_ppm)
    enumerateCrossLinksAndMasses = function(peptides, cross_link_mass_light, cross_link_mass_mono_link, cross_link_residue1, cross_link_residue2, spectrum_precursors, precursor_correction_positions, precursor_mass_tolerance, precursor_mass_tolerance_unit_ppm){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASeqWithMass")))){ stop("arg peptides wrong type") }
        if(!(is_scalar_double(cross_link_mass_light))){ stop("arg cross_link_mass_light wrong type") }
        if(!(is_list(cross_link_mass_mono_link) && all(sapply(cross_link_mass_mono_link), is_scalar_character))){ stop("arg cross_link_mass_mono_link wrong type") }
        if(!(is_list(cross_link_residue1) && all(sapply(cross_link_residue1),is_scalar_character))){ stop("arg cross_link_residue1 wrong type") }
        if(!(is_list(cross_link_residue2) && all(sapply(cross_link_residue2),is_scalar_character))){ stop("arg cross_link_residue2 wrong type") }
        if(!(is_list(spectrum_precursors) && all(sapply(spectrum_precursors,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg spectrum_precursors wrong type") }
        if(!(is_list(precursor_correction_positions) && all(sapply(precursor_correction_positions,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg precursor_correction_positions wrong type") }
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(precursor_mass_tolerance_unit_ppm) || is_scalar_double(precursor_mass_tolerance_unit_ppm)) && precursor_mass_tolerance_unit_ppm == as.integer(precursor_mass_tolerance_unit_ppm))){ stop("arg precursor_mass_tolerance_unit_ppm wrong type") }
        v0 <- r_to_py(peptides)
    
        v2 = r_to_py(cross_link_mass_mono_link)
        v3 = r_to_py(modify_depth(cross_link_residue1,1,py_builtin$bytes(cross_link_residue1,'utf-8')))
        v4 = r_to_py(modify_depth(cross_link_residue2,1,py_builtin$bytes(cross_link_residue2,'utf-8')))
        v5 <- r_to_py(spectrum_precursors)
        v6 <- r_to_py(modify_depth(precursor_correction_positions,1,as.integer))
    
    
        py_ans = private$py_obj$enumerateCrossLinksAndMasses(v0, cross_link_mass_light, v2, v3, v4, v5, v6, precursor_mass_tolerance, as.integer(precursor_mass_tolerance_unit_ppm))
        byref_6 <- map_depth(py_to_r(v6),0,as.list)
        byref_5 <- map_depth(py_to_r(v5),0,as.list)
        
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(spectrum_precursors <- byref_5))
        eval.parent(substitute(precursor_correction_positions <- byref_6))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[AASeqWithMass] digestDatabase(libcpp_vector[FASTAEntry] fasta_db, EnzymaticDigestion digestor, size_t min_peptide_length, StringList cross_link_residue1, StringList cross_link_residue2, ModifiedPeptideGenerator_MapToResidueType & fixed_modifications, ModifiedPeptideGenerator_MapToResidueType & variable_modifications, size_t max_variable_mods_per_peptide)
    digestDatabase = function(fasta_db, digestor, min_peptide_length, cross_link_residue1, cross_link_residue2, fixed_modifications, variable_modifications, max_variable_mods_per_peptide){
    
        if(!(is_list(fasta_db) && all(sapply(fasta_db,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg fasta_db wrong type") }
        if(!(is.R6(digestor) && class(digestor)[1] == "EnzymaticDigestion")){ stop("arg digestor wrong type") }
        if(!( (is_scalar_integer(min_peptide_length) || is_scalar_double(min_peptide_length)) && min_peptide_length == as.integer(min_peptide_length))){ stop("arg min_peptide_length wrong type") }
        if(!(is_list(cross_link_residue1) && all(sapply(cross_link_residue1),is_scalar_character))){ stop("arg cross_link_residue1 wrong type") }
        if(!(is_list(cross_link_residue2) && all(sapply(cross_link_residue2),is_scalar_character))){ stop("arg cross_link_residue2 wrong type") }
        if(!(is.R6(fixed_modifications) && class(fixed_modifications)[1] == "ModifiedPeptideGenerator_MapToResidueType")){ stop("arg fixed_modifications wrong type") }
        if(!(is.R6(variable_modifications) && class(variable_modifications)[1] == "ModifiedPeptideGenerator_MapToResidueType")){ stop("arg variable_modifications wrong type") }
        if(!( (is_scalar_integer(max_variable_mods_per_peptide) || is_scalar_double(max_variable_mods_per_peptide)) && max_variable_mods_per_peptide == as.integer(max_variable_mods_per_peptide))){ stop("arg max_variable_mods_per_peptide wrong type") }
        v0 <- r_to_py(fasta_db)
    
    
        v3 = r_to_py(modify_depth(cross_link_residue1,1,py_builtin$bytes(cross_link_residue1,'utf-8')))
        v4 = r_to_py(modify_depth(cross_link_residue2,1,py_builtin$bytes(cross_link_residue2,'utf-8')))
    
    
    
        py_ans = private$py_obj$digestDatabase(v0, digestor, as.integer(min_peptide_length), v3, v4, fixed_modifications, variable_modifications, as.integer(max_variable_mods_per_peptide))
        
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[ProteinProteinCrossLink] buildCandidates(libcpp_vector[XLPrecursor] & candidates, libcpp_vector[int] & precursor_corrections, libcpp_vector[int] & precursor_correction_positions, libcpp_vector[AASeqWithMass] & peptide_masses, const StringList & cross_link_residue1, const StringList & cross_link_residue2, double cross_link_mass, DoubleList cross_link_mass_mono_link, libcpp_vector[double] & spectrum_precursor_vector, libcpp_vector[double] & allowed_error_vector, String cross_link_name)
    buildCandidates = function(candidates, precursor_corrections, precursor_correction_positions, peptide_masses, cross_link_residue1, cross_link_residue2, cross_link_mass, cross_link_mass_mono_link, spectrum_precursor_vector, allowed_error_vector, cross_link_name){
    
        if(!(is_list(candidates) && all(sapply(candidates,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "XLPrecursor")))){ stop("arg candidates wrong type") }
        if(!(is_list(precursor_corrections) && all(sapply(precursor_corrections,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg precursor_corrections wrong type") }
        if(!(is_list(precursor_correction_positions) && all(sapply(precursor_correction_positions,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg precursor_correction_positions wrong type") }
        if(!(is_list(peptide_masses) && all(sapply(peptide_masses,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASeqWithMass")))){ stop("arg peptide_masses wrong type") }
        if(!(is_list(cross_link_residue1) && all(sapply(cross_link_residue1),is_scalar_character))){ stop("arg cross_link_residue1 wrong type") }
        if(!(is_list(cross_link_residue2) && all(sapply(cross_link_residue2),is_scalar_character))){ stop("arg cross_link_residue2 wrong type") }
        if(!(is_scalar_double(cross_link_mass))){ stop("arg cross_link_mass wrong type") }
        if(!(is_list(cross_link_mass_mono_link) && all(sapply(cross_link_mass_mono_link), is_scalar_character))){ stop("arg cross_link_mass_mono_link wrong type") }
        if(!(is_list(spectrum_precursor_vector) && all(sapply(spectrum_precursor_vector,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg spectrum_precursor_vector wrong type") }
        if(!(is_list(allowed_error_vector) && all(sapply(allowed_error_vector,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg allowed_error_vector wrong type") }
        if(!((is.R6(cross_link_name) && class(cross_link_name)[1]=="String") || is_scalar_character(cross_link_name))){ stop("arg cross_link_name wrong type") }
        v0 <- r_to_py(candidates)
        v1 <- r_to_py(modify_depth(precursor_corrections,1,as.integer))
        v2 <- r_to_py(modify_depth(precursor_correction_positions,1,as.integer))
        v3 <- r_to_py(peptide_masses)
        v4 = r_to_py(modify_depth(cross_link_residue1,1,py_builtin$bytes(cross_link_residue1,'utf-8')))
        v5 = r_to_py(modify_depth(cross_link_residue2,1,py_builtin$bytes(cross_link_residue2,'utf-8')))
    
        v7 = r_to_py(cross_link_mass_mono_link)
        v8 <- r_to_py(spectrum_precursor_vector)
        v9 <- r_to_py(allowed_error_vector)
    
        py_ans = private$py_obj$buildCandidates(v0, v1, v2, v3, v4, v5, cross_link_mass, v7, v8, v9, cross_link_name)
        byref_9 <- map_depth(py_to_r(v9),0,as.list)
        byref_8 <- map_depth(py_to_r(v8),0,as.list)
        byref_5 <- modify_depth(py_to_r(v5),1,as.character)
        byref_4 <- modify_depth(py_to_r(v4),1,as.character)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(candidates <- byref_0))
        eval.parent(substitute(precursor_corrections <- byref_1))
        eval.parent(substitute(precursor_correction_positions <- byref_2))
        eval.parent(substitute(peptide_masses <- byref_3))
        eval.parent(substitute(cross_link_residue1 <- byref_4))
        eval.parent(substitute(cross_link_residue2 <- byref_5))
        eval.parent(substitute(spectrum_precursor_vector <- byref_8))
        eval.parent(substitute(allowed_error_vector <- byref_9))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void buildFragmentAnnotations(libcpp_vector[PeptideHit_PeakAnnotation] & frag_annotations, libcpp_vector[libcpp_pair[size_t,size_t]] matching, MSSpectrum theoretical_spectrum, MSSpectrum experiment_spectrum)
    buildFragmentAnnotations = function(frag_annotations, matching, theoretical_spectrum, experiment_spectrum){
    
        if(!(is_list(frag_annotations) && all(sapply(frag_annotations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_PeakAnnotation")))){ stop("arg frag_annotations wrong type") }
        if(!(is_list(matching) && all(sapply(matching,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matching wrong type") }
        if(!(is.R6(theoretical_spectrum) && class(theoretical_spectrum)[1] == "MSSpectrum")){ stop("arg theoretical_spectrum wrong type") }
        if(!(is.R6(experiment_spectrum) && class(experiment_spectrum)[1] == "MSSpectrum")){ stop("arg experiment_spectrum wrong type") }
        v0 <- r_to_py(frag_annotations)
        v1 <- r_to_py(matching)
    
    
        private$py_obj$buildFragmentAnnotations(v0, v1, theoretical_spectrum, experiment_spectrum)
        
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(frag_annotations <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void buildPeptideIDs(libcpp_vector[PeptideIdentification] & peptide_ids, libcpp_vector[CrossLinkSpectrumMatch] top_csms_spectrum, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] & all_top_csms, size_t all_top_csms_current_index, MSExperiment spectra, size_t scan_index, size_t scan_index_heavy)
    buildPeptideIDs = function(peptide_ids, top_csms_spectrum, all_top_csms, all_top_csms_current_index, spectra, scan_index, scan_index_heavy){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(top_csms_spectrum) && all(sapply(top_csms_spectrum,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CrossLinkSpectrumMatch")))){ stop("arg top_csms_spectrum wrong type") }
        if(!(is_list(all_top_csms) && all(sapply(all_top_csms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch")))))){ stop("arg all_top_csms wrong type") }
        if(!( (is_scalar_integer(all_top_csms_current_index) || is_scalar_double(all_top_csms_current_index)) && all_top_csms_current_index == as.integer(all_top_csms_current_index))){ stop("arg all_top_csms_current_index wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!( (is_scalar_integer(scan_index) || is_scalar_double(scan_index)) && scan_index == as.integer(scan_index))){ stop("arg scan_index wrong type") }
        if(!( (is_scalar_integer(scan_index_heavy) || is_scalar_double(scan_index_heavy)) && scan_index_heavy == as.integer(scan_index_heavy))){ stop("arg scan_index_heavy wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 <- r_to_py(top_csms_spectrum)
        v2 <- r_to_py(all_top_csms)
    
    
    
    
        private$py_obj$buildPeptideIDs(v0, v1, v2, as.integer(all_top_csms_current_index), spectra, as.integer(scan_index), as.integer(scan_index_heavy))
        v2 <- py_to_r(v2)
        byref_2 <- map_depth(v2,listDepth(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(all_top_csms <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addProteinPositionMetaValues(libcpp_vector[PeptideIdentification] & peptide_ids)
    addProteinPositionMetaValues = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        private$py_obj$addProteinPositionMetaValues(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addXLTargetDecoyMV(libcpp_vector[PeptideIdentification] & peptide_ids)
    addXLTargetDecoyMV = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        private$py_obj$addXLTargetDecoyMV(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addBetaAccessions(libcpp_vector[PeptideIdentification] & peptide_ids)
    addBetaAccessions = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        private$py_obj$addBetaAccessions(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeBetaPeptideHits(libcpp_vector[PeptideIdentification] & peptide_ids)
    removeBetaPeptideHits = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        private$py_obj$removeBetaPeptideHits(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addPercolatorFeatureList(ProteinIdentification & prot_id)
    addPercolatorFeatureList = function(prot_id){
    
        if(!(is.R6(prot_id) && class(prot_id)[1] == "ProteinIdentification")){ stop("arg prot_id wrong type") }
    
        private$py_obj$addPercolatorFeatureList(prot_id)
        invisible()
    },
    
    # C++ signature: void computeDeltaScores(libcpp_vector[PeptideIdentification] & peptide_ids)
    computeDeltaScores = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        private$py_obj$computeDeltaScores(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] combineTopRanksFromPairs(libcpp_vector[PeptideIdentification] & peptide_ids, size_t number_top_hits)
    combineTopRanksFromPairs = function(peptide_ids, number_top_hits){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!( (is_scalar_integer(number_top_hits) || is_scalar_double(number_top_hits)) && number_top_hits == as.integer(number_top_hits))){ stop("arg number_top_hits wrong type") }
        v0 <- r_to_py(peptide_ids)
    
        py_ans = private$py_obj$combineTopRanksFromPairs(v0, as.integer(number_top_hits))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[ProteinProteinCrossLink] collectPrecursorCandidates(IntList precursor_correction_steps, double precursor_mass, double precursor_mass_tolerance, bool precursor_mass_tolerance_unit_ppm, libcpp_vector[AASeqWithMass] filtered_peptide_masses, double cross_link_mass, DoubleList cross_link_mass_mono_link, StringList cross_link_residue1, StringList cross_link_residue2, String cross_link_name, bool use_sequence_tags, const libcpp_vector[libcpp_string] & tags)
    collectPrecursorCandidates = function(precursor_correction_steps, precursor_mass, precursor_mass_tolerance, precursor_mass_tolerance_unit_ppm, filtered_peptide_masses, cross_link_mass, cross_link_mass_mono_link, cross_link_residue1, cross_link_residue2, cross_link_name, use_sequence_tags, tags){
    
        if(!(is_list(precursor_correction_steps) && all(sapply(precursor_correction_steps), function(inner) inner == as.integer(inner)))){ stop("arg precursor_correction_steps wrong type") }
        if(!(is_scalar_double(precursor_mass))){ stop("arg precursor_mass wrong type") }
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(precursor_mass_tolerance_unit_ppm) || is_scalar_double(precursor_mass_tolerance_unit_ppm)) && precursor_mass_tolerance_unit_ppm == as.integer(precursor_mass_tolerance_unit_ppm))){ stop("arg precursor_mass_tolerance_unit_ppm wrong type") }
        if(!(is_list(filtered_peptide_masses) && all(sapply(filtered_peptide_masses,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASeqWithMass")))){ stop("arg filtered_peptide_masses wrong type") }
        if(!(is_scalar_double(cross_link_mass))){ stop("arg cross_link_mass wrong type") }
        if(!(is_list(cross_link_mass_mono_link) && all(sapply(cross_link_mass_mono_link), is_scalar_character))){ stop("arg cross_link_mass_mono_link wrong type") }
        if(!(is_list(cross_link_residue1) && all(sapply(cross_link_residue1),is_scalar_character))){ stop("arg cross_link_residue1 wrong type") }
        if(!(is_list(cross_link_residue2) && all(sapply(cross_link_residue2),is_scalar_character))){ stop("arg cross_link_residue2 wrong type") }
        if(!((is.R6(cross_link_name) && class(cross_link_name)[1]=="String") || is_scalar_character(cross_link_name))){ stop("arg cross_link_name wrong type") }
        if(!( (is_scalar_integer(use_sequence_tags) || is_scalar_double(use_sequence_tags)) && use_sequence_tags == as.integer(use_sequence_tags))){ stop("arg use_sequence_tags wrong type") }
        if(!(is_list(tags) && all(sapply(tags,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg tags wrong type") }
        v0 = r_to_py(precursor_correction_steps)
    
    
    
        v4 <- r_to_py(filtered_peptide_masses)
    
        v6 = r_to_py(cross_link_mass_mono_link)
        v7 = r_to_py(modify_depth(cross_link_residue1,1,py_builtin$bytes(cross_link_residue1,'utf-8')))
        v8 = r_to_py(modify_depth(cross_link_residue2,1,py_builtin$bytes(cross_link_residue2,'utf-8')))
    
    
        v11 <- r_to_py(modify_depth(tags,1, function(a) py_builtin$bytes(a, 'utf-8')))
        py_ans = private$py_obj$collectPrecursorCandidates(v0, precursor_mass, precursor_mass_tolerance, as.integer(precursor_mass_tolerance_unit_ppm), v4, cross_link_mass, v6, v7, v8, cross_link_name, as.integer(use_sequence_tags), v11)
        
        
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: double computePrecursorError(CrossLinkSpectrumMatch csm, double precursor_mz, int precursor_charge)
    computePrecursorError = function(csm, precursor_mz, precursor_charge){
    
        if(!(is.R6(csm) && class(csm)[1] == "CrossLinkSpectrumMatch")){ stop("arg csm wrong type") }
        if(!(is_scalar_double(precursor_mz))){ stop("arg precursor_mz wrong type") }
        if(!( (is_scalar_integer(precursor_charge) || is_scalar_double(precursor_charge)) && precursor_charge == as.integer(precursor_charge))){ stop("arg precursor_charge wrong type") }
    
    
    
        py_ans = private$py_obj$computePrecursorError(csm, precursor_mz, as.integer(precursor_charge))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void isoPeakMeans(CrossLinkSpectrumMatch & csm, IntegerDataArray & num_iso_peaks_array, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_linear_alpha, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_linear_beta, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_xlinks_alpha, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_xlinks_beta)
    isoPeakMeans = function(csm, num_iso_peaks_array, matched_spec_linear_alpha, matched_spec_linear_beta, matched_spec_xlinks_alpha, matched_spec_xlinks_beta){
    
        if(!(is.R6(csm) && class(csm)[1] == "CrossLinkSpectrumMatch")){ stop("arg csm wrong type") }
        if(!(is.R6(num_iso_peaks_array) && class(num_iso_peaks_array)[1] == "IntegerDataArray")){ stop("arg num_iso_peaks_array wrong type") }
        if(!(is_list(matched_spec_linear_alpha) && all(sapply(matched_spec_linear_alpha,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_linear_alpha wrong type") }
        if(!(is_list(matched_spec_linear_beta) && all(sapply(matched_spec_linear_beta,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_linear_beta wrong type") }
        if(!(is_list(matched_spec_xlinks_alpha) && all(sapply(matched_spec_xlinks_alpha,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_xlinks_alpha wrong type") }
        if(!(is_list(matched_spec_xlinks_beta) && all(sapply(matched_spec_xlinks_beta,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_xlinks_beta wrong type") }
    
    
        v2 <- r_to_py(matched_spec_linear_alpha)
        v3 <- r_to_py(matched_spec_linear_beta)
        v4 <- r_to_py(matched_spec_xlinks_alpha)
        v5 <- r_to_py(matched_spec_xlinks_beta)
        private$py_obj$isoPeakMeans(csm, num_iso_peaks_array, v2, v3, v4, v5)
        byref_5 <- py_to_r(v5)
        byref_4 <- py_to_r(v4)
        byref_3 <- py_to_r(v3)
        byref_2 <- py_to_r(v2)
    
        tryCatch({
        eval.parent(substitute(matched_spec_linear_alpha <- byref_2))
        eval.parent(substitute(matched_spec_linear_beta <- byref_3))
        eval.parent(substitute(matched_spec_xlinks_alpha <- byref_4))
        eval.parent(substitute(matched_spec_xlinks_beta <- byref_5))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _OPXLSpectrumProcessingAlgorithms
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OPXLSpectrumProcessingAlgorithms.html
OPXLSpectrumProcessingAlgorithms <- R6Class(classname = "OPXLSpectrumProcessingAlgorithms",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OPXLSpectrumProcessingAlgorithms(OPXLSpectrumProcessingAlgorithms)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OPXLSpectrumProcessingAlgorithms")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OPXLSpectrumProcessingAlgorithms(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OPXLSpectrumProcessingAlgorithms()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$OPXLSpectrumProcessingAlgorithms()
        invisible()
    
    
    },
    
    # C++ signature: void OPXLSpectrumProcessingAlgorithms(OPXLSpectrumProcessingAlgorithms)
    # C++ signature: void OPXLSpectrumProcessingAlgorithms()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OPXLSpectrumProcessingAlgorithms")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OPXLSpectrumProcessingAlgorithms" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: MSSpectrum mergeAnnotatedSpectra(MSSpectrum & first_spectrum, MSSpectrum & second_spectrum)
    mergeAnnotatedSpectra = function(first_spectrum, second_spectrum){
    
        if(!(is.R6(first_spectrum) && class(first_spectrum)[1] == "MSSpectrum")){ stop("arg first_spectrum wrong type") }
        if(!(is.R6(second_spectrum) && class(second_spectrum)[1] == "MSSpectrum")){ stop("arg second_spectrum wrong type") }
    
    
        py_ans = private$py_obj$mergeAnnotatedSpectra(first_spectrum, second_spectrum)
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSExperiment preprocessSpectra(MSExperiment & exp, double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, size_t peptide_min_size, int min_precursor_charge, int max_precursor_charge, bool deisotope, bool labeled)
    preprocessSpectra = function(exp, fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, peptide_min_size, min_precursor_charge, max_precursor_charge, deisotope, labeled){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!( (is_scalar_integer(peptide_min_size) || is_scalar_double(peptide_min_size)) && peptide_min_size == as.integer(peptide_min_size))){ stop("arg peptide_min_size wrong type") }
        if(!( (is_scalar_integer(min_precursor_charge) || is_scalar_double(min_precursor_charge)) && min_precursor_charge == as.integer(min_precursor_charge))){ stop("arg min_precursor_charge wrong type") }
        if(!( (is_scalar_integer(max_precursor_charge) || is_scalar_double(max_precursor_charge)) && max_precursor_charge == as.integer(max_precursor_charge))){ stop("arg max_precursor_charge wrong type") }
        if(!( (is_scalar_integer(deisotope) || is_scalar_double(deisotope)) && deisotope == as.integer(deisotope))){ stop("arg deisotope wrong type") }
        if(!( (is_scalar_integer(labeled) || is_scalar_double(labeled)) && labeled == as.integer(labeled))){ stop("arg labeled wrong type") }
    
    
    
    
    
    
    
    
        py_ans = private$py_obj$preprocessSpectra(exp, fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), as.integer(peptide_min_size), as.integer(min_precursor_charge), as.integer(max_precursor_charge), as.integer(deisotope), as.integer(labeled))
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getSpectrumAlignmentFastCharge(libcpp_vector[libcpp_pair[size_t,size_t]] & alignment, double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, const MSSpectrum & theo_spectrum, const MSSpectrum & exp_spectrum, const IntegerDataArray & theo_charges, const IntegerDataArray & exp_charges, FloatDataArray & ppm_error_array, double intensity_cutoff)
    getSpectrumAlignmentFastCharge = function(alignment, fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, theo_spectrum, exp_spectrum, theo_charges, exp_charges, ppm_error_array, intensity_cutoff){
    
        if(!(is_list(alignment) && all(sapply(alignment,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg alignment wrong type") }
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(is.R6(theo_spectrum) && class(theo_spectrum)[1] == "MSSpectrum")){ stop("arg theo_spectrum wrong type") }
        if(!(is.R6(exp_spectrum) && class(exp_spectrum)[1] == "MSSpectrum")){ stop("arg exp_spectrum wrong type") }
        if(!(is.R6(theo_charges) && class(theo_charges)[1] == "IntegerDataArray")){ stop("arg theo_charges wrong type") }
        if(!(is.R6(exp_charges) && class(exp_charges)[1] == "IntegerDataArray")){ stop("arg exp_charges wrong type") }
        if(!(is.R6(ppm_error_array) && class(ppm_error_array)[1] == "FloatDataArray")){ stop("arg ppm_error_array wrong type") }
        if(!(is_scalar_double(intensity_cutoff))){ stop("arg intensity_cutoff wrong type") }
        v0 <- r_to_py(alignment)
    
    
    
    
    
    
    
    
        private$py_obj$getSpectrumAlignmentFastCharge(v0, fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), theo_spectrum, exp_spectrum, theo_charges, exp_charges, ppm_error_array, intensity_cutoff)
        byref_0 <- py_to_r(v0)
    
        tryCatch({
        eval.parent(substitute(alignment <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getSpectrumAlignmentSimple(libcpp_vector[libcpp_pair[size_t,size_t]] & alignment, double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, const libcpp_vector[SimplePeak] & theo_spectrum, const MSSpectrum & exp_spectrum, const IntegerDataArray & exp_charges)
    getSpectrumAlignmentSimple = function(alignment, fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, theo_spectrum, exp_spectrum, exp_charges){
    
        if(!(is_list(alignment) && all(sapply(alignment,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg alignment wrong type") }
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(is_list(theo_spectrum) && all(sapply(theo_spectrum,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak")))){ stop("arg theo_spectrum wrong type") }
        if(!(is.R6(exp_spectrum) && class(exp_spectrum)[1] == "MSSpectrum")){ stop("arg exp_spectrum wrong type") }
        if(!(is.R6(exp_charges) && class(exp_charges)[1] == "IntegerDataArray")){ stop("arg exp_charges wrong type") }
        v0 <- r_to_py(alignment)
    
    
        v3 <- r_to_py(theo_spectrum)
    
    
        private$py_obj$getSpectrumAlignmentSimple(v0, fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), v3, exp_spectrum, exp_charges)
        
        byref_0 <- py_to_r(v0)
    
        tryCatch({
        eval.parent(substitute(alignment <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _OPXL_PreprocessedPairSpectra
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::OPXLDataStructs_1_1OPXL_PreprocessedPairSpectra.html
OPXL_PreprocessedPairSpectra <- R6Class(classname = "OPXL_PreprocessedPairSpectra",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        spectra_linear_peaks = function(spectra_linear_peaks){
    
        if(!missing(spectra_linear_peaks)){
            if(!(is.R6(spectra_linear_peaks) && class(spectra_linear_peaks)[1] == "MSExperiment")){ stop("arg spectra_linear_peaks wrong type") }
        
        
            private$py_obj$spectra_linear_peaks <- spectra_linear_peaks
            } else {
        
                py_ans = private$py_obj$spectra_linear_peaks
            r_result = MSExperiment$new(py_ans)
                return(r_result)
                }
        },
        spectra_xlink_peaks = function(spectra_xlink_peaks){
    
        if(!missing(spectra_xlink_peaks)){
            if(!(is.R6(spectra_xlink_peaks) && class(spectra_xlink_peaks)[1] == "MSExperiment")){ stop("arg spectra_xlink_peaks wrong type") }
        
        
            private$py_obj$spectra_xlink_peaks <- spectra_xlink_peaks
            } else {
        
                py_ans = private$py_obj$spectra_xlink_peaks
            r_result = MSExperiment$new(py_ans)
                return(r_result)
                }
        },
        spectra_all_peaks = function(spectra_all_peaks){
    
        if(!missing(spectra_all_peaks)){
            if(!(is.R6(spectra_all_peaks) && class(spectra_all_peaks)[1] == "MSExperiment")){ stop("arg spectra_all_peaks wrong type") }
        
        
            private$py_obj$spectra_all_peaks <- spectra_all_peaks
            } else {
        
                py_ans = private$py_obj$spectra_all_peaks
            r_result = MSExperiment$new(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OPXL_PreprocessedPairSpectra(OPXL_PreprocessedPairSpectra)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OPXL_PreprocessedPairSpectra")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OPXL_PreprocessedPairSpectra(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OPXL_PreprocessedPairSpectra(size_t size)
    init_1 = function(size){
    
        if(!( (is_scalar_integer(size) || is_scalar_double(size)) && size == as.integer(size))){ stop("arg size wrong type") }
    
    
        private$py_obj <- Pymod$OPXL_PreprocessedPairSpectra(as.integer(size))
        invisible()
    
    
    },
    
    # C++ signature: void OPXL_PreprocessedPairSpectra(OPXL_PreprocessedPairSpectra)
    # C++ signature: void OPXL_PreprocessedPairSpectra(size_t size)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OPXL_PreprocessedPairSpectra")) { self$init_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OPXL_PreprocessedPairSpectra" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OSBinaryDataArray
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1OSBinaryDataArray.html
OSBinaryDataArray <- R6Class(classname = "OSBinaryDataArray",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        data = function(data){
    
        if(!missing(data)){
            if(!(is_list(data) && all(sapply(data,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg data wrong type") }
        
            v0 <- r_to_py(data)
            private$py_obj$data <- v0
            } else {
            
                py_ans = private$py_obj$data
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!(is_scalar_character(description))){ stop("arg description wrong type") }
        
        description_0 = py_builtin$bytes(description,'utf-8')
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = as.character(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OSBinaryDataArray()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OSBinaryDataArray()
        invisible()
    
    
    },
    
    # C++ signature: void OSBinaryDataArray(OSBinaryDataArray)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OSBinaryDataArray")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OSBinaryDataArray(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OSBinaryDataArray()
    # C++ signature: void OSBinaryDataArray(OSBinaryDataArray)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OSBinaryDataArray")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OSBinaryDataArray" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OSChromatogram
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1OSChromatogram.html
OSChromatogram <- R6Class(classname = "OSChromatogram",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OSChromatogram()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OSChromatogram()
        invisible()
    
    
    },
    
    # C++ signature: void OSChromatogram(OSChromatogram)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OSChromatogram")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OSChromatogram(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OSChromatogram()
    # C++ signature: void OSChromatogram(OSChromatogram)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OSChromatogram")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OSChromatogram" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OSChromatogramMeta
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1OSChromatogramMeta.html
OSChromatogramMeta <- R6Class(classname = "OSChromatogramMeta",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!(is_scalar_character(id))){ stop("arg id wrong type") }
        
        id_0 = py_builtin$bytes(id,'utf-8')
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = as.character(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OSChromatogramMeta()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OSChromatogramMeta) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OSChromatogramMeta()
        invisible()
    }
    
    }
)
) 

# R implementation of _OSSpectrum
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1OSSpectrum.html
OSSpectrum <- R6Class(classname = "OSSpectrum",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OSSpectrum()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OSSpectrum()
        invisible()
    
    
    },
    
    # C++ signature: void OSSpectrum(OSSpectrum)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OSSpectrum")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OSSpectrum(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OSSpectrum()
    # C++ signature: void OSSpectrum(OSSpectrum)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OSSpectrum")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OSSpectrum" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OSSpectrumMeta
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1OSSpectrumMeta.html
OSSpectrumMeta <- R6Class(classname = "OSSpectrumMeta",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!(is_scalar_character(id))){ stop("arg id wrong type") }
        
        id_0 = py_builtin$bytes(id,'utf-8')
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        RT = function(RT){
    
        if(!missing(RT)){
            if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        
        
            private$py_obj$RT <- RT
            } else {
        
                py_ans = private$py_obj$RT
                r_result = py_ans
                return(r_result)
                }
        },
        ms_level = function(ms_level){
    
        if(!missing(ms_level)){
            if(!( (is_scalar_integer(ms_level) || is_scalar_double(ms_level)) && ms_level == as.integer(ms_level))){ stop("arg ms_level wrong type") }
        
        
            private$py_obj$ms_level <- as.integer(ms_level)
            } else {
        
                py_ans = private$py_obj$ms_level
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OSSpectrumMeta()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OSSpectrumMeta) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OSSpectrumMeta()
        invisible()
    }
    
    }
)
) 

# R implementation of _OSWFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OSWFile.html
OSWFile <- R6Class(classname = "OSWFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OSWFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OSWFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OSWFile()
        invisible()
    }
    
    }
)
) 

# R implementation of _OSW_ChromExtractParams
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OSW_ChromExtractParams.html
OSW_ChromExtractParams <- R6Class(classname = "OSW_ChromExtractParams",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        min_upper_edge_dist = function(min_upper_edge_dist){
    
        if(!missing(min_upper_edge_dist)){
            if(!(is_scalar_double(min_upper_edge_dist))){ stop("arg min_upper_edge_dist wrong type") }
        
        
            private$py_obj$min_upper_edge_dist <- min_upper_edge_dist
            } else {
        
                py_ans = private$py_obj$min_upper_edge_dist
                r_result = py_ans
                return(r_result)
                }
        },
        mz_extraction_window = function(mz_extraction_window){
    
        if(!missing(mz_extraction_window)){
            if(!(is_scalar_double(mz_extraction_window))){ stop("arg mz_extraction_window wrong type") }
        
        
            private$py_obj$mz_extraction_window <- mz_extraction_window
            } else {
        
                py_ans = private$py_obj$mz_extraction_window
                r_result = py_ans
                return(r_result)
                }
        },
        ppm = function(ppm){
    
        if(!missing(ppm)){
            if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        
        
            private$py_obj$ppm <- as.integer(ppm)
            } else {
        
                py_ans = private$py_obj$ppm
                r_result = py_ans
                return(r_result)
                }
        },
        extraction_function = function(extraction_function){
    
        if(!missing(extraction_function)){
            if(!(is_scalar_character(extraction_function))){ stop("arg extraction_function wrong type") }
        
        extraction_function_0 = py_builtin$bytes(extraction_function,'utf-8')
            private$py_obj$extraction_function <- extraction_function
            } else {
        
                py_ans = private$py_obj$extraction_function
            r_result = as.character(py_ans)
                return(r_result)
                }
        },
        rt_extraction_window = function(rt_extraction_window){
    
        if(!missing(rt_extraction_window)){
            if(!(is_scalar_double(rt_extraction_window))){ stop("arg rt_extraction_window wrong type") }
        
        
            private$py_obj$rt_extraction_window <- rt_extraction_window
            } else {
        
                py_ans = private$py_obj$rt_extraction_window
                r_result = py_ans
                return(r_result)
                }
        },
        extra_rt_extract = function(extra_rt_extract){
    
        if(!missing(extra_rt_extract)){
            if(!(is_scalar_double(extra_rt_extract))){ stop("arg extra_rt_extract wrong type") }
        
        
            private$py_obj$extra_rt_extract <- extra_rt_extract
            } else {
        
                py_ans = private$py_obj$extra_rt_extract
                r_result = py_ans
                return(r_result)
                }
        },
        im_extraction_window = function(im_extraction_window){
    
        if(!missing(im_extraction_window)){
            if(!(is_scalar_double(im_extraction_window))){ stop("arg im_extraction_window wrong type") }
        
        
            private$py_obj$im_extraction_window <- im_extraction_window
            } else {
        
                py_ans = private$py_obj$im_extraction_window
                r_result = py_ans
                return(r_result)
                }
        }

    )
) 

# R implementation of _OfflinePrecursorIonSelection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OfflinePrecursorIonSelection.html
OfflinePrecursorIonSelection <- R6Class(classname = "OfflinePrecursorIonSelection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OfflinePrecursorIonSelection()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OfflinePrecursorIonSelection) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OfflinePrecursorIonSelection()
        invisible()
    }
    
    },
    
    # C++ signature: void makePrecursorSelectionForKnownLCMSMap(FeatureMap & features, MSExperiment & experiment, MSExperiment & ms2, libcpp_set[int] & charges_set, bool feature_based)
    makePrecursorSelectionForKnownLCMSMap = function(features, experiment, ms2, charges_set, feature_based){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!(is.R6(ms2) && class(ms2)[1] == "MSExperiment")){ stop("arg ms2 wrong type") }
        if(!(is_list(charges_set) && all(sapply(charges_set,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(charges_set)))){ stop("arg charges_set wrong type") }
        if(!( (is_scalar_integer(feature_based) || is_scalar_double(feature_based)) && feature_based == as.integer(feature_based))){ stop("arg feature_based wrong type") }
    
    
    
        py$v3 <- charges_set
        py_run_string("v3 = [int(t) for t in v3];v3 = set(v3)")
    
        private$py_obj$makePrecursorSelectionForKnownLCMSMap(features, experiment, ms2, py$v3, as.integer(feature_based))
        byref_3 <- as.list(py_eval("list(v3)"))
        py_run_string("del v3; gc.collect()")
    
        tryCatch({
        eval.parent(substitute(charges_set <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void createProteinSequenceBasedLPInclusionList(String include_, String rt_model_file, String pt_model_file, FeatureMap & precursors)
    createProteinSequenceBasedLPInclusionList = function(include_, rt_model_file, pt_model_file, precursors){
    
        if(!((is.R6(include_) && class(include_)[1]=="String") || is_scalar_character(include_))){ stop("arg include_ wrong type") }
        if(!((is.R6(rt_model_file) && class(rt_model_file)[1]=="String") || is_scalar_character(rt_model_file))){ stop("arg rt_model_file wrong type") }
        if(!((is.R6(pt_model_file) && class(pt_model_file)[1]=="String") || is_scalar_character(pt_model_file))){ stop("arg pt_model_file wrong type") }
        if(!(is.R6(precursors) && class(precursors)[1] == "FeatureMap")){ stop("arg precursors wrong type") }
    
    
    
    
        private$py_obj$createProteinSequenceBasedLPInclusionList(include_, rt_model_file, pt_model_file, precursors)
        invisible()
    },
    
    # C++ signature: void setLPSolver(SOLVER solver)
    setLPSolver = function(solver){
    
        if(!(solver %in% c(0))){ stop("arg solver wrong type") }
    
        private$py_obj$setLPSolver(as.integer(solver))
        invisible()
    },
    
    # C++ signature: SOLVER getLPSolver()
    getLPSolver = function(){
    
        py_ans = private$py_obj$getLPSolver()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _OnDiscMSExperiment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OnDiscMSExperiment.html
OnDiscMSExperiment <- R6Class(classname = "OnDiscMSExperiment",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OnDiscMSExperiment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OnDiscMSExperiment()
        invisible()
    
    
    },
    
    # C++ signature: void OnDiscMSExperiment(OnDiscMSExperiment &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OnDiscMSExperiment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OnDiscMSExperiment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OnDiscMSExperiment()
    # C++ signature: void OnDiscMSExperiment(OnDiscMSExperiment &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OnDiscMSExperiment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OnDiscMSExperiment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool openFile(String filename)
    openFile_0 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$`_openFile_0`(filename)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool openFile(String filename, bool skipLoadingMetaData)
    openFile_1 = function(filename, skipLoadingMetaData){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(skipLoadingMetaData) || is_scalar_double(skipLoadingMetaData)) && skipLoadingMetaData == as.integer(skipLoadingMetaData))){ stop("arg skipLoadingMetaData wrong type") }
    
    
        py_ans = private$py_obj$`_openFile_1`(filename, as.integer(skipLoadingMetaData))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool openFile(String filename)
    # C++ signature: bool openFile(String filename, bool skipLoadingMetaData)
    openFile = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$openFile_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$openFile_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[const ExperimentalSettings] getExperimentalSettings()
    getExperimentalSettings = function(){
    
        py_ans = private$py_obj$getExperimentalSettings()
        r_ans = ExperimentalSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[MSExperiment] getMetaData()
    getMetaData = function(){
    
        py_ans = private$py_obj$getMetaData()
        r_ans = MSExperiment$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum getSpectrum(size_t id)
    getSpectrum = function(id){
    
        if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getSpectrum(as.integer(id))
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum getSpectrumByNativeId(String id)
    getSpectrumByNativeId = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getSpectrumByNativeId(id)
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSChromatogram getChromatogram(size_t id)
    getChromatogram = function(id){
    
        if(!( (is_scalar_integer(id) || is_scalar_double(id)) && id == as.integer(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getChromatogram(as.integer(id))
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSChromatogram getChromatogramByNativeId(String id)
    getChromatogramByNativeId = function(id){
    
        if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
    
        py_ans = private$py_obj$getChromatogramByNativeId(id)
        r_ans = MSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[_Interfaces_Spectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = Spectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[_Interfaces_Chromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = Chromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSkipXMLChecks(bool skip)
    setSkipXMLChecks = function(skip){
    
        if(!( (is_scalar_integer(skip) || is_scalar_double(skip)) && skip == as.integer(skip))){ stop("arg skip wrong type") }
    
        private$py_obj$setSkipXMLChecks(as.integer(skip))
        invisible()
    }
)
) 

# R implementation of _OpenPepXLAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenPepXLAlgorithm.html
OpenPepXLAlgorithm <- R6Class(classname = "OpenPepXLAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OpenPepXLAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OpenPepXLAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OpenPepXLAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: OpenPepXLAlgorithm_ExitCodes run(MSExperiment & unprocessed_spectra, ConsensusMap & cfeatures, libcpp_vector[FASTAEntry] & fasta_db, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, OPXL_PreprocessedPairSpectra & preprocessed_pair_spectra, libcpp_vector[libcpp_pair[size_t,size_t]] & spectrum_pairs, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] & all_top_csms, MSExperiment & spectra)
    run = function(unprocessed_spectra, cfeatures, fasta_db, protein_ids, peptide_ids, preprocessed_pair_spectra, spectrum_pairs, all_top_csms, spectra){
    
        if(!(is.R6(unprocessed_spectra) && class(unprocessed_spectra)[1] == "MSExperiment")){ stop("arg unprocessed_spectra wrong type") }
        if(!(is.R6(cfeatures) && class(cfeatures)[1] == "ConsensusMap")){ stop("arg cfeatures wrong type") }
        if(!(is_list(fasta_db) && all(sapply(fasta_db,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg fasta_db wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is.R6(preprocessed_pair_spectra) && class(preprocessed_pair_spectra)[1] == "OPXL_PreprocessedPairSpectra")){ stop("arg preprocessed_pair_spectra wrong type") }
        if(!(is_list(spectrum_pairs) && all(sapply(spectrum_pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg spectrum_pairs wrong type") }
        if(!(is_list(all_top_csms) && all(sapply(all_top_csms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch")))))){ stop("arg all_top_csms wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
    
        v2 <- r_to_py(fasta_db)
        v3 <- r_to_py(protein_ids)
        v4 <- r_to_py(peptide_ids)
    
        v6 <- r_to_py(spectrum_pairs)
        v7 <- r_to_py(all_top_csms)
    
        py_ans = private$py_obj$run(unprocessed_spectra, cfeatures, v2, v3, v4, preprocessed_pair_spectra, v6, v7, spectra)
        v7 <- py_to_r(v7)
        byref_7 <- map_depth(v7,listDepth(v7),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_6 <- py_to_r(v6)
        byref_4 <- map(py_to_r(v4),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(fasta_db <- byref_2))
        eval.parent(substitute(protein_ids <- byref_3))
        eval.parent(substitute(peptide_ids <- byref_4))
        eval.parent(substitute(spectrum_pairs <- byref_6))
        eval.parent(substitute(all_top_csms <- byref_7))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _OpenPepXLLFAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenPepXLLFAlgorithm.html
OpenPepXLLFAlgorithm <- R6Class(classname = "OpenPepXLLFAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OpenPepXLLFAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OpenPepXLLFAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OpenPepXLLFAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: OpenPepXLLFAlgorithm_ExitCodes run(MSExperiment & unprocessed_spectra, libcpp_vector[FASTAEntry] & fasta_db, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] & all_top_csms, MSExperiment & spectra)
    run = function(unprocessed_spectra, fasta_db, protein_ids, peptide_ids, all_top_csms, spectra){
    
        if(!(is.R6(unprocessed_spectra) && class(unprocessed_spectra)[1] == "MSExperiment")){ stop("arg unprocessed_spectra wrong type") }
        if(!(is_list(fasta_db) && all(sapply(fasta_db,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg fasta_db wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(all_top_csms) && all(sapply(all_top_csms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch")))))){ stop("arg all_top_csms wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
        v1 <- r_to_py(fasta_db)
        v2 <- r_to_py(protein_ids)
        v3 <- r_to_py(peptide_ids)
        v4 <- r_to_py(all_top_csms)
    
        py_ans = private$py_obj$run(unprocessed_spectra, v1, v2, v3, v4, spectra)
        v4 <- py_to_r(v4)
        byref_4 <- map_depth(v4,listDepth(v4),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(fasta_db <- byref_1))
        eval.parent(substitute(protein_ids <- byref_2))
        eval.parent(substitute(peptide_ids <- byref_3))
        eval.parent(substitute(all_top_csms <- byref_4))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _OpenSwathDataAccessHelper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwathDataAccessHelper.html
OpenSwathDataAccessHelper <- R6Class(classname = "OpenSwathDataAccessHelper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void convertToOpenMSSpectrum(shared_ptr[OSSpectrum] sptr, MSSpectrum & spectrum)
    convertToOpenMSSpectrum = function(sptr, spectrum){
    
        if(!(all(class(sptr) == c('OSSpectrum','R6')))){ stop("arg sptr wrong type") }
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        input_sptr <- r_to_py(sptr)
    
        private$py_obj$convertToOpenMSSpectrum(input_sptr, spectrum)
        invisible()
    },
    
    # C++ signature: void convertToOpenMSChromatogram(shared_ptr[OSChromatogram] cptr, MSChromatogram & chromatogram)
    convertToOpenMSChromatogram = function(cptr, chromatogram){
    
        if(!(all(class(cptr) == c('OSChromatogram','R6')))){ stop("arg cptr wrong type") }
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        input_cptr <- r_to_py(cptr)
    
        private$py_obj$convertToOpenMSChromatogram(input_cptr, chromatogram)
        invisible()
    },
    
    # C++ signature: void convertToOpenMSChromatogramFilter(MSChromatogram & chromatogram, shared_ptr[OSChromatogram] cptr, double rt_min, double rt_max)
    convertToOpenMSChromatogramFilter = function(chromatogram, cptr, rt_min, rt_max){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!(all(class(cptr) == c('OSChromatogram','R6')))){ stop("arg cptr wrong type") }
        if(!(is_scalar_double(rt_min))){ stop("arg rt_min wrong type") }
        if(!(is_scalar_double(rt_max))){ stop("arg rt_max wrong type") }
    
        input_cptr <- r_to_py(cptr)
    
    
        private$py_obj$convertToOpenMSChromatogramFilter(chromatogram, input_cptr, rt_min, rt_max)
        invisible()
    },
    
    # C++ signature: void convertTargetedExp(TargetedExperiment & transition_exp_, LightTargetedExperiment & transition_exp)
    convertTargetedExp = function(transition_exp_, transition_exp){
    
        if(!(is.R6(transition_exp_) && class(transition_exp_)[1] == "TargetedExperiment")){ stop("arg transition_exp_ wrong type") }
        if(!(is.R6(transition_exp) && class(transition_exp)[1] == "LightTargetedExperiment")){ stop("arg transition_exp wrong type") }
    
    
        private$py_obj$convertTargetedExp(transition_exp_, transition_exp)
        invisible()
    },
    
    # C++ signature: void convertPeptideToAASequence(LightCompound & peptide, AASequence & aa_sequence)
    convertPeptideToAASequence = function(peptide, aa_sequence){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "LightCompound")){ stop("arg peptide wrong type") }
        if(!(is.R6(aa_sequence) && class(aa_sequence)[1] == "AASequence")){ stop("arg aa_sequence wrong type") }
    
    
        private$py_obj$convertPeptideToAASequence(peptide, aa_sequence)
        invisible()
    },
    
    # C++ signature: void convertTargetedCompound(Peptide pep, LightCompound & p)
    convertTargetedCompound = function(pep, p){
    
        if(!(is.R6(pep) && class(pep)[1] == "Peptide")){ stop("arg pep wrong type") }
        if(!(is.R6(p) && class(p)[1] == "LightCompound")){ stop("arg p wrong type") }
    
    
        private$py_obj$convertTargetedCompound(pep, p)
        invisible()
    }
)
) 

# R implementation of _OpenSwathHelper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwathHelper.html
OpenSwathHelper <- R6Class(classname = "OpenSwathHelper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: bool checkSwathMapAndSelectTransitions(MSExperiment & exp, TargetedExperiment & targeted_exp, TargetedExperiment & transition_exp_used, double min_upper_edge_dist)
    checkSwathMapAndSelectTransitions = function(exp, targeted_exp, transition_exp_used, min_upper_edge_dist){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
        if(!(is.R6(transition_exp_used) && class(transition_exp_used)[1] == "TargetedExperiment")){ stop("arg transition_exp_used wrong type") }
        if(!(is_scalar_double(min_upper_edge_dist))){ stop("arg min_upper_edge_dist wrong type") }
    
    
    
    
        py_ans = private$py_obj$checkSwathMapAndSelectTransitions(exp, targeted_exp, transition_exp_used, min_upper_edge_dist)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_pair[double,double] estimateRTRange(LightTargetedExperiment exp)
    estimateRTRange = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "LightTargetedExperiment")){ stop("arg exp wrong type") }
    
        py_ans = private$py_obj$estimateRTRange(exp)
        r_ans = list(py_ans[[1]], py_ans[[2]])
        return(r_ans)
    },
    
    # C++ signature: String computePrecursorId(const String & transition_group_id, int isotope)
    computePrecursorId = function(transition_group_id, isotope){
    
        if(!((is.R6(transition_group_id) && class(transition_group_id)[1]=="String") || is_scalar_character(transition_group_id))){ stop("arg transition_group_id wrong type") }
        if(!( (is_scalar_integer(isotope) || is_scalar_double(isotope)) && isotope == as.integer(isotope))){ stop("arg isotope wrong type") }
    
    
        py_ans = private$py_obj$computePrecursorId(transition_group_id, as.integer(isotope))
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _OpenSwathOSWWriter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwathOSWWriter.html
OpenSwathOSWWriter <- R6Class(classname = "OpenSwathOSWWriter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OpenSwathOSWWriter(String output_filename, String input_filename, bool ms1_scores, bool sonar, bool uis_scores)
    initialize = function(output_filename, input_filename, ms1_scores, sonar, uis_scores){
    
    if(missing(input_filename) && missing(ms1_scores) && missing(sonar) && missing(uis_scores)){
         if( "python.builtin.object" %in% class(output_filename) && class_to_wrap(output_filename) == OpenSwathOSWWriter ) { private$py_obj <- output_filename }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(output_filename) && class(output_filename)[1]=="String") || is_scalar_character(output_filename))){ stop("arg output_filename wrong type") }
        if(!((is.R6(input_filename) && class(input_filename)[1]=="String") || is_scalar_character(input_filename))){ stop("arg input_filename wrong type") }
        if(!( (is_scalar_integer(ms1_scores) || is_scalar_double(ms1_scores)) && ms1_scores == as.integer(ms1_scores))){ stop("arg ms1_scores wrong type") }
        if(!( (is_scalar_integer(sonar) || is_scalar_double(sonar)) && sonar == as.integer(sonar))){ stop("arg sonar wrong type") }
        if(!( (is_scalar_integer(uis_scores) || is_scalar_double(uis_scores)) && uis_scores == as.integer(uis_scores))){ stop("arg uis_scores wrong type") }
    
    
    
    
    
    
        private$py_obj <- Pymod$OpenSwathOSWWriter(output_filename, input_filename, as.integer(ms1_scores), as.integer(sonar), as.integer(uis_scores))
        invisible()
    }
    
    },
    
    # C++ signature: bool isActive()
    isActive = function(){
    
        py_ans = private$py_obj$isActive()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void writeHeader()
    writeHeader = function(){
    
        private$py_obj$writeHeader()
        invisible()
    },
    
    # C++ signature: String prepareLine(LightCompound & compound, LightTransition * tr, FeatureMap & output, String id_)
    prepareLine = function(compound, tr, output, id_){
    
        if(!(is.R6(compound) && class(compound)[1] == "LightCompound")){ stop("arg compound wrong type") }
        if(!(is.R6(tr) && class(tr)[1] == "LightTransition")){ stop("arg tr wrong type") }
        if(!(is.R6(output) && class(output)[1] == "FeatureMap")){ stop("arg output wrong type") }
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
    
    
    
    
        py_ans = private$py_obj$prepareLine(compound, tr, output, id_)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void writeLines(libcpp_vector[String] to_osw_output)
    writeLines = function(to_osw_output){
    
        if(!(is_list(to_osw_output) && all(sapply(to_osw_output),is_scalar_character))){ stop("arg to_osw_output wrong type") }
        v0 = r_to_py(modify_depth(to_osw_output,1,py_builtin$bytes(to_osw_output,'utf-8')))
        private$py_obj$writeLines(v0)
        invisible()
    }
)
) 

# R implementation of _OpenSwathScoring
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwathScoring.html
OpenSwathScoring <- R6Class(classname = "OpenSwathScoring",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OpenSwathScoring()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OpenSwathScoring) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OpenSwathScoring()
        invisible()
    }
    
    },
    
    # C++ signature: void initialize(double rt_normalization_factor, int add_up_spectra, double spacing_for_spectra_resampling, double drift_extra, OpenSwath_Scores_Usage su, libcpp_string spectrum_addition_method)
    initialise = function(rt_normalization_factor, add_up_spectra, spacing_for_spectra_resampling, drift_extra, su, spectrum_addition_method){
    
        if(!(is_scalar_double(rt_normalization_factor))){ stop("arg rt_normalization_factor wrong type") }
        if(!( (is_scalar_integer(add_up_spectra) || is_scalar_double(add_up_spectra)) && add_up_spectra == as.integer(add_up_spectra))){ stop("arg add_up_spectra wrong type") }
        if(!(is_scalar_double(spacing_for_spectra_resampling))){ stop("arg spacing_for_spectra_resampling wrong type") }
        if(!(is_scalar_double(drift_extra))){ stop("arg drift_extra wrong type") }
        if(!(is.R6(su) && class(su)[1] == "OpenSwath_Scores_Usage")){ stop("arg su wrong type") }
        if(!(is_scalar_character(spectrum_addition_method))){ stop("arg spectrum_addition_method wrong type") }
    
    
    
    
    
    spectrum_addition_method_5 = py_builtin$bytes(spectrum_addition_method,'utf-8')
        private$py_obj$initialize(rt_normalization_factor, as.integer(add_up_spectra), spacing_for_spectra_resampling, drift_extra, su, spectrum_addition_method)
        invisible()
    },
    
    # C++ signature: void getNormalized_library_intensities_(libcpp_vector[LightTransition] transitions, libcpp_vector[double] normalized_library_intensity)
    getNormalized_library_intensities_ = function(transitions, normalized_library_intensity){
    
        if(!(is_list(transitions) && all(sapply(transitions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "LightTransition")))){ stop("arg transitions wrong type") }
        if(!(is_list(normalized_library_intensity) && all(sapply(normalized_library_intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg normalized_library_intensity wrong type") }
        v0 <- r_to_py(transitions)
        v1 <- r_to_py(normalized_library_intensity)
        private$py_obj$getNormalized_library_intensities_(v0, v1)
        
        
        invisible()
    }
)
) 

# R implementation of _OpenSwath_Scores
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwath_Scores.html
OpenSwath_Scores <- R6Class(classname = "OpenSwath_Scores",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        elution_model_fit_score = function(elution_model_fit_score){
    
        if(!missing(elution_model_fit_score)){
            if(!(is_scalar_double(elution_model_fit_score))){ stop("arg elution_model_fit_score wrong type") }
        
        
            private$py_obj$elution_model_fit_score <- elution_model_fit_score
            } else {
        
                py_ans = private$py_obj$elution_model_fit_score
                r_result = py_ans
                return(r_result)
                }
        },
        library_corr = function(library_corr){
    
        if(!missing(library_corr)){
            if(!(is_scalar_double(library_corr))){ stop("arg library_corr wrong type") }
        
        
            private$py_obj$library_corr <- library_corr
            } else {
        
                py_ans = private$py_obj$library_corr
                r_result = py_ans
                return(r_result)
                }
        },
        library_norm_manhattan = function(library_norm_manhattan){
    
        if(!missing(library_norm_manhattan)){
            if(!(is_scalar_double(library_norm_manhattan))){ stop("arg library_norm_manhattan wrong type") }
        
        
            private$py_obj$library_norm_manhattan <- library_norm_manhattan
            } else {
        
                py_ans = private$py_obj$library_norm_manhattan
                r_result = py_ans
                return(r_result)
                }
        },
        library_rootmeansquare = function(library_rootmeansquare){
    
        if(!missing(library_rootmeansquare)){
            if(!(is_scalar_double(library_rootmeansquare))){ stop("arg library_rootmeansquare wrong type") }
        
        
            private$py_obj$library_rootmeansquare <- library_rootmeansquare
            } else {
        
                py_ans = private$py_obj$library_rootmeansquare
                r_result = py_ans
                return(r_result)
                }
        },
        library_sangle = function(library_sangle){
    
        if(!missing(library_sangle)){
            if(!(is_scalar_double(library_sangle))){ stop("arg library_sangle wrong type") }
        
        
            private$py_obj$library_sangle <- library_sangle
            } else {
        
                py_ans = private$py_obj$library_sangle
                r_result = py_ans
                return(r_result)
                }
        },
        norm_rt_score = function(norm_rt_score){
    
        if(!missing(norm_rt_score)){
            if(!(is_scalar_double(norm_rt_score))){ stop("arg norm_rt_score wrong type") }
        
        
            private$py_obj$norm_rt_score <- norm_rt_score
            } else {
        
                py_ans = private$py_obj$norm_rt_score
                r_result = py_ans
                return(r_result)
                }
        },
        isotope_correlation = function(isotope_correlation){
    
        if(!missing(isotope_correlation)){
            if(!(is_scalar_double(isotope_correlation))){ stop("arg isotope_correlation wrong type") }
        
        
            private$py_obj$isotope_correlation <- isotope_correlation
            } else {
        
                py_ans = private$py_obj$isotope_correlation
                r_result = py_ans
                return(r_result)
                }
        },
        isotope_overlap = function(isotope_overlap){
    
        if(!missing(isotope_overlap)){
            if(!(is_scalar_double(isotope_overlap))){ stop("arg isotope_overlap wrong type") }
        
        
            private$py_obj$isotope_overlap <- isotope_overlap
            } else {
        
                py_ans = private$py_obj$isotope_overlap
                r_result = py_ans
                return(r_result)
                }
        },
        massdev_score = function(massdev_score){
    
        if(!missing(massdev_score)){
            if(!(is_scalar_double(massdev_score))){ stop("arg massdev_score wrong type") }
        
        
            private$py_obj$massdev_score <- massdev_score
            } else {
        
                py_ans = private$py_obj$massdev_score
                r_result = py_ans
                return(r_result)
                }
        },
        xcorr_coelution_score = function(xcorr_coelution_score){
    
        if(!missing(xcorr_coelution_score)){
            if(!(is_scalar_double(xcorr_coelution_score))){ stop("arg xcorr_coelution_score wrong type") }
        
        
            private$py_obj$xcorr_coelution_score <- xcorr_coelution_score
            } else {
        
                py_ans = private$py_obj$xcorr_coelution_score
                r_result = py_ans
                return(r_result)
                }
        },
        xcorr_shape_score = function(xcorr_shape_score){
    
        if(!missing(xcorr_shape_score)){
            if(!(is_scalar_double(xcorr_shape_score))){ stop("arg xcorr_shape_score wrong type") }
        
        
            private$py_obj$xcorr_shape_score <- xcorr_shape_score
            } else {
        
                py_ans = private$py_obj$xcorr_shape_score
                r_result = py_ans
                return(r_result)
                }
        },
        yseries_score = function(yseries_score){
    
        if(!missing(yseries_score)){
            if(!(is_scalar_double(yseries_score))){ stop("arg yseries_score wrong type") }
        
        
            private$py_obj$yseries_score <- yseries_score
            } else {
        
                py_ans = private$py_obj$yseries_score
                r_result = py_ans
                return(r_result)
                }
        },
        bseries_score = function(bseries_score){
    
        if(!missing(bseries_score)){
            if(!(is_scalar_double(bseries_score))){ stop("arg bseries_score wrong type") }
        
        
            private$py_obj$bseries_score <- bseries_score
            } else {
        
                py_ans = private$py_obj$bseries_score
                r_result = py_ans
                return(r_result)
                }
        },
        log_sn_score = function(log_sn_score){
    
        if(!missing(log_sn_score)){
            if(!(is_scalar_double(log_sn_score))){ stop("arg log_sn_score wrong type") }
        
        
            private$py_obj$log_sn_score <- log_sn_score
            } else {
        
                py_ans = private$py_obj$log_sn_score
                r_result = py_ans
                return(r_result)
                }
        },
        weighted_coelution_score = function(weighted_coelution_score){
    
        if(!missing(weighted_coelution_score)){
            if(!(is_scalar_double(weighted_coelution_score))){ stop("arg weighted_coelution_score wrong type") }
        
        
            private$py_obj$weighted_coelution_score <- weighted_coelution_score
            } else {
        
                py_ans = private$py_obj$weighted_coelution_score
                r_result = py_ans
                return(r_result)
                }
        },
        weighted_xcorr_shape = function(weighted_xcorr_shape){
    
        if(!missing(weighted_xcorr_shape)){
            if(!(is_scalar_double(weighted_xcorr_shape))){ stop("arg weighted_xcorr_shape wrong type") }
        
        
            private$py_obj$weighted_xcorr_shape <- weighted_xcorr_shape
            } else {
        
                py_ans = private$py_obj$weighted_xcorr_shape
                r_result = py_ans
                return(r_result)
                }
        },
        weighted_massdev_score = function(weighted_massdev_score){
    
        if(!missing(weighted_massdev_score)){
            if(!(is_scalar_double(weighted_massdev_score))){ stop("arg weighted_massdev_score wrong type") }
        
        
            private$py_obj$weighted_massdev_score <- weighted_massdev_score
            } else {
        
                py_ans = private$py_obj$weighted_massdev_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_coelution_score = function(ms1_xcorr_coelution_score){
    
        if(!missing(ms1_xcorr_coelution_score)){
            if(!(is_scalar_double(ms1_xcorr_coelution_score))){ stop("arg ms1_xcorr_coelution_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_coelution_score <- ms1_xcorr_coelution_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_coelution_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_coelution_contrast_score = function(ms1_xcorr_coelution_contrast_score){
    
        if(!missing(ms1_xcorr_coelution_contrast_score)){
            if(!(is_scalar_double(ms1_xcorr_coelution_contrast_score))){ stop("arg ms1_xcorr_coelution_contrast_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_coelution_contrast_score <- ms1_xcorr_coelution_contrast_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_coelution_contrast_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_coelution_combined_score = function(ms1_xcorr_coelution_combined_score){
    
        if(!missing(ms1_xcorr_coelution_combined_score)){
            if(!(is_scalar_double(ms1_xcorr_coelution_combined_score))){ stop("arg ms1_xcorr_coelution_combined_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_coelution_combined_score <- ms1_xcorr_coelution_combined_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_coelution_combined_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_shape_score = function(ms1_xcorr_shape_score){
    
        if(!missing(ms1_xcorr_shape_score)){
            if(!(is_scalar_double(ms1_xcorr_shape_score))){ stop("arg ms1_xcorr_shape_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_shape_score <- ms1_xcorr_shape_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_shape_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_shape_contrast_score = function(ms1_xcorr_shape_contrast_score){
    
        if(!missing(ms1_xcorr_shape_contrast_score)){
            if(!(is_scalar_double(ms1_xcorr_shape_contrast_score))){ stop("arg ms1_xcorr_shape_contrast_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_shape_contrast_score <- ms1_xcorr_shape_contrast_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_shape_contrast_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_xcorr_shape_combined_score = function(ms1_xcorr_shape_combined_score){
    
        if(!missing(ms1_xcorr_shape_combined_score)){
            if(!(is_scalar_double(ms1_xcorr_shape_combined_score))){ stop("arg ms1_xcorr_shape_combined_score wrong type") }
        
        
            private$py_obj$ms1_xcorr_shape_combined_score <- ms1_xcorr_shape_combined_score
            } else {
        
                py_ans = private$py_obj$ms1_xcorr_shape_combined_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_ppm_score = function(ms1_ppm_score){
    
        if(!missing(ms1_ppm_score)){
            if(!(is_scalar_double(ms1_ppm_score))){ stop("arg ms1_ppm_score wrong type") }
        
        
            private$py_obj$ms1_ppm_score <- ms1_ppm_score
            } else {
        
                py_ans = private$py_obj$ms1_ppm_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_isotope_correlation = function(ms1_isotope_correlation){
    
        if(!missing(ms1_isotope_correlation)){
            if(!(is_scalar_double(ms1_isotope_correlation))){ stop("arg ms1_isotope_correlation wrong type") }
        
        
            private$py_obj$ms1_isotope_correlation <- ms1_isotope_correlation
            } else {
        
                py_ans = private$py_obj$ms1_isotope_correlation
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_isotope_overlap = function(ms1_isotope_overlap){
    
        if(!missing(ms1_isotope_overlap)){
            if(!(is_scalar_double(ms1_isotope_overlap))){ stop("arg ms1_isotope_overlap wrong type") }
        
        
            private$py_obj$ms1_isotope_overlap <- ms1_isotope_overlap
            } else {
        
                py_ans = private$py_obj$ms1_isotope_overlap
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_mi_score = function(ms1_mi_score){
    
        if(!missing(ms1_mi_score)){
            if(!(is_scalar_double(ms1_mi_score))){ stop("arg ms1_mi_score wrong type") }
        
        
            private$py_obj$ms1_mi_score <- ms1_mi_score
            } else {
        
                py_ans = private$py_obj$ms1_mi_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_mi_contrast_score = function(ms1_mi_contrast_score){
    
        if(!missing(ms1_mi_contrast_score)){
            if(!(is_scalar_double(ms1_mi_contrast_score))){ stop("arg ms1_mi_contrast_score wrong type") }
        
        
            private$py_obj$ms1_mi_contrast_score <- ms1_mi_contrast_score
            } else {
        
                py_ans = private$py_obj$ms1_mi_contrast_score
                r_result = py_ans
                return(r_result)
                }
        },
        ms1_mi_combined_score = function(ms1_mi_combined_score){
    
        if(!missing(ms1_mi_combined_score)){
            if(!(is_scalar_double(ms1_mi_combined_score))){ stop("arg ms1_mi_combined_score wrong type") }
        
        
            private$py_obj$ms1_mi_combined_score <- ms1_mi_combined_score
            } else {
        
                py_ans = private$py_obj$ms1_mi_combined_score
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_sn = function(sonar_sn){
    
        if(!missing(sonar_sn)){
            if(!(is_scalar_double(sonar_sn))){ stop("arg sonar_sn wrong type") }
        
        
            private$py_obj$sonar_sn <- sonar_sn
            } else {
        
                py_ans = private$py_obj$sonar_sn
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_diff = function(sonar_diff){
    
        if(!missing(sonar_diff)){
            if(!(is_scalar_double(sonar_diff))){ stop("arg sonar_diff wrong type") }
        
        
            private$py_obj$sonar_diff <- sonar_diff
            } else {
        
                py_ans = private$py_obj$sonar_diff
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_trend = function(sonar_trend){
    
        if(!missing(sonar_trend)){
            if(!(is_scalar_double(sonar_trend))){ stop("arg sonar_trend wrong type") }
        
        
            private$py_obj$sonar_trend <- sonar_trend
            } else {
        
                py_ans = private$py_obj$sonar_trend
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_rsq = function(sonar_rsq){
    
        if(!missing(sonar_rsq)){
            if(!(is_scalar_double(sonar_rsq))){ stop("arg sonar_rsq wrong type") }
        
        
            private$py_obj$sonar_rsq <- sonar_rsq
            } else {
        
                py_ans = private$py_obj$sonar_rsq
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_shape = function(sonar_shape){
    
        if(!missing(sonar_shape)){
            if(!(is_scalar_double(sonar_shape))){ stop("arg sonar_shape wrong type") }
        
        
            private$py_obj$sonar_shape <- sonar_shape
            } else {
        
                py_ans = private$py_obj$sonar_shape
                r_result = py_ans
                return(r_result)
                }
        },
        sonar_lag = function(sonar_lag){
    
        if(!missing(sonar_lag)){
            if(!(is_scalar_double(sonar_lag))){ stop("arg sonar_lag wrong type") }
        
        
            private$py_obj$sonar_lag <- sonar_lag
            } else {
        
                py_ans = private$py_obj$sonar_lag
                r_result = py_ans
                return(r_result)
                }
        },
        library_manhattan = function(library_manhattan){
    
        if(!missing(library_manhattan)){
            if(!(is_scalar_double(library_manhattan))){ stop("arg library_manhattan wrong type") }
        
        
            private$py_obj$library_manhattan <- library_manhattan
            } else {
        
                py_ans = private$py_obj$library_manhattan
                r_result = py_ans
                return(r_result)
                }
        },
        library_dotprod = function(library_dotprod){
    
        if(!missing(library_dotprod)){
            if(!(is_scalar_double(library_dotprod))){ stop("arg library_dotprod wrong type") }
        
        
            private$py_obj$library_dotprod <- library_dotprod
            } else {
        
                py_ans = private$py_obj$library_dotprod
                r_result = py_ans
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        
        
            private$py_obj$intensity <- intensity
            } else {
        
                py_ans = private$py_obj$intensity
                r_result = py_ans
                return(r_result)
                }
        },
        total_xic = function(total_xic){
    
        if(!missing(total_xic)){
            if(!(is_scalar_double(total_xic))){ stop("arg total_xic wrong type") }
        
        
            private$py_obj$total_xic <- total_xic
            } else {
        
                py_ans = private$py_obj$total_xic
                r_result = py_ans
                return(r_result)
                }
        },
        nr_peaks = function(nr_peaks){
    
        if(!missing(nr_peaks)){
            if(!(is_scalar_double(nr_peaks))){ stop("arg nr_peaks wrong type") }
        
        
            private$py_obj$nr_peaks <- nr_peaks
            } else {
        
                py_ans = private$py_obj$nr_peaks
                r_result = py_ans
                return(r_result)
                }
        },
        sn_ratio = function(sn_ratio){
    
        if(!missing(sn_ratio)){
            if(!(is_scalar_double(sn_ratio))){ stop("arg sn_ratio wrong type") }
        
        
            private$py_obj$sn_ratio <- sn_ratio
            } else {
        
                py_ans = private$py_obj$sn_ratio
                r_result = py_ans
                return(r_result)
                }
        },
        mi_score = function(mi_score){
    
        if(!missing(mi_score)){
            if(!(is_scalar_double(mi_score))){ stop("arg mi_score wrong type") }
        
        
            private$py_obj$mi_score <- mi_score
            } else {
        
                py_ans = private$py_obj$mi_score
                r_result = py_ans
                return(r_result)
                }
        },
        weighted_mi_score = function(weighted_mi_score){
    
        if(!missing(weighted_mi_score)){
            if(!(is_scalar_double(weighted_mi_score))){ stop("arg weighted_mi_score wrong type") }
        
        
            private$py_obj$weighted_mi_score <- weighted_mi_score
            } else {
        
                py_ans = private$py_obj$weighted_mi_score
                r_result = py_ans
                return(r_result)
                }
        },
        rt_difference = function(rt_difference){
    
        if(!missing(rt_difference)){
            if(!(is_scalar_double(rt_difference))){ stop("arg rt_difference wrong type") }
        
        
            private$py_obj$rt_difference <- rt_difference
            } else {
        
                py_ans = private$py_obj$rt_difference
                r_result = py_ans
                return(r_result)
                }
        },
        normalized_experimental_rt = function(normalized_experimental_rt){
    
        if(!missing(normalized_experimental_rt)){
            if(!(is_scalar_double(normalized_experimental_rt))){ stop("arg normalized_experimental_rt wrong type") }
        
        
            private$py_obj$normalized_experimental_rt <- normalized_experimental_rt
            } else {
        
                py_ans = private$py_obj$normalized_experimental_rt
                r_result = py_ans
                return(r_result)
                }
        },
        raw_rt_score = function(raw_rt_score){
    
        if(!missing(raw_rt_score)){
            if(!(is_scalar_double(raw_rt_score))){ stop("arg raw_rt_score wrong type") }
        
        
            private$py_obj$raw_rt_score <- raw_rt_score
            } else {
        
                py_ans = private$py_obj$raw_rt_score
                r_result = py_ans
                return(r_result)
                }
        },
        dotprod_score_dia = function(dotprod_score_dia){
    
        if(!missing(dotprod_score_dia)){
            if(!(is_scalar_double(dotprod_score_dia))){ stop("arg dotprod_score_dia wrong type") }
        
        
            private$py_obj$dotprod_score_dia <- dotprod_score_dia
            } else {
        
                py_ans = private$py_obj$dotprod_score_dia
                r_result = py_ans
                return(r_result)
                }
        },
        manhatt_score_dia = function(manhatt_score_dia){
    
        if(!missing(manhatt_score_dia)){
            if(!(is_scalar_double(manhatt_score_dia))){ stop("arg manhatt_score_dia wrong type") }
        
        
            private$py_obj$manhatt_score_dia <- manhatt_score_dia
            } else {
        
                py_ans = private$py_obj$manhatt_score_dia
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OpenSwath_Scores()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OpenSwath_Scores) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OpenSwath_Scores()
        invisible()
    }
    
    },
    
    # C++ signature: double get_quick_lda_score(double library_corr_, double library_norm_manhattan_, double norm_rt_score_, double xcorr_coelution_score_, double xcorr_shape_score_, double log_sn_score_)
    get_quick_lda_score = function(library_corr_, library_norm_manhattan_, norm_rt_score_, xcorr_coelution_score_, xcorr_shape_score_, log_sn_score_){
    
        if(!(is_scalar_double(library_corr_))){ stop("arg library_corr_ wrong type") }
        if(!(is_scalar_double(library_norm_manhattan_))){ stop("arg library_norm_manhattan_ wrong type") }
        if(!(is_scalar_double(norm_rt_score_))){ stop("arg norm_rt_score_ wrong type") }
        if(!(is_scalar_double(xcorr_coelution_score_))){ stop("arg xcorr_coelution_score_ wrong type") }
        if(!(is_scalar_double(xcorr_shape_score_))){ stop("arg xcorr_shape_score_ wrong type") }
        if(!(is_scalar_double(log_sn_score_))){ stop("arg log_sn_score_ wrong type") }
    
    
    
    
    
    
        py_ans = private$py_obj$get_quick_lda_score(library_corr_, library_norm_manhattan_, norm_rt_score_, xcorr_coelution_score_, xcorr_shape_score_, log_sn_score_)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calculate_lda_prescore(OpenSwath_Scores scores)
    calculate_lda_prescore = function(scores){
    
        if(!(is.R6(scores) && class(scores)[1] == "OpenSwath_Scores")){ stop("arg scores wrong type") }
    
        py_ans = private$py_obj$calculate_lda_prescore(scores)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double calculate_swath_lda_prescore(OpenSwath_Scores scores)
    calculate_swath_lda_prescore = function(scores){
    
        if(!(is.R6(scores) && class(scores)[1] == "OpenSwath_Scores")){ stop("arg scores wrong type") }
    
        py_ans = private$py_obj$calculate_swath_lda_prescore(scores)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _OpenSwath_Scores_Usage
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OpenSwath_Scores_Usage.html
OpenSwath_Scores_Usage <- R6Class(classname = "OpenSwath_Scores_Usage",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        use_coelution_score_ = function(use_coelution_score_){
    
        if(!missing(use_coelution_score_)){
            if(!( (is_scalar_integer(use_coelution_score_) || is_scalar_double(use_coelution_score_)) && use_coelution_score_ == as.integer(use_coelution_score_))){ stop("arg use_coelution_score_ wrong type") }
        
        
            private$py_obj$use_coelution_score_ <- as.integer(use_coelution_score_)
            } else {
        
                py_ans = private$py_obj$use_coelution_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_shape_score_ = function(use_shape_score_){
    
        if(!missing(use_shape_score_)){
            if(!( (is_scalar_integer(use_shape_score_) || is_scalar_double(use_shape_score_)) && use_shape_score_ == as.integer(use_shape_score_))){ stop("arg use_shape_score_ wrong type") }
        
        
            private$py_obj$use_shape_score_ <- as.integer(use_shape_score_)
            } else {
        
                py_ans = private$py_obj$use_shape_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_rt_score_ = function(use_rt_score_){
    
        if(!missing(use_rt_score_)){
            if(!( (is_scalar_integer(use_rt_score_) || is_scalar_double(use_rt_score_)) && use_rt_score_ == as.integer(use_rt_score_))){ stop("arg use_rt_score_ wrong type") }
        
        
            private$py_obj$use_rt_score_ <- as.integer(use_rt_score_)
            } else {
        
                py_ans = private$py_obj$use_rt_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_library_score_ = function(use_library_score_){
    
        if(!missing(use_library_score_)){
            if(!( (is_scalar_integer(use_library_score_) || is_scalar_double(use_library_score_)) && use_library_score_ == as.integer(use_library_score_))){ stop("arg use_library_score_ wrong type") }
        
        
            private$py_obj$use_library_score_ <- as.integer(use_library_score_)
            } else {
        
                py_ans = private$py_obj$use_library_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_elution_model_score_ = function(use_elution_model_score_){
    
        if(!missing(use_elution_model_score_)){
            if(!( (is_scalar_integer(use_elution_model_score_) || is_scalar_double(use_elution_model_score_)) && use_elution_model_score_ == as.integer(use_elution_model_score_))){ stop("arg use_elution_model_score_ wrong type") }
        
        
            private$py_obj$use_elution_model_score_ <- as.integer(use_elution_model_score_)
            } else {
        
                py_ans = private$py_obj$use_elution_model_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_intensity_score_ = function(use_intensity_score_){
    
        if(!missing(use_intensity_score_)){
            if(!( (is_scalar_integer(use_intensity_score_) || is_scalar_double(use_intensity_score_)) && use_intensity_score_ == as.integer(use_intensity_score_))){ stop("arg use_intensity_score_ wrong type") }
        
        
            private$py_obj$use_intensity_score_ <- as.integer(use_intensity_score_)
            } else {
        
                py_ans = private$py_obj$use_intensity_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_total_xic_score_ = function(use_total_xic_score_){
    
        if(!missing(use_total_xic_score_)){
            if(!( (is_scalar_integer(use_total_xic_score_) || is_scalar_double(use_total_xic_score_)) && use_total_xic_score_ == as.integer(use_total_xic_score_))){ stop("arg use_total_xic_score_ wrong type") }
        
        
            private$py_obj$use_total_xic_score_ <- as.integer(use_total_xic_score_)
            } else {
        
                py_ans = private$py_obj$use_total_xic_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_total_mi_score_ = function(use_total_mi_score_){
    
        if(!missing(use_total_mi_score_)){
            if(!( (is_scalar_integer(use_total_mi_score_) || is_scalar_double(use_total_mi_score_)) && use_total_mi_score_ == as.integer(use_total_mi_score_))){ stop("arg use_total_mi_score_ wrong type") }
        
        
            private$py_obj$use_total_mi_score_ <- as.integer(use_total_mi_score_)
            } else {
        
                py_ans = private$py_obj$use_total_mi_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_nr_peaks_score_ = function(use_nr_peaks_score_){
    
        if(!missing(use_nr_peaks_score_)){
            if(!( (is_scalar_integer(use_nr_peaks_score_) || is_scalar_double(use_nr_peaks_score_)) && use_nr_peaks_score_ == as.integer(use_nr_peaks_score_))){ stop("arg use_nr_peaks_score_ wrong type") }
        
        
            private$py_obj$use_nr_peaks_score_ <- as.integer(use_nr_peaks_score_)
            } else {
        
                py_ans = private$py_obj$use_nr_peaks_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_sn_score_ = function(use_sn_score_){
    
        if(!missing(use_sn_score_)){
            if(!( (is_scalar_integer(use_sn_score_) || is_scalar_double(use_sn_score_)) && use_sn_score_ == as.integer(use_sn_score_))){ stop("arg use_sn_score_ wrong type") }
        
        
            private$py_obj$use_sn_score_ <- as.integer(use_sn_score_)
            } else {
        
                py_ans = private$py_obj$use_sn_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_mi_score_ = function(use_mi_score_){
    
        if(!missing(use_mi_score_)){
            if(!( (is_scalar_integer(use_mi_score_) || is_scalar_double(use_mi_score_)) && use_mi_score_ == as.integer(use_mi_score_))){ stop("arg use_mi_score_ wrong type") }
        
        
            private$py_obj$use_mi_score_ <- as.integer(use_mi_score_)
            } else {
        
                py_ans = private$py_obj$use_mi_score_
                r_result = py_ans
                return(r_result)
                }
        },
        use_dia_scores_ = function(use_dia_scores_){
    
        if(!missing(use_dia_scores_)){
            if(!( (is_scalar_integer(use_dia_scores_) || is_scalar_double(use_dia_scores_)) && use_dia_scores_ == as.integer(use_dia_scores_))){ stop("arg use_dia_scores_ wrong type") }
        
        
            private$py_obj$use_dia_scores_ <- as.integer(use_dia_scores_)
            } else {
        
                py_ans = private$py_obj$use_dia_scores_
                r_result = py_ans
                return(r_result)
                }
        },
        use_sonar_scores = function(use_sonar_scores){
    
        if(!missing(use_sonar_scores)){
            if(!( (is_scalar_integer(use_sonar_scores) || is_scalar_double(use_sonar_scores)) && use_sonar_scores == as.integer(use_sonar_scores))){ stop("arg use_sonar_scores wrong type") }
        
        
            private$py_obj$use_sonar_scores <- as.integer(use_sonar_scores)
            } else {
        
                py_ans = private$py_obj$use_sonar_scores
                r_result = py_ans
                return(r_result)
                }
        },
        use_ms1_correlation = function(use_ms1_correlation){
    
        if(!missing(use_ms1_correlation)){
            if(!( (is_scalar_integer(use_ms1_correlation) || is_scalar_double(use_ms1_correlation)) && use_ms1_correlation == as.integer(use_ms1_correlation))){ stop("arg use_ms1_correlation wrong type") }
        
        
            private$py_obj$use_ms1_correlation <- as.integer(use_ms1_correlation)
            } else {
        
                py_ans = private$py_obj$use_ms1_correlation
                r_result = py_ans
                return(r_result)
                }
        },
        use_ms1_fullscan = function(use_ms1_fullscan){
    
        if(!missing(use_ms1_fullscan)){
            if(!( (is_scalar_integer(use_ms1_fullscan) || is_scalar_double(use_ms1_fullscan)) && use_ms1_fullscan == as.integer(use_ms1_fullscan))){ stop("arg use_ms1_fullscan wrong type") }
        
        
            private$py_obj$use_ms1_fullscan <- as.integer(use_ms1_fullscan)
            } else {
        
                py_ans = private$py_obj$use_ms1_fullscan
                r_result = py_ans
                return(r_result)
                }
        },
        use_ms1_mi = function(use_ms1_mi){
    
        if(!missing(use_ms1_mi)){
            if(!( (is_scalar_integer(use_ms1_mi) || is_scalar_double(use_ms1_mi)) && use_ms1_mi == as.integer(use_ms1_mi))){ stop("arg use_ms1_mi wrong type") }
        
        
            private$py_obj$use_ms1_mi <- as.integer(use_ms1_mi)
            } else {
        
                py_ans = private$py_obj$use_ms1_mi
                r_result = py_ans
                return(r_result)
                }
        },
        use_uis_scores = function(use_uis_scores){
    
        if(!missing(use_uis_scores)){
            if(!( (is_scalar_integer(use_uis_scores) || is_scalar_double(use_uis_scores)) && use_uis_scores == as.integer(use_uis_scores))){ stop("arg use_uis_scores wrong type") }
        
        
            private$py_obj$use_uis_scores <- as.integer(use_uis_scores)
            } else {
        
                py_ans = private$py_obj$use_uis_scores
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OpenSwath_Scores_Usage()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == OpenSwath_Scores_Usage) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$OpenSwath_Scores_Usage()
        invisible()
    }
    
    }
)
) 

# R implementation of _OptimizationFunctions_PenaltyFactors
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OptimizationFunctions_PenaltyFactors.html
OptimizationFunctions_PenaltyFactors <- R6Class(classname = "OptimizationFunctions_PenaltyFactors",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        pos = function(pos){
    
        if(!missing(pos)){
            if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
        
        
            private$py_obj$pos <- pos
            } else {
        
                py_ans = private$py_obj$pos
                r_result = py_ans
                return(r_result)
                }
        },
        lWidth = function(lWidth){
    
        if(!missing(lWidth)){
            if(!(is_scalar_double(lWidth))){ stop("arg lWidth wrong type") }
        
        
            private$py_obj$lWidth <- lWidth
            } else {
        
                py_ans = private$py_obj$lWidth
                r_result = py_ans
                return(r_result)
                }
        },
        rWidth = function(rWidth){
    
        if(!missing(rWidth)){
            if(!(is_scalar_double(rWidth))){ stop("arg rWidth wrong type") }
        
        
            private$py_obj$rWidth <- rWidth
            } else {
        
                py_ans = private$py_obj$rWidth
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OptimizationFunctions_PenaltyFactors()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OptimizationFunctions_PenaltyFactors()
        invisible()
    
    
    },
    
    # C++ signature: void OptimizationFunctions_PenaltyFactors(OptimizationFunctions_PenaltyFactors)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OptimizationFunctions_PenaltyFactors")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OptimizationFunctions_PenaltyFactors(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OptimizationFunctions_PenaltyFactors()
    # C++ signature: void OptimizationFunctions_PenaltyFactors(OptimizationFunctions_PenaltyFactors)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OptimizationFunctions_PenaltyFactors")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OptimizationFunctions_PenaltyFactors" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OptimizePeakDeconvolution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OptimizePeakDeconvolution.html
OptimizePeakDeconvolution <- R6Class(classname = "OptimizePeakDeconvolution",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OptimizePeakDeconvolution()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OptimizePeakDeconvolution()
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePeakDeconvolution(OptimizePeakDeconvolution)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OptimizePeakDeconvolution")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OptimizePeakDeconvolution(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePeakDeconvolution()
    # C++ signature: void OptimizePeakDeconvolution(OptimizePeakDeconvolution)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OptimizePeakDeconvolution")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OptimizePeakDeconvolution" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: PenaltyFactorsIntensity getPenalties()
    getPenalties = function(){
    
        py_ans = private$py_obj$getPenalties()
        r_ans = PenaltyFactorsIntensity$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPenalties(PenaltyFactorsIntensity & penalties)
    setPenalties = function(penalties){
    
        if(!(is.R6(penalties) && class(penalties)[1] == "PenaltyFactorsIntensity")){ stop("arg penalties wrong type") }
    
        private$py_obj$setPenalties(penalties)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: bool optimize(libcpp_vector[PeakShape] & peaks, OptimizePeakDeconvolution_Data & data)
    optimize = function(peaks, data){
    
        if(!(is_list(peaks) && all(sapply(peaks,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeakShape")))){ stop("arg peaks wrong type") }
        if(!(is.R6(data) && class(data)[1] == "OptimizePeakDeconvolution_Data")){ stop("arg data wrong type") }
        v0 <- r_to_py(peaks)
    
        py_ans = private$py_obj$optimize(v0, data)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(peaks <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: size_t getNumberOfPeaks_(int charge, libcpp_vector[PeakShape] & temp_shapes, OptimizePeakDeconvolution_Data & data)
    getNumberOfPeaks_ = function(charge, temp_shapes, data){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!(is_list(temp_shapes) && all(sapply(temp_shapes,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeakShape")))){ stop("arg temp_shapes wrong type") }
        if(!(is.R6(data) && class(data)[1] == "OptimizePeakDeconvolution_Data")){ stop("arg data wrong type") }
    
        v1 <- r_to_py(temp_shapes)
    
        py_ans = private$py_obj$getNumberOfPeaks_(as.integer(charge), v1, data)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(temp_shapes <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _OptimizePeakDeconvolution_Data
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OptimizePeakDeconvolution_Data.html
OptimizePeakDeconvolution_Data <- R6Class(classname = "OptimizePeakDeconvolution_Data",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        peaks = function(peaks){
    
        if(!missing(peaks)){
            if(!(is_list(peaks) && all(sapply(peaks,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeakShape")))){ stop("arg peaks wrong type") }
        
            v0 <- r_to_py(peaks)
            private$py_obj$peaks <- v0
            } else {
            
                py_ans = private$py_obj$peaks
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        positions = function(positions){
    
        if(!missing(positions)){
            if(!(is_list(positions) && all(sapply(positions,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg positions wrong type") }
        
            v0 <- r_to_py(positions)
            private$py_obj$positions <- v0
            } else {
            
                py_ans = private$py_obj$positions
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        signal = function(signal){
    
        if(!missing(signal)){
            if(!(is_list(signal) && all(sapply(signal,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg signal wrong type") }
        
            v0 <- r_to_py(signal)
            private$py_obj$signal <- v0
            } else {
            
                py_ans = private$py_obj$signal
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        penalties = function(penalties){
    
        if(!missing(penalties)){
            if(!(is.R6(penalties) && class(penalties)[1] == "PenaltyFactorsIntensity")){ stop("arg penalties wrong type") }
        
        
            private$py_obj$penalties <- penalties
            } else {
        
                py_ans = private$py_obj$penalties
            r_result = PenaltyFactorsIntensity$new(py_ans)
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void OptimizePeakDeconvolution_Data()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OptimizePeakDeconvolution_Data()
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePeakDeconvolution_Data(OptimizePeakDeconvolution_Data)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "OptimizePeakDeconvolution_Data")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$OptimizePeakDeconvolution_Data(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePeakDeconvolution_Data()
    # C++ signature: void OptimizePeakDeconvolution_Data(OptimizePeakDeconvolution_Data)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OptimizePeakDeconvolution_Data")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OptimizePeakDeconvolution_Data" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _OptimizePick
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OptimizePick.html
OptimizePick <- R6Class(classname = "OptimizePick",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void OptimizePick()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$OptimizePick()
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePick(OptimizationFunctions_PenaltyFactors penalties_, int max_iteration_)
    init_1 = function(penalties_, max_iteration_){
    
        if(!(is.R6(penalties_) && class(penalties_)[1] == "OptimizationFunctions_PenaltyFactors")){ stop("arg penalties_ wrong type") }
        if(!( (is_scalar_integer(max_iteration_) || is_scalar_double(max_iteration_)) && max_iteration_ == as.integer(max_iteration_))){ stop("arg max_iteration_ wrong type") }
    
    
    
        private$py_obj <- Pymod$OptimizePick(penalties_, as.integer(max_iteration_))
        invisible()
    
    
    },
    
    # C++ signature: void OptimizePick()
    # C++ signature: void OptimizePick(OptimizationFunctions_PenaltyFactors penalties_, int max_iteration_)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "OptimizationFunctions_PenaltyFactors") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "OptimizePick" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: OptimizationFunctions_PenaltyFactors getPenalties()
    getPenalties = function(){
    
        py_ans = private$py_obj$getPenalties()
        r_ans = OptimizationFunctions_PenaltyFactors$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPenalties(OptimizationFunctions_PenaltyFactors penalties)
    setPenalties = function(penalties){
    
        if(!(is.R6(penalties) && class(penalties)[1] == "OptimizationFunctions_PenaltyFactors")){ stop("arg penalties wrong type") }
    
        private$py_obj$setPenalties(penalties)
        invisible()
    },
    
    # C++ signature: unsigned int getNumberIterations()
    getNumberIterations = function(){
    
        py_ans = private$py_obj$getNumberIterations()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNumberIterations(int max_iteration)
    setNumberIterations = function(max_iteration){
    
        if(!( (is_scalar_integer(max_iteration) || is_scalar_double(max_iteration)) && max_iteration == as.integer(max_iteration))){ stop("arg max_iteration wrong type") }
    
        private$py_obj$setNumberIterations(as.integer(max_iteration))
        invisible()
    }
)
) 

# R implementation of _OptimizePick_Data
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1OptimizePick_Data.html
OptimizePick_Data <- R6Class(classname = "OptimizePick_Data",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        positions = function(positions){
    
        if(!missing(positions)){
            if(!(is_list(positions) && all(sapply(positions,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg positions wrong type") }
        
            v0 <- r_to_py(positions)
            private$py_obj$positions <- v0
            } else {
            
                py_ans = private$py_obj$positions
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        signal = function(signal){
    
        if(!missing(signal)){
            if(!(is_list(signal) && all(sapply(signal,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg signal wrong type") }
        
            v0 <- r_to_py(signal)
            private$py_obj$signal <- v0
            } else {
            
                py_ans = private$py_obj$signal
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    )
) 

# R implementation of _PI_PeakArea
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PI_PeakArea.html
PI_PeakArea <- R6Class(classname = "PI_PeakArea",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        area = function(area){
    
        if(!missing(area)){
            if(!(is_scalar_double(area))){ stop("arg area wrong type") }
        
        
            private$py_obj$area <- area
            } else {
        
                py_ans = private$py_obj$area
                r_result = py_ans
                return(r_result)
                }
        },
        height = function(height){
    
        if(!missing(height)){
            if(!(is_scalar_double(height))){ stop("arg height wrong type") }
        
        
            private$py_obj$height <- height
            } else {
        
                py_ans = private$py_obj$height
                r_result = py_ans
                return(r_result)
                }
        },
        apex_pos = function(apex_pos){
    
        if(!missing(apex_pos)){
            if(!(is_scalar_double(apex_pos))){ stop("arg apex_pos wrong type") }
        
        
            private$py_obj$apex_pos <- apex_pos
            } else {
        
                py_ans = private$py_obj$apex_pos
                r_result = py_ans
                return(r_result)
                }
        },
        hull_points = function(hull_points){
    
        if(!missing(hull_points)){
            if(!(is.matrix(hull_points) && NROW(hull_points) == 2 && is_double(hull_points[1,]) && is_double(hull_points[2,]))){ stop("arg hull_points wrong type") }
        
            dp_0 <- r_to_py(hull_points)
            private$py_obj$hull_points <- dp_0
            } else {
        
                py_ans = private$py_obj$hull_points
            r_result <- py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PI_PeakArea()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PI_PeakArea()
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakArea(PI_PeakArea)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PI_PeakArea")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PI_PeakArea(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakArea()
    # C++ signature: void PI_PeakArea(PI_PeakArea)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PI_PeakArea")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PI_PeakArea" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _PI_PeakBackground
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PI_PeakBackground.html
PI_PeakBackground <- R6Class(classname = "PI_PeakBackground",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        area = function(area){
    
        if(!missing(area)){
            if(!(is_scalar_double(area))){ stop("arg area wrong type") }
        
        
            private$py_obj$area <- area
            } else {
        
                py_ans = private$py_obj$area
                r_result = py_ans
                return(r_result)
                }
        },
        height = function(height){
    
        if(!missing(height)){
            if(!(is_scalar_double(height))){ stop("arg height wrong type") }
        
        
            private$py_obj$height <- height
            } else {
        
                py_ans = private$py_obj$height
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PI_PeakBackground()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PI_PeakBackground()
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakBackground(PI_PeakBackground)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PI_PeakBackground")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PI_PeakBackground(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakBackground()
    # C++ signature: void PI_PeakBackground(PI_PeakBackground)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PI_PeakBackground")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PI_PeakBackground" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _PI_PeakShapeMetrics
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PI_PeakShapeMetrics.html
PI_PeakShapeMetrics <- R6Class(classname = "PI_PeakShapeMetrics",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        width_at_5 = function(width_at_5){
    
        if(!missing(width_at_5)){
            if(!(is_scalar_double(width_at_5))){ stop("arg width_at_5 wrong type") }
        
        
            private$py_obj$width_at_5 <- width_at_5
            } else {
        
                py_ans = private$py_obj$width_at_5
                r_result = py_ans
                return(r_result)
                }
        },
        width_at_10 = function(width_at_10){
    
        if(!missing(width_at_10)){
            if(!(is_scalar_double(width_at_10))){ stop("arg width_at_10 wrong type") }
        
        
            private$py_obj$width_at_10 <- width_at_10
            } else {
        
                py_ans = private$py_obj$width_at_10
                r_result = py_ans
                return(r_result)
                }
        },
        width_at_50 = function(width_at_50){
    
        if(!missing(width_at_50)){
            if(!(is_scalar_double(width_at_50))){ stop("arg width_at_50 wrong type") }
        
        
            private$py_obj$width_at_50 <- width_at_50
            } else {
        
                py_ans = private$py_obj$width_at_50
                r_result = py_ans
                return(r_result)
                }
        },
        start_position_at_5 = function(start_position_at_5){
    
        if(!missing(start_position_at_5)){
            if(!(is_scalar_double(start_position_at_5))){ stop("arg start_position_at_5 wrong type") }
        
        
            private$py_obj$start_position_at_5 <- start_position_at_5
            } else {
        
                py_ans = private$py_obj$start_position_at_5
                r_result = py_ans
                return(r_result)
                }
        },
        start_position_at_10 = function(start_position_at_10){
    
        if(!missing(start_position_at_10)){
            if(!(is_scalar_double(start_position_at_10))){ stop("arg start_position_at_10 wrong type") }
        
        
            private$py_obj$start_position_at_10 <- start_position_at_10
            } else {
        
                py_ans = private$py_obj$start_position_at_10
                r_result = py_ans
                return(r_result)
                }
        },
        start_position_at_50 = function(start_position_at_50){
    
        if(!missing(start_position_at_50)){
            if(!(is_scalar_double(start_position_at_50))){ stop("arg start_position_at_50 wrong type") }
        
        
            private$py_obj$start_position_at_50 <- start_position_at_50
            } else {
        
                py_ans = private$py_obj$start_position_at_50
                r_result = py_ans
                return(r_result)
                }
        },
        end_position_at_5 = function(end_position_at_5){
    
        if(!missing(end_position_at_5)){
            if(!(is_scalar_double(end_position_at_5))){ stop("arg end_position_at_5 wrong type") }
        
        
            private$py_obj$end_position_at_5 <- end_position_at_5
            } else {
        
                py_ans = private$py_obj$end_position_at_5
                r_result = py_ans
                return(r_result)
                }
        },
        end_position_at_10 = function(end_position_at_10){
    
        if(!missing(end_position_at_10)){
            if(!(is_scalar_double(end_position_at_10))){ stop("arg end_position_at_10 wrong type") }
        
        
            private$py_obj$end_position_at_10 <- end_position_at_10
            } else {
        
                py_ans = private$py_obj$end_position_at_10
                r_result = py_ans
                return(r_result)
                }
        },
        end_position_at_50 = function(end_position_at_50){
    
        if(!missing(end_position_at_50)){
            if(!(is_scalar_double(end_position_at_50))){ stop("arg end_position_at_50 wrong type") }
        
        
            private$py_obj$end_position_at_50 <- end_position_at_50
            } else {
        
                py_ans = private$py_obj$end_position_at_50
                r_result = py_ans
                return(r_result)
                }
        },
        total_width = function(total_width){
    
        if(!missing(total_width)){
            if(!(is_scalar_double(total_width))){ stop("arg total_width wrong type") }
        
        
            private$py_obj$total_width <- total_width
            } else {
        
                py_ans = private$py_obj$total_width
                r_result = py_ans
                return(r_result)
                }
        },
        tailing_factor = function(tailing_factor){
    
        if(!missing(tailing_factor)){
            if(!(is_scalar_double(tailing_factor))){ stop("arg tailing_factor wrong type") }
        
        
            private$py_obj$tailing_factor <- tailing_factor
            } else {
        
                py_ans = private$py_obj$tailing_factor
                r_result = py_ans
                return(r_result)
                }
        },
        asymmetry_factor = function(asymmetry_factor){
    
        if(!missing(asymmetry_factor)){
            if(!(is_scalar_double(asymmetry_factor))){ stop("arg asymmetry_factor wrong type") }
        
        
            private$py_obj$asymmetry_factor <- asymmetry_factor
            } else {
        
                py_ans = private$py_obj$asymmetry_factor
                r_result = py_ans
                return(r_result)
                }
        },
        slope_of_baseline = function(slope_of_baseline){
    
        if(!missing(slope_of_baseline)){
            if(!(is_scalar_double(slope_of_baseline))){ stop("arg slope_of_baseline wrong type") }
        
        
            private$py_obj$slope_of_baseline <- slope_of_baseline
            } else {
        
                py_ans = private$py_obj$slope_of_baseline
                r_result = py_ans
                return(r_result)
                }
        },
        baseline_delta_2_height = function(baseline_delta_2_height){
    
        if(!missing(baseline_delta_2_height)){
            if(!(is_scalar_double(baseline_delta_2_height))){ stop("arg baseline_delta_2_height wrong type") }
        
        
            private$py_obj$baseline_delta_2_height <- baseline_delta_2_height
            } else {
        
                py_ans = private$py_obj$baseline_delta_2_height
                r_result = py_ans
                return(r_result)
                }
        },
        points_across_baseline = function(points_across_baseline){
    
        if(!missing(points_across_baseline)){
            if(!( (is_scalar_integer(points_across_baseline) || is_scalar_double(points_across_baseline)) && points_across_baseline == as.integer(points_across_baseline))){ stop("arg points_across_baseline wrong type") }
        
        
            private$py_obj$points_across_baseline <- as.integer(points_across_baseline)
            } else {
        
                py_ans = private$py_obj$points_across_baseline
                r_result = py_ans
                return(r_result)
                }
        },
        points_across_half_height = function(points_across_half_height){
    
        if(!missing(points_across_half_height)){
            if(!( (is_scalar_integer(points_across_half_height) || is_scalar_double(points_across_half_height)) && points_across_half_height == as.integer(points_across_half_height))){ stop("arg points_across_half_height wrong type") }
        
        
            private$py_obj$points_across_half_height <- as.integer(points_across_half_height)
            } else {
        
                py_ans = private$py_obj$points_across_half_height
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PI_PeakShapeMetrics()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PI_PeakShapeMetrics()
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakShapeMetrics(PI_PeakShapeMetrics)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PI_PeakShapeMetrics")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PI_PeakShapeMetrics(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PI_PeakShapeMetrics()
    # C++ signature: void PI_PeakShapeMetrics(PI_PeakShapeMetrics)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PI_PeakShapeMetrics")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PI_PeakShapeMetrics" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _PSLPFormulation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PSLPFormulation.html
PSLPFormulation <- R6Class(classname = "PSLPFormulation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PSLPFormulation()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PSLPFormulation) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PSLPFormulation()
        invisible()
    }
    
    },
    
    # C++ signature: void createAndSolveILPForKnownLCMSMapFeatureBased(FeatureMap & features, MSExperiment & experiment, libcpp_vector[IndexTriple] & variable_indices, libcpp_vector[libcpp_vector[libcpp_pair[size_t,size_t]]] & mass_ranges, libcpp_set[int] & charges_set, unsigned int ms2_spectra_per_rt_bin, libcpp_vector[int] & solution_indices)
    createAndSolveILPForKnownLCMSMapFeatureBased = function(features, experiment, variable_indices, mass_ranges, charges_set, ms2_spectra_per_rt_bin, solution_indices){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!(is_list(variable_indices) && all(sapply(variable_indices,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IndexTriple")))){ stop("arg variable_indices wrong type") }
        if(!(is_list(mass_ranges) && all(sapply(mass_ranges,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is_list(elemt_rec_rec) && length(elemt_rec_rec) == 2 &&  (is_scalar_integer(elemt_rec_rec[[1]]) || is_scalar_double(elemt_rec_rec[[1]])) && elemt_rec_rec[[1]] == as.integer(elemt_rec_rec[[1]]) &&  (is_scalar_integer(elemt_rec_rec[[2]]) || is_scalar_double(elemt_rec_rec[[2]])) && elemt_rec_rec[[2]] == as.integer(elemt_rec_rec[[2]]))))))){ stop("arg mass_ranges wrong type") }
        if(!(is_list(charges_set) && all(sapply(charges_set,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(charges_set)))){ stop("arg charges_set wrong type") }
        if(!( (is_scalar_integer(ms2_spectra_per_rt_bin) || is_scalar_double(ms2_spectra_per_rt_bin)) && ms2_spectra_per_rt_bin == as.integer(ms2_spectra_per_rt_bin))){ stop("arg ms2_spectra_per_rt_bin wrong type") }
        if(!(is_list(solution_indices) && all(sapply(solution_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg solution_indices wrong type") }
    
    
        v2 <- r_to_py(variable_indices)
        v3 <- r_to_py(mass_ranges)
        py$v4 <- charges_set
        py_run_string("v4 = [int(t) for t in v4];v4 = set(v4)")
    
        v6 <- r_to_py(modify_depth(solution_indices,1,as.integer))
        private$py_obj$createAndSolveILPForKnownLCMSMapFeatureBased(features, experiment, v2, v3, py$v4, as.integer(ms2_spectra_per_rt_bin), v6)
        byref_6 <- map_depth(py_to_r(v6),0,as.list)
        byref_4 <- as.list(py_eval("list(v4)"))
        py_run_string("del v4; gc.collect()")
        byref_3 <- py_to_r(v3)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(variable_indices <- byref_2))
        eval.parent(substitute(mass_ranges <- byref_3))
        eval.parent(substitute(charges_set <- byref_4))
        eval.parent(substitute(solution_indices <- byref_6))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void createAndSolveILPForInclusionListCreation(PrecursorIonSelectionPreprocessing & preprocessing, unsigned int ms2_spectra_per_rt_bin, unsigned int max_list_size, FeatureMap & precursors, bool solve_ILP)
    createAndSolveILPForInclusionListCreation = function(preprocessing, ms2_spectra_per_rt_bin, max_list_size, precursors, solve_ILP){
    
        if(!(is.R6(preprocessing) && class(preprocessing)[1] == "PrecursorIonSelectionPreprocessing")){ stop("arg preprocessing wrong type") }
        if(!( (is_scalar_integer(ms2_spectra_per_rt_bin) || is_scalar_double(ms2_spectra_per_rt_bin)) && ms2_spectra_per_rt_bin == as.integer(ms2_spectra_per_rt_bin))){ stop("arg ms2_spectra_per_rt_bin wrong type") }
        if(!( (is_scalar_integer(max_list_size) || is_scalar_double(max_list_size)) && max_list_size == as.integer(max_list_size))){ stop("arg max_list_size wrong type") }
        if(!(is.R6(precursors) && class(precursors)[1] == "FeatureMap")){ stop("arg precursors wrong type") }
        if(!( (is_scalar_integer(solve_ILP) || is_scalar_double(solve_ILP)) && solve_ILP == as.integer(solve_ILP))){ stop("arg solve_ILP wrong type") }
    
    
    
    
    
        private$py_obj$createAndSolveILPForInclusionListCreation(preprocessing, as.integer(ms2_spectra_per_rt_bin), as.integer(max_list_size), precursors, as.integer(solve_ILP))
        invisible()
    },
    
    # C++ signature: void updateStepSizeConstraint(size_t iteration, unsigned int step_size)
    updateStepSizeConstraint = function(iteration, step_size){
    
        if(!( (is_scalar_integer(iteration) || is_scalar_double(iteration)) && iteration == as.integer(iteration))){ stop("arg iteration wrong type") }
        if(!( (is_scalar_integer(step_size) || is_scalar_double(step_size)) && step_size == as.integer(step_size))){ stop("arg step_size wrong type") }
    
    
        private$py_obj$updateStepSizeConstraint(as.integer(iteration), as.integer(step_size))
        invisible()
    },
    
    # C++ signature: void updateRTConstraintsForSequentialILP(size_t & rt_index, unsigned int ms2_spectra_per_rt_bin, size_t max_rt_index)
    updateRTConstraintsForSequentialILP = function(rt_index, ms2_spectra_per_rt_bin, max_rt_index){
    
        if(!( (is_scalar_integer(rt_index) || is_scalar_double(rt_index)) && rt_index == as.integer(rt_index))){ stop("arg rt_index wrong type") }
        if(!( (is_scalar_integer(ms2_spectra_per_rt_bin) || is_scalar_double(ms2_spectra_per_rt_bin)) && ms2_spectra_per_rt_bin == as.integer(ms2_spectra_per_rt_bin))){ stop("arg ms2_spectra_per_rt_bin wrong type") }
        if(!( (is_scalar_integer(max_rt_index) || is_scalar_double(max_rt_index)) && max_rt_index == as.integer(max_rt_index))){ stop("arg max_rt_index wrong type") }
    
    
    
        private$py_obj$updateRTConstraintsForSequentialILP(as.integer(rt_index), as.integer(ms2_spectra_per_rt_bin), as.integer(max_rt_index))
        invisible()
    },
    
    # C++ signature: void solveILP(libcpp_vector[int] & solution_indices)
    solveILP = function(solution_indices){
    
        if(!(is_list(solution_indices) && all(sapply(solution_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg solution_indices wrong type") }
        v0 <- r_to_py(modify_depth(solution_indices,1,as.integer))
        private$py_obj$solveILP(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(solution_indices <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setLPSolver(SOLVER solver)
    setLPSolver = function(solver){
    
        if(!(solver %in% c(0))){ stop("arg solver wrong type") }
    
        private$py_obj$setLPSolver(as.integer(solver))
        invisible()
    },
    
    # C++ signature: SOLVER getLPSolver()
    getLPSolver = function(){
    
        py_ans = private$py_obj$getLPSolver()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PSProteinInference
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PSProteinInference.html
PSProteinInference <- R6Class(classname = "PSProteinInference",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PSProteinInference()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PSProteinInference) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PSProteinInference()
        invisible()
    }
    
    },
    
    # C++ signature: size_t findMinimalProteinList(libcpp_vector[PeptideIdentification] & peptide_ids)
    findMinimalProteinList = function(peptide_ids){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        v0 <- r_to_py(peptide_ids)
        py_ans = private$py_obj$findMinimalProteinList(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void calculateProteinProbabilities(libcpp_vector[PeptideIdentification] & ids)
    calculateProteinProbabilities = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg ids wrong type") }
        v0 <- r_to_py(ids)
        private$py_obj$calculateProteinProbabilities(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getProteinProbability(const String & acc)
    getProteinProbability = function(acc){
    
        if(!((is.R6(acc) && class(acc)[1]=="String") || is_scalar_character(acc))){ stop("arg acc wrong type") }
    
        py_ans = private$py_obj$getProteinProbability(acc)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isProteinInMinimalList(const String & acc)
    isProteinInMinimalList = function(acc){
    
        if(!((is.R6(acc) && class(acc)[1]=="String") || is_scalar_character(acc))){ stop("arg acc wrong type") }
    
        py_ans = private$py_obj$isProteinInMinimalList(acc)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getNumberOfProtIds(double protein_id_threshold)
    getNumberOfProtIds = function(protein_id_threshold){
    
        if(!(is_scalar_double(protein_id_threshold))){ stop("arg protein_id_threshold wrong type") }
    
        py_ans = private$py_obj$getNumberOfProtIds(protein_id_threshold)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSolver(SOLVER solver)
    setSolver = function(solver){
    
        if(!(solver %in% c(0))){ stop("arg solver wrong type") }
    
        private$py_obj$setSolver(as.integer(solver))
        invisible()
    },
    
    # C++ signature: SOLVER getSolver()
    getSolver = function(){
    
        py_ans = private$py_obj$getSolver()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _PScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PScore.html
PScore <- R6Class(classname = "PScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PScore()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PScore) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PScore()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[size_t] calculateIntensityRankInMZWindow(libcpp_vector[double] & mz, libcpp_vector[double] & intensities, double mz_window)
    calculateIntensityRankInMZWindow = function(mz, intensities, mz_window){
    
        if(!(is_list(mz) && all(sapply(mz,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz wrong type") }
        if(!(is_list(intensities) && all(sapply(intensities,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensities wrong type") }
        if(!(is_scalar_double(mz_window))){ stop("arg mz_window wrong type") }
        v0 <- r_to_py(mz)
        v1 <- r_to_py(intensities)
    
        py_ans = private$py_obj$calculateIntensityRankInMZWindow(v0, v1, mz_window)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans <- modify_depth(py_ans,0,as.list)
    
        tryCatch({
        eval.parent(substitute(mz <- byref_0))
        eval.parent(substitute(intensities <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[libcpp_vector[size_t]] calculateRankMap(MSExperiment & peak_map, double mz_window)
    calculateRankMap = function(peak_map, mz_window){
    
        if(!(is.R6(peak_map) && class(peak_map)[1] == "MSExperiment")){ stop("arg peak_map wrong type") }
        if(!(is_scalar_double(mz_window))){ stop("arg mz_window wrong type") }
    
    
        py_ans = private$py_obj$calculateRankMap(peak_map, mz_window)
        r_ans <- modify_depth(py_ans,1,as.list)
        return(r_ans)
    },
    
    # C++ signature: libcpp_map[size_t,MSSpectrum] calculatePeakLevelSpectra(MSSpectrum & spec, libcpp_vector[size_t] & ranks, size_t min_level, size_t max_level)
    calculatePeakLevelSpectra = function(spec, ranks, min_level, max_level){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is_list(ranks) && all(sapply(ranks,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg ranks wrong type") }
        if(!( (is_scalar_integer(min_level) || is_scalar_double(min_level)) && min_level == as.integer(min_level))){ stop("arg min_level wrong type") }
        if(!( (is_scalar_integer(max_level) || is_scalar_double(max_level)) && max_level == as.integer(max_level))){ stop("arg max_level wrong type") }
    
        v1 <- r_to_py(ranks)
    
    
        py_ans = py_call(private$py_obj$calculatePeakLevelSpectra,spec, v1, as.integer(min_level), as.integer(max_level))
        byref_1 <- py_to_r(v1)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())), function(i) MSSpectrum$new(i)), py_to_r(py_builtin$list(py_ans$keys())))
    
        tryCatch({
        eval.parent(substitute(ranks <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double computePScore(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, libcpp_map[size_t,MSSpectrum] & peak_level_spectra, libcpp_vector[MSSpectrum] & theo_spectra, double mz_window)
    computePScore_0 = function(fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, peak_level_spectra, theo_spectra, mz_window){
    
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(
          is.environment(peak_level_spectra) && identical(parent.env(peak_level_spectra), asNamespace("collections")) && identical(strsplit(capture.output(peak_level_spectra$print())," ")[[1]][1], "dict")
          && all(sapply(peak_level_spectra$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(peak_level_spectra$values(),function(v) is.R6(v) && class(v)[1] == "MSSpectrum"))
          )){ stop("arg peak_level_spectra wrong type") }
        if(!(is_list(theo_spectra) && all(sapply(theo_spectra,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg theo_spectra wrong type") }
        if(!(is_scalar_double(mz_window))){ stop("arg mz_window wrong type") }
    
    
        v2 <- py_dict(as.integer(peak_level_spectra$keys()),peak_level_spectra$values())
        v3 <- r_to_py(theo_spectra)
    
        py_ans = private$py_obj$`_computePScore_0`(fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), v2, v3, mz_window)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_2 <- collections::dict(lapply(py_to_r(py_builtin$list(v2$values())),function(i) MSSpectrum$new(i)), py_to_r(py_builtin$list(v2$keys())))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(peak_level_spectra <- byref_2))
        eval.parent(substitute(theo_spectra <- byref_3))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double computePScore(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, libcpp_map[size_t,MSSpectrum] & peak_level_spectra, MSSpectrum & theo_spectrum, double mz_window)
    computePScore_1 = function(fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, peak_level_spectra, theo_spectrum, mz_window){
    
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!(
          is.environment(peak_level_spectra) && identical(parent.env(peak_level_spectra), asNamespace("collections")) && identical(strsplit(capture.output(peak_level_spectra$print())," ")[[1]][1], "dict")
          && all(sapply(peak_level_spectra$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(peak_level_spectra$values(),function(v) is.R6(v) && class(v)[1] == "MSSpectrum"))
          )){ stop("arg peak_level_spectra wrong type") }
        if(!(is.R6(theo_spectrum) && class(theo_spectrum)[1] == "MSSpectrum")){ stop("arg theo_spectrum wrong type") }
        if(!(is_scalar_double(mz_window))){ stop("arg mz_window wrong type") }
    
    
        v2 <- py_dict(as.integer(peak_level_spectra$keys()),peak_level_spectra$values())
    
    
        py_ans = private$py_obj$`_computePScore_1`(fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), v2, theo_spectrum, mz_window)
        byref_2 <- collections::dict(lapply(py_to_r(py_builtin$list(v2$values())),function(i) MSSpectrum$new(i)), py_to_r(py_builtin$list(v2$keys())))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(peak_level_spectra <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double computePScore(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, libcpp_map[size_t,MSSpectrum] & peak_level_spectra, libcpp_vector[MSSpectrum] & theo_spectra, double mz_window)
    # C++ signature: double computePScore(double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, libcpp_map[size_t,MSSpectrum] & peak_level_spectra, MSSpectrum & theo_spectrum, double mz_window)
    computePScore = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (
          is.environment(arg_list[[3]]) && identical(parent.env(arg_list[[3]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[3]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[3]]$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(arg_list[[3]]$values(),function(v) is.R6(v) && class(v)[1] == "MSSpectrum"))
          ) && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is_scalar_double(arg_list[[5]]))) { self$computePScore_0(...) }
        else if ((length(arg_list)==5) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (
          is.environment(arg_list[[3]]) && identical(parent.env(arg_list[[3]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[3]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[3]]$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(arg_list[[3]]$values(),function(v) is.R6(v) && class(v)[1] == "MSSpectrum"))
          ) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[5]]))) { self$computePScore_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _Param
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Param.html
Param <- R6Class(classname = "Param",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Param()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Param()
        invisible()
    
    
    },
    
    # C++ signature: void Param(Param)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Param(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Param()
    # C++ signature: void Param(Param)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Param")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Param" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setValue(String key, DataValue val, String desc, StringList tags)
    setValue_0 = function(key, val, desc, tags){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is.R6(val) && class(val)[1] == "DataValue")){ stop("arg val wrong type") }
        if(!((is.R6(desc) && class(desc)[1]=="String") || is_scalar_character(desc))){ stop("arg desc wrong type") }
        if(!(is_list(tags) && all(sapply(tags),is_scalar_character))){ stop("arg tags wrong type") }
    
    
    
        v3 = r_to_py(modify_depth(tags,1,py_builtin$bytes(tags,'utf-8')))
        private$py_obj$`_setValue_0`(key, val, desc, v3)
        invisible()
    },
    
    # C++ signature: void setValue(String key, DataValue val, String desc)
    setValue_1 = function(key, val, desc){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is.R6(val) && class(val)[1] == "DataValue")){ stop("arg val wrong type") }
        if(!((is.R6(desc) && class(desc)[1]=="String") || is_scalar_character(desc))){ stop("arg desc wrong type") }
    
    
    
        private$py_obj$`_setValue_1`(key, val, desc)
        invisible()
    },
    
    # C++ signature: void setValue(String key, DataValue val)
    setValue_2 = function(key, val){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is.R6(val) && class(val)[1] == "DataValue")){ stop("arg val wrong type") }
    
    
        private$py_obj$`_setValue_2`(key, val)
        invisible()
    },
    
    # C++ signature: void setValue(String key, DataValue val, String desc, StringList tags)
    # C++ signature: void setValue(String key, DataValue val, String desc)
    # C++ signature: void setValue(String key, DataValue val)
    setValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]]),is_scalar_character))) { self$setValue_0(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$setValue_1(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setValue_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: DataValue getValue(String key)
    getValue = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getValue(key)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: ParamEntry getEntry(String)
    getEntry = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getEntry(in_0)
        r_ans = ParamEntry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool exists(String key)
    exists = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$exists(key)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addTag(String key, String tag)
    addTag = function(key, tag){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(tag) && class(tag)[1]=="String") || is_scalar_character(tag))){ stop("arg tag wrong type") }
    
    
        private$py_obj$addTag(key, tag)
        invisible()
    },
    
    # C++ signature: void addTags(String key, StringList tags)
    addTags = function(key, tags){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is_list(tags) && all(sapply(tags),is_scalar_character))){ stop("arg tags wrong type") }
    
        v1 = r_to_py(modify_depth(tags,1,py_builtin$bytes(tags,'utf-8')))
        private$py_obj$addTags(key, v1)
        invisible()
    },
    
    # C++ signature: int hasTag(String key, String tag)
    hasTag = function(key, tag){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(tag) && class(tag)[1]=="String") || is_scalar_character(tag))){ stop("arg tag wrong type") }
    
    
        py_ans = private$py_obj$hasTag(key, tag)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: StringList getTags(String key)
    getTags = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getTags(key)
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void clearTags(String key)
    clearTags = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        private$py_obj$clearTags(key)
        invisible()
    },
    
    # C++ signature: String getDescription(String key)
    getDescription = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getDescription(key)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSectionDescription(String key, String desc)
    setSectionDescription = function(key, desc){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!((is.R6(desc) && class(desc)[1]=="String") || is_scalar_character(desc))){ stop("arg desc wrong type") }
    
    
        private$py_obj$setSectionDescription(key, desc)
        invisible()
    },
    
    # C++ signature: String getSectionDescription(String key)
    getSectionDescription = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$getSectionDescription(key)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void insert(String prefix, Param param)
    insert = function(prefix, param){
    
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
    
        private$py_obj$insert(prefix, param)
        invisible()
    },
    
    # C++ signature: void remove(String key)
    remove = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        private$py_obj$remove(key)
        invisible()
    },
    
    # C++ signature: void removeAll(String prefix)
    removeAll = function(prefix){
    
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
    
        private$py_obj$removeAll(prefix)
        invisible()
    },
    
    # C++ signature: Param copy(String prefix, bool)
    copy_0 = function(prefix, in_1){
    
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
        if(!( (is_scalar_integer(in_1) || is_scalar_double(in_1)) && in_1 == as.integer(in_1))){ stop("arg in_1 wrong type") }
    
    
        py_ans = private$py_obj$`_copy_0`(prefix, as.integer(in_1))
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param copy(String prefix)
    copy_1 = function(prefix){
    
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
    
        py_ans = private$py_obj$`_copy_1`(prefix)
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param copy(String prefix, bool)
    # C++ signature: Param copy(String prefix)
    copy = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$copy_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$copy_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void merge(Param toMerge)
    merge = function(toMerge){
    
        if(!(is.R6(toMerge) && class(toMerge)[1] == "Param")){ stop("arg toMerge wrong type") }
    
        private$py_obj$merge(toMerge)
        invisible()
    },
    
    # C++ signature: void setDefaults(Param defaults, String previx, bool showMessage)
    setDefaults_0 = function(defaults, previx, showMessage){
    
        if(!(is.R6(defaults) && class(defaults)[1] == "Param")){ stop("arg defaults wrong type") }
        if(!((is.R6(previx) && class(previx)[1]=="String") || is_scalar_character(previx))){ stop("arg previx wrong type") }
        if(!( (is_scalar_integer(showMessage) || is_scalar_double(showMessage)) && showMessage == as.integer(showMessage))){ stop("arg showMessage wrong type") }
    
    
    
        private$py_obj$`_setDefaults_0`(defaults, previx, as.integer(showMessage))
        invisible()
    },
    
    # C++ signature: void setDefaults(Param defaults, String previx)
    setDefaults_1 = function(defaults, previx){
    
        if(!(is.R6(defaults) && class(defaults)[1] == "Param")){ stop("arg defaults wrong type") }
        if(!((is.R6(previx) && class(previx)[1]=="String") || is_scalar_character(previx))){ stop("arg previx wrong type") }
    
    
        private$py_obj$`_setDefaults_1`(defaults, previx)
        invisible()
    },
    
    # C++ signature: void setDefaults(Param defaults)
    setDefaults_2 = function(defaults){
    
        if(!(is.R6(defaults) && class(defaults)[1] == "Param")){ stop("arg defaults wrong type") }
    
        private$py_obj$`_setDefaults_2`(defaults)
        invisible()
    },
    
    # C++ signature: void setDefaults(Param defaults, String previx, bool showMessage)
    # C++ signature: void setDefaults(Param defaults, String previx)
    # C++ signature: void setDefaults(Param defaults)
    setDefaults = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Param") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$setDefaults_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Param") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$setDefaults_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Param")) { self$setDefaults_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void checkDefaults(String name, Param defaults, String prefix)
    checkDefaults_0 = function(name, defaults, prefix){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(defaults) && class(defaults)[1] == "Param")){ stop("arg defaults wrong type") }
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
    
    
    
        private$py_obj$`_checkDefaults_0`(name, defaults, prefix)
        invisible()
    },
    
    # C++ signature: void checkDefaults(String name, Param defaults)
    checkDefaults_1 = function(name, defaults){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(defaults) && class(defaults)[1] == "Param")){ stop("arg defaults wrong type") }
    
    
        private$py_obj$`_checkDefaults_1`(name, defaults)
        invisible()
    },
    
    # C++ signature: void checkDefaults(String name, Param defaults, String prefix)
    # C++ signature: void checkDefaults(String name, Param defaults)
    checkDefaults = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Param") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$checkDefaults_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Param")) { self$checkDefaults_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setValidStrings(String key, libcpp_vector[String] strings)
    setValidStrings = function(key, strings){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is_list(strings) && all(sapply(strings),is_scalar_character))){ stop("arg strings wrong type") }
    
        v1 = r_to_py(modify_depth(strings,1,py_builtin$bytes(strings,'utf-8')))
        private$py_obj$setValidStrings(key, v1)
        invisible()
    },
    
    # C++ signature: void setMinInt(String key, int min)
    setMinInt = function(key, min){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!( (is_scalar_integer(min) || is_scalar_double(min)) && min == as.integer(min))){ stop("arg min wrong type") }
    
    
        private$py_obj$setMinInt(key, as.integer(min))
        invisible()
    },
    
    # C++ signature: void setMaxInt(String key, int max)
    setMaxInt = function(key, max){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!( (is_scalar_integer(max) || is_scalar_double(max)) && max == as.integer(max))){ stop("arg max wrong type") }
    
    
        private$py_obj$setMaxInt(key, as.integer(max))
        invisible()
    },
    
    # C++ signature: void setMinFloat(String key, double min)
    setMinFloat = function(key, min){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is_scalar_double(min))){ stop("arg min wrong type") }
    
    
        private$py_obj$setMinFloat(key, min)
        invisible()
    },
    
    # C++ signature: void setMaxFloat(String key, double max)
    setMaxFloat = function(key, max){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
        if(!(is_scalar_double(max))){ stop("arg max wrong type") }
    
    
        private$py_obj$setMaxFloat(key, max)
        invisible()
    }
)
) 

# R implementation of _ParamEntry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Param_1_1ParamEntry.html
ParamEntry <- R6Class(classname = "ParamEntry",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        value = function(value){
    
        if(!missing(value)){
            if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
        
        
            private$py_obj$value <- value
            } else {
        
                py_ans = private$py_obj$value
            dtype = DataType$new()
            type = py_ans$valueType()
            if( type == dtype$STRING_VALUE ){
               r_result = py_ans$toString()
            } else if ( type == dtype$INT_VALUE ){
               r_result = py_ans$toInt()
            } else if ( type == dtype$DOUBLE_VALUE ){
                r_result = py_ans$toDouble()
            } else if ( type == dtype$INT_LIST ){
               r_result = py_ans$toIntList()
            } else if ( type == dtype$DOUBLE_LIST ){
               r_result = py_ans$toDoubleList()
            } else if ( type == dtype$STRING_LIST ){
               r_result = py_ans$toStringList()
            } else if ( type == dtype$EMPTY_VALUE ){
               r_result = NULL
            } else {
                stop(paste0("DataValue instance has invalid value",type))
            }
                return(r_result)
                }
        },
        tags = function(tags){
    
        if(!missing(tags)){
            if(!(is_list(tags) && all(sapply(tags),is_scalar_character) && !any(duplicated(tags) == T))){ stop("arg tags wrong type") }
        
            v0 = py_builtin$set(modify_depth(tags,1,py_builtin$bytes(tags,'utf-8')))
            private$py_obj$tags <- v0
            } else {
        
                py_ans = private$py_obj$tags
            r_result = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
                return(r_result)
                }
        },
        valid_strings = function(valid_strings){
    
        if(!missing(valid_strings)){
            if(!(is_list(valid_strings) && all(sapply(valid_strings),is_scalar_character))){ stop("arg valid_strings wrong type") }
        
            v0 = r_to_py(modify_depth(valid_strings,1,py_builtin$bytes(valid_strings,'utf-8')))
            private$py_obj$valid_strings <- v0
            } else {
        
                py_ans = private$py_obj$valid_strings
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        max_float = function(max_float){
    
        if(!missing(max_float)){
            if(!(is_scalar_double(max_float))){ stop("arg max_float wrong type") }
        
        
            private$py_obj$max_float <- max_float
            } else {
        
                py_ans = private$py_obj$max_float
                r_result = py_ans
                return(r_result)
                }
        },
        min_float = function(min_float){
    
        if(!missing(min_float)){
            if(!(is_scalar_double(min_float))){ stop("arg min_float wrong type") }
        
        
            private$py_obj$min_float <- min_float
            } else {
        
                py_ans = private$py_obj$min_float
                r_result = py_ans
                return(r_result)
                }
        },
        max_int = function(max_int){
    
        if(!missing(max_int)){
            if(!( (is_scalar_integer(max_int) || is_scalar_double(max_int)) && max_int == as.integer(max_int))){ stop("arg max_int wrong type") }
        
        
            private$py_obj$max_int <- as.integer(max_int)
            } else {
        
                py_ans = private$py_obj$max_int
                r_result = py_ans
                return(r_result)
                }
        },
        min_int = function(min_int){
    
        if(!missing(min_int)){
            if(!( (is_scalar_integer(min_int) || is_scalar_double(min_int)) && min_int == as.integer(min_int))){ stop("arg min_int wrong type") }
        
        
            private$py_obj$min_int <- as.integer(min_int)
            } else {
        
                py_ans = private$py_obj$min_int
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ParamEntry()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ParamEntry()
        invisible()
    
    
    },
    
    # C++ signature: void ParamEntry(ParamEntry)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ParamEntry")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ParamEntry(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ParamEntry(String n, DataValue v, String d, StringList t)
    init_2 = function(n, v, d, t){
    
        if(!((is.R6(n) && class(n)[1]=="String") || is_scalar_character(n))){ stop("arg n wrong type") }
        if(!(is.R6(v) && class(v)[1] == "DataValue")){ stop("arg v wrong type") }
        if(!((is.R6(d) && class(d)[1]=="String") || is_scalar_character(d))){ stop("arg d wrong type") }
        if(!(is_list(t) && all(sapply(t),is_scalar_character))){ stop("arg t wrong type") }
    
    
    
        v3 = r_to_py(modify_depth(t,1,py_builtin$bytes(t,'utf-8')))
    
        private$py_obj <- Pymod$ParamEntry(n, v, d, v3)
        invisible()
    
    
    },
    
    # C++ signature: void ParamEntry(String n, DataValue v, String d)
    init_3 = function(n, v, d){
    
        if(!((is.R6(n) && class(n)[1]=="String") || is_scalar_character(n))){ stop("arg n wrong type") }
        if(!(is.R6(v) && class(v)[1] == "DataValue")){ stop("arg v wrong type") }
        if(!((is.R6(d) && class(d)[1]=="String") || is_scalar_character(d))){ stop("arg d wrong type") }
    
    
    
    
        private$py_obj <- Pymod$ParamEntry(n, v, d)
        invisible()
    
    
    },
    
    # C++ signature: void ParamEntry()
    # C++ signature: void ParamEntry(ParamEntry)
    # C++ signature: void ParamEntry(String n, DataValue v, String d, StringList t)
    # C++ signature: void ParamEntry(String n, DataValue v, String d)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ParamEntry")) { self$init_1(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]]),is_scalar_character))) { self$init_2(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue") && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$init_3(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ParamEntry" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isValid(String & message)
    isValid = function(message){
    
        if(!((is.R6(message) && class(message)[1]=="String") || is_scalar_character(message))){ stop("arg message wrong type") }
    
        py_ans = private$py_obj$isValid(message)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ParamNode
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Param_1_1ParamNode.html
ParamNode <- R6Class(classname = "ParamNode",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        entries = function(entries){
    
        if(!missing(entries)){
            if(!(is_list(entries) && all(sapply(entries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ParamEntry")))){ stop("arg entries wrong type") }
        
            v0 <- r_to_py(entries)
            private$py_obj$entries <- v0
            } else {
            
                py_ans = private$py_obj$entries
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        nodes = function(nodes){
    
        if(!missing(nodes)){
            if(!(is_list(nodes) && all(sapply(nodes,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ParamNode")))){ stop("arg nodes wrong type") }
        
            v0 <- r_to_py(nodes)
            private$py_obj$nodes <- v0
            } else {
            
                py_ans = private$py_obj$nodes
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ParamNode()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ParamNode()
        invisible()
    
    
    },
    
    # C++ signature: void ParamNode(const String & n, const String & d)
    init_1 = function(n, d){
    
        if(!((is.R6(n) && class(n)[1]=="String") || is_scalar_character(n))){ stop("arg n wrong type") }
        if(!((is.R6(d) && class(d)[1]=="String") || is_scalar_character(d))){ stop("arg d wrong type") }
    
    
    
        private$py_obj <- Pymod$ParamNode(n, d)
        invisible()
    
    
    },
    
    # C++ signature: void ParamNode()
    # C++ signature: void ParamNode(const String & n, const String & d)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ParamNode" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: ParamNode * findParentOf(const String & name)
    findParentOf = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$findParentOf(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ParamNode$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: ParamEntry * findEntryRecursive(const String & name)
    findEntryRecursive = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$findEntryRecursive(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ParamEntry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void insert(ParamNode & node, const String & prefix)
    insert_0 = function(node, prefix){
    
        if(!(is.R6(node) && class(node)[1] == "ParamNode")){ stop("arg node wrong type") }
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
    
    
        private$py_obj$`_insert_0`(node, prefix)
        invisible()
    },
    
    # C++ signature: void insert(ParamEntry & entry, const String & prefix)
    insert_1 = function(entry, prefix){
    
        if(!(is.R6(entry) && class(entry)[1] == "ParamEntry")){ stop("arg entry wrong type") }
        if(!((is.R6(prefix) && class(prefix)[1]=="String") || is_scalar_character(prefix))){ stop("arg prefix wrong type") }
    
    
        private$py_obj$`_insert_1`(entry, prefix)
        invisible()
    },
    
    # C++ signature: void insert(ParamNode & node, const String & prefix)
    # C++ signature: void insert(ParamEntry & entry, const String & prefix)
    insert = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ParamNode") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$insert_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ParamEntry") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$insert_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String suffix(const String & key)
    suffix = function(key){
    
        if(!((is.R6(key) && class(key)[1]=="String") || is_scalar_character(key))){ stop("arg key wrong type") }
    
        py_ans = private$py_obj$suffix(key)
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ParamXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ParamXMLFile.html
ParamXMLFile <- R6Class(classname = "ParamXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ParamXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ParamXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ParamXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, Param &)
    load = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "Param")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$load(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void store(String, Param &)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "Param")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    }
)
) 

# R implementation of _ParentPeakMower
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ParentPeakMower.html
ParentPeakMower <- R6Class(classname = "ParentPeakMower",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ParentPeakMower()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ParentPeakMower) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ParentPeakMower()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Peak1D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Peak1D.html
Peak1D <- R6Class(classname = "Peak1D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Peak1D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Peak1D()
        invisible()
    
    
    },
    
    # C++ signature: void Peak1D(Peak1D &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Peak1D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Peak1D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Peak1D()
    # C++ signature: void Peak1D(Peak1D &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Peak1D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Peak1D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: double getPos()
    getPos = function(){
    
        py_ans = private$py_obj$getPos()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPos(double pos)
    setPos = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        private$py_obj$setPos(pos)
        invisible()
    }
)
) 

# R implementation of _Peak2D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Peak2D.html
Peak2D <- R6Class(classname = "Peak2D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Peak2D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Peak2D()
        invisible()
    
    
    },
    
    # C++ signature: void Peak2D(Peak2D &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Peak2D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Peak2D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Peak2D()
    # C++ signature: void Peak2D(Peak2D &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Peak2D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Peak2D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    }
)
) 

# R implementation of _PeakBoundary
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakBoundary.html
PeakBoundary <- R6Class(classname = "PeakBoundary",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mz_min = function(mz_min){
    
        if(!missing(mz_min)){
            if(!(is_scalar_double(mz_min))){ stop("arg mz_min wrong type") }
        
        
            private$py_obj$mz_min <- mz_min
            } else {
        
                py_ans = private$py_obj$mz_min
                r_result = py_ans
                return(r_result)
                }
        },
        mz_max = function(mz_max){
    
        if(!missing(mz_max)){
            if(!(is_scalar_double(mz_max))){ stop("arg mz_max wrong type") }
        
        
            private$py_obj$mz_max <- mz_max
            } else {
        
                py_ans = private$py_obj$mz_max
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeakBoundary()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakBoundary) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakBoundary()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeakCandidate
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakCandidate.html
PeakCandidate <- R6Class(classname = "PeakCandidate",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        pos = function(pos){
    
        if(!missing(pos)){
            if(!( (is_scalar_integer(pos) || is_scalar_double(pos)) && pos == as.integer(pos))){ stop("arg pos wrong type") }
        
        
            private$py_obj$pos <- as.integer(pos)
            } else {
        
                py_ans = private$py_obj$pos
                r_result = py_ans
                return(r_result)
                }
        },
        left_boundary = function(left_boundary){
    
        if(!missing(left_boundary)){
            if(!( (is_scalar_integer(left_boundary) || is_scalar_double(left_boundary)) && left_boundary == as.integer(left_boundary))){ stop("arg left_boundary wrong type") }
        
        
            private$py_obj$left_boundary <- as.integer(left_boundary)
            } else {
        
                py_ans = private$py_obj$left_boundary
                r_result = py_ans
                return(r_result)
                }
        },
        right_boundary = function(right_boundary){
    
        if(!missing(right_boundary)){
            if(!( (is_scalar_integer(right_boundary) || is_scalar_double(right_boundary)) && right_boundary == as.integer(right_boundary))){ stop("arg right_boundary wrong type") }
        
        
            private$py_obj$right_boundary <- as.integer(right_boundary)
            } else {
        
                py_ans = private$py_obj$right_boundary
                r_result = py_ans
                return(r_result)
                }
        },
        mz_max = function(mz_max){
    
        if(!missing(mz_max)){
            if(!(is_scalar_double(mz_max))){ stop("arg mz_max wrong type") }
        
        
            private$py_obj$mz_max <- mz_max
            } else {
        
                py_ans = private$py_obj$mz_max
                r_result = py_ans
                return(r_result)
                }
        },
        int_max = function(int_max){
    
        if(!missing(int_max)){
            if(!(is_scalar_double(int_max))){ stop("arg int_max wrong type") }
        
        
            private$py_obj$int_max <- int_max
            } else {
        
                py_ans = private$py_obj$int_max
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeakCandidate()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakCandidate()
        invisible()
    
    
    },
    
    # C++ signature: void PeakCandidate(PeakCandidate &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakCandidate")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakCandidate(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakCandidate()
    # C++ signature: void PeakCandidate(PeakCandidate &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakCandidate")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakCandidate" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _PeakFileOptions
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakFileOptions.html
PeakFileOptions <- R6Class(classname = "PeakFileOptions",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakFileOptions()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakFileOptions()
        invisible()
    
    
    },
    
    # C++ signature: void PeakFileOptions(PeakFileOptions)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakFileOptions")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakFileOptions(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakFileOptions()
    # C++ signature: void PeakFileOptions(PeakFileOptions)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakFileOptions")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakFileOptions" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setMetadataOnly(bool)
    setMetadataOnly = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMetadataOnly(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getMetadataOnly()
    getMetadataOnly = function(){
    
        py_ans = private$py_obj$getMetadataOnly()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWriteSupplementalData(bool)
    setWriteSupplementalData = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setWriteSupplementalData(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getWriteSupplementalData()
    getWriteSupplementalData = function(){
    
        py_ans = private$py_obj$getWriteSupplementalData()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMSLevels(libcpp_vector[int] levels)
    setMSLevels = function(levels){
    
        if(!(is_list(levels) && all(sapply(levels,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg levels wrong type") }
        v0 <- r_to_py(modify_depth(levels,1,as.integer))
        private$py_obj$setMSLevels(v0)
        
        invisible()
    },
    
    # C++ signature: void addMSLevel(int level)
    addMSLevel = function(level){
    
        if(!( (is_scalar_integer(level) || is_scalar_double(level)) && level == as.integer(level))){ stop("arg level wrong type") }
    
        private$py_obj$addMSLevel(as.integer(level))
        invisible()
    },
    
    # C++ signature: void clearMSLevels()
    clearMSLevels = function(){
    
        private$py_obj$clearMSLevels()
        invisible()
    },
    
    # C++ signature: bool hasMSLevels()
    hasMSLevels = function(){
    
        py_ans = private$py_obj$hasMSLevels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool containsMSLevel(int level)
    containsMSLevel = function(level){
    
        if(!( (is_scalar_integer(level) || is_scalar_double(level)) && level == as.integer(level))){ stop("arg level wrong type") }
    
        py_ans = private$py_obj$containsMSLevel(as.integer(level))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[int] getMSLevels()
    getMSLevels = function(){
    
        py_ans = private$py_obj$getMSLevels()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setCompression(bool)
    setCompression = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setCompression(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool getCompression()
    getCompression = function(){
    
        py_ans = private$py_obj$getCompression()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMz32Bit(bool mz_32_bit)
    setMz32Bit = function(mz_32_bit){
    
        if(!( (is_scalar_integer(mz_32_bit) || is_scalar_double(mz_32_bit)) && mz_32_bit == as.integer(mz_32_bit))){ stop("arg mz_32_bit wrong type") }
    
        private$py_obj$setMz32Bit(as.integer(mz_32_bit))
        invisible()
    },
    
    # C++ signature: bool getMz32Bit()
    getMz32Bit = function(){
    
        py_ans = private$py_obj$getMz32Bit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIntensity32Bit(bool int_32_bit)
    setIntensity32Bit = function(int_32_bit){
    
        if(!( (is_scalar_integer(int_32_bit) || is_scalar_double(int_32_bit)) && int_32_bit == as.integer(int_32_bit))){ stop("arg int_32_bit wrong type") }
    
        private$py_obj$setIntensity32Bit(as.integer(int_32_bit))
        invisible()
    },
    
    # C++ signature: bool getIntensity32Bit()
    getIntensity32Bit = function(){
    
        py_ans = private$py_obj$getIntensity32Bit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRTRange(DRange1 & range_)
    setRTRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setRTRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasRTRange()
    hasRTRange = function(){
    
        py_ans = private$py_obj$hasRTRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getRTRange()
    getRTRange = function(){
    
        py_ans = private$py_obj$getRTRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setMZRange(DRange1 & range_)
    setMZRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setMZRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasMZRange()
    hasMZRange = function(){
    
        py_ans = private$py_obj$hasMZRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getMZRange()
    getMZRange = function(){
    
        py_ans = private$py_obj$getMZRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setIntensityRange(DRange1 & range_)
    setIntensityRange = function(range_){
    
        if(!(is.R6(range_) && class(range_)[1] == "DRange1")){ stop("arg range_ wrong type") }
    
        private$py_obj$setIntensityRange(range_)
        invisible()
    },
    
    # C++ signature: bool hasIntensityRange()
    hasIntensityRange = function(){
    
        py_ans = private$py_obj$hasIntensityRange()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: DRange1 getIntensityRange()
    getIntensityRange = function(){
    
        py_ans = private$py_obj$getIntensityRange()
        r_ans = DRange1$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getMaxDataPoolSize()
    getMaxDataPoolSize = function(){
    
        py_ans = private$py_obj$getMaxDataPoolSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxDataPoolSize(size_t s)
    setMaxDataPoolSize = function(s){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
    
        private$py_obj$setMaxDataPoolSize(as.integer(s))
        invisible()
    },
    
    # C++ signature: void setSortSpectraByMZ(bool doSort)
    setSortSpectraByMZ = function(doSort){
    
        if(!( (is_scalar_integer(doSort) || is_scalar_double(doSort)) && doSort == as.integer(doSort))){ stop("arg doSort wrong type") }
    
        private$py_obj$setSortSpectraByMZ(as.integer(doSort))
        invisible()
    },
    
    # C++ signature: bool getSortSpectraByMZ()
    getSortSpectraByMZ = function(){
    
        py_ans = private$py_obj$getSortSpectraByMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSortChromatogramsByRT(bool doSort)
    setSortChromatogramsByRT = function(doSort){
    
        if(!( (is_scalar_integer(doSort) || is_scalar_double(doSort)) && doSort == as.integer(doSort))){ stop("arg doSort wrong type") }
    
        private$py_obj$setSortChromatogramsByRT(as.integer(doSort))
        invisible()
    },
    
    # C++ signature: bool getSortChromatogramsByRT()
    getSortChromatogramsByRT = function(){
    
        py_ans = private$py_obj$getSortChromatogramsByRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasFilters()
    hasFilters = function(){
    
        py_ans = private$py_obj$hasFilters()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFillData(bool only)
    setFillData = function(only){
    
        if(!( (is_scalar_integer(only) || is_scalar_double(only)) && only == as.integer(only))){ stop("arg only wrong type") }
    
        private$py_obj$setFillData(as.integer(only))
        invisible()
    },
    
    # C++ signature: bool getFillData()
    getFillData = function(){
    
        py_ans = private$py_obj$getFillData()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSkipXMLChecks(bool only)
    setSkipXMLChecks = function(only){
    
        if(!( (is_scalar_integer(only) || is_scalar_double(only)) && only == as.integer(only))){ stop("arg only wrong type") }
    
        private$py_obj$setSkipXMLChecks(as.integer(only))
        invisible()
    },
    
    # C++ signature: bool getSkipXMLChecks()
    getSkipXMLChecks = function(){
    
        py_ans = private$py_obj$getSkipXMLChecks()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool getWriteIndex()
    getWriteIndex = function(){
    
        py_ans = private$py_obj$getWriteIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setWriteIndex(bool write_index)
    setWriteIndex = function(write_index){
    
        if(!( (is_scalar_integer(write_index) || is_scalar_double(write_index)) && write_index == as.integer(write_index))){ stop("arg write_index wrong type") }
    
        private$py_obj$setWriteIndex(as.integer(write_index))
        invisible()
    },
    
    # C++ signature: NumpressConfig getNumpressConfigurationMassTime()
    getNumpressConfigurationMassTime = function(){
    
        py_ans = private$py_obj$getNumpressConfigurationMassTime()
        r_ans = NumpressConfig$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setNumpressConfigurationMassTime(NumpressConfig config)
    setNumpressConfigurationMassTime = function(config){
    
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
    
        private$py_obj$setNumpressConfigurationMassTime(config)
        invisible()
    },
    
    # C++ signature: NumpressConfig getNumpressConfigurationIntensity()
    getNumpressConfigurationIntensity = function(){
    
        py_ans = private$py_obj$getNumpressConfigurationIntensity()
        r_ans = NumpressConfig$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setNumpressConfigurationIntensity(NumpressConfig config)
    setNumpressConfigurationIntensity = function(config){
    
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
    
        private$py_obj$setNumpressConfigurationIntensity(config)
        invisible()
    },
    
    # C++ signature: NumpressConfig getNumpressConfigurationFloatDataArray()
    getNumpressConfigurationFloatDataArray = function(){
    
        py_ans = private$py_obj$getNumpressConfigurationFloatDataArray()
        r_ans = NumpressConfig$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setNumpressConfigurationFloatDataArray(NumpressConfig config)
    setNumpressConfigurationFloatDataArray = function(config){
    
        if(!(is.R6(config) && class(config)[1] == "NumpressConfig")){ stop("arg config wrong type") }
    
        private$py_obj$setNumpressConfigurationFloatDataArray(config)
        invisible()
    },
    
    # C++ signature: void setForceMQCompatability(bool forceMQ)
    setForceMQCompatability = function(forceMQ){
    
        if(!( (is_scalar_integer(forceMQ) || is_scalar_double(forceMQ)) && forceMQ == as.integer(forceMQ))){ stop("arg forceMQ wrong type") }
    
        private$py_obj$setForceMQCompatability(as.integer(forceMQ))
        invisible()
    },
    
    # C++ signature: bool getForceMQCompatability()
    getForceMQCompatability = function(){
    
        py_ans = private$py_obj$getForceMQCompatability()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setForceTPPCompatability(bool forceTPP)
    setForceTPPCompatability = function(forceTPP){
    
        if(!( (is_scalar_integer(forceTPP) || is_scalar_double(forceTPP)) && forceTPP == as.integer(forceTPP))){ stop("arg forceTPP wrong type") }
    
        private$py_obj$setForceTPPCompatability(as.integer(forceTPP))
        invisible()
    },
    
    # C++ signature: bool getForceTPPCompatability()
    getForceTPPCompatability = function(){
    
        py_ans = private$py_obj$getForceTPPCompatability()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _PeakIndex
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakIndex.html
PeakIndex <- R6Class(classname = "PeakIndex",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        peak = function(peak){
    
        if(!missing(peak)){
            if(!( (is_scalar_integer(peak) || is_scalar_double(peak)) && peak == as.integer(peak))){ stop("arg peak wrong type") }
        
        
            private$py_obj$peak <- as.integer(peak)
            } else {
        
                py_ans = private$py_obj$peak
                r_result = py_ans
                return(r_result)
                }
        },
        spectrum = function(spectrum){
    
        if(!missing(spectrum)){
            if(!( (is_scalar_integer(spectrum) || is_scalar_double(spectrum)) && spectrum == as.integer(spectrum))){ stop("arg spectrum wrong type") }
        
        
            private$py_obj$spectrum <- as.integer(spectrum)
            } else {
        
                py_ans = private$py_obj$spectrum
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeakIndex()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakIndex()
        invisible()
    
    
    },
    
    # C++ signature: void PeakIndex(size_t peak)
    init_1 = function(peak){
    
        if(!( (is_scalar_integer(peak) || is_scalar_double(peak)) && peak == as.integer(peak))){ stop("arg peak wrong type") }
    
    
        private$py_obj <- Pymod$PeakIndex(as.integer(peak))
        invisible()
    
    
    },
    
    # C++ signature: void PeakIndex(size_t spectrum, size_t peak)
    init_2 = function(spectrum, peak){
    
        if(!( (is_scalar_integer(spectrum) || is_scalar_double(spectrum)) && spectrum == as.integer(spectrum))){ stop("arg spectrum wrong type") }
        if(!( (is_scalar_integer(peak) || is_scalar_double(peak)) && peak == as.integer(peak))){ stop("arg peak wrong type") }
    
    
    
        private$py_obj <- Pymod$PeakIndex(as.integer(spectrum), as.integer(peak))
        invisible()
    
    
    },
    
    # C++ signature: void PeakIndex()
    # C++ signature: void PeakIndex(size_t peak)
    # C++ signature: void PeakIndex(size_t spectrum, size_t peak)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakIndex" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isValid()
    isValid = function(){
    
        py_ans = private$py_obj$isValid()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: Feature getFeature(FeatureMap & map_)
    getFeature = function(map_){
    
        if(!(is.R6(map_) && class(map_)[1] == "FeatureMap")){ stop("arg map_ wrong type") }
    
        py_ans = private$py_obj$getFeature(map_)
        r_ans = Feature$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Peak1D getPeak(MSExperiment & map_)
    getPeak = function(map_){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
    
        py_ans = private$py_obj$getPeak(map_)
        r_ans = Peak1D$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: MSSpectrum getSpectrum(MSExperiment & map_)
    getSpectrum = function(map_){
    
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
    
        py_ans = private$py_obj$getSpectrum(map_)
        r_ans = MSSpectrum$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _PeakIntegrator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakIntegrator.html
PeakIntegrator <- R6Class(classname = "PeakIntegrator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakIntegrator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakIntegrator()
        invisible()
    
    
    },
    
    # C++ signature: void PeakIntegrator(PeakIntegrator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakIntegrator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakIntegrator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakIntegrator()
    # C++ signature: void PeakIntegrator(PeakIntegrator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakIntegrator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakIntegrator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getDefaultParameters(Param)
    getDefaultParameters = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
        private$py_obj$getDefaultParameters(in_0)
        invisible()
    },
    
    # C++ signature: PI_PeakArea integratePeak(MSChromatogram & chromatogram, double left, double right)
    integratePeak_0 = function(chromatogram, left, right){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
    
    
    
        py_ans = private$py_obj$`_integratePeak_0`(chromatogram, left, right)
        r_ans = PI_PeakArea$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakArea integratePeak(MSSpectrum & spectrum, double left, double right)
    integratePeak_1 = function(spectrum, left, right){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
    
    
    
        py_ans = private$py_obj$`_integratePeak_1`(spectrum, left, right)
        r_ans = PI_PeakArea$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakArea integratePeak(MSChromatogram & chromatogram, double left, double right)
    # C++ signature: PI_PeakArea integratePeak(MSSpectrum & spectrum, double left, double right)
    integratePeak = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$integratePeak_0(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$integratePeak_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: PI_PeakBackground estimateBackground(MSChromatogram & chromatogram, double left, double right, double peak_apex_pos)
    estimateBackground_0 = function(chromatogram, left, right, peak_apex_pos){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
        if(!(is_scalar_double(peak_apex_pos))){ stop("arg peak_apex_pos wrong type") }
    
    
    
    
        py_ans = private$py_obj$`_estimateBackground_0`(chromatogram, left, right, peak_apex_pos)
        r_ans = PI_PeakBackground$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakBackground estimateBackground(MSSpectrum & spectrum, double left, double right, double peak_apex_pos)
    estimateBackground_1 = function(spectrum, left, right, peak_apex_pos){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
        if(!(is_scalar_double(peak_apex_pos))){ stop("arg peak_apex_pos wrong type") }
    
    
    
    
        py_ans = private$py_obj$`_estimateBackground_1`(spectrum, left, right, peak_apex_pos)
        r_ans = PI_PeakBackground$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakBackground estimateBackground(MSChromatogram & chromatogram, double left, double right, double peak_apex_pos)
    # C++ signature: PI_PeakBackground estimateBackground(MSSpectrum & spectrum, double left, double right, double peak_apex_pos)
    estimateBackground = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$estimateBackground_0(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]]))) { self$estimateBackground_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: PI_PeakShapeMetrics calculatePeakShapeMetrics(MSChromatogram & chromatogram, double left, double right, double peak_height, double peak_apex_pos)
    calculatePeakShapeMetrics_0 = function(chromatogram, left, right, peak_height, peak_apex_pos){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
        if(!(is_scalar_double(peak_height))){ stop("arg peak_height wrong type") }
        if(!(is_scalar_double(peak_apex_pos))){ stop("arg peak_apex_pos wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$`_calculatePeakShapeMetrics_0`(chromatogram, left, right, peak_height, peak_apex_pos)
        r_ans = PI_PeakShapeMetrics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakShapeMetrics calculatePeakShapeMetrics(MSSpectrum & spectrum, double left, double right, double peak_height, double peak_apex_pos)
    calculatePeakShapeMetrics_1 = function(spectrum, left, right, peak_height, peak_apex_pos){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is_scalar_double(left))){ stop("arg left wrong type") }
        if(!(is_scalar_double(right))){ stop("arg right wrong type") }
        if(!(is_scalar_double(peak_height))){ stop("arg peak_height wrong type") }
        if(!(is_scalar_double(peak_apex_pos))){ stop("arg peak_apex_pos wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$`_calculatePeakShapeMetrics_1`(spectrum, left, right, peak_height, peak_apex_pos)
        r_ans = PI_PeakShapeMetrics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PI_PeakShapeMetrics calculatePeakShapeMetrics(MSChromatogram & chromatogram, double left, double right, double peak_height, double peak_apex_pos)
    # C++ signature: PI_PeakShapeMetrics calculatePeakShapeMetrics(MSSpectrum & spectrum, double left, double right, double peak_height, double peak_apex_pos)
    calculatePeakShapeMetrics = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]]))) { self$calculatePeakShapeMetrics_0(...) }
        else if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]]))) { self$calculatePeakShapeMetrics_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PeakIntensityPredictor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakIntensityPredictor.html
PeakIntensityPredictor <- R6Class(classname = "PeakIntensityPredictor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakIntensityPredictor()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakIntensityPredictor) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakIntensityPredictor()
        invisible()
    }
    
    },
    
    # C++ signature: double predict(AASequence & sequence)
    predict_0 = function(sequence){
    
        if(!(is.R6(sequence) && class(sequence)[1] == "AASequence")){ stop("arg sequence wrong type") }
    
        py_ans = private$py_obj$`_predict_0`(sequence)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double predict(AASequence & sequence, libcpp_vector[double] & add_info)
    predict_1 = function(sequence, add_info){
    
        if(!(is.R6(sequence) && class(sequence)[1] == "AASequence")){ stop("arg sequence wrong type") }
        if(!(is_list(add_info) && all(sapply(add_info,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg add_info wrong type") }
    
        v1 <- r_to_py(add_info)
        py_ans = private$py_obj$`_predict_1`(sequence, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(add_info <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] predict(libcpp_vector[AASequence] & sequences)
    predict_2 = function(sequences){
    
        if(!(is_list(sequences) && all(sapply(sequences,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg sequences wrong type") }
        v0 <- r_to_py(sequences)
        py_ans = private$py_obj$`_predict_2`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans <- modify_depth(py_ans,0,as.list)
    
        tryCatch({
        eval.parent(substitute(sequences <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] predict(libcpp_vector[AASequence] & sequences, libcpp_vector[libcpp_vector[double]] & add_info)
    predict_3 = function(sequences, add_info){
    
        if(!(is_list(sequences) && all(sapply(sequences,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg sequences wrong type") }
        if(!(is_list(add_info) && all(sapply(add_info,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is_scalar_double(elemt_rec_rec))))))){ stop("arg add_info wrong type") }
        v0 <- r_to_py(sequences)
        v1 <- r_to_py(add_info)
        py_ans = private$py_obj$`_predict_3`(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),1,as.list)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans <- modify_depth(py_ans,0,as.list)
    
        tryCatch({
        eval.parent(substitute(sequences <- byref_0))
        eval.parent(substitute(add_info <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double predict(AASequence & sequence)
    # C++ signature: double predict(AASequence & sequence, libcpp_vector[double] & add_info)
    # C++ signature: libcpp_vector[double] predict(libcpp_vector[AASequence] & sequences)
    # C++ signature: libcpp_vector[double] predict(libcpp_vector[AASequence] & sequences, libcpp_vector[libcpp_vector[double]] & add_info)
    predict = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASequence")) { self$predict_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASequence") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec))))) { self$predict_1(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))) { self$predict_2(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is_scalar_double(elemt_rec_rec))))))) { self$predict_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _PeakMarker
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakMarker.html
PeakMarker <- R6Class(classname = "PeakMarker",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakMarker()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakMarker()
        invisible()
    
    
    },
    
    # C++ signature: void PeakMarker(PeakMarker)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakMarker")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakMarker(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakMarker()
    # C++ signature: void PeakMarker(PeakMarker)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakMarker")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakMarker" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PeakPickerCWT
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerCWT.html
PeakPickerCWT <- R6Class(classname = "PeakPickerCWT",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerCWT()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakPickerCWT) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakPickerCWT()
        invisible()
    }
    
    },
    
    # C++ signature: void pick(MSSpectrum & input, MSSpectrum & output)
    pick = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSSpectrum")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSSpectrum")){ stop("arg output wrong type") }
    
    
        private$py_obj$pick(input, output)
        invisible()
    },
    
    # C++ signature: void pickExperiment(MSExperiment & input, MSExperiment & output)
    pickExperiment = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
    
    
        private$py_obj$pickExperiment(input, output)
        invisible()
    },
    
    # C++ signature: double estimatePeakWidth(MSExperiment & input)
    estimatePeakWidth = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
    
        py_ans = private$py_obj$estimatePeakWidth(input)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _PeakPickerHiRes
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerHiRes.html
PeakPickerHiRes <- R6Class(classname = "PeakPickerHiRes",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerHiRes()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakPickerHiRes) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakPickerHiRes()
        invisible()
    }
    
    },
    
    # C++ signature: void pick(MSSpectrum & input, MSSpectrum & output)
    pick = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSSpectrum")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSSpectrum")){ stop("arg output wrong type") }
    
    
        private$py_obj$pick(input, output)
        invisible()
    },
    
    # C++ signature: void pickExperiment(MSExperiment & input, MSExperiment & output)
    pickExperiment = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
    
    
        private$py_obj$pickExperiment(input, output)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _PeakPickerIterative
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerIterative.html
PeakPickerIterative <- R6Class(classname = "PeakPickerIterative",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerIterative()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakPickerIterative) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakPickerIterative()
        invisible()
    }
    
    },
    
    # C++ signature: void pick(MSSpectrum & input, MSSpectrum & output)
    pick = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSSpectrum")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSSpectrum")){ stop("arg output wrong type") }
    
    
        private$py_obj$pick(input, output)
        invisible()
    },
    
    # C++ signature: void pickExperiment(MSExperiment & input, MSExperiment & output)
    pickExperiment = function(input, output){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
    
    
        private$py_obj$pickExperiment(input, output)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _PeakPickerMRM
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerMRM.html
PeakPickerMRM <- R6Class(classname = "PeakPickerMRM",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerMRM()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakPickerMRM) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakPickerMRM()
        invisible()
    }
    
    },
    
    # C++ signature: void pickChromatogram(MSChromatogram & chromatogram, MSChromatogram & picked_chrom)
    pickChromatogram = function(chromatogram, picked_chrom){
    
        if(!(is.R6(chromatogram) && class(chromatogram)[1] == "MSChromatogram")){ stop("arg chromatogram wrong type") }
        if(!(is.R6(picked_chrom) && class(picked_chrom)[1] == "MSChromatogram")){ stop("arg picked_chrom wrong type") }
    
    
        private$py_obj$pickChromatogram(chromatogram, picked_chrom)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PeakPickerMaxima
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerMaxima.html
PeakPickerMaxima <- R6Class(classname = "PeakPickerMaxima",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerMaxima(PeakPickerMaxima &)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakPickerMaxima")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakPickerMaxima(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakPickerMaxima(double signal_to_noise, double spacing_difference, double sn_window_length)
    init_1 = function(signal_to_noise, spacing_difference, sn_window_length){
    
        if(!(is_scalar_double(signal_to_noise))){ stop("arg signal_to_noise wrong type") }
        if(!(is_scalar_double(spacing_difference))){ stop("arg spacing_difference wrong type") }
        if(!(is_scalar_double(sn_window_length))){ stop("arg sn_window_length wrong type") }
    
    
    
    
        private$py_obj <- Pymod$PeakPickerMaxima(signal_to_noise, spacing_difference, sn_window_length)
        invisible()
    
    
    },
    
    # C++ signature: void PeakPickerMaxima(PeakPickerMaxima &)
    # C++ signature: void PeakPickerMaxima(double signal_to_noise, double spacing_difference, double sn_window_length)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakPickerMaxima")) { self$init_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakPickerMaxima" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void findMaxima(libcpp_vector[double] mz_array, libcpp_vector[double] int_array, libcpp_vector[PeakCandidate] & pc)
    findMaxima = function(mz_array, int_array, pc){
    
        if(!(is_list(mz_array) && all(sapply(mz_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz_array wrong type") }
        if(!(is_list(int_array) && all(sapply(int_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg int_array wrong type") }
        if(!(is_list(pc) && all(sapply(pc,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeakCandidate")))){ stop("arg pc wrong type") }
        v0 <- r_to_py(mz_array)
        v1 <- r_to_py(int_array)
        v2 <- r_to_py(pc)
        private$py_obj$findMaxima(v0, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        
        
    
        tryCatch({
        eval.parent(substitute(pc <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void pick(libcpp_vector[double] mz_array, libcpp_vector[double] int_array, libcpp_vector[PeakCandidate] & pc)
    pick = function(mz_array, int_array, pc){
    
        if(!(is_list(mz_array) && all(sapply(mz_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz_array wrong type") }
        if(!(is_list(int_array) && all(sapply(int_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg int_array wrong type") }
        if(!(is_list(pc) && all(sapply(pc,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeakCandidate")))){ stop("arg pc wrong type") }
        v0 <- r_to_py(mz_array)
        v1 <- r_to_py(int_array)
        v2 <- r_to_py(pc)
        private$py_obj$pick(v0, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        
        
    
        tryCatch({
        eval.parent(substitute(pc <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _PeakPickerSH
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakPickerSH.html
PeakPickerSH <- R6Class(classname = "PeakPickerSH",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakPickerSH()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakPickerSH) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakPickerSH()
        invisible()
    }
    
    },
    
    # C++ signature: void pick(MSSpectrum & input_, MSSpectrum & output, float fWindowWidth)
    pick = function(input_, output, fWindowWidth){
    
        if(!(is.R6(input_) && class(input_)[1] == "MSSpectrum")){ stop("arg input_ wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSSpectrum")){ stop("arg output wrong type") }
        if(!(is_scalar_double(fWindowWidth))){ stop("arg fWindowWidth wrong type") }
    
    
    
        private$py_obj$pick(input_, output, fWindowWidth)
        invisible()
    },
    
    # C++ signature: void pickExperiment(MSExperiment & input_, MSExperiment & output)
    pickExperiment = function(input_, output){
    
        if(!(is.R6(input_) && class(input_)[1] == "MSExperiment")){ stop("arg input_ wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
    
    
        private$py_obj$pickExperiment(input_, output)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _PeakShape
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakShape.html
PeakShape <- R6Class(classname = "PeakShape",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        height = function(height){
    
        if(!missing(height)){
            if(!(is_scalar_double(height))){ stop("arg height wrong type") }
        
        
            private$py_obj$height <- height
            } else {
        
                py_ans = private$py_obj$height
                r_result = py_ans
                return(r_result)
                }
        },
        mz_position = function(mz_position){
    
        if(!missing(mz_position)){
            if(!(is_scalar_double(mz_position))){ stop("arg mz_position wrong type") }
        
        
            private$py_obj$mz_position <- mz_position
            } else {
        
                py_ans = private$py_obj$mz_position
                r_result = py_ans
                return(r_result)
                }
        },
        left_width = function(left_width){
    
        if(!missing(left_width)){
            if(!(is_scalar_double(left_width))){ stop("arg left_width wrong type") }
        
        
            private$py_obj$left_width <- left_width
            } else {
        
                py_ans = private$py_obj$left_width
                r_result = py_ans
                return(r_result)
                }
        },
        right_width = function(right_width){
    
        if(!missing(right_width)){
            if(!(is_scalar_double(right_width))){ stop("arg right_width wrong type") }
        
        
            private$py_obj$right_width <- right_width
            } else {
        
                py_ans = private$py_obj$right_width
                r_result = py_ans
                return(r_result)
                }
        },
        area = function(area){
    
        if(!missing(area)){
            if(!(is_scalar_double(area))){ stop("arg area wrong type") }
        
        
            private$py_obj$area <- area
            } else {
        
                py_ans = private$py_obj$area
                r_result = py_ans
                return(r_result)
                }
        },
        r_value = function(r_value){
    
        if(!missing(r_value)){
            if(!(is_scalar_double(r_value))){ stop("arg r_value wrong type") }
        
        
            private$py_obj$r_value <- r_value
            } else {
        
                py_ans = private$py_obj$r_value
                r_result = py_ans
                return(r_result)
                }
        },
        signal_to_noise = function(signal_to_noise){
    
        if(!missing(signal_to_noise)){
            if(!(is_scalar_double(signal_to_noise))){ stop("arg signal_to_noise wrong type") }
        
        
            private$py_obj$signal_to_noise <- signal_to_noise
            } else {
        
                py_ans = private$py_obj$signal_to_noise
                r_result = py_ans
                return(r_result)
                }
        },
        type = function(type){
    
        if(!missing(type)){
            if(!(type %in% c(0, 1, 2))){ stop("arg type wrong type") }
        
        
            private$py_obj$type <- as.integer(type)
            } else {
        
                py_ans = private$py_obj$type
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeakShape()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeakShape()
        invisible()
    
    
    },
    
    # C++ signature: void PeakShape(PeakShape)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeakShape")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeakShape(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeakShape(double height_, double mz_position_, double left_width_, double right_width_, double area_, PeakShape_Type type_)
    init_2 = function(height_, mz_position_, left_width_, right_width_, area_, type_){
    
        if(!(is_scalar_double(height_))){ stop("arg height_ wrong type") }
        if(!(is_scalar_double(mz_position_))){ stop("arg mz_position_ wrong type") }
        if(!(is_scalar_double(left_width_))){ stop("arg left_width_ wrong type") }
        if(!(is_scalar_double(right_width_))){ stop("arg right_width_ wrong type") }
        if(!(is_scalar_double(area_))){ stop("arg area_ wrong type") }
        if(!(type_ %in% c(0, 1, 2))){ stop("arg type_ wrong type") }
    
    
    
    
    
    
    
        private$py_obj <- Pymod$PeakShape(height_, mz_position_, left_width_, right_width_, area_, as.integer(type_))
        invisible()
    
    
    },
    
    # C++ signature: void PeakShape()
    # C++ signature: void PeakShape(PeakShape)
    # C++ signature: void PeakShape(double height_, double mz_position_, double left_width_, double right_width_, double area_, PeakShape_Type type_)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeakShape")) { self$init_1(...) }
        else if ((length(arg_list)==6) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && (is_scalar_double(arg_list[[5]])) && (arg_list[[6]] %in% c(0, 1, 2))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeakShape" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getSymmetricMeasure()
    getSymmetricMeasure = function(){
    
        py_ans = private$py_obj$getSymmetricMeasure()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getFWHM()
    getFWHM = function(){
    
        py_ans = private$py_obj$getFWHM()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool iteratorsSet()
    iteratorsSet = function(){
    
        py_ans = private$py_obj$iteratorsSet()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _PeakTypeEstimator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakTypeEstimator.html
PeakTypeEstimator <- R6Class(classname = "PeakTypeEstimator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakTypeEstimator()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeakTypeEstimator) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeakTypeEstimator()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeakWidthEstimator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeakWidthEstimator.html
PeakWidthEstimator <- R6Class(classname = "PeakWidthEstimator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeakWidthEstimator(MSExperiment exp_picked, libcpp_vector[libcpp_vector[PeakBoundary]] & boundaries)
    initialize = function(exp_picked, boundaries){
    
    if(missing(boundaries)){
         if( "python.builtin.object" %in% class(exp_picked) && class_to_wrap(exp_picked) == PeakWidthEstimator ) { private$py_obj <- exp_picked }
         else { stop("arg wrong type") }
      } else {
        if(!(is.R6(exp_picked) && class(exp_picked)[1] == "MSExperiment")){ stop("arg exp_picked wrong type") }
        if(!(is_list(boundaries) && all(sapply(boundaries,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "PeakBoundary")))))){ stop("arg boundaries wrong type") }
    
        v1 <- r_to_py(boundaries)
    
        private$py_obj <- Pymod$PeakWidthEstimator(exp_picked, v1)
        invisible()
    }
        v1 <- py_to_r(v1)
        byref_1 <- map_depth(v1,listDepth(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: double getPeakWidth(double mz)
    getPeakWidth = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        py_ans = private$py_obj$getPeakWidth(mz)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _PenaltyFactorsIntensity
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PenaltyFactorsIntensity.html
PenaltyFactorsIntensity <- R6Class(classname = "PenaltyFactorsIntensity",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        height = function(height){
    
        if(!missing(height)){
            if(!(is_scalar_double(height))){ stop("arg height wrong type") }
        
        
            private$py_obj$height <- height
            } else {
        
                py_ans = private$py_obj$height
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PenaltyFactorsIntensity()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PenaltyFactorsIntensity()
        invisible()
    
    
    },
    
    # C++ signature: void PenaltyFactorsIntensity(PenaltyFactorsIntensity)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PenaltyFactorsIntensity")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PenaltyFactorsIntensity(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PenaltyFactorsIntensity()
    # C++ signature: void PenaltyFactorsIntensity(PenaltyFactorsIntensity)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PenaltyFactorsIntensity")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PenaltyFactorsIntensity" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _PepXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PepXMLFile.html
PepXMLFile <- R6Class(classname = "PepXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PepXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PepXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PepXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    load_0 = function(filename, protein_ids, peptide_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
        private$py_obj$`_load_0`(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String experiment_name)
    load_1 = function(filename, protein_ids, peptide_ids, experiment_name){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!((is.R6(experiment_name) && class(experiment_name)[1]=="String") || is_scalar_character(experiment_name))){ stop("arg experiment_name wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
    
        private$py_obj$`_load_1`(filename, v1, v2, experiment_name)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String experiment_name, SpectrumMetaDataLookup lookup)
    load_2 = function(filename, protein_ids, peptide_ids, experiment_name, lookup){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!((is.R6(experiment_name) && class(experiment_name)[1]=="String") || is_scalar_character(experiment_name))){ stop("arg experiment_name wrong type") }
        if(!(is.R6(lookup) && class(lookup)[1] == "SpectrumMetaDataLookup")){ stop("arg lookup wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
    
    
        private$py_obj$`_load_2`(filename, v1, v2, experiment_name, lookup)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String experiment_name)
    # C++ signature: void load(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String experiment_name, SpectrumMetaDataLookup lookup)
    load = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$load_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$load_1(...) }
        else if ((length(arg_list)==5) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]])) && (is.R6(arg_list[[5]]) && class(arg_list[[5]])[1] == "SpectrumMetaDataLookup")) { self$load_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    store_0 = function(filename, protein_ids, peptide_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
        private$py_obj$`_store_0`(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String mz_file, String mz_name, bool peptideprophet_analyzed, double rt_tolerance)
    store_1 = function(filename, protein_ids, peptide_ids, mz_file, mz_name, peptideprophet_analyzed, rt_tolerance){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(protein_ids) && all(sapply(protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg protein_ids wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!((is.R6(mz_file) && class(mz_file)[1]=="String") || is_scalar_character(mz_file))){ stop("arg mz_file wrong type") }
        if(!((is.R6(mz_name) && class(mz_name)[1]=="String") || is_scalar_character(mz_name))){ stop("arg mz_name wrong type") }
        if(!( (is_scalar_integer(peptideprophet_analyzed) || is_scalar_double(peptideprophet_analyzed)) && peptideprophet_analyzed == as.integer(peptideprophet_analyzed))){ stop("arg peptideprophet_analyzed wrong type") }
        if(!(is_scalar_double(rt_tolerance))){ stop("arg rt_tolerance wrong type") }
    
        v1 <- r_to_py(protein_ids)
        v2 <- r_to_py(peptide_ids)
    
    
    
    
        private$py_obj$`_store_1`(filename, v1, v2, mz_file, mz_name, as.integer(peptideprophet_analyzed), rt_tolerance)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_ids <- byref_1))
        eval.parent(substitute(peptide_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids)
    # C++ signature: void store(String filename, libcpp_vector[ProteinIdentification] & protein_ids, libcpp_vector[PeptideIdentification] & peptide_ids, String mz_file, String mz_name, bool peptideprophet_analyzed, double rt_tolerance)
    store = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$store_0(...) }
        else if ((length(arg_list)==7) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]])) && ((is.R6(arg_list[[5]]) && class(arg_list[[5]])[1]=="String") || is_scalar_character(arg_list[[5]])) && ( (is_scalar_integer(arg_list[[6]]) || is_scalar_double(arg_list[[6]])) && arg_list[[6]] == as.integer(arg_list[[6]])) && (is_scalar_double(arg_list[[7]]))) { self$store_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void keepNativeSpectrumName(bool keep)
    keepNativeSpectrumName = function(keep){
    
        if(!( (is_scalar_integer(keep) || is_scalar_double(keep)) && keep == as.integer(keep))){ stop("arg keep wrong type") }
    
        private$py_obj$keepNativeSpectrumName(as.integer(keep))
        invisible()
    }
)
) 

# R implementation of _PepXMLFileMascot
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PepXMLFileMascot.html
PepXMLFileMascot <- R6Class(classname = "PepXMLFileMascot",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PepXMLFileMascot()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PepXMLFileMascot) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PepXMLFileMascot()
        invisible()
    }
    
    }
)
) 

# R implementation of _Peptide
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Peptide.html
Peptide <- R6Class(classname = "Peptide",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        rts = function(rts){
    
        if(!missing(rts)){
            if(!(is_list(rts) && all(sapply(rts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "RetentionTime")))){ stop("arg rts wrong type") }
        
            v0 <- r_to_py(rts)
            private$py_obj$rts <- v0
            } else {
            
                py_ans = private$py_obj$rts
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        protein_refs = function(protein_refs){
    
        if(!missing(protein_refs)){
            if(!(is_list(protein_refs) && all(sapply(protein_refs),is_scalar_character))){ stop("arg protein_refs wrong type") }
        
            v0 = r_to_py(modify_depth(protein_refs,1,py_builtin$bytes(protein_refs,'utf-8')))
            private$py_obj$protein_refs <- v0
            } else {
        
                py_ans = private$py_obj$protein_refs
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        evidence = function(evidence){
    
        if(!missing(evidence)){
            if(!(is.R6(evidence) && class(evidence)[1] == "CVTermList")){ stop("arg evidence wrong type") }
        
        
            private$py_obj$evidence <- evidence
            } else {
        
                py_ans = private$py_obj$evidence
            r_result = CVTermList$new(py_ans)
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = py_ans
                return(r_result)
                }
        },
        mods = function(mods){
    
        if(!missing(mods)){
            if(!(is_list(mods) && all(sapply(mods,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TargetedExperiment_Modification")))){ stop("arg mods wrong type") }
        
            v0 <- r_to_py(mods)
            private$py_obj$mods <- v0
            } else {
            
                py_ans = private$py_obj$mods
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Peptide()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Peptide()
        invisible()
    
    
    },
    
    # C++ signature: void Peptide(Peptide)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Peptide")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Peptide(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Peptide()
    # C++ signature: void Peptide(Peptide)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Peptide")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Peptide" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setPeptideGroupLabel(String label)
    setPeptideGroupLabel = function(label){
    
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
        private$py_obj$setPeptideGroupLabel(label)
        invisible()
    },
    
    # C++ signature: String getPeptideGroupLabel()
    getPeptideGroupLabel = function(){
    
        py_ans = private$py_obj$getPeptideGroupLabel()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setChargeState(int charge)
    setChargeState = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setChargeState(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getChargeState()
    getChargeState = function(){
    
        py_ans = private$py_obj$getChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasCharge()
    hasCharge = function(){
    
        py_ans = private$py_obj$hasCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRetentionTime()
    getRetentionTime = function(){
    
        py_ans = private$py_obj$getRetentionTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasRetentionTime()
    hasRetentionTime = function(){
    
        py_ans = private$py_obj$hasRetentionTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: RTType getRetentionTimeType()
    getRetentionTimeType = function(){
    
        py_ans = private$py_obj$getRetentionTimeType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: RTUnit getRetentionTimeUnit()
    getRetentionTimeUnit = function(){
    
        py_ans = private$py_obj$getRetentionTimeUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _PeptideAndProteinQuant
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideAndProteinQuant.html
PeptideAndProteinQuant <- R6Class(classname = "PeptideAndProteinQuant",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideAndProteinQuant()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideAndProteinQuant) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideAndProteinQuant()
        invisible()
    }
    
    },
    
    # C++ signature: void readQuantData(FeatureMap & map_in, ExperimentalDesign & ed)
    readQuantData_0 = function(map_in, ed){
    
        if(!(is.R6(map_in) && class(map_in)[1] == "FeatureMap")){ stop("arg map_in wrong type") }
        if(!(is.R6(ed) && class(ed)[1] == "ExperimentalDesign")){ stop("arg ed wrong type") }
    
    
        private$py_obj$`_readQuantData_0`(map_in, ed)
        invisible()
    },
    
    # C++ signature: void readQuantData(ConsensusMap & map_in, ExperimentalDesign & ed)
    readQuantData_1 = function(map_in, ed){
    
        if(!(is.R6(map_in) && class(map_in)[1] == "ConsensusMap")){ stop("arg map_in wrong type") }
        if(!(is.R6(ed) && class(ed)[1] == "ExperimentalDesign")){ stop("arg ed wrong type") }
    
    
        private$py_obj$`_readQuantData_1`(map_in, ed)
        invisible()
    },
    
    # C++ signature: void readQuantData(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides, ExperimentalDesign & ed)
    readQuantData_2 = function(proteins, peptides, ed){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is.R6(ed) && class(ed)[1] == "ExperimentalDesign")){ stop("arg ed wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(peptides)
    
        private$py_obj$`_readQuantData_2`(v0, v1, ed)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void readQuantData(FeatureMap & map_in, ExperimentalDesign & ed)
    # C++ signature: void readQuantData(ConsensusMap & map_in, ExperimentalDesign & ed)
    # C++ signature: void readQuantData(libcpp_vector[ProteinIdentification] & proteins, libcpp_vector[PeptideIdentification] & peptides, ExperimentalDesign & ed)
    readQuantData = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ExperimentalDesign")) { self$readQuantData_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ExperimentalDesign")) { self$readQuantData_1(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "ExperimentalDesign")) { self$readQuantData_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void quantifyPeptides(libcpp_vector[PeptideIdentification] & peptides)
    quantifyPeptides = function(peptides){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        v0 <- r_to_py(peptides)
        private$py_obj$quantifyPeptides(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void quantifyProteins(ProteinIdentification & proteins)
    quantifyProteins = function(proteins){
    
        if(!(is.R6(proteins) && class(proteins)[1] == "ProteinIdentification")){ stop("arg proteins wrong type") }
    
        private$py_obj$quantifyProteins(proteins)
        invisible()
    },
    
    # C++ signature: PeptideAndProteinQuant_Statistics getStatistics()
    getStatistics = function(){
    
        py_ans = private$py_obj$getStatistics()
        r_ans = PeptideAndProteinQuant_Statistics$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PeptideAndProteinQuant_PeptideData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideAndProteinQuant_PeptideData.html
PeptideAndProteinQuant_PeptideData <- R6Class(classname = "PeptideAndProteinQuant_PeptideData",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        accessions = function(accessions){
    
        if(!missing(accessions)){
            if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character) && !any(duplicated(accessions) == T))){ stop("arg accessions wrong type") }
        
            v0 = py_builtin$set(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
            private$py_obj$accessions <- v0
            } else {
        
                py_ans = private$py_obj$accessions
            r_result = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
                return(r_result)
                }
        },
        psm_count = function(psm_count){
    
        if(!missing(psm_count)){
            if(!( (is_scalar_integer(psm_count) || is_scalar_double(psm_count)) && psm_count == as.integer(psm_count))){ stop("arg psm_count wrong type") }
        
        
            private$py_obj$psm_count <- as.integer(psm_count)
            } else {
        
                py_ans = private$py_obj$psm_count
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideAndProteinQuant_PeptideData()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideAndProteinQuant_PeptideData) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideAndProteinQuant_PeptideData()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeptideAndProteinQuant_ProteinData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideAndProteinQuant_ProteinData.html
PeptideAndProteinQuant_ProteinData <- R6Class(classname = "PeptideAndProteinQuant_ProteinData",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        psm_count = function(psm_count){
    
        if(!missing(psm_count)){
            if(!( (is_scalar_integer(psm_count) || is_scalar_double(psm_count)) && psm_count == as.integer(psm_count))){ stop("arg psm_count wrong type") }
        
        
            private$py_obj$psm_count <- as.integer(psm_count)
            } else {
        
                py_ans = private$py_obj$psm_count
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideAndProteinQuant_ProteinData()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideAndProteinQuant_ProteinData) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideAndProteinQuant_ProteinData()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeptideAndProteinQuant_Statistics
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideAndProteinQuant_Statistics.html
PeptideAndProteinQuant_Statistics <- R6Class(classname = "PeptideAndProteinQuant_Statistics",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        n_samples = function(n_samples){
    
        if(!missing(n_samples)){
            if(!( (is_scalar_integer(n_samples) || is_scalar_double(n_samples)) && n_samples == as.integer(n_samples))){ stop("arg n_samples wrong type") }
        
        
            private$py_obj$n_samples <- as.integer(n_samples)
            } else {
        
                py_ans = private$py_obj$n_samples
                r_result = py_ans
                return(r_result)
                }
        },
        quant_proteins = function(quant_proteins){
    
        if(!missing(quant_proteins)){
            if(!( (is_scalar_integer(quant_proteins) || is_scalar_double(quant_proteins)) && quant_proteins == as.integer(quant_proteins))){ stop("arg quant_proteins wrong type") }
        
        
            private$py_obj$quant_proteins <- as.integer(quant_proteins)
            } else {
        
                py_ans = private$py_obj$quant_proteins
                r_result = py_ans
                return(r_result)
                }
        },
        too_few_peptides = function(too_few_peptides){
    
        if(!missing(too_few_peptides)){
            if(!( (is_scalar_integer(too_few_peptides) || is_scalar_double(too_few_peptides)) && too_few_peptides == as.integer(too_few_peptides))){ stop("arg too_few_peptides wrong type") }
        
        
            private$py_obj$too_few_peptides <- as.integer(too_few_peptides)
            } else {
        
                py_ans = private$py_obj$too_few_peptides
                r_result = py_ans
                return(r_result)
                }
        },
        quant_peptides = function(quant_peptides){
    
        if(!missing(quant_peptides)){
            if(!( (is_scalar_integer(quant_peptides) || is_scalar_double(quant_peptides)) && quant_peptides == as.integer(quant_peptides))){ stop("arg quant_peptides wrong type") }
        
        
            private$py_obj$quant_peptides <- as.integer(quant_peptides)
            } else {
        
                py_ans = private$py_obj$quant_peptides
                r_result = py_ans
                return(r_result)
                }
        },
        total_peptides = function(total_peptides){
    
        if(!missing(total_peptides)){
            if(!( (is_scalar_integer(total_peptides) || is_scalar_double(total_peptides)) && total_peptides == as.integer(total_peptides))){ stop("arg total_peptides wrong type") }
        
        
            private$py_obj$total_peptides <- as.integer(total_peptides)
            } else {
        
                py_ans = private$py_obj$total_peptides
                r_result = py_ans
                return(r_result)
                }
        },
        quant_features = function(quant_features){
    
        if(!missing(quant_features)){
            if(!( (is_scalar_integer(quant_features) || is_scalar_double(quant_features)) && quant_features == as.integer(quant_features))){ stop("arg quant_features wrong type") }
        
        
            private$py_obj$quant_features <- as.integer(quant_features)
            } else {
        
                py_ans = private$py_obj$quant_features
                r_result = py_ans
                return(r_result)
                }
        },
        total_features = function(total_features){
    
        if(!missing(total_features)){
            if(!( (is_scalar_integer(total_features) || is_scalar_double(total_features)) && total_features == as.integer(total_features))){ stop("arg total_features wrong type") }
        
        
            private$py_obj$total_features <- as.integer(total_features)
            } else {
        
                py_ans = private$py_obj$total_features
                r_result = py_ans
                return(r_result)
                }
        },
        blank_features = function(blank_features){
    
        if(!missing(blank_features)){
            if(!( (is_scalar_integer(blank_features) || is_scalar_double(blank_features)) && blank_features == as.integer(blank_features))){ stop("arg blank_features wrong type") }
        
        
            private$py_obj$blank_features <- as.integer(blank_features)
            } else {
        
                py_ans = private$py_obj$blank_features
                r_result = py_ans
                return(r_result)
                }
        },
        ambig_features = function(ambig_features){
    
        if(!missing(ambig_features)){
            if(!( (is_scalar_integer(ambig_features) || is_scalar_double(ambig_features)) && ambig_features == as.integer(ambig_features))){ stop("arg ambig_features wrong type") }
        
        
            private$py_obj$ambig_features <- as.integer(ambig_features)
            } else {
        
                py_ans = private$py_obj$ambig_features
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideAndProteinQuant_Statistics()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideAndProteinQuant_Statistics) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideAndProteinQuant_Statistics()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeptideEntry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideEntry.html
PeptideEntry <- R6Class(classname = "PeptideEntry",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        traversed = function(traversed){
    
        if(!missing(traversed)){
            if(!( (is_scalar_integer(traversed) || is_scalar_double(traversed)) && traversed == as.integer(traversed))){ stop("arg traversed wrong type") }
        
        
            private$py_obj$traversed <- as.integer(traversed)
            } else {
        
                py_ans = private$py_obj$traversed
                r_result = py_ans
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = py_ans
                return(r_result)
                }
        },
        peptide_identification = function(peptide_identification){
    
        if(!missing(peptide_identification)){
            if(!( (is_scalar_integer(peptide_identification) || is_scalar_double(peptide_identification)) && peptide_identification == as.integer(peptide_identification))){ stop("arg peptide_identification wrong type") }
        
        
            private$py_obj$peptide_identification <- as.integer(peptide_identification)
            } else {
        
                py_ans = private$py_obj$peptide_identification
                r_result = py_ans
                return(r_result)
                }
        },
        peptide_hit = function(peptide_hit){
    
        if(!missing(peptide_hit)){
            if(!( (is_scalar_integer(peptide_hit) || is_scalar_double(peptide_hit)) && peptide_hit == as.integer(peptide_hit))){ stop("arg peptide_hit wrong type") }
        
        
            private$py_obj$peptide_hit <- as.integer(peptide_hit)
            } else {
        
                py_ans = private$py_obj$peptide_hit
                r_result = py_ans
                return(r_result)
                }
        },
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        },
        msd_group = function(msd_group){
    
        if(!missing(msd_group)){
            if(!( (is_scalar_integer(msd_group) || is_scalar_double(msd_group)) && msd_group == as.integer(msd_group))){ stop("arg msd_group wrong type") }
        
        
            private$py_obj$msd_group <- as.integer(msd_group)
            } else {
        
                py_ans = private$py_obj$msd_group
                r_result = py_ans
                return(r_result)
                }
        },
        isd_group = function(isd_group){
    
        if(!missing(isd_group)){
            if(!( (is_scalar_integer(isd_group) || is_scalar_double(isd_group)) && isd_group == as.integer(isd_group))){ stop("arg isd_group wrong type") }
        
        
            private$py_obj$isd_group <- as.integer(isd_group)
            } else {
        
                py_ans = private$py_obj$isd_group
                r_result = py_ans
                return(r_result)
                }
        },
        experimental = function(experimental){
    
        if(!missing(experimental)){
            if(!( (is_scalar_integer(experimental) || is_scalar_double(experimental)) && experimental == as.integer(experimental))){ stop("arg experimental wrong type") }
        
        
            private$py_obj$experimental <- as.integer(experimental)
            } else {
        
                py_ans = private$py_obj$experimental
                r_result = py_ans
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        
        
            private$py_obj$intensity <- intensity
            } else {
        
                py_ans = private$py_obj$intensity
                r_result = py_ans
                return(r_result)
                }
        },
        origin = function(origin){
    
        if(!missing(origin)){
            if(!((is.R6(origin) && class(origin)[1]=="String") || is_scalar_character(origin))){ stop("arg origin wrong type") }
        
        
            private$py_obj$origin <- origin
            } else {
        
                py_ans = private$py_obj$origin
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideEntry()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideEntry) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideEntry()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeptideEvidence
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideEvidence.html
PeptideEvidence <- R6Class(classname = "PeptideEvidence",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideEvidence()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeptideEvidence()
        invisible()
    
    
    },
    
    # C++ signature: void PeptideEvidence(PeptideEvidence)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeptideEvidence")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeptideEvidence(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeptideEvidence()
    # C++ signature: void PeptideEvidence(PeptideEvidence)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeptideEvidence")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeptideEvidence" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setStart(int start)
    setStart = function(start){
    
        if(!( (is_scalar_integer(start) || is_scalar_double(start)) && start == as.integer(start))){ stop("arg start wrong type") }
    
        private$py_obj$setStart(as.integer(start))
        invisible()
    },
    
    # C++ signature: int getStart()
    getStart = function(){
    
        py_ans = private$py_obj$getStart()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnd(int end)
    setEnd = function(end){
    
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
    
        private$py_obj$setEnd(as.integer(end))
        invisible()
    },
    
    # C++ signature: int getEnd()
    getEnd = function(){
    
        py_ans = private$py_obj$getEnd()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAABefore(char rhs)
    setAABefore = function(rhs){
    
        if(!(is_scalar_character(rhs))){ stop("arg rhs wrong type") }
    py_run_string("rhs = bytes(rhs)")
        private$py_obj$setAABefore(py$rhs)
        py_run_string("del rhs")
        invisible()
    },
    
    # C++ signature: char getAABefore()
    getAABefore = function(){
    
        py_ans = private$py_obj$getAABefore()
        r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAAAfter(char rhs)
    setAAAfter = function(rhs){
    
        if(!(is_scalar_character(rhs))){ stop("arg rhs wrong type") }
    py_run_string("rhs = bytes(rhs)")
        private$py_obj$setAAAfter(py$rhs)
        py_run_string("del rhs")
        invisible()
    },
    
    # C++ signature: char getAAAfter()
    getAAAfter = function(){
    
        py_ans = private$py_obj$getAAAfter()
        r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setProteinAccession(String s)
    setProteinAccession = function(s){
    
        if(!((is.R6(s) && class(s)[1]=="String") || is_scalar_character(s))){ stop("arg s wrong type") }
    
        private$py_obj$setProteinAccession(s)
        invisible()
    },
    
    # C++ signature: String getProteinAccession()
    getProteinAccession = function(){
    
        py_ans = private$py_obj$getProteinAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasValidLimits()
    hasValidLimits = function(){
    
        py_ans = private$py_obj$hasValidLimits()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _PeptideHit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideHit.html
PeptideHit <- R6Class(classname = "PeptideHit",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideHit()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeptideHit()
        invisible()
    
    
    },
    
    # C++ signature: void PeptideHit(double score, unsigned int rank, int charge, AASequence sequence)
    init_1 = function(score, rank, charge, sequence){
    
        if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!(is.R6(sequence) && class(sequence)[1] == "AASequence")){ stop("arg sequence wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$PeptideHit(score, as.integer(rank), as.integer(charge), sequence)
        invisible()
    
    
    },
    
    # C++ signature: void PeptideHit()
    # C++ signature: void PeptideHit(double score, unsigned int rank, int charge, AASequence sequence)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "AASequence")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeptideHit" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getScore()
    getScore = function(){
    
        py_ans = private$py_obj$getScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getRank()
    getRank = function(){
    
        py_ans = private$py_obj$getRank()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: AASequence getSequence()
    getSequence = function(){
    
        py_ans = private$py_obj$getSequence()
        r_ans = AASequence$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideEvidence] getPeptideEvidences()
    getPeptideEvidences = function(){
    
        py_ans = private$py_obj$getPeptideEvidences()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideEvidences(libcpp_vector[PeptideEvidence])
    setPeptideEvidences = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideEvidence")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPeptideEvidences(v0)
        
        invisible()
    },
    
    # C++ signature: void addPeptideEvidence(PeptideEvidence)
    addPeptideEvidence = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeptideEvidence")){ stop("arg in_0 wrong type") }
    
        private$py_obj$addPeptideEvidence(in_0)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] extractProteinAccessionsSet()
    extractProteinAccessionsSet = function(){
    
        py_ans = private$py_obj$extractProteinAccessionsSet()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setAnalysisResults(libcpp_vector[PeptideHit_AnalysisResult] aresult)
    setAnalysisResults = function(aresult){
    
        if(!(is_list(aresult) && all(sapply(aresult,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_AnalysisResult")))){ stop("arg aresult wrong type") }
        v0 <- r_to_py(aresult)
        private$py_obj$setAnalysisResults(v0)
        
        invisible()
    },
    
    # C++ signature: void addAnalysisResults(PeptideHit_AnalysisResult aresult)
    addAnalysisResults = function(aresult){
    
        if(!(is.R6(aresult) && class(aresult)[1] == "PeptideHit_AnalysisResult")){ stop("arg aresult wrong type") }
    
        private$py_obj$addAnalysisResults(aresult)
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideHit_AnalysisResult] getAnalysisResults()
    getAnalysisResults = function(){
    
        py_ans = private$py_obj$getAnalysisResults()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeakAnnotations(libcpp_vector[PeptideHit_PeakAnnotation])
    setPeakAnnotations = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_PeakAnnotation")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPeakAnnotations(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideHit_PeakAnnotation] getPeakAnnotations()
    getPeakAnnotations = function(){
    
        py_ans = private$py_obj$getPeakAnnotations()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setScore(double)
    setScore = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setScore(in_0)
        invisible()
    },
    
    # C++ signature: void setRank(unsigned int)
    setRank = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRank(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: void setSequence(AASequence)
    setSequence = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AASequence")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSequence(in_0)
        invisible()
    },
    
    # C++ signature: void setCharge(int)
    setCharge = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setCharge(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _PeptideHit_AnalysisResult
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideHit_AnalysisResult.html
PeptideHit_AnalysisResult <- R6Class(classname = "PeptideHit_AnalysisResult",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        score_type = function(score_type){
    
        if(!missing(score_type)){
            if(!((is.R6(score_type) && class(score_type)[1]=="String") || is_scalar_character(score_type))){ stop("arg score_type wrong type") }
        
        
            private$py_obj$score_type <- score_type
            } else {
        
                py_ans = private$py_obj$score_type
            r_result = py_ans
                return(r_result)
                }
        },
        higher_is_better = function(higher_is_better){
    
        if(!missing(higher_is_better)){
            if(!( (is_scalar_integer(higher_is_better) || is_scalar_double(higher_is_better)) && higher_is_better == as.integer(higher_is_better))){ stop("arg higher_is_better wrong type") }
        
        
            private$py_obj$higher_is_better <- as.integer(higher_is_better)
            } else {
        
                py_ans = private$py_obj$higher_is_better
                r_result = py_ans
                return(r_result)
                }
        },
        main_score = function(main_score){
    
        if(!missing(main_score)){
            if(!(is_scalar_double(main_score))){ stop("arg main_score wrong type") }
        
        
            private$py_obj$main_score <- main_score
            } else {
        
                py_ans = private$py_obj$main_score
                r_result = py_ans
                return(r_result)
                }
        },
        sub_scores = function(sub_scores){
    
        if(!missing(sub_scores)){
            if(!(
          is.environment(sub_scores) && identical(parent.env(sub_scores), asNamespace("collections")) && identical(strsplit(capture.output(sub_scores$print())," ")[[1]][1], "dict")
          && all(sapply(sub_scores$keys(),function(k) (is.R6(k) && class(k)[1]=="String") || is_scalar_character(k)))
          && all(sapply(sub_scores$values(),function(v) is_scalar_double(v)))
          )){ stop("arg sub_scores wrong type") }
        
            v0 <- py_dict(sub_scores$keys(),sub_scores$values())
            private$py_obj$sub_scores <- v0
            } else {
        
                py_ans = private$py_obj$sub_scores
            r_result <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),lapply(py_to_r(py_builtin$list(py_ans$keys())),function(i) String$new(i)))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideHit_AnalysisResult()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideHit_AnalysisResult) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideHit_AnalysisResult()
        invisible()
    }
    
    }
)
) 

# R implementation of _PeptideHit_PeakAnnotation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideHit_PeakAnnotation.html
PeptideHit_PeakAnnotation <- R6Class(classname = "PeptideHit_PeakAnnotation",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        annotation = function(annotation){
    
        if(!missing(annotation)){
            if(!((is.R6(annotation) && class(annotation)[1]=="String") || is_scalar_character(annotation))){ stop("arg annotation wrong type") }
        
        
            private$py_obj$annotation <- annotation
            } else {
        
                py_ans = private$py_obj$annotation
            r_result = py_ans
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        },
        mz = function(mz){
    
        if(!missing(mz)){
            if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        
        
            private$py_obj$mz <- mz
            } else {
        
                py_ans = private$py_obj$mz
                r_result = py_ans
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        
        
            private$py_obj$intensity <- intensity
            } else {
        
                py_ans = private$py_obj$intensity
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideHit_PeakAnnotation()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideHit_PeakAnnotation) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideHit_PeakAnnotation()
        invisible()
    }
    
    },
    
    # C++ signature: void writePeakAnnotationsString_(String & annotation_string, libcpp_vector[PeptideHit_PeakAnnotation] annotations)
    writePeakAnnotationsString_ = function(annotation_string, annotations){
    
        if(!((is.R6(annotation_string) && class(annotation_string)[1]=="String") || is_scalar_character(annotation_string))){ stop("arg annotation_string wrong type") }
        if(!(is_list(annotations) && all(sapply(annotations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit_PeakAnnotation")))){ stop("arg annotations wrong type") }
    
        v1 <- r_to_py(annotations)
        private$py_obj$writePeakAnnotationsString_(annotation_string, v1)
        
        invisible()
    }
)
) 

# R implementation of _PeptideIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideIdentification.html
PeptideIdentification <- R6Class(classname = "PeptideIdentification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideIdentification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PeptideIdentification()
        invisible()
    
    
    },
    
    # C++ signature: void PeptideIdentification(PeptideIdentification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeptideIdentification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PeptideIdentification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PeptideIdentification()
    # C++ signature: void PeptideIdentification(PeptideIdentification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PeptideIdentification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PeptideIdentification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[PeptideHit] getHits()
    getHits = function(){
    
        py_ans = private$py_obj$getHits()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void insertHit(PeptideHit)
    insertHit = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PeptideHit")){ stop("arg in_0 wrong type") }
    
        private$py_obj$insertHit(in_0)
        invisible()
    },
    
    # C++ signature: void setHits(libcpp_vector[PeptideHit])
    setHits = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setHits(v0)
        
        invisible()
    },
    
    # C++ signature: double getSignificanceThreshold()
    getSignificanceThreshold = function(){
    
        py_ans = private$py_obj$getSignificanceThreshold()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSignificanceThreshold(double value)
    setSignificanceThreshold = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setSignificanceThreshold(value)
        invisible()
    },
    
    # C++ signature: String getScoreType()
    getScoreType = function(){
    
        py_ans = private$py_obj$getScoreType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScoreType(String)
    setScoreType = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setScoreType(in_0)
        invisible()
    },
    
    # C++ signature: bool isHigherScoreBetter()
    isHigherScoreBetter = function(){
    
        py_ans = private$py_obj$isHigherScoreBetter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setHigherScoreBetter(bool)
    setHigherScoreBetter = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setHigherScoreBetter(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(String)
    setIdentifier = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIdentifier(in_0)
        invisible()
    },
    
    # C++ signature: bool hasMZ()
    hasMZ = function(){
    
        py_ans = private$py_obj$hasMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: bool hasRT()
    hasRT = function(){
    
        py_ans = private$py_obj$hasRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: String getBaseName()
    getBaseName = function(){
    
        py_ans = private$py_obj$getBaseName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setBaseName(String)
    setBaseName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setBaseName(in_0)
        invisible()
    },
    
    # C++ signature: String getExperimentLabel()
    getExperimentLabel = function(){
    
        py_ans = private$py_obj$getExperimentLabel()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setExperimentLabel(String)
    setExperimentLabel = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setExperimentLabel(in_0)
        invisible()
    },
    
    # C++ signature: void assignRanks()
    assignRanks = function(){
    
        private$py_obj$assignRanks()
        invisible()
    },
    
    # C++ signature: void sort()
    sort = function(){
    
        private$py_obj$sort()
        invisible()
    },
    
    # C++ signature: void sortByRank()
    sortByRank = function(){
    
        private$py_obj$sortByRank()
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[PeptideHit] getReferencingHits(libcpp_vector[PeptideHit], libcpp_set[String] &)
    getReferencingHits = function(in_0, in_1){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1),is_scalar_character) && !any(duplicated(in_1) == T))){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(in_0)
        v1 = py_builtin$set(modify_depth(in_1,1,py_builtin$bytes(in_1,'utf-8')))
        py_ans = private$py_obj$getReferencingHits(v0, v1)
        byref_1 <- modify_depth(py_to_r(py_builtin$list(v1)),1,as.character)
        
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(in_1 <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _PeptideIndexing
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideIndexing.html
PeptideIndexing <- R6Class(classname = "PeptideIndexing",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideIndexing()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideIndexing) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideIndexing()
        invisible()
    }
    
    },
    
    # C++ signature: PeptideIndexing_ExitCodes run(libcpp_vector[FASTAEntry] & proteins, libcpp_vector[ProteinIdentification] & prot_ids, libcpp_vector[PeptideIdentification] & pep_ids)
    run = function(proteins, prot_ids, pep_ids){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg proteins wrong type") }
        if(!(is_list(prot_ids) && all(sapply(prot_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg prot_ids wrong type") }
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
        v0 <- r_to_py(proteins)
        v1 <- r_to_py(prot_ids)
        v2 <- r_to_py(pep_ids)
        py_ans = private$py_obj$run(v0, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(proteins <- byref_0))
        eval.parent(substitute(prot_ids <- byref_1))
        eval.parent(substitute(pep_ids <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: String getDecoyString()
    getDecoyString = function(){
    
        py_ans = private$py_obj$getDecoyString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isPrefix()
    isPrefix = function(){
    
        py_ans = private$py_obj$isPrefix()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PeptideProteinResolution
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideProteinResolution.html
PeptideProteinResolution <- R6Class(classname = "PeptideProteinResolution",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PeptideProteinResolution(bool statistics)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideProteinResolution) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!( (is_scalar_integer(statistics) || is_scalar_double(statistics)) && statistics == as.integer(statistics))){ stop("arg statistics wrong type") }
    
    
        private$py_obj <- Pymod$PeptideProteinResolution(as.integer(statistics))
        invisible()
    }
    
    },
    
    # C++ signature: void buildGraph(ProteinIdentification & protein, libcpp_vector[PeptideIdentification] & peptides)
    buildGraph = function(protein, peptides){
    
        if(!(is.R6(protein) && class(protein)[1] == "ProteinIdentification")){ stop("arg protein wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
    
        v1 <- r_to_py(peptides)
        private$py_obj$buildGraph(protein, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void resolveGraph(ProteinIdentification & protein, libcpp_vector[PeptideIdentification] & peptides)
    resolveGraph = function(protein, peptides){
    
        if(!(is.R6(protein) && class(protein)[1] == "ProteinIdentification")){ stop("arg protein wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
    
        v1 <- r_to_py(peptides)
        private$py_obj$resolveGraph(protein, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: PeptideProteinResolution_ConnectedComponent findConnectedComponent(size_t & root_prot_grp)
    findConnectedComponent = function(root_prot_grp){
    
        if(!( (is_scalar_integer(root_prot_grp) || is_scalar_double(root_prot_grp)) && root_prot_grp == as.integer(root_prot_grp))){ stop("arg root_prot_grp wrong type") }
    
        py_ans = private$py_obj$findConnectedComponent(as.integer(root_prot_grp))
        r_ans = PeptideProteinResolution_ConnectedComponent$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void resolveConnectedComponent(PeptideProteinResolution_ConnectedComponent & conn_comp, ProteinIdentification & protein, libcpp_vector[PeptideIdentification] & peptides)
    resolveConnectedComponent = function(conn_comp, protein, peptides){
    
        if(!(is.R6(conn_comp) && class(conn_comp)[1] == "PeptideProteinResolution_ConnectedComponent")){ stop("arg conn_comp wrong type") }
        if(!(is.R6(protein) && class(protein)[1] == "ProteinIdentification")){ stop("arg protein wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
    
    
        v2 <- r_to_py(peptides)
        private$py_obj$resolveConnectedComponent(conn_comp, protein, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _PeptideProteinResolution_ConnectedComponent
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PeptideProteinResolution_ConnectedComponent.html
PeptideProteinResolution_ConnectedComponent <- R6Class(classname = "PeptideProteinResolution_ConnectedComponent",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        prot_grp_indices = function(prot_grp_indices){
    
        if(!missing(prot_grp_indices)){
            if(!(is_list(prot_grp_indices) && all(sapply(prot_grp_indices,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(prot_grp_indices)))){ stop("arg prot_grp_indices wrong type") }
        
            py$v0 <- prot_grp_indices
            py_run_string("v0 = [int(t) for t in v0];v0 = set(v0)")
            private$py_obj$prot_grp_indices <- py$v0
            } else {
        
                py_ans = private$py_obj$prot_grp_indices
            py$res <- py_ans
            r_result = as.list(py_eval("list(res)"))
            py_run_string("del res;gc.collect()")
                return(r_result)
                }
        },
        pep_indices = function(pep_indices){
    
        if(!missing(pep_indices)){
            if(!(is_list(pep_indices) && all(sapply(pep_indices,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(pep_indices)))){ stop("arg pep_indices wrong type") }
        
            py$v0 <- pep_indices
            py_run_string("v0 = [int(t) for t in v0];v0 = set(v0)")
            private$py_obj$pep_indices <- py$v0
            } else {
        
                py_ans = private$py_obj$pep_indices
            py$res <- py_ans
            r_result = as.list(py_eval("list(res)"))
            py_run_string("del res;gc.collect()")
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PeptideProteinResolution_ConnectedComponent()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PeptideProteinResolution_ConnectedComponent) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PeptideProteinResolution_ConnectedComponent()
        invisible()
    }
    
    }
)
) 

# R implementation of _PercolatorFeatureSetHelper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PercolatorFeatureSetHelper.html
PercolatorFeatureSetHelper <- R6Class(classname = "PercolatorFeatureSetHelper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void concatMULTISEPeptideIds(libcpp_vector[PeptideIdentification] & all_peptide_ids, libcpp_vector[PeptideIdentification] & new_peptide_ids, String search_engine)
    concatMULTISEPeptideIds = function(all_peptide_ids, new_peptide_ids, search_engine){
    
        if(!(is_list(all_peptide_ids) && all(sapply(all_peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg all_peptide_ids wrong type") }
        if(!(is_list(new_peptide_ids) && all(sapply(new_peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg new_peptide_ids wrong type") }
        if(!((is.R6(search_engine) && class(search_engine)[1]=="String") || is_scalar_character(search_engine))){ stop("arg search_engine wrong type") }
        v0 <- r_to_py(all_peptide_ids)
        v1 <- r_to_py(new_peptide_ids)
    
        private$py_obj$concatMULTISEPeptideIds(v0, v1, search_engine)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(all_peptide_ids <- byref_0))
        eval.parent(substitute(new_peptide_ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void mergeMULTISEPeptideIds(libcpp_vector[PeptideIdentification] & all_peptide_ids, libcpp_vector[PeptideIdentification] & new_peptide_ids, String search_engine)
    mergeMULTISEPeptideIds = function(all_peptide_ids, new_peptide_ids, search_engine){
    
        if(!(is_list(all_peptide_ids) && all(sapply(all_peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg all_peptide_ids wrong type") }
        if(!(is_list(new_peptide_ids) && all(sapply(new_peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg new_peptide_ids wrong type") }
        if(!((is.R6(search_engine) && class(search_engine)[1]=="String") || is_scalar_character(search_engine))){ stop("arg search_engine wrong type") }
        v0 <- r_to_py(all_peptide_ids)
        v1 <- r_to_py(new_peptide_ids)
    
        private$py_obj$mergeMULTISEPeptideIds(v0, v1, search_engine)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(all_peptide_ids <- byref_0))
        eval.parent(substitute(new_peptide_ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void mergeMULTISEProteinIds(libcpp_vector[ProteinIdentification] & all_protein_ids, libcpp_vector[ProteinIdentification] & new_protein_ids)
    mergeMULTISEProteinIds = function(all_protein_ids, new_protein_ids){
    
        if(!(is_list(all_protein_ids) && all(sapply(all_protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg all_protein_ids wrong type") }
        if(!(is_list(new_protein_ids) && all(sapply(new_protein_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg new_protein_ids wrong type") }
        v0 <- r_to_py(all_protein_ids)
        v1 <- r_to_py(new_protein_ids)
        private$py_obj$mergeMULTISEProteinIds(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(all_protein_ids <- byref_0))
        eval.parent(substitute(new_protein_ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addMSGFFeatures(libcpp_vector[PeptideIdentification] & peptide_ids, StringList & feature_set)
    addMSGFFeatures = function(peptide_ids, feature_set){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
        private$py_obj$addMSGFFeatures(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(feature_set <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addXTANDEMFeatures(libcpp_vector[PeptideIdentification] & peptide_ids, StringList & feature_set)
    addXTANDEMFeatures = function(peptide_ids, feature_set){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
        private$py_obj$addXTANDEMFeatures(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(feature_set <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addCOMETFeatures(libcpp_vector[PeptideIdentification] & peptide_ids, StringList & feature_set)
    addCOMETFeatures = function(peptide_ids, feature_set){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
        private$py_obj$addCOMETFeatures(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(feature_set <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addMASCOTFeatures(libcpp_vector[PeptideIdentification] & peptide_ids, StringList & feature_set)
    addMASCOTFeatures = function(peptide_ids, feature_set){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
        private$py_obj$addMASCOTFeatures(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(feature_set <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addMULTISEFeatures(libcpp_vector[PeptideIdentification] & peptide_ids, StringList & search_engines_used, StringList & feature_set, bool complete_only, bool limits_imputation)
    addMULTISEFeatures = function(peptide_ids, search_engines_used, feature_set, complete_only, limits_imputation){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_list(search_engines_used) && all(sapply(search_engines_used),is_scalar_character))){ stop("arg search_engines_used wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        if(!( (is_scalar_integer(complete_only) || is_scalar_double(complete_only)) && complete_only == as.integer(complete_only))){ stop("arg complete_only wrong type") }
        if(!( (is_scalar_integer(limits_imputation) || is_scalar_double(limits_imputation)) && limits_imputation == as.integer(limits_imputation))){ stop("arg limits_imputation wrong type") }
        v0 <- r_to_py(peptide_ids)
        v1 = r_to_py(modify_depth(search_engines_used,1,py_builtin$bytes(search_engines_used,'utf-8')))
        v2 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
    
    
        private$py_obj$addMULTISEFeatures(v0, v1, v2, as.integer(complete_only), as.integer(limits_imputation))
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        eval.parent(substitute(search_engines_used <- byref_1))
        eval.parent(substitute(feature_set <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addCONCATSEFeatures(libcpp_vector[PeptideIdentification] & peptide_id_list, StringList & search_engines_used, StringList & feature_set)
    addCONCATSEFeatures = function(peptide_id_list, search_engines_used, feature_set){
    
        if(!(is_list(peptide_id_list) && all(sapply(peptide_id_list,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_id_list wrong type") }
        if(!(is_list(search_engines_used) && all(sapply(search_engines_used),is_scalar_character))){ stop("arg search_engines_used wrong type") }
        if(!(is_list(feature_set) && all(sapply(feature_set),is_scalar_character))){ stop("arg feature_set wrong type") }
        v0 <- r_to_py(peptide_id_list)
        v1 = r_to_py(modify_depth(search_engines_used,1,py_builtin$bytes(search_engines_used,'utf-8')))
        v2 = r_to_py(modify_depth(feature_set,1,py_builtin$bytes(feature_set,'utf-8')))
        private$py_obj$addCONCATSEFeatures(v0, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_id_list <- byref_0))
        eval.parent(substitute(search_engines_used <- byref_1))
        eval.parent(substitute(feature_set <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void checkExtraFeatures(libcpp_vector[PeptideHit] & psms, StringList & extra_features)
    checkExtraFeatures = function(psms, extra_features){
    
        if(!(is_list(psms) && all(sapply(psms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideHit")))){ stop("arg psms wrong type") }
        if(!(is_list(extra_features) && all(sapply(extra_features),is_scalar_character))){ stop("arg extra_features wrong type") }
        v0 <- r_to_py(psms)
        v1 = r_to_py(modify_depth(extra_features,1,py_builtin$bytes(extra_features,'utf-8')))
        private$py_obj$checkExtraFeatures(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(psms <- byref_0))
        eval.parent(substitute(extra_features <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _PercolatorOutfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PercolatorOutfile.html
PercolatorOutfile <- R6Class(classname = "PercolatorOutfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PercolatorOutfile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PercolatorOutfile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PercolatorOutfile()
        invisible()
    }
    
    },
    
    # C++ signature: PercolatorOutfile_ScoreType getScoreType(String score_type_name)
    getScoreType = function(score_type_name){
    
        if(!((is.R6(score_type_name) && class(score_type_name)[1]=="String") || is_scalar_character(score_type_name))){ stop("arg score_type_name wrong type") }
    
        py_ans = private$py_obj$getScoreType(score_type_name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void load(const String & filename, ProteinIdentification & proteins, libcpp_vector[PeptideIdentification] & peptides, SpectrumMetaDataLookup & lookup, PercolatorOutfile_ScoreType output_score)
    load = function(filename, proteins, peptides, lookup, output_score){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(proteins) && class(proteins)[1] == "ProteinIdentification")){ stop("arg proteins wrong type") }
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is.R6(lookup) && class(lookup)[1] == "SpectrumMetaDataLookup")){ stop("arg lookup wrong type") }
        if(!(output_score %in% c(0, 1, 2, 3))){ stop("arg output_score wrong type") }
    
    
        v2 <- r_to_py(peptides)
    
    
        private$py_obj$load(filename, proteins, v2, lookup, as.integer(output_score))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _PlainMSDataWritingConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PlainMSDataWritingConsumer.html
PlainMSDataWritingConsumer <- R6Class(classname = "PlainMSDataWritingConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PlainMSDataWritingConsumer(String filename)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PlainMSDataWritingConsumer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$PlainMSDataWritingConsumer(filename)
        invisible()
    }
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings & exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void setExpectedSize(size_t expectedSpectra, size_t expectedChromatograms)
    setExpectedSize = function(expectedSpectra, expectedChromatograms){
    
        if(!( (is_scalar_integer(expectedSpectra) || is_scalar_double(expectedSpectra)) && expectedSpectra == as.integer(expectedSpectra))){ stop("arg expectedSpectra wrong type") }
        if(!( (is_scalar_integer(expectedChromatograms) || is_scalar_double(expectedChromatograms)) && expectedChromatograms == as.integer(expectedChromatograms))){ stop("arg expectedChromatograms wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(expectedSpectra), as.integer(expectedChromatograms))
        invisible()
    },
    
    # C++ signature: void addDataProcessing(DataProcessing d)
    addDataProcessing = function(d){
    
        if(!(is.R6(d) && class(d)[1] == "DataProcessing")){ stop("arg d wrong type") }
    
        private$py_obj$addDataProcessing(d)
        invisible()
    },
    
    # C++ signature: size_t getNrSpectraWritten()
    getNrSpectraWritten = function(){
    
        py_ans = private$py_obj$getNrSpectraWritten()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatogramsWritten()
    getNrChromatogramsWritten = function(){
    
        py_ans = private$py_obj$getNrChromatogramsWritten()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOptions(PeakFileOptions opt)
    setOptions = function(opt){
    
        if(!(is.R6(opt) && class(opt)[1] == "PeakFileOptions")){ stop("arg opt wrong type") }
    
        private$py_obj$setOptions(opt)
        invisible()
    },
    
    # C++ signature: PeakFileOptions getOptions()
    getOptions = function(){
    
        py_ans = private$py_obj$getOptions()
        r_ans = PeakFileOptions$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _PosteriorErrorProbabilityModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1PosteriorErrorProbabilityModel.html
PosteriorErrorProbabilityModel <- R6Class(classname = "PosteriorErrorProbabilityModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PosteriorErrorProbabilityModel()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PosteriorErrorProbabilityModel) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PosteriorErrorProbabilityModel()
        invisible()
    }
    
    },
    
    # C++ signature: bool fit(libcpp_vector[double] & search_engine_scores, String outlier_handling)
    fit_0 = function(search_engine_scores, outlier_handling){
    
        if(!(is_list(search_engine_scores) && all(sapply(search_engine_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg search_engine_scores wrong type") }
        if(!((is.R6(outlier_handling) && class(outlier_handling)[1]=="String") || is_scalar_character(outlier_handling))){ stop("arg outlier_handling wrong type") }
        v0 <- r_to_py(search_engine_scores)
    
        py_ans = private$py_obj$`_fit_0`(v0, outlier_handling)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(search_engine_scores <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: bool fit(libcpp_vector[double] & search_engine_scores, libcpp_vector[double] & probabilities, String outlier_handling)
    fit_1 = function(search_engine_scores, probabilities, outlier_handling){
    
        if(!(is_list(search_engine_scores) && all(sapply(search_engine_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg search_engine_scores wrong type") }
        if(!(is_list(probabilities) && all(sapply(probabilities,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg probabilities wrong type") }
        if(!((is.R6(outlier_handling) && class(outlier_handling)[1]=="String") || is_scalar_character(outlier_handling))){ stop("arg outlier_handling wrong type") }
        v0 <- r_to_py(search_engine_scores)
        v1 <- r_to_py(probabilities)
    
        py_ans = private$py_obj$`_fit_1`(v0, v1, outlier_handling)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(search_engine_scores <- byref_0))
        eval.parent(substitute(probabilities <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: bool fit(libcpp_vector[double] & search_engine_scores, String outlier_handling)
    # C++ signature: bool fit(libcpp_vector[double] & search_engine_scores, libcpp_vector[double] & probabilities, String outlier_handling)
    fit = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$fit_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec)))) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$fit_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void fillDensities(libcpp_vector[double] & x_scores, libcpp_vector[double] & incorrect_density, libcpp_vector[double] & correct_density)
    fillDensities = function(x_scores, incorrect_density, correct_density){
    
        if(!(is_list(x_scores) && all(sapply(x_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x_scores wrong type") }
        if(!(is_list(incorrect_density) && all(sapply(incorrect_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg incorrect_density wrong type") }
        if(!(is_list(correct_density) && all(sapply(correct_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg correct_density wrong type") }
        v0 <- r_to_py(x_scores)
        v1 <- r_to_py(incorrect_density)
        v2 <- r_to_py(correct_density)
        private$py_obj$fillDensities(v0, v1, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(x_scores <- byref_0))
        eval.parent(substitute(incorrect_density <- byref_1))
        eval.parent(substitute(correct_density <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void fillLogDensities(libcpp_vector[double] & x_scores, libcpp_vector[double] & incorrect_density, libcpp_vector[double] & correct_density)
    fillLogDensities = function(x_scores, incorrect_density, correct_density){
    
        if(!(is_list(x_scores) && all(sapply(x_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x_scores wrong type") }
        if(!(is_list(incorrect_density) && all(sapply(incorrect_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg incorrect_density wrong type") }
        if(!(is_list(correct_density) && all(sapply(correct_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg correct_density wrong type") }
        v0 <- r_to_py(x_scores)
        v1 <- r_to_py(incorrect_density)
        v2 <- r_to_py(correct_density)
        private$py_obj$fillLogDensities(v0, v1, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(x_scores <- byref_0))
        eval.parent(substitute(incorrect_density <- byref_1))
        eval.parent(substitute(correct_density <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double computeLogLikelihood(libcpp_vector[double] & incorrect_density, libcpp_vector[double] & correct_density)
    computeLogLikelihood = function(incorrect_density, correct_density){
    
        if(!(is_list(incorrect_density) && all(sapply(incorrect_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg incorrect_density wrong type") }
        if(!(is_list(correct_density) && all(sapply(correct_density,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg correct_density wrong type") }
        v0 <- r_to_py(incorrect_density)
        v1 <- r_to_py(correct_density)
        py_ans = private$py_obj$computeLogLikelihood(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(incorrect_density <- byref_0))
        eval.parent(substitute(correct_density <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_pair[double,double] pos_neg_mean_weighted_posteriors(libcpp_vector[double] & x_scores, libcpp_vector[double] & incorrect_posteriors)
    pos_neg_mean_weighted_posteriors = function(x_scores, incorrect_posteriors){
    
        if(!(is_list(x_scores) && all(sapply(x_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x_scores wrong type") }
        if(!(is_list(incorrect_posteriors) && all(sapply(incorrect_posteriors,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg incorrect_posteriors wrong type") }
        v0 <- r_to_py(x_scores)
        v1 <- r_to_py(incorrect_posteriors)
        py_ans = private$py_obj$pos_neg_mean_weighted_posteriors(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = list(py_ans[[1]], py_ans[[2]])
    
        tryCatch({
        eval.parent(substitute(x_scores <- byref_0))
        eval.parent(substitute(incorrect_posteriors <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: GaussFitResult getCorrectlyAssignedFitResult()
    getCorrectlyAssignedFitResult = function(){
    
        py_ans = private$py_obj$getCorrectlyAssignedFitResult()
        r_ans = GaussFitResult$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: GaussFitResult getIncorrectlyAssignedFitResult()
    getIncorrectlyAssignedFitResult = function(){
    
        py_ans = private$py_obj$getIncorrectlyAssignedFitResult()
        r_ans = GaussFitResult$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double getNegativePrior()
    getNegativePrior = function(){
    
        py_ans = private$py_obj$getNegativePrior()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double computeProbability(double score)
    computeProbability = function(score){
    
        if(!(is_scalar_double(score))){ stop("arg score wrong type") }
    
        py_ans = private$py_obj$computeProbability(score)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: TextFile initPlots(libcpp_vector[double] & x_scores)
    initPlots = function(x_scores){
    
        if(!(is_list(x_scores) && all(sapply(x_scores,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg x_scores wrong type") }
        v0 <- r_to_py(x_scores)
        py_ans = private$py_obj$initPlots(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
        r_ans = TextFile$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(x_scores <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: String getGumbelGnuplotFormula(GaussFitResult & params)
    getGumbelGnuplotFormula = function(params){
    
        if(!(is.R6(params) && class(params)[1] == "GaussFitResult")){ stop("arg params wrong type") }
    
        py_ans = private$py_obj$getGumbelGnuplotFormula(params)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getGaussGnuplotFormula(GaussFitResult & params)
    getGaussGnuplotFormula = function(params){
    
        if(!(is.R6(params) && class(params)[1] == "GaussFitResult")){ stop("arg params wrong type") }
    
        py_ans = private$py_obj$getGaussGnuplotFormula(params)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getBothGnuplotFormula(GaussFitResult & incorrect, GaussFitResult & correct)
    getBothGnuplotFormula = function(incorrect, correct){
    
        if(!(is.R6(incorrect) && class(incorrect)[1] == "GaussFitResult")){ stop("arg incorrect wrong type") }
        if(!(is.R6(correct) && class(correct)[1] == "GaussFitResult")){ stop("arg correct wrong type") }
    
    
        py_ans = private$py_obj$getBothGnuplotFormula(incorrect, correct)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void plotTargetDecoyEstimation(libcpp_vector[double] & target, libcpp_vector[double] & decoy)
    plotTargetDecoyEstimation = function(target, decoy){
    
        if(!(is_list(target) && all(sapply(target,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg target wrong type") }
        if(!(is_list(decoy) && all(sapply(decoy,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg decoy wrong type") }
        v0 <- r_to_py(target)
        v1 <- r_to_py(decoy)
        private$py_obj$plotTargetDecoyEstimation(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(target <- byref_0))
        eval.parent(substitute(decoy <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getSmallestScore()
    getSmallestScore = function(){
    
        py_ans = private$py_obj$getSmallestScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void tryGnuplot(const String & gp_file)
    tryGnuplot = function(gp_file){
    
        if(!((is.R6(gp_file) && class(gp_file)[1]=="String") || is_scalar_character(gp_file))){ stop("arg gp_file wrong type") }
    
        private$py_obj$tryGnuplot(gp_file)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Precursor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Precursor.html
Precursor <- R6Class(classname = "Precursor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Precursor()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Precursor()
        invisible()
    
    
    },
    
    # C++ signature: void Precursor(Precursor)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Precursor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Precursor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Precursor()
    # C++ signature: void Precursor(Precursor)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Precursor")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Precursor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_set[ActivationMethod] getActivationMethods()
    getActivationMethods = function(){
    
        py_ans = private$py_obj$getActivationMethods()
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: void setActivationMethods(libcpp_set[ActivationMethod] activation_methods)
    setActivationMethods = function(activation_methods){
    
        if(!(is_list(activation_methods) && all(sapply(activation_methods,function(el) el %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))) && !(TRUE %in% duplicated(activation_methods)))){ stop("arg activation_methods wrong type") }
        py$v0 <- activation_methods
        py_run_string("v0 = [int(t) for t in v0];v0 = set(v0)")
        private$py_obj$setActivationMethods(py$v0)
        py_run_string('del v0');gc.collect()
        invisible()
    },
    
    # C++ signature: double getActivationEnergy()
    getActivationEnergy = function(){
    
        py_ans = private$py_obj$getActivationEnergy()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setActivationEnergy(double activation_energy)
    setActivationEnergy = function(activation_energy){
    
        if(!(is_scalar_double(activation_energy))){ stop("arg activation_energy wrong type") }
    
        private$py_obj$setActivationEnergy(activation_energy)
        invisible()
    },
    
    # C++ signature: double getIsolationWindowLowerOffset()
    getIsolationWindowLowerOffset = function(){
    
        py_ans = private$py_obj$getIsolationWindowLowerOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsolationWindowLowerOffset(double bound)
    setIsolationWindowLowerOffset = function(bound){
    
        if(!(is_scalar_double(bound))){ stop("arg bound wrong type") }
    
        private$py_obj$setIsolationWindowLowerOffset(bound)
        invisible()
    },
    
    # C++ signature: double getDriftTime()
    getDriftTime = function(){
    
        py_ans = private$py_obj$getDriftTime()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDriftTime(double drift_time)
    setDriftTime = function(drift_time){
    
        if(!(is_scalar_double(drift_time))){ stop("arg drift_time wrong type") }
    
        private$py_obj$setDriftTime(drift_time)
        invisible()
    },
    
    # C++ signature: double getIsolationWindowUpperOffset()
    getIsolationWindowUpperOffset = function(){
    
        py_ans = private$py_obj$getIsolationWindowUpperOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsolationWindowUpperOffset(double bound)
    setIsolationWindowUpperOffset = function(bound){
    
        if(!(is_scalar_double(bound))){ stop("arg bound wrong type") }
    
        private$py_obj$setIsolationWindowUpperOffset(bound)
        invisible()
    },
    
    # C++ signature: double getDriftTimeWindowLowerOffset()
    getDriftTimeWindowLowerOffset = function(){
    
        py_ans = private$py_obj$getDriftTimeWindowLowerOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDriftTimeWindowLowerOffset(double drift_time)
    setDriftTimeWindowLowerOffset = function(drift_time){
    
        if(!(is_scalar_double(drift_time))){ stop("arg drift_time wrong type") }
    
        private$py_obj$setDriftTimeWindowLowerOffset(drift_time)
        invisible()
    },
    
    # C++ signature: double getDriftTimeWindowUpperOffset()
    getDriftTimeWindowUpperOffset = function(){
    
        py_ans = private$py_obj$getDriftTimeWindowUpperOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDriftTimeWindowUpperOffset(double drift_time)
    setDriftTimeWindowUpperOffset = function(drift_time){
    
        if(!(is_scalar_double(drift_time))){ stop("arg drift_time wrong type") }
    
        private$py_obj$setDriftTimeWindowUpperOffset(drift_time)
        invisible()
    },
    
    # C++ signature: int getCharge()
    getCharge = function(){
    
        py_ans = private$py_obj$getCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCharge(int charge)
    setCharge = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setCharge(as.integer(charge))
        invisible()
    },
    
    # C++ signature: libcpp_vector[int] getPossibleChargeStates()
    getPossibleChargeStates = function(){
    
        py_ans = private$py_obj$getPossibleChargeStates()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setPossibleChargeStates(libcpp_vector[int] possible_charge_states)
    setPossibleChargeStates = function(possible_charge_states){
    
        if(!(is_list(possible_charge_states) && all(sapply(possible_charge_states,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg possible_charge_states wrong type") }
        v0 <- r_to_py(modify_depth(possible_charge_states,1,as.integer))
        private$py_obj$setPossibleChargeStates(v0)
        
        invisible()
    },
    
    # C++ signature: double getUnchargedMass()
    getUnchargedMass = function(){
    
        py_ans = private$py_obj$getUnchargedMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: double getPos()
    getPos = function(){
    
        py_ans = private$py_obj$getPos()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPos(double pos)
    setPos = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        private$py_obj$setPos(pos)
        invisible()
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _PrecursorCorrection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PrecursorCorrection.html
PrecursorCorrection <- R6Class(classname = "PrecursorCorrection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void getPrecursors(MSExperiment & exp, libcpp_vector[Precursor] & precursors, libcpp_vector[double] & precursors_rt, libcpp_vector[size_t] & precursor_scan_index)
    getPrecursors = function(exp, precursors, precursors_rt, precursor_scan_index){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_list(precursors) && all(sapply(precursors,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Precursor")))){ stop("arg precursors wrong type") }
        if(!(is_list(precursors_rt) && all(sapply(precursors_rt,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg precursors_rt wrong type") }
        if(!(is_list(precursor_scan_index) && all(sapply(precursor_scan_index,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg precursor_scan_index wrong type") }
    
        v1 <- r_to_py(precursors)
        v2 <- r_to_py(precursors_rt)
        v3 <- r_to_py(precursor_scan_index)
        private$py_obj$getPrecursors(exp, v1, v2, v3)
        byref_3 <- py_to_r(v3)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(precursors <- byref_1))
        eval.parent(substitute(precursors_rt <- byref_2))
        eval.parent(substitute(precursor_scan_index <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void writeHist(String & out_csv, libcpp_vector[double] & delta_mzs, libcpp_vector[double] & mzs, libcpp_vector[double] & rts)
    writeHist = function(out_csv, delta_mzs, mzs, rts){
    
        if(!((is.R6(out_csv) && class(out_csv)[1]=="String") || is_scalar_character(out_csv))){ stop("arg out_csv wrong type") }
        if(!(is_list(delta_mzs) && all(sapply(delta_mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg delta_mzs wrong type") }
        if(!(is_list(mzs) && all(sapply(mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mzs wrong type") }
        if(!(is_list(rts) && all(sapply(rts,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg rts wrong type") }
    
        v1 <- r_to_py(delta_mzs)
        v2 <- r_to_py(mzs)
        v3 <- r_to_py(rts)
        private$py_obj$writeHist(out_csv, v1, v2, v3)
        byref_3 <- map_depth(py_to_r(v3),0,as.list)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(delta_mzs <- byref_1))
        eval.parent(substitute(mzs <- byref_2))
        eval.parent(substitute(rts <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_set[size_t] correctToNearestMS1Peak(MSExperiment & exp, double mz_tolerance, bool ppm, libcpp_vector[double] & delta_mzs, libcpp_vector[double] & mzs, libcpp_vector[double] & rts)
    correctToNearestMS1Peak = function(exp, mz_tolerance, ppm, delta_mzs, mzs, rts){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(mz_tolerance))){ stop("arg mz_tolerance wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_list(delta_mzs) && all(sapply(delta_mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg delta_mzs wrong type") }
        if(!(is_list(mzs) && all(sapply(mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mzs wrong type") }
        if(!(is_list(rts) && all(sapply(rts,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg rts wrong type") }
    
    
    
        v3 <- r_to_py(delta_mzs)
        v4 <- r_to_py(mzs)
        v5 <- r_to_py(rts)
        py_ans = private$py_obj$correctToNearestMS1Peak(exp, mz_tolerance, as.integer(ppm), v3, v4, v5)
        byref_5 <- map_depth(py_to_r(v5),0,as.list)
        byref_4 <- map_depth(py_to_r(v4),0,as.list)
        byref_3 <- map_depth(py_to_r(v3),0,as.list)
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
    
        tryCatch({
        eval.parent(substitute(delta_mzs <- byref_3))
        eval.parent(substitute(mzs <- byref_4))
        eval.parent(substitute(rts <- byref_5))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_set[size_t] correctToHighestIntensityMS1Peak(MSExperiment & exp, double mz_tolerance, bool ppm, libcpp_vector[double] & delta_mzs, libcpp_vector[double] & mzs, libcpp_vector[double] & rts)
    correctToHighestIntensityMS1Peak = function(exp, mz_tolerance, ppm, delta_mzs, mzs, rts){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(mz_tolerance))){ stop("arg mz_tolerance wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!(is_list(delta_mzs) && all(sapply(delta_mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg delta_mzs wrong type") }
        if(!(is_list(mzs) && all(sapply(mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mzs wrong type") }
        if(!(is_list(rts) && all(sapply(rts,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg rts wrong type") }
    
    
    
        v3 <- r_to_py(delta_mzs)
        v4 <- r_to_py(mzs)
        v5 <- r_to_py(rts)
        py_ans = private$py_obj$correctToHighestIntensityMS1Peak(exp, mz_tolerance, as.integer(ppm), v3, v4, v5)
        byref_5 <- map_depth(py_to_r(v5),0,as.list)
        byref_4 <- map_depth(py_to_r(v4),0,as.list)
        byref_3 <- map_depth(py_to_r(v3),0,as.list)
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
    
        tryCatch({
        eval.parent(substitute(delta_mzs <- byref_3))
        eval.parent(substitute(mzs <- byref_4))
        eval.parent(substitute(rts <- byref_5))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_set[size_t] correctToNearestFeature(FeatureMap & features, MSExperiment & exp, double rt_tolerance_s, double mz_tolerance, bool ppm, bool believe_charge, bool keep_original, bool all_matching_features, int max_trace, int debug_level)
    correctToNearestFeature = function(features, exp, rt_tolerance_s, mz_tolerance, ppm, believe_charge, keep_original, all_matching_features, max_trace, debug_level){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is_scalar_double(rt_tolerance_s))){ stop("arg rt_tolerance_s wrong type") }
        if(!(is_scalar_double(mz_tolerance))){ stop("arg mz_tolerance wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        if(!( (is_scalar_integer(believe_charge) || is_scalar_double(believe_charge)) && believe_charge == as.integer(believe_charge))){ stop("arg believe_charge wrong type") }
        if(!( (is_scalar_integer(keep_original) || is_scalar_double(keep_original)) && keep_original == as.integer(keep_original))){ stop("arg keep_original wrong type") }
        if(!( (is_scalar_integer(all_matching_features) || is_scalar_double(all_matching_features)) && all_matching_features == as.integer(all_matching_features))){ stop("arg all_matching_features wrong type") }
        if(!( (is_scalar_integer(max_trace) || is_scalar_double(max_trace)) && max_trace == as.integer(max_trace))){ stop("arg max_trace wrong type") }
        if(!( (is_scalar_integer(debug_level) || is_scalar_double(debug_level)) && debug_level == as.integer(debug_level))){ stop("arg debug_level wrong type") }
    
    
    
    
    
    
    
    
    
    
        py_ans = private$py_obj$correctToNearestFeature(features, exp, rt_tolerance_s, mz_tolerance, as.integer(ppm), as.integer(believe_charge), as.integer(keep_original), as.integer(all_matching_features), as.integer(max_trace), as.integer(debug_level))
        py$res <- py_ans
        r_ans = as.list(py_eval("list(res)"))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    }
)
) 

# R implementation of _PrecursorIonSelection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PrecursorIonSelection.html
PrecursorIonSelection <- R6Class(classname = "PrecursorIonSelection",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PrecursorIonSelection()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PrecursorIonSelection()
        invisible()
    
    
    },
    
    # C++ signature: void PrecursorIonSelection(PrecursorIonSelection)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PrecursorIonSelection")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PrecursorIonSelection(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PrecursorIonSelection()
    # C++ signature: void PrecursorIonSelection(PrecursorIonSelection)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PrecursorIonSelection")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PrecursorIonSelection" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMaxScore()
    getMaxScore = function(){
    
        py_ans = private$py_obj$getMaxScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxScore(double & max_score)
    setMaxScore = function(max_score){
    
        if(!(is_scalar_double(max_score))){ stop("arg max_score wrong type") }
    
        private$py_obj$setMaxScore(max_score)
        invisible()
    },
    
    # C++ signature: void sortByTotalScore(FeatureMap & features)
    sortByTotalScore = function(features){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
    
        private$py_obj$sortByTotalScore(features)
        invisible()
    },
    
    # C++ signature: void getNextPrecursors(FeatureMap & features, FeatureMap & next_features, unsigned int number)
    getNextPrecursors_0 = function(features, next_features, number){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(next_features) && class(next_features)[1] == "FeatureMap")){ stop("arg next_features wrong type") }
        if(!( (is_scalar_integer(number) || is_scalar_double(number)) && number == as.integer(number))){ stop("arg number wrong type") }
    
    
    
        private$py_obj$`_getNextPrecursors_0`(features, next_features, as.integer(number))
        invisible()
    },
    
    # C++ signature: void getNextPrecursors(libcpp_vector[int] & solution_indices, libcpp_vector[IndexTriple] & variable_indices, libcpp_set[int] & measured_variables, FeatureMap & features, FeatureMap & new_features, unsigned int step_size, PSLPFormulation & ilp)
    getNextPrecursors_1 = function(solution_indices, variable_indices, measured_variables, features, new_features, step_size, ilp){
    
        if(!(is_list(solution_indices) && all(sapply(solution_indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg solution_indices wrong type") }
        if(!(is_list(variable_indices) && all(sapply(variable_indices,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IndexTriple")))){ stop("arg variable_indices wrong type") }
        if(!(is_list(measured_variables) && all(sapply(measured_variables,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(measured_variables)))){ stop("arg measured_variables wrong type") }
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.R6(new_features) && class(new_features)[1] == "FeatureMap")){ stop("arg new_features wrong type") }
        if(!( (is_scalar_integer(step_size) || is_scalar_double(step_size)) && step_size == as.integer(step_size))){ stop("arg step_size wrong type") }
        if(!(is.R6(ilp) && class(ilp)[1] == "PSLPFormulation")){ stop("arg ilp wrong type") }
        v0 <- r_to_py(modify_depth(solution_indices,1,as.integer))
        v1 <- r_to_py(variable_indices)
        py$v2 <- measured_variables
        py_run_string("v2 = [int(t) for t in v2];v2 = set(v2)")
    
    
    
    
        private$py_obj$`_getNextPrecursors_1`(v0, v1, py$v2, features, new_features, as.integer(step_size), ilp)
        byref_2 <- as.list(py_eval("list(v2)"))
        py_run_string("del v2; gc.collect()")
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(solution_indices <- byref_0))
        eval.parent(substitute(variable_indices <- byref_1))
        eval.parent(substitute(measured_variables <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getNextPrecursors(FeatureMap & features, FeatureMap & next_features, unsigned int number)
    # C++ signature: void getNextPrecursors(libcpp_vector[int] & solution_indices, libcpp_vector[IndexTriple] & variable_indices, libcpp_set[int] & measured_variables, FeatureMap & features, FeatureMap & new_features, unsigned int step_size, PSLPFormulation & ilp)
    getNextPrecursors = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$getNextPrecursors_0(...) }
        else if ((length(arg_list)==7) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IndexTriple"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(arg_list[[3]]))) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "FeatureMap") && (is.R6(arg_list[[5]]) && class(arg_list[[5]])[1] == "FeatureMap") && ( (is_scalar_integer(arg_list[[6]]) || is_scalar_double(arg_list[[6]])) && arg_list[[6]] == as.integer(arg_list[[6]])) && (is.R6(arg_list[[7]]) && class(arg_list[[7]])[1] == "PSLPFormulation")) { self$getNextPrecursors_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void rescore(FeatureMap & features, libcpp_vector[PeptideIdentification] & new_pep_ids, libcpp_vector[ProteinIdentification] & prot_ids, PrecursorIonSelectionPreprocessing & preprocessed_db, bool check_meta_values)
    rescore = function(features, new_pep_ids, prot_ids, preprocessed_db, check_meta_values){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is_list(new_pep_ids) && all(sapply(new_pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg new_pep_ids wrong type") }
        if(!(is_list(prot_ids) && all(sapply(prot_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg prot_ids wrong type") }
        if(!(is.R6(preprocessed_db) && class(preprocessed_db)[1] == "PrecursorIonSelectionPreprocessing")){ stop("arg preprocessed_db wrong type") }
        if(!( (is_scalar_integer(check_meta_values) || is_scalar_double(check_meta_values)) && check_meta_values == as.integer(check_meta_values))){ stop("arg check_meta_values wrong type") }
    
        v1 <- r_to_py(new_pep_ids)
        v2 <- r_to_py(prot_ids)
    
    
        private$py_obj$rescore(features, v1, v2, preprocessed_db, as.integer(check_meta_values))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(new_pep_ids <- byref_1))
        eval.parent(substitute(prot_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void simulateRun(FeatureMap & features, libcpp_vector[PeptideIdentification] & pep_ids, libcpp_vector[ProteinIdentification] & prot_ids, PrecursorIonSelectionPreprocessing & preprocessed_db, String path, MSExperiment & experiment, String precursor_path)
    simulateRun = function(features, pep_ids, prot_ids, preprocessed_db, path, experiment, precursor_path){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
        if(!(is_list(prot_ids) && all(sapply(prot_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg prot_ids wrong type") }
        if(!(is.R6(preprocessed_db) && class(preprocessed_db)[1] == "PrecursorIonSelectionPreprocessing")){ stop("arg preprocessed_db wrong type") }
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
        if(!(is.R6(experiment) && class(experiment)[1] == "MSExperiment")){ stop("arg experiment wrong type") }
        if(!((is.R6(precursor_path) && class(precursor_path)[1]=="String") || is_scalar_character(precursor_path))){ stop("arg precursor_path wrong type") }
    
        v1 <- r_to_py(pep_ids)
        v2 <- r_to_py(prot_ids)
    
    
    
    
        private$py_obj$simulateRun(features, v1, v2, preprocessed_db, path, experiment, precursor_path)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(pep_ids <- byref_1))
        eval.parent(substitute(prot_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setLPSolver(SOLVER solver)
    setLPSolver = function(solver){
    
        if(!(solver %in% c(0))){ stop("arg solver wrong type") }
    
        private$py_obj$setLPSolver(as.integer(solver))
        invisible()
    },
    
    # C++ signature: SOLVER getLPSolver()
    getLPSolver = function(){
    
        py_ans = private$py_obj$getLPSolver()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void reset()
    reset = function(){
    
        private$py_obj$reset()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PrecursorIonSelectionPreprocessing
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PrecursorIonSelectionPreprocessing.html
PrecursorIonSelectionPreprocessing <- R6Class(classname = "PrecursorIonSelectionPreprocessing",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PrecursorIonSelectionPreprocessing()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$PrecursorIonSelectionPreprocessing()
        invisible()
    
    
    },
    
    # C++ signature: void PrecursorIonSelectionPreprocessing(PrecursorIonSelectionPreprocessing)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PrecursorIonSelectionPreprocessing")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PrecursorIonSelectionPreprocessing(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PrecursorIonSelectionPreprocessing()
    # C++ signature: void PrecursorIonSelectionPreprocessing(PrecursorIonSelectionPreprocessing)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PrecursorIonSelectionPreprocessing")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PrecursorIonSelectionPreprocessing" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[double] getMasses(String acc)
    getMasses = function(acc){
    
        if(!((is.R6(acc) && class(acc)[1]=="String") || is_scalar_character(acc))){ stop("arg acc wrong type") }
    
        py_ans = private$py_obj$getMasses(acc)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void dbPreprocessing(String db_path, bool save)
    dbPreprocessing_0 = function(db_path, save){
    
        if(!((is.R6(db_path) && class(db_path)[1]=="String") || is_scalar_character(db_path))){ stop("arg db_path wrong type") }
        if(!( (is_scalar_integer(save) || is_scalar_double(save)) && save == as.integer(save))){ stop("arg save wrong type") }
    
    
        private$py_obj$`_dbPreprocessing_0`(db_path, as.integer(save))
        invisible()
    },
    
    # C++ signature: void dbPreprocessing(String db_path, String rt_model_path, String dt_model_path, bool save)
    dbPreprocessing_1 = function(db_path, rt_model_path, dt_model_path, save){
    
        if(!((is.R6(db_path) && class(db_path)[1]=="String") || is_scalar_character(db_path))){ stop("arg db_path wrong type") }
        if(!((is.R6(rt_model_path) && class(rt_model_path)[1]=="String") || is_scalar_character(rt_model_path))){ stop("arg rt_model_path wrong type") }
        if(!((is.R6(dt_model_path) && class(dt_model_path)[1]=="String") || is_scalar_character(dt_model_path))){ stop("arg dt_model_path wrong type") }
        if(!( (is_scalar_integer(save) || is_scalar_double(save)) && save == as.integer(save))){ stop("arg save wrong type") }
    
    
    
    
        private$py_obj$`_dbPreprocessing_1`(db_path, rt_model_path, dt_model_path, as.integer(save))
        invisible()
    },
    
    # C++ signature: void dbPreprocessing(String db_path, bool save)
    # C++ signature: void dbPreprocessing(String db_path, String rt_model_path, String dt_model_path, bool save)
    dbPreprocessing = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$dbPreprocessing_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$dbPreprocessing_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void loadPreprocessing()
    loadPreprocessing = function(){
    
        private$py_obj$loadPreprocessing()
        invisible()
    },
    
    # C++ signature: double getWeight(double mass)
    getWeight = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        py_ans = private$py_obj$getWeight(mass)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT(String prot_id, size_t peptide_index)
    getRT = function(prot_id, peptide_index){
    
        if(!((is.R6(prot_id) && class(prot_id)[1]=="String") || is_scalar_character(prot_id))){ stop("arg prot_id wrong type") }
        if(!( (is_scalar_integer(peptide_index) || is_scalar_double(peptide_index)) && peptide_index == as.integer(peptide_index))){ stop("arg peptide_index wrong type") }
    
    
        py_ans = private$py_obj$getRT(prot_id, as.integer(peptide_index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPT(String prot_id, size_t peptide_index)
    getPT = function(prot_id, peptide_index){
    
        if(!((is.R6(prot_id) && class(prot_id)[1]=="String") || is_scalar_character(prot_id))){ stop("arg prot_id wrong type") }
        if(!( (is_scalar_integer(peptide_index) || is_scalar_double(peptide_index)) && peptide_index == as.integer(peptide_index))){ stop("arg peptide_index wrong type") }
    
    
        py_ans = private$py_obj$getPT(prot_id, as.integer(peptide_index))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFixedModifications(StringList & modifications)
    setFixedModifications = function(modifications){
    
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character))){ stop("arg modifications wrong type") }
        v0 = r_to_py(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
        private$py_obj$setFixedModifications(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(modifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setGaussianParameters(double mu, double sigma)
    setGaussianParameters = function(mu, sigma){
    
        if(!(is_scalar_double(mu))){ stop("arg mu wrong type") }
        if(!(is_scalar_double(sigma))){ stop("arg sigma wrong type") }
    
    
        private$py_obj$setGaussianParameters(mu, sigma)
        invisible()
    },
    
    # C++ signature: double getGaussMu()
    getGaussMu = function(){
    
        py_ans = private$py_obj$getGaussMu()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getGaussSigma()
    getGaussSigma = function(){
    
        py_ans = private$py_obj$getGaussSigma()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRTProbability(String prot_id, size_t peptide_index, Feature & feature)
    getRTProbability_0 = function(prot_id, peptide_index, feature){
    
        if(!((is.R6(prot_id) && class(prot_id)[1]=="String") || is_scalar_character(prot_id))){ stop("arg prot_id wrong type") }
        if(!( (is_scalar_integer(peptide_index) || is_scalar_double(peptide_index)) && peptide_index == as.integer(peptide_index))){ stop("arg peptide_index wrong type") }
        if(!(is.R6(feature) && class(feature)[1] == "Feature")){ stop("arg feature wrong type") }
    
    
    
        py_ans = private$py_obj$`_getRTProbability_0`(prot_id, as.integer(peptide_index), feature)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRTProbability(double pred_rt, Feature & feature)
    getRTProbability_1 = function(pred_rt, feature){
    
        if(!(is_scalar_double(pred_rt))){ stop("arg pred_rt wrong type") }
        if(!(is.R6(feature) && class(feature)[1] == "Feature")){ stop("arg feature wrong type") }
    
    
        py_ans = private$py_obj$`_getRTProbability_1`(pred_rt, feature)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRTProbability(String prot_id, size_t peptide_index, Feature & feature)
    # C++ signature: double getRTProbability(double pred_rt, Feature & feature)
    getRTProbability = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "Feature")) { self$getRTProbability_0(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Feature")) { self$getRTProbability_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _PrecursorPurity
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PrecursorPurity.html
PrecursorPurity <- R6Class(classname = "PrecursorPurity",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void PrecursorPurity()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == PrecursorPurity) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$PrecursorPurity()
        invisible()
    }
    
    },
    
    # C++ signature: PurityScores computePrecursorPurity(MSSpectrum ms1, Precursor pre, double precursor_mass_tolerance, bool precursor_mass_tolerance_unit_ppm)
    computePrecursorPurity = function(ms1, pre, precursor_mass_tolerance, precursor_mass_tolerance_unit_ppm){
    
        if(!(is.R6(ms1) && class(ms1)[1] == "MSSpectrum")){ stop("arg ms1 wrong type") }
        if(!(is.R6(pre) && class(pre)[1] == "Precursor")){ stop("arg pre wrong type") }
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(precursor_mass_tolerance_unit_ppm) || is_scalar_double(precursor_mass_tolerance_unit_ppm)) && precursor_mass_tolerance_unit_ppm == as.integer(precursor_mass_tolerance_unit_ppm))){ stop("arg precursor_mass_tolerance_unit_ppm wrong type") }
    
    
    
    
        py_ans = private$py_obj$computePrecursorPurity(ms1, pre, precursor_mass_tolerance, as.integer(precursor_mass_tolerance_unit_ppm))
        r_ans = PurityScores$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _Prediction
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Prediction.html
Prediction <- R6Class(classname = "Prediction",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        software_ref = function(software_ref){
    
        if(!missing(software_ref)){
            if(!((is.R6(software_ref) && class(software_ref)[1]=="String") || is_scalar_character(software_ref))){ stop("arg software_ref wrong type") }
        
        
            private$py_obj$software_ref <- software_ref
            } else {
        
                py_ans = private$py_obj$software_ref
            r_result = py_ans
                return(r_result)
                }
        },
        contact_ref = function(contact_ref){
    
        if(!missing(contact_ref)){
            if(!((is.R6(contact_ref) && class(contact_ref)[1]=="String") || is_scalar_character(contact_ref))){ stop("arg contact_ref wrong type") }
        
        
            private$py_obj$contact_ref <- contact_ref
            } else {
        
                py_ans = private$py_obj$contact_ref
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Prediction()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Prediction) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Prediction()
        invisible()
    }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ProbablePhosphoSites
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProbablePhosphoSites.html
ProbablePhosphoSites <- R6Class(classname = "ProbablePhosphoSites",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        first = function(first){
    
        if(!missing(first)){
            if(!( (is_scalar_integer(first) || is_scalar_double(first)) && first == as.integer(first))){ stop("arg first wrong type") }
        
        
            private$py_obj$first <- as.integer(first)
            } else {
        
                py_ans = private$py_obj$first
                r_result = py_ans
                return(r_result)
                }
        },
        second = function(second){
    
        if(!missing(second)){
            if(!( (is_scalar_integer(second) || is_scalar_double(second)) && second == as.integer(second))){ stop("arg second wrong type") }
        
        
            private$py_obj$second <- as.integer(second)
            } else {
        
                py_ans = private$py_obj$second
                r_result = py_ans
                return(r_result)
                }
        },
        seq_1 = function(seq_1){
    
        if(!missing(seq_1)){
            if(!( (is_scalar_integer(seq_1) || is_scalar_double(seq_1)) && seq_1 == as.integer(seq_1))){ stop("arg seq_1 wrong type") }
        
        
            private$py_obj$seq_1 <- as.integer(seq_1)
            } else {
        
                py_ans = private$py_obj$seq_1
                r_result = py_ans
                return(r_result)
                }
        },
        seq_2 = function(seq_2){
    
        if(!missing(seq_2)){
            if(!( (is_scalar_integer(seq_2) || is_scalar_double(seq_2)) && seq_2 == as.integer(seq_2))){ stop("arg seq_2 wrong type") }
        
        
            private$py_obj$seq_2 <- as.integer(seq_2)
            } else {
        
                py_ans = private$py_obj$seq_2
                r_result = py_ans
                return(r_result)
                }
        },
        peak_depth = function(peak_depth){
    
        if(!missing(peak_depth)){
            if(!( (is_scalar_integer(peak_depth) || is_scalar_double(peak_depth)) && peak_depth == as.integer(peak_depth))){ stop("arg peak_depth wrong type") }
        
        
            private$py_obj$peak_depth <- as.integer(peak_depth)
            } else {
        
                py_ans = private$py_obj$peak_depth
                r_result = py_ans
                return(r_result)
                }
        },
        AScore = function(AScore){
    
        if(!missing(AScore)){
            if(!( (is_scalar_integer(AScore) || is_scalar_double(AScore)) && AScore == as.integer(AScore))){ stop("arg AScore wrong type") }
        
        
            private$py_obj$AScore <- as.integer(AScore)
            } else {
        
                py_ans = private$py_obj$AScore
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ProbablePhosphoSites()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ProbablePhosphoSites) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ProbablePhosphoSites()
        invisible()
    }
    
    }
)
) 

# R implementation of _Product
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Product.html
Product <- R6Class(classname = "Product",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Product()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Product()
        invisible()
    
    
    },
    
    # C++ signature: void Product(Product)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Product")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Product(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Product()
    # C++ signature: void Product(Product)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Product")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Product" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: double getIsolationWindowLowerOffset()
    getIsolationWindowLowerOffset = function(){
    
        py_ans = private$py_obj$getIsolationWindowLowerOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsolationWindowLowerOffset(double bound)
    setIsolationWindowLowerOffset = function(bound){
    
        if(!(is_scalar_double(bound))){ stop("arg bound wrong type") }
    
        private$py_obj$setIsolationWindowLowerOffset(bound)
        invisible()
    },
    
    # C++ signature: double getIsolationWindowUpperOffset()
    getIsolationWindowUpperOffset = function(){
    
        py_ans = private$py_obj$getIsolationWindowUpperOffset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIsolationWindowUpperOffset(double bound)
    setIsolationWindowUpperOffset = function(bound){
    
        if(!(is_scalar_double(bound))){ stop("arg bound wrong type") }
    
        private$py_obj$setIsolationWindowUpperOffset(bound)
        invisible()
    }
)
) 

# R implementation of _ProgressLogger
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProgressLogger.html
ProgressLogger <- R6Class(classname = "ProgressLogger",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProgressLogger()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ProgressLogger) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ProgressLogger()
        invisible()
    }
    
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _ProtXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProtXMLFile.html
ProtXMLFile <- R6Class(classname = "ProtXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProtXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ProtXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ProtXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, ProteinIdentification & protein_ids, PeptideIdentification & peptide_ids)
    load = function(filename, protein_ids, peptide_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_ids) && class(protein_ids)[1] == "ProteinIdentification")){ stop("arg protein_ids wrong type") }
        if(!(is.R6(peptide_ids) && class(peptide_ids)[1] == "PeptideIdentification")){ stop("arg peptide_ids wrong type") }
    
    
    
        private$py_obj$load(filename, protein_ids, peptide_ids)
        invisible()
    },
    
    # C++ signature: void store(String filename, ProteinIdentification & protein_ids, PeptideIdentification & peptide_ids, String document_id)
    store = function(filename, protein_ids, peptide_ids, document_id){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_ids) && class(protein_ids)[1] == "ProteinIdentification")){ stop("arg protein_ids wrong type") }
        if(!(is.R6(peptide_ids) && class(peptide_ids)[1] == "PeptideIdentification")){ stop("arg peptide_ids wrong type") }
        if(!((is.R6(document_id) && class(document_id)[1]=="String") || is_scalar_character(document_id))){ stop("arg document_id wrong type") }
    
    
    
    
        private$py_obj$store(filename, protein_ids, peptide_ids, document_id)
        invisible()
    }
)
) 

# R implementation of _ProteaseDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteaseDB.html
ProteaseDB <- R6Class(classname = "ProteaseDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: const DigestionEnzymeProtein * getEnzyme(const String & name)
    getEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getEnzyme(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = DigestionEnzymeProtein$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const DigestionEnzymeProtein * getEnzymeByRegEx(const String & cleavage_regex)
    getEnzymeByRegEx = function(cleavage_regex){
    
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
    
        py_ans = private$py_obj$getEnzymeByRegEx(cleavage_regex) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = DigestionEnzymeProtein$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getAllNames(libcpp_vector[String] & all_names)
    getAllNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getAllXTandemNames(libcpp_vector[String] & all_names)
    getAllXTandemNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllXTandemNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getAllOMSSANames(libcpp_vector[String] & all_names)
    getAllOMSSANames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllOMSSANames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getAllCometNames(libcpp_vector[String] & all_names)
    getAllCometNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllCometNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getAllCruxNames(libcpp_vector[String] & all_names)
    getAllCruxNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllCruxNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getAllMSGFNames(libcpp_vector[String] & all_names)
    getAllMSGFNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllMSGFNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool hasEnzyme(const String & name)
    hasEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$hasEnzyme(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasRegEx(const String & cleavage_regex)
    hasRegEx = function(cleavage_regex){
    
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
    
        py_ans = private$py_obj$hasRegEx(cleavage_regex)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ProteaseDigestion
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteaseDigestion.html
ProteaseDigestion <- R6Class(classname = "ProteaseDigestion",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProteaseDigestion()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ProteaseDigestion) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ProteaseDigestion()
        invisible()
    }
    
    },
    
    # C++ signature: ptrdiff_t getMissedCleavages()
    getMissedCleavages = function(){
    
        py_ans = private$py_obj$getMissedCleavages()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMissedCleavages(ptrdiff_t missed_cleavages)
    setMissedCleavages = function(missed_cleavages){
    
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
    
        private$py_obj$setMissedCleavages(as.integer(missed_cleavages))
        invisible()
    },
    
    # C++ signature: String getEnzymeName()
    getEnzymeName = function(){
    
        py_ans = private$py_obj$getEnzymeName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(String name)
    setEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setEnzyme(name)
        invisible()
    },
    
    # C++ signature: size_t digest(AASequence & protein, libcpp_vector[AASequence] & output)
    digest_0 = function(protein, output){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg output wrong type") }
    
        v1 <- r_to_py(output)
        py_ans = private$py_obj$`_digest_0`(protein, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: size_t digest(AASequence & protein, libcpp_vector[AASequence] & output, size_t min_length, size_t max_length)
    digest_1 = function(protein, output, min_length, max_length){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(min_length) || is_scalar_double(min_length)) && min_length == as.integer(min_length))){ stop("arg min_length wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
    
        v1 <- r_to_py(output)
    
    
        py_ans = private$py_obj$`_digest_1`(protein, v1, as.integer(min_length), as.integer(max_length))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: size_t digest(AASequence & protein, libcpp_vector[AASequence] & output)
    # C++ signature: size_t digest(AASequence & protein, libcpp_vector[AASequence] & output, size_t min_length, size_t max_length)
    digest = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASequence") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))) { self$digest_0(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASequence") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence"))) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$digest_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: size_t peptideCount(AASequence & protein)
    peptideCount = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
    
        py_ans = private$py_obj$peptideCount(protein)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Specificity getSpecificity()
    getSpecificity = function(){
    
        py_ans = private$py_obj$getSpecificity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpecificity(Specificity spec)
    setSpecificity = function(spec){
    
        if(!(spec %in% c(0, 1, 2, 3, 8, 9, 10))){ stop("arg spec wrong type") }
    
        private$py_obj$setSpecificity(as.integer(spec))
        invisible()
    },
    
    # C++ signature: Specificity getSpecificityByName(String name)
    getSpecificityByName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getSpecificityByName(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValidProduct(AASequence protein, size_t pep_pos, size_t pep_length, bool ignore_missed_cleavages, bool methionine_cleavage)
    isValidProduct_0 = function(protein, pep_pos, pep_length, ignore_missed_cleavages, methionine_cleavage){
    
        if(!(is.R6(protein) && class(protein)[1] == "AASequence")){ stop("arg protein wrong type") }
        if(!( (is_scalar_integer(pep_pos) || is_scalar_double(pep_pos)) && pep_pos == as.integer(pep_pos))){ stop("arg pep_pos wrong type") }
        if(!( (is_scalar_integer(pep_length) || is_scalar_double(pep_length)) && pep_length == as.integer(pep_length))){ stop("arg pep_length wrong type") }
        if(!( (is_scalar_integer(ignore_missed_cleavages) || is_scalar_double(ignore_missed_cleavages)) && ignore_missed_cleavages == as.integer(ignore_missed_cleavages))){ stop("arg ignore_missed_cleavages wrong type") }
        if(!( (is_scalar_integer(methionine_cleavage) || is_scalar_double(methionine_cleavage)) && methionine_cleavage == as.integer(methionine_cleavage))){ stop("arg methionine_cleavage wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$`_isValidProduct_0`(protein, as.integer(pep_pos), as.integer(pep_length), as.integer(ignore_missed_cleavages), as.integer(methionine_cleavage))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValidProduct(String protein, size_t pep_pos, size_t pep_length, bool ignore_missed_cleavages, bool methionine_cleavage)
    isValidProduct_1 = function(protein, pep_pos, pep_length, ignore_missed_cleavages, methionine_cleavage){
    
        if(!((is.R6(protein) && class(protein)[1]=="String") || is_scalar_character(protein))){ stop("arg protein wrong type") }
        if(!( (is_scalar_integer(pep_pos) || is_scalar_double(pep_pos)) && pep_pos == as.integer(pep_pos))){ stop("arg pep_pos wrong type") }
        if(!( (is_scalar_integer(pep_length) || is_scalar_double(pep_length)) && pep_length == as.integer(pep_length))){ stop("arg pep_length wrong type") }
        if(!( (is_scalar_integer(ignore_missed_cleavages) || is_scalar_double(ignore_missed_cleavages)) && ignore_missed_cleavages == as.integer(ignore_missed_cleavages))){ stop("arg ignore_missed_cleavages wrong type") }
        if(!( (is_scalar_integer(methionine_cleavage) || is_scalar_double(methionine_cleavage)) && methionine_cleavage == as.integer(methionine_cleavage))){ stop("arg methionine_cleavage wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$`_isValidProduct_1`(protein, as.integer(pep_pos), as.integer(pep_length), as.integer(ignore_missed_cleavages), as.integer(methionine_cleavage))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValidProduct(AASequence protein, size_t pep_pos, size_t pep_length, bool ignore_missed_cleavages, bool methionine_cleavage)
    # C++ signature: bool isValidProduct(String protein, size_t pep_pos, size_t pep_length, bool ignore_missed_cleavages, bool methionine_cleavage)
    isValidProduct = function(...){
        arg_list = list(...)
        if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "AASequence") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$isValidProduct_0(...) }
        else if ((length(arg_list)==5) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$isValidProduct_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _Protein
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Protein.html
Protein <- R6Class(classname = "Protein",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        sequence = function(sequence){
    
        if(!missing(sequence)){
            if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
        
        
            private$py_obj$sequence <- sequence
            } else {
        
                py_ans = private$py_obj$sequence
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Protein()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Protein()
        invisible()
    
    
    },
    
    # C++ signature: void Protein(Protein)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Protein")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Protein(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Protein()
    # C++ signature: void Protein(Protein)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Protein")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Protein" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ProteinEntry
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinEntry.html
ProteinEntry <- R6Class(classname = "ProteinEntry",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        traversed = function(traversed){
    
        if(!missing(traversed)){
            if(!( (is_scalar_integer(traversed) || is_scalar_double(traversed)) && traversed == as.integer(traversed))){ stop("arg traversed wrong type") }
        
        
            private$py_obj$traversed <- as.integer(traversed)
            } else {
        
                py_ans = private$py_obj$traversed
                r_result = py_ans
                return(r_result)
                }
        },
        fasta_entry = function(fasta_entry){
    
        if(!missing(fasta_entry)){
            if(!(is.R6(fasta_entry) && class(fasta_entry)[1] == "FASTAEntry")){ stop("arg fasta_entry wrong type") }
        
        
            private$py_obj$fasta_entry <- fasta_entry
            } else {
        
            if (is.null(private$py_obj$fasta_entry)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$fasta_entry ; if( is.null(py_ans) ) { return(NULL) }
            r_result = FASTAEntry$new(py_ans)
                return(r_result)
                }
            }
        },
        protein_type = function(protein_type){
    
        if(!missing(protein_type)){
            if(!(protein_type %in% c(0, 1, 2, 3))){ stop("arg protein_type wrong type") }
        
        
            private$py_obj$protein_type <- as.integer(protein_type)
            } else {
        
                py_ans = private$py_obj$protein_type
                r_result = py_ans
                return(r_result)
                }
        },
        weight = function(weight){
    
        if(!missing(weight)){
            if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
        
        
            private$py_obj$weight <- weight
            } else {
        
                py_ans = private$py_obj$weight
                r_result = py_ans
                return(r_result)
                }
        },
        coverage = function(coverage){
    
        if(!missing(coverage)){
            if(!(is_scalar_double(coverage))){ stop("arg coverage wrong type") }
        
        
            private$py_obj$coverage <- coverage
            } else {
        
                py_ans = private$py_obj$coverage
                r_result = py_ans
                return(r_result)
                }
        },
        index = function(index){
    
        if(!missing(index)){
            if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        
        
            private$py_obj$index <- as.integer(index)
            } else {
        
                py_ans = private$py_obj$index
                r_result = py_ans
                return(r_result)
                }
        },
        msd_group = function(msd_group){
    
        if(!missing(msd_group)){
            if(!( (is_scalar_integer(msd_group) || is_scalar_double(msd_group)) && msd_group == as.integer(msd_group))){ stop("arg msd_group wrong type") }
        
        
            private$py_obj$msd_group <- as.integer(msd_group)
            } else {
        
                py_ans = private$py_obj$msd_group
                r_result = py_ans
                return(r_result)
                }
        },
        isd_group = function(isd_group){
    
        if(!missing(isd_group)){
            if(!( (is_scalar_integer(isd_group) || is_scalar_double(isd_group)) && isd_group == as.integer(isd_group))){ stop("arg isd_group wrong type") }
        
        
            private$py_obj$isd_group <- as.integer(isd_group)
            } else {
        
                py_ans = private$py_obj$isd_group
                r_result = py_ans
                return(r_result)
                }
        },
        number_of_experimental_peptides = function(number_of_experimental_peptides){
    
        if(!missing(number_of_experimental_peptides)){
            if(!( (is_scalar_integer(number_of_experimental_peptides) || is_scalar_double(number_of_experimental_peptides)) && number_of_experimental_peptides == as.integer(number_of_experimental_peptides))){ stop("arg number_of_experimental_peptides wrong type") }
        
        
            private$py_obj$number_of_experimental_peptides <- as.integer(number_of_experimental_peptides)
            } else {
        
                py_ans = private$py_obj$number_of_experimental_peptides
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ProteinEntry()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ProteinEntry) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ProteinEntry()
        invisible()
    }
    
    }
)
) 

# R implementation of _ProteinGroup
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinGroup.html
ProteinGroup <- R6Class(classname = "ProteinGroup",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        probability = function(probability){
    
        if(!missing(probability)){
            if(!(is_scalar_double(probability))){ stop("arg probability wrong type") }
        
        
            private$py_obj$probability <- probability
            } else {
        
                py_ans = private$py_obj$probability
                r_result = py_ans
                return(r_result)
                }
        },
        accessions = function(accessions){
    
        if(!missing(accessions)){
            if(!(is_list(accessions) && all(sapply(accessions),is_scalar_character))){ stop("arg accessions wrong type") }
        
            v0 = r_to_py(modify_depth(accessions,1,py_builtin$bytes(accessions,'utf-8')))
            private$py_obj$accessions <- v0
            } else {
        
                py_ans = private$py_obj$accessions
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ProteinGroup()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProteinGroup()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinGroup(ProteinGroup)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinGroup")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinGroup(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinGroup()
    # C++ signature: void ProteinGroup(ProteinGroup)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinGroup")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinGroup" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _ProteinHit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinHit.html
ProteinHit <- R6Class(classname = "ProteinHit",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProteinHit()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProteinHit()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinHit(double score, unsigned int rank, String accession, String sequence)
    init_1 = function(score, rank, accession, sequence){
    
        if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        if(!((is.R6(sequence) && class(sequence)[1]=="String") || is_scalar_character(sequence))){ stop("arg sequence wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$ProteinHit(score, as.integer(rank), accession, sequence)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinHit(ProteinHit)
    init_2 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinHit")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinHit(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinHit()
    # C++ signature: void ProteinHit(double score, unsigned int rank, String accession, String sequence)
    # C++ signature: void ProteinHit(ProteinHit)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==4) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]]))) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinHit")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinHit" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getScore()
    getScore = function(){
    
        py_ans = private$py_obj$getScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: unsigned int getRank()
    getRank = function(){
    
        py_ans = private$py_obj$getRank()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getSequence()
    getSequence = function(){
    
        py_ans = private$py_obj$getSequence()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getAccession()
    getAccession = function(){
    
        py_ans = private$py_obj$getAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getDescription()
    getDescription = function(){
    
        py_ans = private$py_obj$getDescription()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCoverage()
    getCoverage = function(){
    
        py_ans = private$py_obj$getCoverage()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScore(float)
    setScore = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setScore(in_0)
        invisible()
    },
    
    # C++ signature: void setRank(unsigned int)
    setRank = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRank(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: void setSequence(String)
    setSequence = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSequence(in_0)
        invisible()
    },
    
    # C++ signature: void setAccession(String)
    setAccession = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setAccession(in_0)
        invisible()
    },
    
    # C++ signature: void setDescription(String description)
    setDescription = function(description){
    
        if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
    
        private$py_obj$setDescription(description)
        invisible()
    },
    
    # C++ signature: void setCoverage(double)
    setCoverage = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setCoverage(in_0)
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ProteinIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinIdentification.html
ProteinIdentification <- R6Class(classname = "ProteinIdentification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProteinIdentification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProteinIdentification()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinIdentification(ProteinIdentification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinIdentification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinIdentification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinIdentification()
    # C++ signature: void ProteinIdentification(ProteinIdentification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinIdentification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinIdentification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: libcpp_vector[ProteinHit] getHits()
    getHits = function(){
    
        py_ans = private$py_obj$getHits()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void insertHit(ProteinHit input)
    insertHit = function(input){
    
        if(!(is.R6(input) && class(input)[1] == "ProteinHit")){ stop("arg input wrong type") }
    
        private$py_obj$insertHit(input)
        invisible()
    },
    
    # C++ signature: void setHits(libcpp_vector[ProteinHit] hits)
    setHits = function(hits){
    
        if(!(is_list(hits) && all(sapply(hits,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinHit")))){ stop("arg hits wrong type") }
        v0 <- r_to_py(hits)
        private$py_obj$setHits(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinGroup] getProteinGroups()
    getProteinGroups = function(){
    
        py_ans = private$py_obj$getProteinGroups()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void insertProteinGroup(ProteinGroup group)
    insertProteinGroup = function(group){
    
        if(!(is.R6(group) && class(group)[1] == "ProteinGroup")){ stop("arg group wrong type") }
    
        private$py_obj$insertProteinGroup(group)
        invisible()
    },
    
    # C++ signature: libcpp_vector[ProteinGroup] getIndistinguishableProteins()
    getIndistinguishableProteins = function(){
    
        py_ans = private$py_obj$getIndistinguishableProteins()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void insertIndistinguishableProteins(ProteinGroup group)
    insertIndistinguishableProteins = function(group){
    
        if(!(is.R6(group) && class(group)[1] == "ProteinGroup")){ stop("arg group wrong type") }
    
        private$py_obj$insertIndistinguishableProteins(group)
        invisible()
    },
    
    # C++ signature: double getSignificanceThreshold()
    getSignificanceThreshold = function(){
    
        py_ans = private$py_obj$getSignificanceThreshold()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSignificanceThreshold(double value)
    setSignificanceThreshold = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setSignificanceThreshold(value)
        invisible()
    },
    
    # C++ signature: String getScoreType()
    getScoreType = function(){
    
        py_ans = private$py_obj$getScoreType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setScoreType(String type)
    setScoreType = function(type){
    
        if(!((is.R6(type) && class(type)[1]=="String") || is_scalar_character(type))){ stop("arg type wrong type") }
    
        private$py_obj$setScoreType(type)
        invisible()
    },
    
    # C++ signature: bool isHigherScoreBetter()
    isHigherScoreBetter = function(){
    
        py_ans = private$py_obj$isHigherScoreBetter()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setHigherScoreBetter(bool higher_is_better)
    setHigherScoreBetter = function(higher_is_better){
    
        if(!( (is_scalar_integer(higher_is_better) || is_scalar_double(higher_is_better)) && higher_is_better == as.integer(higher_is_better))){ stop("arg higher_is_better wrong type") }
    
        private$py_obj$setHigherScoreBetter(as.integer(higher_is_better))
        invisible()
    },
    
    # C++ signature: void sort()
    sort = function(){
    
        private$py_obj$sort()
        invisible()
    },
    
    # C++ signature: void assignRanks()
    assignRanks = function(){
    
        private$py_obj$assignRanks()
        invisible()
    },
    
    # C++ signature: void computeCoverage(libcpp_vector[PeptideIdentification] pep_ids)
    computeCoverage = function(pep_ids){
    
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
        v0 <- r_to_py(pep_ids)
        private$py_obj$computeCoverage(v0)
        
        invisible()
    },
    
    # C++ signature: DateTime getDateTime()
    getDateTime = function(){
    
        py_ans = private$py_obj$getDateTime()
        r_ans = DateTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDateTime(DateTime date)
    setDateTime = function(date){
    
        if(!(is.R6(date) && class(date)[1] == "DateTime")){ stop("arg date wrong type") }
    
        private$py_obj$setDateTime(date)
        invisible()
    },
    
    # C++ signature: void setSearchEngine(String search_engine)
    setSearchEngine = function(search_engine){
    
        if(!((is.R6(search_engine) && class(search_engine)[1]=="String") || is_scalar_character(search_engine))){ stop("arg search_engine wrong type") }
    
        private$py_obj$setSearchEngine(search_engine)
        invisible()
    },
    
    # C++ signature: String getSearchEngine()
    getSearchEngine = function(){
    
        py_ans = private$py_obj$getSearchEngine()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSearchEngineVersion(String search_engine_version)
    setSearchEngineVersion = function(search_engine_version){
    
        if(!((is.R6(search_engine_version) && class(search_engine_version)[1]=="String") || is_scalar_character(search_engine_version))){ stop("arg search_engine_version wrong type") }
    
        private$py_obj$setSearchEngineVersion(search_engine_version)
        invisible()
    },
    
    # C++ signature: String getSearchEngineVersion()
    getSearchEngineVersion = function(){
    
        py_ans = private$py_obj$getSearchEngineVersion()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSearchParameters(SearchParameters search_parameters)
    setSearchParameters = function(search_parameters){
    
        if(!(is.R6(search_parameters) && class(search_parameters)[1] == "SearchParameters")){ stop("arg search_parameters wrong type") }
    
        private$py_obj$setSearchParameters(search_parameters)
        invisible()
    },
    
    # C++ signature: SearchParameters getSearchParameters()
    getSearchParameters = function(){
    
        py_ans = private$py_obj$getSearchParameters()
        r_ans = SearchParameters$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getIdentifier()
    getIdentifier = function(){
    
        py_ans = private$py_obj$getIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifier(String id_)
    setIdentifier = function(id_){
    
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
    
        private$py_obj$setIdentifier(id_)
        invisible()
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    setPrimaryMSRunPath_0 = function(s){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
        private$py_obj$`_setPrimaryMSRunPath_0`(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s, bool raw)
    setPrimaryMSRunPath_1 = function(s, raw){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(raw) || is_scalar_double(raw)) && raw == as.integer(raw))){ stop("arg raw wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
    
        private$py_obj$`_setPrimaryMSRunPath_1`(v0, as.integer(raw))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPrimaryMSRunPath(StringList & s)
    # C++ signature: void setPrimaryMSRunPath(StringList & s, bool raw)
    setPrimaryMSRunPath = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$setPrimaryMSRunPath_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$setPrimaryMSRunPath_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void addPrimaryMSRunPath(StringList & s)
    addPrimaryMSRunPath_0 = function(s){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
        private$py_obj$`_addPrimaryMSRunPath_0`(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addPrimaryMSRunPath(StringList & s, bool raw)
    addPrimaryMSRunPath_1 = function(s, raw){
    
        if(!(is_list(s) && all(sapply(s),is_scalar_character))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(raw) || is_scalar_double(raw)) && raw == as.integer(raw))){ stop("arg raw wrong type") }
        v0 = r_to_py(modify_depth(s,1,py_builtin$bytes(s,'utf-8')))
    
        private$py_obj$`_addPrimaryMSRunPath_1`(v0, as.integer(raw))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addPrimaryMSRunPath(StringList & s)
    # C++ signature: void addPrimaryMSRunPath(StringList & s, bool raw)
    addPrimaryMSRunPath = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$addPrimaryMSRunPath_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$addPrimaryMSRunPath_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & output)
    getPrimaryMSRunPath_0 = function(output){
    
        if(!(is_list(output) && all(sapply(output),is_scalar_character))){ stop("arg output wrong type") }
        v0 = r_to_py(modify_depth(output,1,py_builtin$bytes(output,'utf-8')))
        private$py_obj$`_getPrimaryMSRunPath_0`(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(output <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & output, bool raw)
    getPrimaryMSRunPath_1 = function(output, raw){
    
        if(!(is_list(output) && all(sapply(output),is_scalar_character))){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(raw) || is_scalar_double(raw)) && raw == as.integer(raw))){ stop("arg raw wrong type") }
        v0 = r_to_py(modify_depth(output,1,py_builtin$bytes(output,'utf-8')))
    
        private$py_obj$`_getPrimaryMSRunPath_1`(v0, as.integer(raw))
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(output <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getPrimaryMSRunPath(StringList & output)
    # C++ signature: void getPrimaryMSRunPath(StringList & output, bool raw)
    getPrimaryMSRunPath = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character))) { self$getPrimaryMSRunPath_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]]),is_scalar_character)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$getPrimaryMSRunPath_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _ProteinInference
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinInference.html
ProteinInference <- R6Class(classname = "ProteinInference",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProteinInference()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProteinInference()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinInference(ProteinInference)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinInference")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinInference(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinInference()
    # C++ signature: void ProteinInference(ProteinInference)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinInference")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinInference" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void infer(ConsensusMap & consensus_map, unsigned int reference_map)
    infer = function(consensus_map, reference_map){
    
        if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
        if(!( (is_scalar_integer(reference_map) || is_scalar_double(reference_map)) && reference_map == as.integer(reference_map))){ stop("arg reference_map wrong type") }
    
    
        private$py_obj$infer(consensus_map, as.integer(reference_map))
        invisible()
    }
)
) 

# R implementation of _ProteinProteinCrossLink
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::OPXLDataStructs_1_1ProteinProteinCrossLink.html
ProteinProteinCrossLink <- R6Class(classname = "ProteinProteinCrossLink",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        alpha = function(alpha){
    
        if(!missing(alpha)){
            if(!(is.R6(alpha) && class(alpha)[1] == "AASequence")){ stop("arg alpha wrong type") }
        
        
            private$py_obj$alpha <- alpha
            } else {
        
            if (is.null(private$py_obj$alpha)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$alpha ; if( is.null(py_ans) ) { return(NULL) }
            r_result = AASequence$new(py_ans)
                return(r_result)
                }
            }
        },
        beta = function(beta){
    
        if(!missing(beta)){
            if(!(is.R6(beta) && class(beta)[1] == "AASequence")){ stop("arg beta wrong type") }
        
        
            private$py_obj$beta <- beta
            } else {
        
            if (is.null(private$py_obj$beta)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$beta ; if( is.null(py_ans) ) { return(NULL) }
            r_result = AASequence$new(py_ans)
                return(r_result)
                }
            }
        },
        cross_link_position = function(cross_link_position){
    
        if(!missing(cross_link_position)){
            if(!(is_list(cross_link_position) && length(cross_link_position) == 2 &&  (is_scalar_integer(cross_link_position[[1]]) || is_scalar_double(cross_link_position[[1]])) && cross_link_position[[1]] == as.integer(cross_link_position[[1]]) &&  (is_scalar_integer(cross_link_position[[2]]) || is_scalar_double(cross_link_position[[2]])) && cross_link_position[[2]] == as.integer(cross_link_position[[2]]))){ stop("arg cross_link_position wrong type") }
        
            v0 = r_to_py(list(as.integer(cross_link_position[[1]]),as.integer(cross_link_position[[2]])))
            private$py_obj$cross_link_position <- v0
            } else {
                py_ans = private$py_obj$cross_link_position
            r_result = list(py_ans[[1]], py_ans[[2]])
                return(r_result)
                }
        },
        cross_linker_mass = function(cross_linker_mass){
    
        if(!missing(cross_linker_mass)){
            if(!(is_scalar_double(cross_linker_mass))){ stop("arg cross_linker_mass wrong type") }
        
        
            private$py_obj$cross_linker_mass <- cross_linker_mass
            } else {
        
                py_ans = private$py_obj$cross_linker_mass
                r_result = py_ans
                return(r_result)
                }
        },
        cross_linker_name = function(cross_linker_name){
    
        if(!missing(cross_linker_name)){
            if(!((is.R6(cross_linker_name) && class(cross_linker_name)[1]=="String") || is_scalar_character(cross_linker_name))){ stop("arg cross_linker_name wrong type") }
        
        
            private$py_obj$cross_linker_name <- cross_linker_name
            } else {
        
                py_ans = private$py_obj$cross_linker_name
            r_result = py_ans
                return(r_result)
                }
        },
        term_spec_alpha = function(term_spec_alpha){
    
        if(!missing(term_spec_alpha)){
            if(!(term_spec_alpha %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec_alpha wrong type") }
        
        
            private$py_obj$term_spec_alpha <- as.integer(term_spec_alpha)
            } else {
        
                py_ans = private$py_obj$term_spec_alpha
                r_result = py_ans
                return(r_result)
                }
        },
        term_spec_beta = function(term_spec_beta){
    
        if(!missing(term_spec_beta)){
            if(!(term_spec_beta %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec_beta wrong type") }
        
        
            private$py_obj$term_spec_beta <- as.integer(term_spec_beta)
            } else {
        
                py_ans = private$py_obj$term_spec_beta
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_correction = function(precursor_correction){
    
        if(!missing(precursor_correction)){
            if(!( (is_scalar_integer(precursor_correction) || is_scalar_double(precursor_correction)) && precursor_correction == as.integer(precursor_correction))){ stop("arg precursor_correction wrong type") }
        
        
            private$py_obj$precursor_correction <- as.integer(precursor_correction)
            } else {
        
                py_ans = private$py_obj$precursor_correction
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ProteinProteinCrossLink(ProteinProteinCrossLink)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinProteinCrossLink")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinProteinCrossLink(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinProteinCrossLink()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$ProteinProteinCrossLink()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinProteinCrossLink(ProteinProteinCrossLink)
    # C++ signature: void ProteinProteinCrossLink()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinProteinCrossLink")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinProteinCrossLink" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: ProteinProteinCrossLinkType getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ProteinResolver
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProteinResolver.html
ProteinResolver <- R6Class(classname = "ProteinResolver",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProteinResolver()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProteinResolver()
        invisible()
    
    
    },
    
    # C++ signature: void ProteinResolver(ProteinResolver)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProteinResolver")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProteinResolver(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProteinResolver()
    # C++ signature: void ProteinResolver(ProteinResolver)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProteinResolver")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProteinResolver" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void resolveConsensus(ConsensusMap & consensus)
    resolveConsensus = function(consensus){
    
        if(!(is.R6(consensus) && class(consensus)[1] == "ConsensusMap")){ stop("arg consensus wrong type") }
    
        private$py_obj$resolveConsensus(consensus)
        invisible()
    },
    
    # C++ signature: void resolveID(libcpp_vector[PeptideIdentification] & peptide_identifications)
    resolveID = function(peptide_identifications){
    
        if(!(is_list(peptide_identifications) && all(sapply(peptide_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_identifications wrong type") }
        v0 <- r_to_py(peptide_identifications)
        private$py_obj$resolveID(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_identifications <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setProteinData(libcpp_vector[FASTAEntry] & protein_data)
    setProteinData = function(protein_data){
    
        if(!(is_list(protein_data) && all(sapply(protein_data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FASTAEntry")))){ stop("arg protein_data wrong type") }
        v0 <- r_to_py(protein_data)
        private$py_obj$setProteinData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(protein_data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[ResolverResult] getResults()
    getResults = function(){
    
        py_ans = private$py_obj$getResults()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void countTargetDecoy(libcpp_vector[MSDGroup] & msd_groups, ConsensusMap & consensus)
    countTargetDecoy_0 = function(msd_groups, consensus){
    
        if(!(is_list(msd_groups) && all(sapply(msd_groups,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSDGroup")))){ stop("arg msd_groups wrong type") }
        if(!(is.R6(consensus) && class(consensus)[1] == "ConsensusMap")){ stop("arg consensus wrong type") }
        v0 <- r_to_py(msd_groups)
    
        private$py_obj$`_countTargetDecoy_0`(v0, consensus)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(msd_groups <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void countTargetDecoy(libcpp_vector[MSDGroup] & msd_groups, libcpp_vector[PeptideIdentification] & peptide_nodes)
    countTargetDecoy_1 = function(msd_groups, peptide_nodes){
    
        if(!(is_list(msd_groups) && all(sapply(msd_groups,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSDGroup")))){ stop("arg msd_groups wrong type") }
        if(!(is_list(peptide_nodes) && all(sapply(peptide_nodes,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_nodes wrong type") }
        v0 <- r_to_py(msd_groups)
        v1 <- r_to_py(peptide_nodes)
        private$py_obj$`_countTargetDecoy_1`(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(msd_groups <- byref_0))
        eval.parent(substitute(peptide_nodes <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void countTargetDecoy(libcpp_vector[MSDGroup] & msd_groups, ConsensusMap & consensus)
    # C++ signature: void countTargetDecoy(libcpp_vector[MSDGroup] & msd_groups, libcpp_vector[PeptideIdentification] & peptide_nodes)
    countTargetDecoy = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSDGroup"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$countTargetDecoy_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSDGroup"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))) { self$countTargetDecoy_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void clearResult()
    clearResult = function(){
    
        private$py_obj$clearResult()
        invisible()
    },
    
    # C++ signature: PeptideIdentification getPeptideIdentification(ConsensusMap & consensus, PeptideEntry * peptide)
    getPeptideIdentification_0 = function(consensus, peptide){
    
        if(!(is.R6(consensus) && class(consensus)[1] == "ConsensusMap")){ stop("arg consensus wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "PeptideEntry")){ stop("arg peptide wrong type") }
    
    
        py_ans = private$py_obj$`_getPeptideIdentification_0`(consensus, peptide)
        r_ans = PeptideIdentification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PeptideIdentification getPeptideIdentification(libcpp_vector[PeptideIdentification] & peptide_nodes, PeptideEntry * peptide)
    getPeptideIdentification_1 = function(peptide_nodes, peptide){
    
        if(!(is_list(peptide_nodes) && all(sapply(peptide_nodes,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_nodes wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "PeptideEntry")){ stop("arg peptide wrong type") }
        v0 <- r_to_py(peptide_nodes)
    
        py_ans = private$py_obj$`_getPeptideIdentification_1`(v0, peptide)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = PeptideIdentification$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(peptide_nodes <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: PeptideIdentification getPeptideIdentification(ConsensusMap & consensus, PeptideEntry * peptide)
    # C++ signature: PeptideIdentification getPeptideIdentification(libcpp_vector[PeptideIdentification] & peptide_nodes, PeptideEntry * peptide)
    getPeptideIdentification = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "PeptideEntry")) { self$getPeptideIdentification_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "PeptideEntry")) { self$getPeptideIdentification_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: PeptideHit getPeptideHit(ConsensusMap & consensus, PeptideEntry * peptide)
    getPeptideHit_0 = function(consensus, peptide){
    
        if(!(is.R6(consensus) && class(consensus)[1] == "ConsensusMap")){ stop("arg consensus wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "PeptideEntry")){ stop("arg peptide wrong type") }
    
    
        py_ans = private$py_obj$`_getPeptideHit_0`(consensus, peptide)
        r_ans = PeptideHit$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: PeptideHit getPeptideHit(libcpp_vector[PeptideIdentification] & peptide_nodes, PeptideEntry * peptide)
    getPeptideHit_1 = function(peptide_nodes, peptide){
    
        if(!(is_list(peptide_nodes) && all(sapply(peptide_nodes,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_nodes wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "PeptideEntry")){ stop("arg peptide wrong type") }
        v0 <- r_to_py(peptide_nodes)
    
        py_ans = private$py_obj$`_getPeptideHit_1`(v0, peptide)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = PeptideHit$new(py_ans)
    
        tryCatch({
        eval.parent(substitute(peptide_nodes <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: PeptideHit getPeptideHit(ConsensusMap & consensus, PeptideEntry * peptide)
    # C++ signature: PeptideHit getPeptideHit(libcpp_vector[PeptideIdentification] & peptide_nodes, PeptideEntry * peptide)
    getPeptideHit = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ConsensusMap") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "PeptideEntry")) { self$getPeptideHit_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "PeptideEntry")) { self$getPeptideHit_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ProtonDistributionModel
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ProtonDistributionModel.html
ProtonDistributionModel <- R6Class(classname = "ProtonDistributionModel",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ProtonDistributionModel()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ProtonDistributionModel()
        invisible()
    
    
    },
    
    # C++ signature: void ProtonDistributionModel(ProtonDistributionModel)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ProtonDistributionModel")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ProtonDistributionModel(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ProtonDistributionModel()
    # C++ signature: void ProtonDistributionModel(ProtonDistributionModel)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ProtonDistributionModel")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ProtonDistributionModel" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getProtonDistribution(libcpp_vector[double] & bb_charges, libcpp_vector[double] & sc_charges, AASequence & peptide, int charge, ResidueType res_type)
    getProtonDistribution = function(bb_charges, sc_charges, peptide, charge, res_type){
    
        if(!(is_list(bb_charges) && all(sapply(bb_charges,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg bb_charges wrong type") }
        if(!(is_list(sc_charges) && all(sapply(sc_charges,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg sc_charges wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
        v0 <- r_to_py(bb_charges)
        v1 <- r_to_py(sc_charges)
    
    
    
        private$py_obj$getProtonDistribution(v0, v1, peptide, as.integer(charge), as.integer(res_type))
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(bb_charges <- byref_0))
        eval.parent(substitute(sc_charges <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getChargeStateIntensities(AASequence & peptide, AASequence & n_term_ion, AASequence & c_term_ion, int charge, ResidueType n_term_type, libcpp_vector[double] & n_term_intensities, libcpp_vector[double] & c_term_intensities, FragmentationType type_)
    getChargeStateIntensities = function(peptide, n_term_ion, c_term_ion, charge, n_term_type, n_term_intensities, c_term_intensities, type_){
    
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!(is.R6(n_term_ion) && class(n_term_ion)[1] == "AASequence")){ stop("arg n_term_ion wrong type") }
        if(!(is.R6(c_term_ion) && class(c_term_ion)[1] == "AASequence")){ stop("arg c_term_ion wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!(n_term_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg n_term_type wrong type") }
        if(!(is_list(n_term_intensities) && all(sapply(n_term_intensities,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg n_term_intensities wrong type") }
        if(!(is_list(c_term_intensities) && all(sapply(c_term_intensities,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg c_term_intensities wrong type") }
        if(!(type_ %in% c(0, 1, 2))){ stop("arg type_ wrong type") }
    
    
    
    
    
        v5 <- r_to_py(n_term_intensities)
        v6 <- r_to_py(c_term_intensities)
    
        private$py_obj$getChargeStateIntensities(peptide, n_term_ion, c_term_ion, as.integer(charge), as.integer(n_term_type), v5, v6, as.integer(type_))
        byref_6 <- map_depth(py_to_r(v6),0,as.list)
        byref_5 <- map_depth(py_to_r(v5),0,as.list)
    
        tryCatch({
        eval.parent(substitute(n_term_intensities <- byref_5))
        eval.parent(substitute(c_term_intensities <- byref_6))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setPeptideProtonDistribution(libcpp_vector[double] & bb_charge, libcpp_vector[double] & sc_charge)
    setPeptideProtonDistribution = function(bb_charge, sc_charge){
    
        if(!(is_list(bb_charge) && all(sapply(bb_charge,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg bb_charge wrong type") }
        if(!(is_list(sc_charge) && all(sapply(sc_charge,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg sc_charge wrong type") }
        v0 <- r_to_py(bb_charge)
        v1 <- r_to_py(sc_charge)
        private$py_obj$setPeptideProtonDistribution(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(bb_charge <- byref_0))
        eval.parent(substitute(sc_charge <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _Publication
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1Publication.html
Publication <- R6Class(classname = "Publication",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Publication()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Publication) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Publication()
        invisible()
    }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _PurityScores
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1PurityScores.html
PurityScores <- R6Class(classname = "PurityScores",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        total_intensity = function(total_intensity){
    
        if(!missing(total_intensity)){
            if(!(is_scalar_double(total_intensity))){ stop("arg total_intensity wrong type") }
        
        
            private$py_obj$total_intensity <- total_intensity
            } else {
        
                py_ans = private$py_obj$total_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        target_intensity = function(target_intensity){
    
        if(!missing(target_intensity)){
            if(!(is_scalar_double(target_intensity))){ stop("arg target_intensity wrong type") }
        
        
            private$py_obj$target_intensity <- target_intensity
            } else {
        
                py_ans = private$py_obj$target_intensity
                r_result = py_ans
                return(r_result)
                }
        },
        signal_proportion = function(signal_proportion){
    
        if(!missing(signal_proportion)){
            if(!(is_scalar_double(signal_proportion))){ stop("arg signal_proportion wrong type") }
        
        
            private$py_obj$signal_proportion <- signal_proportion
            } else {
        
                py_ans = private$py_obj$signal_proportion
                r_result = py_ans
                return(r_result)
                }
        },
        target_peak_count = function(target_peak_count){
    
        if(!missing(target_peak_count)){
            if(!( (is_scalar_integer(target_peak_count) || is_scalar_double(target_peak_count)) && target_peak_count == as.integer(target_peak_count))){ stop("arg target_peak_count wrong type") }
        
        
            private$py_obj$target_peak_count <- as.integer(target_peak_count)
            } else {
        
                py_ans = private$py_obj$target_peak_count
                r_result = py_ans
                return(r_result)
                }
        },
        residual_peak_count = function(residual_peak_count){
    
        if(!missing(residual_peak_count)){
            if(!( (is_scalar_integer(residual_peak_count) || is_scalar_double(residual_peak_count)) && residual_peak_count == as.integer(residual_peak_count))){ stop("arg residual_peak_count wrong type") }
        
        
            private$py_obj$residual_peak_count <- as.integer(residual_peak_count)
            } else {
        
                py_ans = private$py_obj$residual_peak_count
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void PurityScores(PurityScores)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "PurityScores")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$PurityScores(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void PurityScores()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$PurityScores()
        invisible()
    
    
    },
    
    # C++ signature: void PurityScores(PurityScores)
    # C++ signature: void PurityScores()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "PurityScores")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "PurityScores" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _QTCluster
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1QTCluster.html
QTCluster <- R6Class(classname = "QTCluster",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: double getCenterRT()
    getCenterRT = function(){
    
        py_ans = private$py_obj$getCenterRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getCenterMZ()
    getCenterMZ = function(){
    
        py_ans = private$py_obj$getCenterMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getXCoord()
    getXCoord = function(){
    
        py_ans = private$py_obj$getXCoord()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getYCoord()
    getYCoord = function(){
    
        py_ans = private$py_obj$getYCoord()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getQuality()
    getQuality = function(){
    
        py_ans = private$py_obj$getQuality()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[AASequence] getAnnotations()
    getAnnotations = function(){
    
        py_ans = private$py_obj$getAnnotations()
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) AASequence$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: void setInvalid()
    setInvalid = function(){
    
        private$py_obj$setInvalid()
        invisible()
    },
    
    # C++ signature: bool isInvalid()
    isInvalid = function(){
    
        py_ans = private$py_obj$isInvalid()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void initializeCluster()
    initializeCluster = function(){
    
        private$py_obj$initializeCluster()
        invisible()
    },
    
    # C++ signature: void finalizeCluster()
    finalizeCluster = function(){
    
        private$py_obj$finalizeCluster()
        invisible()
    }
)
) 

# R implementation of _QTClusterFinder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1QTClusterFinder.html
QTClusterFinder <- R6Class(classname = "QTClusterFinder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void QTClusterFinder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == QTClusterFinder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$QTClusterFinder()
        invisible()
    }
    
    },
    
    # C++ signature: void run(libcpp_vector[ConsensusMap] & input_maps, ConsensusMap & result_map)
    run_0 = function(input_maps, result_map){
    
        if(!(is_list(input_maps) && all(sapply(input_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg input_maps wrong type") }
        if(!(is.R6(result_map) && class(result_map)[1] == "ConsensusMap")){ stop("arg result_map wrong type") }
        v0 <- r_to_py(input_maps)
    
        private$py_obj$`_run_0`(v0, result_map)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(input_maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void run(libcpp_vector[FeatureMap] & input_maps, ConsensusMap & result_map)
    run_1 = function(input_maps, result_map){
    
        if(!(is_list(input_maps) && all(sapply(input_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg input_maps wrong type") }
        if(!(is.R6(result_map) && class(result_map)[1] == "ConsensusMap")){ stop("arg result_map wrong type") }
        v0 <- r_to_py(input_maps)
    
        private$py_obj$`_run_1`(v0, result_map)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(input_maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void run(libcpp_vector[ConsensusMap] & input_maps, ConsensusMap & result_map)
    # C++ signature: void run(libcpp_vector[FeatureMap] & input_maps, ConsensusMap & result_map)
    run = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$run_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ConsensusMap")) { self$run_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _QcMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1QcMLFile.html
QcMLFile <- R6Class(classname = "QcMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void QcMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == QcMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$QcMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: String exportIDstats(const String & filename)
    exportIDstats = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$exportIDstats(filename)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addRunQualityParameter(String r, QualityParameter qp)
    addRunQualityParameter = function(r, qp){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is.R6(qp) && class(qp)[1] == "QualityParameter")){ stop("arg qp wrong type") }
    
    
        private$py_obj$addRunQualityParameter(r, qp)
        invisible()
    },
    
    # C++ signature: void addRunAttachment(String r, Attachment at)
    addRunAttachment = function(r, at){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is.R6(at) && class(at)[1] == "Attachment")){ stop("arg at wrong type") }
    
    
        private$py_obj$addRunAttachment(r, at)
        invisible()
    },
    
    # C++ signature: void addSetQualityParameter(String r, QualityParameter qp)
    addSetQualityParameter = function(r, qp){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is.R6(qp) && class(qp)[1] == "QualityParameter")){ stop("arg qp wrong type") }
    
    
        private$py_obj$addSetQualityParameter(r, qp)
        invisible()
    },
    
    # C++ signature: void addSetAttachment(String r, Attachment at)
    addSetAttachment = function(r, at){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is.R6(at) && class(at)[1] == "Attachment")){ stop("arg at wrong type") }
    
    
        private$py_obj$addSetAttachment(r, at)
        invisible()
    },
    
    # C++ signature: void removeAttachment(String r, libcpp_vector[String] & ids, String at)
    removeAttachment_0 = function(r, ids, at){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
        if(!((is.R6(at) && class(at)[1]=="String") || is_scalar_character(at))){ stop("arg at wrong type") }
    
        v1 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
    
        private$py_obj$`_removeAttachment_0`(r, v1, at)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void removeAttachment(String r, String at)
    removeAttachment_1 = function(r, at){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!((is.R6(at) && class(at)[1]=="String") || is_scalar_character(at))){ stop("arg at wrong type") }
    
    
        private$py_obj$`_removeAttachment_1`(r, at)
        invisible()
    },
    
    # C++ signature: void removeAttachment(String r, libcpp_vector[String] & ids, String at)
    # C++ signature: void removeAttachment(String r, String at)
    removeAttachment = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]]),is_scalar_character)) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$removeAttachment_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$removeAttachment_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeAllAttachments(String at)
    removeAllAttachments = function(at){
    
        if(!((is.R6(at) && class(at)[1]=="String") || is_scalar_character(at))){ stop("arg at wrong type") }
    
        private$py_obj$removeAllAttachments(at)
        invisible()
    },
    
    # C++ signature: void removeQualityParameter(String r, libcpp_vector[String] & ids)
    removeQualityParameter = function(r, ids){
    
        if(!((is.R6(r) && class(r)[1]=="String") || is_scalar_character(r))){ stop("arg r wrong type") }
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
    
        v1 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
        private$py_obj$removeQualityParameter(r, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void merge(QcMLFile & addendum, String setname)
    merge = function(addendum, setname){
    
        if(!(is.R6(addendum) && class(addendum)[1] == "QcMLFile")){ stop("arg addendum wrong type") }
        if(!((is.R6(setname) && class(setname)[1]=="String") || is_scalar_character(setname))){ stop("arg setname wrong type") }
    
    
        private$py_obj$merge(addendum, setname)
        invisible()
    },
    
    # C++ signature: void collectSetParameter(String setname, String qp, libcpp_vector[String] & ret)
    collectSetParameter = function(setname, qp, ret){
    
        if(!((is.R6(setname) && class(setname)[1]=="String") || is_scalar_character(setname))){ stop("arg setname wrong type") }
        if(!((is.R6(qp) && class(qp)[1]=="String") || is_scalar_character(qp))){ stop("arg qp wrong type") }
        if(!(is_list(ret) && all(sapply(ret),is_scalar_character))){ stop("arg ret wrong type") }
    
    
        v2 = r_to_py(modify_depth(ret,1,py_builtin$bytes(ret,'utf-8')))
        private$py_obj$collectSetParameter(setname, qp, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ret <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String exportAttachment(String filename, String qpname)
    exportAttachment = function(filename, qpname){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(qpname) && class(qpname)[1]=="String") || is_scalar_character(qpname))){ stop("arg qpname wrong type") }
    
    
        py_ans = private$py_obj$exportAttachment(filename, qpname)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getRunNames(libcpp_vector[String] & ids)
    getRunNames = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
        v0 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
        private$py_obj$getRunNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool existsRun(String filename)
    existsRun = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$existsRun(filename)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool existsSet(String filename)
    existsSet = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$existsSet(filename)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void existsRunQualityParameter(String filename, String qpname, libcpp_vector[String] & ids)
    existsRunQualityParameter = function(filename, qpname, ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(qpname) && class(qpname)[1]=="String") || is_scalar_character(qpname))){ stop("arg qpname wrong type") }
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
    
    
        v2 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
        private$py_obj$existsRunQualityParameter(filename, qpname, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void existsSetQualityParameter(String filename, String qpname, libcpp_vector[String] & ids)
    existsSetQualityParameter = function(filename, qpname, ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(qpname) && class(qpname)[1]=="String") || is_scalar_character(qpname))){ stop("arg qpname wrong type") }
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
    
    
        v2 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
        private$py_obj$existsSetQualityParameter(filename, qpname, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(const String & filename)
    store = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$store(filename)
        invisible()
    },
    
    # C++ signature: void load(const String & filename)
    load = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$load(filename)
        invisible()
    },
    
    # C++ signature: void registerRun(String id_, String name)
    registerRun = function(id_, name){
    
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
    
        private$py_obj$registerRun(id_, name)
        invisible()
    },
    
    # C++ signature: void registerSet(String id_, String name, libcpp_set[String] & names)
    registerSet = function(id_, name, names){
    
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is_list(names) && all(sapply(names),is_scalar_character) && !any(duplicated(names) == T))){ stop("arg names wrong type") }
    
    
        v2 = py_builtin$set(modify_depth(names,1,py_builtin$bytes(names,'utf-8')))
        private$py_obj$registerSet(id_, name, v2)
        byref_2 <- modify_depth(py_to_r(py_builtin$list(v2)),1,as.character)
    
        tryCatch({
        eval.parent(substitute(names <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String exportQP(String filename, String qpname)
    exportQP = function(filename, qpname){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(qpname) && class(qpname)[1]=="String") || is_scalar_character(qpname))){ stop("arg qpname wrong type") }
    
    
        py_ans = private$py_obj$exportQP(filename, qpname)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String exportQPs(String filename, StringList qpnames)
    exportQPs = function(filename, qpnames){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(qpnames) && all(sapply(qpnames),is_scalar_character))){ stop("arg qpnames wrong type") }
    
        v1 = r_to_py(modify_depth(qpnames,1,py_builtin$bytes(qpnames,'utf-8')))
        py_ans = private$py_obj$exportQPs(filename, v1)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getRunIDs(libcpp_vector[String] & ids)
    getRunIDs = function(ids){
    
        if(!(is_list(ids) && all(sapply(ids),is_scalar_character))){ stop("arg ids wrong type") }
        v0 = r_to_py(modify_depth(ids,1,py_builtin$bytes(ids,'utf-8')))
        private$py_obj$getRunIDs(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(ids <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void reset()
    reset = function(){
    
        private$py_obj$reset()
        invisible()
    },
    
    # C++ signature: void error(ActionMode mode, const String & msg, unsigned int line, unsigned int column)
    error = function(mode, msg, line, column){
    
        if(!(mode %in% c(0, 1))){ stop("arg mode wrong type") }
        if(!((is.R6(msg) && class(msg)[1]=="String") || is_scalar_character(msg))){ stop("arg msg wrong type") }
        if(!( (is_scalar_integer(line) || is_scalar_double(line)) && line == as.integer(line))){ stop("arg line wrong type") }
        if(!( (is_scalar_integer(column) || is_scalar_double(column)) && column == as.integer(column))){ stop("arg column wrong type") }
    
    
    
    
        private$py_obj$error(as.integer(mode), msg, as.integer(line), as.integer(column))
        invisible()
    },
    
    # C++ signature: void warning(ActionMode mode, const String & msg, unsigned int line, unsigned int column)
    warning = function(mode, msg, line, column){
    
        if(!(mode %in% c(0, 1))){ stop("arg mode wrong type") }
        if(!((is.R6(msg) && class(msg)[1]=="String") || is_scalar_character(msg))){ stop("arg msg wrong type") }
        if(!( (is_scalar_integer(line) || is_scalar_double(line)) && line == as.integer(line))){ stop("arg line wrong type") }
        if(!( (is_scalar_integer(column) || is_scalar_double(column)) && column == as.integer(column))){ stop("arg column wrong type") }
    
    
    
    
        private$py_obj$warning(as.integer(mode), msg, as.integer(line), as.integer(column))
        invisible()
    },
    
    # C++ signature: String errorString()
    errorString = function(){
    
        py_ans = private$py_obj$errorString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _QualityParameter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1QualityParameter.html
QualityParameter <- R6Class(classname = "QualityParameter",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        },
        value = function(value){
    
        if(!missing(value)){
            if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
        
        
            private$py_obj$value <- value
            } else {
        
                py_ans = private$py_obj$value
            r_result = py_ans
                return(r_result)
                }
        },
        cvRef = function(cvRef){
    
        if(!missing(cvRef)){
            if(!((is.R6(cvRef) && class(cvRef)[1]=="String") || is_scalar_character(cvRef))){ stop("arg cvRef wrong type") }
        
        
            private$py_obj$cvRef <- cvRef
            } else {
        
                py_ans = private$py_obj$cvRef
            r_result = py_ans
                return(r_result)
                }
        },
        cvAcc = function(cvAcc){
    
        if(!missing(cvAcc)){
            if(!((is.R6(cvAcc) && class(cvAcc)[1]=="String") || is_scalar_character(cvAcc))){ stop("arg cvAcc wrong type") }
        
        
            private$py_obj$cvAcc <- cvAcc
            } else {
        
                py_ans = private$py_obj$cvAcc
            r_result = py_ans
                return(r_result)
                }
        },
        unitRef = function(unitRef){
    
        if(!missing(unitRef)){
            if(!((is.R6(unitRef) && class(unitRef)[1]=="String") || is_scalar_character(unitRef))){ stop("arg unitRef wrong type") }
        
        
            private$py_obj$unitRef <- unitRef
            } else {
        
                py_ans = private$py_obj$unitRef
            r_result = py_ans
                return(r_result)
                }
        },
        unitAcc = function(unitAcc){
    
        if(!missing(unitAcc)){
            if(!((is.R6(unitAcc) && class(unitAcc)[1]=="String") || is_scalar_character(unitAcc))){ stop("arg unitAcc wrong type") }
        
        
            private$py_obj$unitAcc <- unitAcc
            } else {
        
                py_ans = private$py_obj$unitAcc
            r_result = py_ans
                return(r_result)
                }
        },
        flag = function(flag){
    
        if(!missing(flag)){
            if(!((is.R6(flag) && class(flag)[1]=="String") || is_scalar_character(flag))){ stop("arg flag wrong type") }
        
        
            private$py_obj$flag <- flag
            } else {
        
                py_ans = private$py_obj$flag
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void QualityParameter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$QualityParameter()
        invisible()
    
    
    },
    
    # C++ signature: void QualityParameter(QualityParameter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "QualityParameter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$QualityParameter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void QualityParameter()
    # C++ signature: void QualityParameter(QualityParameter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "QualityParameter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "QualityParameter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String toXMLString(unsigned int indentation_level)
    toXMLString = function(indentation_level){
    
        if(!( (is_scalar_integer(indentation_level) || is_scalar_double(indentation_level)) && indentation_level == as.integer(indentation_level))){ stop("arg indentation_level wrong type") }
    
        py_ans = private$py_obj$toXMLString(as.integer(indentation_level))
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _QuantitativeExperimentalDesign
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1QuantitativeExperimentalDesign.html
QuantitativeExperimentalDesign <- R6Class(classname = "QuantitativeExperimentalDesign",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void QuantitativeExperimentalDesign()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == QuantitativeExperimentalDesign) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$QuantitativeExperimentalDesign()
        invisible()
    }
    
    },
    
    # C++ signature: void applyDesign2Resolver(ProteinResolver & resolver, TextFile & file_, StringList & fileNames)
    applyDesign2Resolver = function(resolver, file_, fileNames){
    
        if(!(is.R6(resolver) && class(resolver)[1] == "ProteinResolver")){ stop("arg resolver wrong type") }
        if(!(is.R6(file_) && class(file_)[1] == "TextFile")){ stop("arg file_ wrong type") }
        if(!(is_list(fileNames) && all(sapply(fileNames),is_scalar_character))){ stop("arg fileNames wrong type") }
    
    
        v2 = r_to_py(modify_depth(fileNames,1,py_builtin$bytes(fileNames,'utf-8')))
        private$py_obj$applyDesign2Resolver(resolver, file_, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
    
        tryCatch({
        eval.parent(substitute(fileNames <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _RANSAC[_RansacModelLinear]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1RANSAC[_RansacModelLinear].html
RANSAC <- R6Class(classname = "RANSAC",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RANSAC()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RANSAC) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RANSAC()
        invisible()
    }
    
    }
)
)
    
    # C++ signature: libcpp_vector[libcpp_pair[double,double]] ransac(libcpp_vector[libcpp_pair[double,double]] pairs, size_t n, size_t k, double t, size_t d, bool test)
    RANSAC$ransac = function(pairs, n, k, t, d, test){
    
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg pairs wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
        if(!( (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k))){ stop("arg k wrong type") }
        if(!(is_scalar_double(t))){ stop("arg t wrong type") }
        if(!( (is_scalar_integer(d) || is_scalar_double(d)) && d == as.integer(d))){ stop("arg d wrong type") }
        if(!( (is_scalar_integer(test) || is_scalar_double(test)) && test == as.integer(test))){ stop("arg test wrong type") }
        v0 <- r_to_py(pairs)
    
    
    
    
    
        py_ans = Pymod$RANSAC$ransac(v0, as.integer(n), as.integer(k), t, as.integer(d), as.integer(test))
        
        r_ans <- py_ans
        return(r_ans)
    } 

# R implementation of _RANSACParam
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1RANSACParam.html
RANSACParam <- R6Class(classname = "RANSACParam",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        n = function(n){
    
        if(!missing(n)){
            if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
        
        
            private$py_obj$n <- as.integer(n)
            } else {
        
                py_ans = private$py_obj$n
                r_result = py_ans
                return(r_result)
                }
        },
        k = function(k){
    
        if(!missing(k)){
            if(!( (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k))){ stop("arg k wrong type") }
        
        
            private$py_obj$k <- as.integer(k)
            } else {
        
                py_ans = private$py_obj$k
                r_result = py_ans
                return(r_result)
                }
        },
        t = function(t){
    
        if(!missing(t)){
            if(!(is_scalar_double(t))){ stop("arg t wrong type") }
        
        
            private$py_obj$t <- t
            } else {
        
                py_ans = private$py_obj$t
                r_result = py_ans
                return(r_result)
                }
        },
        d = function(d){
    
        if(!missing(d)){
            if(!( (is_scalar_integer(d) || is_scalar_double(d)) && d == as.integer(d))){ stop("arg d wrong type") }
        
        
            private$py_obj$d <- as.integer(d)
            } else {
        
                py_ans = private$py_obj$d
                r_result = py_ans
                return(r_result)
                }
        },
        relative_d = function(relative_d){
    
        if(!missing(relative_d)){
            if(!( (is_scalar_integer(relative_d) || is_scalar_double(relative_d)) && relative_d == as.integer(relative_d))){ stop("arg relative_d wrong type") }
        
        
            private$py_obj$relative_d <- as.integer(relative_d)
            } else {
        
                py_ans = private$py_obj$relative_d
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void RANSACParam()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$RANSACParam()
        invisible()
    
    
    },
    
    # C++ signature: void RANSACParam(size_t p_n, size_t p_k, double p_t, size_t p_d, bool p_relative_d)
    init_1 = function(p_n, p_k, p_t, p_d, p_relative_d){
    
        if(!( (is_scalar_integer(p_n) || is_scalar_double(p_n)) && p_n == as.integer(p_n))){ stop("arg p_n wrong type") }
        if(!( (is_scalar_integer(p_k) || is_scalar_double(p_k)) && p_k == as.integer(p_k))){ stop("arg p_k wrong type") }
        if(!(is_scalar_double(p_t))){ stop("arg p_t wrong type") }
        if(!( (is_scalar_integer(p_d) || is_scalar_double(p_d)) && p_d == as.integer(p_d))){ stop("arg p_d wrong type") }
        if(!( (is_scalar_integer(p_relative_d) || is_scalar_double(p_relative_d)) && p_relative_d == as.integer(p_relative_d))){ stop("arg p_relative_d wrong type") }
    
    
    
    
    
    
        private$py_obj <- Pymod$RANSACParam(as.integer(p_n), as.integer(p_k), p_t, as.integer(p_d), as.integer(p_relative_d))
        invisible()
    
    
    },
    
    # C++ signature: void RANSACParam()
    # C++ signature: void RANSACParam(size_t p_n, size_t p_k, double p_t, size_t p_d, bool p_relative_d)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==5) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "RANSACParam" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String toString()
    toString = function(){
    
        py_ans = private$py_obj$toString()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RANSAC[_RansacModelQuadratic]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1RANSAC[_RansacModelQuadratic].html
RANSACQuadratic <- R6Class(classname = "RANSACQuadratic",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RANSACQuadratic()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RANSACQuadratic) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RANSACQuadratic()
        invisible()
    }
    
    }
)
)
    
    # C++ signature: libcpp_vector[libcpp_pair[double,double]] ransac(libcpp_vector[libcpp_pair[double,double]] pairs, size_t n, size_t k, double t, size_t d, bool test)
    RANSACQuadratic$ransac = function(pairs, n, k, t, d, test){
    
        if(!(is_list(pairs) && all(sapply(pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg pairs wrong type") }
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
        if(!( (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k))){ stop("arg k wrong type") }
        if(!(is_scalar_double(t))){ stop("arg t wrong type") }
        if(!( (is_scalar_integer(d) || is_scalar_double(d)) && d == as.integer(d))){ stop("arg d wrong type") }
        if(!( (is_scalar_integer(test) || is_scalar_double(test)) && test == as.integer(test))){ stop("arg test wrong type") }
        v0 <- r_to_py(pairs)
    
    
    
    
    
        py_ans = Pymod$RANSACQuadratic$ransac(v0, as.integer(n), as.integer(k), t, as.integer(d), as.integer(test))
        
        r_ans <- py_ans
        return(r_ans)
    } 

# R implementation of _RNPxlMarkerIonExtractor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlMarkerIonExtractor.html
RNPxlMarkerIonExtractor <- R6Class(classname = "RNPxlMarkerIonExtractor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RNPxlMarkerIonExtractor()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RNPxlMarkerIonExtractor) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RNPxlMarkerIonExtractor()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_map[String,libcpp_vector[libcpp_pair[double,double]]] extractMarkerIons(MSSpectrum & s, double marker_tolerance)
    extractMarkerIons = function(s, marker_tolerance){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
        if(!(is_scalar_double(marker_tolerance))){ stop("arg marker_tolerance wrong type") }
    
    
        py_ans = py_call(private$py_obj$extractMarkerIons,s, marker_tolerance)
        r_ans <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),lapply(py_to_r(py_builtin$list(py_ans$keys())),function(i) String$new(i)))
        return(r_ans)
    }
)
) 

# R implementation of _RNPxlModificationMassesResult
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlModificationMassesResult.html
RNPxlModificationMassesResult <- R6Class(classname = "RNPxlModificationMassesResult",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RNPxlModificationMassesResult()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$RNPxlModificationMassesResult()
        invisible()
    
    
    },
    
    # C++ signature: void RNPxlModificationMassesResult(RNPxlModificationMassesResult)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "RNPxlModificationMassesResult")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$RNPxlModificationMassesResult(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void RNPxlModificationMassesResult()
    # C++ signature: void RNPxlModificationMassesResult(RNPxlModificationMassesResult)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "RNPxlModificationMassesResult")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "RNPxlModificationMassesResult" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _RNPxlModificationsGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlModificationsGenerator.html
RNPxlModificationsGenerator <- R6Class(classname = "RNPxlModificationsGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RNPxlModificationsGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$RNPxlModificationsGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void RNPxlModificationsGenerator(RNPxlModificationsGenerator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "RNPxlModificationsGenerator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$RNPxlModificationsGenerator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void RNPxlModificationsGenerator()
    # C++ signature: void RNPxlModificationsGenerator(RNPxlModificationsGenerator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "RNPxlModificationsGenerator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "RNPxlModificationsGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: RNPxlModificationMassesResult initModificationMassesRNA(StringList target_nucleotides, StringList nt_groups, libcpp_set[char] can_xl, StringList mappings, StringList modifications, String sequence_restriction, bool cysteine_adduct, int max_length)
    initModificationMassesRNA = function(target_nucleotides, nt_groups, can_xl, mappings, modifications, sequence_restriction, cysteine_adduct, max_length){
    
        if(!(is_list(target_nucleotides) && all(sapply(target_nucleotides),is_scalar_character))){ stop("arg target_nucleotides wrong type") }
        if(!(is_list(nt_groups) && all(sapply(nt_groups),is_scalar_character))){ stop("arg nt_groups wrong type") }
        if(!(is_list(can_xl) && all(sapply(can_xl,function(el) is_scalar_character(el))) && !(TRUE %in% duplicated(can_xl)))){ stop("arg can_xl wrong type") }
        if(!(is_list(mappings) && all(sapply(mappings),is_scalar_character))){ stop("arg mappings wrong type") }
        if(!(is_list(modifications) && all(sapply(modifications),is_scalar_character))){ stop("arg modifications wrong type") }
        if(!((is.R6(sequence_restriction) && class(sequence_restriction)[1]=="String") || is_scalar_character(sequence_restriction))){ stop("arg sequence_restriction wrong type") }
        if(!( (is_scalar_integer(cysteine_adduct) || is_scalar_double(cysteine_adduct)) && cysteine_adduct == as.integer(cysteine_adduct))){ stop("arg cysteine_adduct wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
        v0 = r_to_py(modify_depth(target_nucleotides,1,py_builtin$bytes(target_nucleotides,'utf-8')))
        v1 = r_to_py(modify_depth(nt_groups,1,py_builtin$bytes(nt_groups,'utf-8')))
        py$v2 <- can_xl
        py_run_string("v2 = set(v2)")
        v3 = r_to_py(modify_depth(mappings,1,py_builtin$bytes(mappings,'utf-8')))
        v4 = r_to_py(modify_depth(modifications,1,py_builtin$bytes(modifications,'utf-8')))
    
    
    
        py_ans = private$py_obj$initModificationMassesRNA(v0, v1, py$v2, v3, v4, sequence_restriction, as.integer(cysteine_adduct), as.integer(max_length))
        r_ans = RNPxlModificationMassesResult$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _RNPxlReport
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlReport.html
RNPxlReport <- R6Class(classname = "RNPxlReport",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: libcpp_vector[RNPxlReportRow] annotate(MSExperiment & spectra, libcpp_vector[PeptideIdentification] & peptide_ids, double marker_ions_tolerance)
    annotate = function(spectra, peptide_ids, marker_ions_tolerance){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is_scalar_double(marker_ions_tolerance))){ stop("arg marker_ions_tolerance wrong type") }
    
        v1 <- r_to_py(peptide_ids)
    
        py_ans = private$py_obj$annotate(spectra, v1, marker_ions_tolerance)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _RNPxlReportRow
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlReportRow.html
RNPxlReportRow <- R6Class(classname = "RNPxlReportRow",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        no_id = function(no_id){
    
        if(!missing(no_id)){
            if(!( (is_scalar_integer(no_id) || is_scalar_double(no_id)) && no_id == as.integer(no_id))){ stop("arg no_id wrong type") }
        
        
            private$py_obj$no_id <- as.integer(no_id)
            } else {
        
                py_ans = private$py_obj$no_id
                r_result = py_ans
                return(r_result)
                }
        },
        rt = function(rt){
    
        if(!missing(rt)){
            if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        
        
            private$py_obj$rt <- rt
            } else {
        
                py_ans = private$py_obj$rt
                r_result = py_ans
                return(r_result)
                }
        },
        original_mz = function(original_mz){
    
        if(!missing(original_mz)){
            if(!(is_scalar_double(original_mz))){ stop("arg original_mz wrong type") }
        
        
            private$py_obj$original_mz <- original_mz
            } else {
        
                py_ans = private$py_obj$original_mz
                r_result = py_ans
                return(r_result)
                }
        },
        accessions = function(accessions){
    
        if(!missing(accessions)){
            if(!((is.R6(accessions) && class(accessions)[1]=="String") || is_scalar_character(accessions))){ stop("arg accessions wrong type") }
        
        
            private$py_obj$accessions <- accessions
            } else {
        
                py_ans = private$py_obj$accessions
            r_result = py_ans
                return(r_result)
                }
        },
        RNA = function(RNA){
    
        if(!missing(RNA)){
            if(!((is.R6(RNA) && class(RNA)[1]=="String") || is_scalar_character(RNA))){ stop("arg RNA wrong type") }
        
        
            private$py_obj$RNA <- RNA
            } else {
        
                py_ans = private$py_obj$RNA
            r_result = py_ans
                return(r_result)
                }
        },
        peptide = function(peptide){
    
        if(!missing(peptide)){
            if(!((is.R6(peptide) && class(peptide)[1]=="String") || is_scalar_character(peptide))){ stop("arg peptide wrong type") }
        
        
            private$py_obj$peptide <- peptide
            } else {
        
                py_ans = private$py_obj$peptide
            r_result = py_ans
                return(r_result)
                }
        },
        best_localization_score = function(best_localization_score){
    
        if(!missing(best_localization_score)){
            if(!(is_scalar_double(best_localization_score))){ stop("arg best_localization_score wrong type") }
        
        
            private$py_obj$best_localization_score <- best_localization_score
            } else {
        
                py_ans = private$py_obj$best_localization_score
                r_result = py_ans
                return(r_result)
                }
        },
        localization_scores = function(localization_scores){
    
        if(!missing(localization_scores)){
            if(!((is.R6(localization_scores) && class(localization_scores)[1]=="String") || is_scalar_character(localization_scores))){ stop("arg localization_scores wrong type") }
        
        
            private$py_obj$localization_scores <- localization_scores
            } else {
        
                py_ans = private$py_obj$localization_scores
            r_result = py_ans
                return(r_result)
                }
        },
        best_localization = function(best_localization){
    
        if(!missing(best_localization)){
            if(!((is.R6(best_localization) && class(best_localization)[1]=="String") || is_scalar_character(best_localization))){ stop("arg best_localization wrong type") }
        
        
            private$py_obj$best_localization <- best_localization
            } else {
        
                py_ans = private$py_obj$best_localization
            r_result = py_ans
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        peptide_weight = function(peptide_weight){
    
        if(!missing(peptide_weight)){
            if(!(is_scalar_double(peptide_weight))){ stop("arg peptide_weight wrong type") }
        
        
            private$py_obj$peptide_weight <- peptide_weight
            } else {
        
                py_ans = private$py_obj$peptide_weight
                r_result = py_ans
                return(r_result)
                }
        },
        RNA_weight = function(RNA_weight){
    
        if(!missing(RNA_weight)){
            if(!(is_scalar_double(RNA_weight))){ stop("arg RNA_weight wrong type") }
        
        
            private$py_obj$RNA_weight <- RNA_weight
            } else {
        
                py_ans = private$py_obj$RNA_weight
                r_result = py_ans
                return(r_result)
                }
        },
        xl_weight = function(xl_weight){
    
        if(!missing(xl_weight)){
            if(!(is_scalar_double(xl_weight))){ stop("arg xl_weight wrong type") }
        
        
            private$py_obj$xl_weight <- xl_weight
            } else {
        
                py_ans = private$py_obj$xl_weight
                r_result = py_ans
                return(r_result)
                }
        },
        abs_prec_error = function(abs_prec_error){
    
        if(!missing(abs_prec_error)){
            if(!(is_scalar_double(abs_prec_error))){ stop("arg abs_prec_error wrong type") }
        
        
            private$py_obj$abs_prec_error <- abs_prec_error
            } else {
        
                py_ans = private$py_obj$abs_prec_error
                r_result = py_ans
                return(r_result)
                }
        },
        rel_prec_error = function(rel_prec_error){
    
        if(!missing(rel_prec_error)){
            if(!(is_scalar_double(rel_prec_error))){ stop("arg rel_prec_error wrong type") }
        
        
            private$py_obj$rel_prec_error <- rel_prec_error
            } else {
        
                py_ans = private$py_obj$rel_prec_error
                r_result = py_ans
                return(r_result)
                }
        },
        marker_ions = function(marker_ions){
    
        if(!missing(marker_ions)){
            if(!(
          is.environment(marker_ions) && identical(parent.env(marker_ions), asNamespace("collections")) && identical(strsplit(capture.output(marker_ions$print())," ")[[1]][1], "dict")
          && all(sapply(marker_ions$keys(),function(k) (is.R6(k) && class(k)[1]=="String") || is_scalar_character(k)))
          && all(sapply(marker_ions$values(),function(v) is_list(v) && all(sapply(v,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]])))))
          )){ stop("arg marker_ions wrong type") }
        
            v0 <- py_dict(marker_ions$keys(),marker_ions$values())
            private$py_obj$marker_ions <- v0
            } else {
        
                py_ans = private$py_obj$marker_ions
            r_result <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),lapply(py_to_r(py_builtin$list(py_ans$keys())),function(i) String$new(i)))
                return(r_result)
                }
        },
        m_H = function(m_H){
    
        if(!missing(m_H)){
            if(!(is_scalar_double(m_H))){ stop("arg m_H wrong type") }
        
        
            private$py_obj$m_H <- m_H
            } else {
        
                py_ans = private$py_obj$m_H
                r_result = py_ans
                return(r_result)
                }
        },
        m_2H = function(m_2H){
    
        if(!missing(m_2H)){
            if(!(is_scalar_double(m_2H))){ stop("arg m_2H wrong type") }
        
        
            private$py_obj$m_2H <- m_2H
            } else {
        
                py_ans = private$py_obj$m_2H
                r_result = py_ans
                return(r_result)
                }
        },
        m_3H = function(m_3H){
    
        if(!missing(m_3H)){
            if(!(is_scalar_double(m_3H))){ stop("arg m_3H wrong type") }
        
        
            private$py_obj$m_3H <- m_3H
            } else {
        
                py_ans = private$py_obj$m_3H
                r_result = py_ans
                return(r_result)
                }
        },
        m_4H = function(m_4H){
    
        if(!missing(m_4H)){
            if(!(is_scalar_double(m_4H))){ stop("arg m_4H wrong type") }
        
        
            private$py_obj$m_4H <- m_4H
            } else {
        
                py_ans = private$py_obj$m_4H
                r_result = py_ans
                return(r_result)
                }
        },
        rank = function(rank){
    
        if(!missing(rank)){
            if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        
        
            private$py_obj$rank <- as.integer(rank)
            } else {
        
                py_ans = private$py_obj$rank
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: String getString(const String & separator)
    getString = function(separator){
    
        if(!((is.R6(separator) && class(separator)[1]=="String") || is_scalar_character(separator))){ stop("arg separator wrong type") }
    
        py_ans = private$py_obj$getString(separator)
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RNPxlReportRowHeader
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNPxlReportRowHeader.html
RNPxlReportRowHeader <- R6Class(classname = "RNPxlReportRowHeader",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: String getString(const String & separator)
    getString = function(separator){
    
        if(!((is.R6(separator) && class(separator)[1]=="String") || is_scalar_character(separator))){ stop("arg separator wrong type") }
    
        py_ans = private$py_obj$getString(separator)
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RNaseDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNaseDB.html
RNaseDB <- R6Class(classname = "RNaseDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: const DigestionEnzymeRNA * getEnzyme(const String & name)
    getEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getEnzyme(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = DigestionEnzymeRNA$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const DigestionEnzymeRNA * getEnzymeByRegEx(const String & cleavage_regex)
    getEnzymeByRegEx = function(cleavage_regex){
    
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
    
        py_ans = private$py_obj$getEnzymeByRegEx(cleavage_regex) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = DigestionEnzymeRNA$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getAllNames(libcpp_vector[String] & all_names)
    getAllNames = function(all_names){
    
        if(!(is_list(all_names) && all(sapply(all_names),is_scalar_character))){ stop("arg all_names wrong type") }
        v0 = r_to_py(modify_depth(all_names,1,py_builtin$bytes(all_names,'utf-8')))
        private$py_obj$getAllNames(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(all_names <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool hasEnzyme(const String & name)
    hasEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$hasEnzyme(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasRegEx(const String & cleavage_regex)
    hasRegEx = function(cleavage_regex){
    
        if(!((is.R6(cleavage_regex) && class(cleavage_regex)[1]=="String") || is_scalar_character(cleavage_regex))){ stop("arg cleavage_regex wrong type") }
    
        py_ans = private$py_obj$hasRegEx(cleavage_regex)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RNaseDigestion
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RNaseDigestion.html
RNaseDigestion <- R6Class(classname = "RNaseDigestion",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RNaseDigestion()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RNaseDigestion) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RNaseDigestion()
        invisible()
    }
    
    },
    
    # C++ signature: ptrdiff_t getMissedCleavages()
    getMissedCleavages = function(){
    
        py_ans = private$py_obj$getMissedCleavages()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMissedCleavages(ptrdiff_t missed_cleavages)
    setMissedCleavages = function(missed_cleavages){
    
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
    
        private$py_obj$setMissedCleavages(as.integer(missed_cleavages))
        invisible()
    },
    
    # C++ signature: String getEnzymeName()
    getEnzymeName = function(){
    
        py_ans = private$py_obj$getEnzymeName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setEnzyme(String name)
    setEnzyme = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setEnzyme(name)
        invisible()
    },
    
    # C++ signature: void digest(NASequence & rna, libcpp_vector[NASequence] & output)
    digest_0 = function(rna, output){
    
        if(!(is.R6(rna) && class(rna)[1] == "NASequence")){ stop("arg rna wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "NASequence")))){ stop("arg output wrong type") }
    
        v1 <- r_to_py(output)
        private$py_obj$`_digest_0`(rna, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void digest(NASequence & rna, libcpp_vector[NASequence] & output, size_t min_length, size_t max_length)
    digest_1 = function(rna, output, min_length, max_length){
    
        if(!(is.R6(rna) && class(rna)[1] == "NASequence")){ stop("arg rna wrong type") }
        if(!(is_list(output) && all(sapply(output,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "NASequence")))){ stop("arg output wrong type") }
        if(!( (is_scalar_integer(min_length) || is_scalar_double(min_length)) && min_length == as.integer(min_length))){ stop("arg min_length wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
    
        v1 <- r_to_py(output)
    
    
        private$py_obj$`_digest_1`(rna, v1, as.integer(min_length), as.integer(max_length))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(output <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void digest(IdentificationData & id_data)
    digest_2 = function(id_data){
    
        if(!(is.R6(id_data) && class(id_data)[1] == "IdentificationData")){ stop("arg id_data wrong type") }
    
        private$py_obj$`_digest_2`(id_data)
        invisible()
    },
    
    # C++ signature: void digest(IdentificationData & id_data, size_t min_length, size_t max_length)
    digest_3 = function(id_data, min_length, max_length){
    
        if(!(is.R6(id_data) && class(id_data)[1] == "IdentificationData")){ stop("arg id_data wrong type") }
        if(!( (is_scalar_integer(min_length) || is_scalar_double(min_length)) && min_length == as.integer(min_length))){ stop("arg min_length wrong type") }
        if(!( (is_scalar_integer(max_length) || is_scalar_double(max_length)) && max_length == as.integer(max_length))){ stop("arg max_length wrong type") }
    
    
    
        private$py_obj$`_digest_3`(id_data, as.integer(min_length), as.integer(max_length))
        invisible()
    },
    
    # C++ signature: void digest(NASequence & rna, libcpp_vector[NASequence] & output)
    # C++ signature: void digest(NASequence & rna, libcpp_vector[NASequence] & output, size_t min_length, size_t max_length)
    # C++ signature: void digest(IdentificationData & id_data)
    # C++ signature: void digest(IdentificationData & id_data, size_t min_length, size_t max_length)
    digest = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "NASequence") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "NASequence")))) { self$digest_0(...) }
        else if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "NASequence") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "NASequence"))) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$digest_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IdentificationData")) { self$digest_2(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "IdentificationData") && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$digest_3(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: Specificity getSpecificity()
    getSpecificity = function(){
    
        py_ans = private$py_obj$getSpecificity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSpecificity(Specificity spec)
    setSpecificity = function(spec){
    
        if(!(spec %in% c(0, 1, 2, 3, 8, 9, 10))){ stop("arg spec wrong type") }
    
        private$py_obj$setSpecificity(as.integer(spec))
        invisible()
    },
    
    # C++ signature: Specificity getSpecificityByName(String name)
    getSpecificityByName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getSpecificityByName(name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValidProduct(String protein, size_t pep_pos, size_t pep_length, bool ignore_missed_cleavages)
    isValidProduct = function(protein, pep_pos, pep_length, ignore_missed_cleavages){
    
        if(!((is.R6(protein) && class(protein)[1]=="String") || is_scalar_character(protein))){ stop("arg protein wrong type") }
        if(!( (is_scalar_integer(pep_pos) || is_scalar_double(pep_pos)) && pep_pos == as.integer(pep_pos))){ stop("arg pep_pos wrong type") }
        if(!( (is_scalar_integer(pep_length) || is_scalar_double(pep_length)) && pep_length == as.integer(pep_length))){ stop("arg pep_length wrong type") }
        if(!( (is_scalar_integer(ignore_missed_cleavages) || is_scalar_double(ignore_missed_cleavages)) && ignore_missed_cleavages == as.integer(ignore_missed_cleavages))){ stop("arg ignore_missed_cleavages wrong type") }
    
    
    
    
        py_ans = private$py_obj$isValidProduct(protein, as.integer(pep_pos), as.integer(pep_length), as.integer(ignore_missed_cleavages))
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RansacModelLinear
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1RansacModelLinear.html
RansacModelLinear <- R6Class(classname = "RansacModelLinear",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RansacModelLinear()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RansacModelLinear) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RansacModelLinear()
        invisible()
    }
    
    }
)
) 

# R implementation of _RansacModelQuadratic
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Math_1_1RansacModelQuadratic.html
RansacModelQuadratic <- R6Class(classname = "RansacModelQuadratic",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RansacModelQuadratic()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RansacModelQuadratic) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RansacModelQuadratic()
        invisible()
    }
    
    }
)
) 

# R implementation of _Ratio
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Ratio.html
Ratio <- R6Class(classname = "Ratio",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        ratio_value_ = function(ratio_value_){
    
        if(!missing(ratio_value_)){
            if(!(is_scalar_double(ratio_value_))){ stop("arg ratio_value_ wrong type") }
        
        
            private$py_obj$ratio_value_ <- ratio_value_
            } else {
        
                py_ans = private$py_obj$ratio_value_
                r_result = py_ans
                return(r_result)
                }
        },
        denominator_ref_ = function(denominator_ref_){
    
        if(!missing(denominator_ref_)){
            if(!((is.R6(denominator_ref_) && class(denominator_ref_)[1]=="String") || is_scalar_character(denominator_ref_))){ stop("arg denominator_ref_ wrong type") }
        
        
            private$py_obj$denominator_ref_ <- denominator_ref_
            } else {
        
                py_ans = private$py_obj$denominator_ref_
            r_result = py_ans
                return(r_result)
                }
        },
        numerator_ref_ = function(numerator_ref_){
    
        if(!missing(numerator_ref_)){
            if(!((is.R6(numerator_ref_) && class(numerator_ref_)[1]=="String") || is_scalar_character(numerator_ref_))){ stop("arg numerator_ref_ wrong type") }
        
        
            private$py_obj$numerator_ref_ <- numerator_ref_
            } else {
        
                py_ans = private$py_obj$numerator_ref_
            r_result = py_ans
                return(r_result)
                }
        },
        description_ = function(description_){
    
        if(!missing(description_)){
            if(!(is_list(description_) && all(sapply(description_),is_scalar_character))){ stop("arg description_ wrong type") }
        
            v0 = r_to_py(modify_depth(description_,1,py_builtin$bytes(description_,'utf-8')))
            private$py_obj$description_ <- v0
            } else {
        
                py_ans = private$py_obj$description_
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Ratio()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Ratio()
        invisible()
    
    
    },
    
    # C++ signature: void Ratio(Ratio rhs)
    init_1 = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "Ratio")){ stop("arg rhs wrong type") }
    
    
        private$py_obj <- Pymod$Ratio(rhs)
        invisible()
    
    
    },
    
    # C++ signature: void Ratio()
    # C++ signature: void Ratio(Ratio rhs)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Ratio")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Ratio" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _ReactionMonitoringTransition
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ReactionMonitoringTransition.html
ReactionMonitoringTransition <- R6Class(classname = "ReactionMonitoringTransition",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ReactionMonitoringTransition()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ReactionMonitoringTransition) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ReactionMonitoringTransition()
        invisible()
    }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getNativeID()
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getPeptideRef()
    getPeptideRef = function(){
    
        py_ans = private$py_obj$getPeptideRef()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: void setNativeID(String name)
    setNativeID = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setNativeID(name)
        invisible()
    },
    
    # C++ signature: void setPeptideRef(String peptide_ref)
    setPeptideRef = function(peptide_ref){
    
        if(!((is.R6(peptide_ref) && class(peptide_ref)[1]=="String") || is_scalar_character(peptide_ref))){ stop("arg peptide_ref wrong type") }
    
        private$py_obj$setPeptideRef(peptide_ref)
        invisible()
    },
    
    # C++ signature: double getProductMZ()
    getProductMZ = function(){
    
        py_ans = private$py_obj$getProductMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setProductMZ(double)
    setProductMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setProductMZ(in_0)
        invisible()
    },
    
    # C++ signature: double getPrecursorMZ()
    getPrecursorMZ = function(){
    
        py_ans = private$py_obj$getPrecursorMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMZ(double)
    setPrecursorMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPrecursorMZ(in_0)
        invisible()
    },
    
    # C++ signature: DecoyTransitionType getDecoyTransitionType()
    getDecoyTransitionType = function(){
    
        py_ans = private$py_obj$getDecoyTransitionType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCompoundRef(const String & compound_ref)
    setCompoundRef = function(compound_ref){
    
        if(!((is.R6(compound_ref) && class(compound_ref)[1]=="String") || is_scalar_character(compound_ref))){ stop("arg compound_ref wrong type") }
    
        private$py_obj$setCompoundRef(compound_ref)
        invisible()
    },
    
    # C++ signature: String getCompoundRef()
    getCompoundRef = function(){
    
        py_ans = private$py_obj$getCompoundRef()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasPrecursorCVTerms()
    hasPrecursorCVTerms = function(){
    
        py_ans = private$py_obj$hasPrecursorCVTerms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorCVTermList(CVTermList & list_)
    setPrecursorCVTermList = function(list_){
    
        if(!(is.R6(list_) && class(list_)[1] == "CVTermList")){ stop("arg list_ wrong type") }
    
        private$py_obj$setPrecursorCVTermList(list_)
        invisible()
    },
    
    # C++ signature: void addPrecursorCVTerm(CVTerm & cv_term)
    addPrecursorCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$addPrecursorCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: CVTermList getPrecursorCVTermList()
    getPrecursorCVTermList = function(){
    
        py_ans = private$py_obj$getPrecursorCVTermList()
        r_ans = CVTermList$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addProductCVTerm(CVTerm & cv_term)
    addProductCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$addProductCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: libcpp_vector[TraMLProduct] getIntermediateProducts()
    getIntermediateProducts = function(){
    
        py_ans = private$py_obj$getIntermediateProducts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addIntermediateProduct(TraMLProduct product)
    addIntermediateProduct = function(product){
    
        if(!(is.R6(product) && class(product)[1] == "TraMLProduct")){ stop("arg product wrong type") }
    
        private$py_obj$addIntermediateProduct(product)
        invisible()
    },
    
    # C++ signature: void setIntermediateProducts(libcpp_vector[TraMLProduct] & products)
    setIntermediateProducts = function(products){
    
        if(!(is_list(products) && all(sapply(products,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TraMLProduct")))){ stop("arg products wrong type") }
        v0 <- r_to_py(products)
        private$py_obj$setIntermediateProducts(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(products <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setProduct(TraMLProduct product)
    setProduct = function(product){
    
        if(!(is.R6(product) && class(product)[1] == "TraMLProduct")){ stop("arg product wrong type") }
    
        private$py_obj$setProduct(product)
        invisible()
    },
    
    # C++ signature: TraMLProduct getProduct()
    getProduct = function(){
    
        py_ans = private$py_obj$getProduct()
        r_ans = TraMLProduct$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setRetentionTime(RetentionTime rt)
    setRetentionTime = function(rt){
    
        if(!(is.R6(rt) && class(rt)[1] == "RetentionTime")){ stop("arg rt wrong type") }
    
        private$py_obj$setRetentionTime(rt)
        invisible()
    },
    
    # C++ signature: RetentionTime getRetentionTime()
    getRetentionTime = function(){
    
        py_ans = private$py_obj$getRetentionTime()
        r_ans = RetentionTime$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPrediction(Prediction & prediction)
    setPrediction = function(prediction){
    
        if(!(is.R6(prediction) && class(prediction)[1] == "Prediction")){ stop("arg prediction wrong type") }
    
        private$py_obj$setPrediction(prediction)
        invisible()
    },
    
    # C++ signature: void addPredictionTerm(CVTerm & prediction)
    addPredictionTerm = function(prediction){
    
        if(!(is.R6(prediction) && class(prediction)[1] == "CVTerm")){ stop("arg prediction wrong type") }
    
        private$py_obj$addPredictionTerm(prediction)
        invisible()
    },
    
    # C++ signature: bool hasPrediction()
    hasPrediction = function(){
    
        py_ans = private$py_obj$hasPrediction()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Prediction getPrediction()
    getPrediction = function(){
    
        py_ans = private$py_obj$getPrediction()
        r_ans = Prediction$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setDecoyTransitionType(DecoyTransitionType & d)
    setDecoyTransitionType = function(d){
    
        if(!(d %in% c(0, 1, 2))){ stop("arg d wrong type") }
    
        private$py_obj$setDecoyTransitionType(as.integer(d))
        invisible()
    },
    
    # C++ signature: double getLibraryIntensity()
    getLibraryIntensity = function(){
    
        py_ans = private$py_obj$getLibraryIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLibraryIntensity(double intensity)
    setLibraryIntensity = function(intensity){
    
        if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
    
        private$py_obj$setLibraryIntensity(intensity)
        invisible()
    },
    
    # C++ signature: int getProductChargeState()
    getProductChargeState = function(){
    
        py_ans = private$py_obj$getProductChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isProductChargeStateSet()
    isProductChargeStateSet = function(){
    
        py_ans = private$py_obj$isProductChargeStateSet()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isDetectingTransition()
    isDetectingTransition = function(){
    
        py_ans = private$py_obj$isDetectingTransition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDetectingTransition(bool val)
    setDetectingTransition = function(val){
    
        if(!( (is_scalar_integer(val) || is_scalar_double(val)) && val == as.integer(val))){ stop("arg val wrong type") }
    
        private$py_obj$setDetectingTransition(as.integer(val))
        invisible()
    },
    
    # C++ signature: bool isIdentifyingTransition()
    isIdentifyingTransition = function(){
    
        py_ans = private$py_obj$isIdentifyingTransition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIdentifyingTransition(bool val)
    setIdentifyingTransition = function(val){
    
        if(!( (is_scalar_integer(val) || is_scalar_double(val)) && val == as.integer(val))){ stop("arg val wrong type") }
    
        private$py_obj$setIdentifyingTransition(as.integer(val))
        invisible()
    },
    
    # C++ signature: bool isQuantifyingTransition()
    isQuantifyingTransition = function(){
    
        py_ans = private$py_obj$isQuantifyingTransition()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setQuantifyingTransition(bool val)
    setQuantifyingTransition = function(val){
    
        if(!( (is_scalar_integer(val) || is_scalar_double(val)) && val == as.integer(val))){ stop("arg val wrong type") }
    
        private$py_obj$setQuantifyingTransition(as.integer(val))
        invisible()
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _RealMassDecomposer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::ims_1_1RealMassDecomposer.html
RealMassDecomposer <- R6Class(classname = "RealMassDecomposer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RealMassDecomposer(IMSWeights & weights)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RealMassDecomposer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!(is.R6(weights) && class(weights)[1] == "IMSWeights")){ stop("arg weights wrong type") }
    
    
        private$py_obj <- Pymod$RealMassDecomposer(weights)
        invisible()
    }
    
    },
    
    # C++ signature: unsigned long int getNumberOfDecompositions(double mass, double error)
    getNumberOfDecompositions = function(mass, error){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
        if(!(is_scalar_double(error))){ stop("arg error wrong type") }
    
    
        py_ans = private$py_obj$getNumberOfDecompositions(mass, error)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RegularSwathFileConsumer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RegularSwathFileConsumer.html
RegularSwathFileConsumer <- R6Class(classname = "RegularSwathFileConsumer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RegularSwathFileConsumer()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == RegularSwathFileConsumer) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$RegularSwathFileConsumer()
        invisible()
    }
    
    },
    
    # C++ signature: void setExpectedSize(size_t s, size_t c)
    setExpectedSize = function(s, c){
    
        if(!( (is_scalar_integer(s) || is_scalar_double(s)) && s == as.integer(s))){ stop("arg s wrong type") }
        if(!( (is_scalar_integer(c) || is_scalar_double(c)) && c == as.integer(c))){ stop("arg c wrong type") }
    
    
        private$py_obj$setExpectedSize(as.integer(s), as.integer(c))
        invisible()
    },
    
    # C++ signature: void setExperimentalSettings(ExperimentalSettings exp)
    setExperimentalSettings = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "ExperimentalSettings")){ stop("arg exp wrong type") }
    
        private$py_obj$setExperimentalSettings(exp)
        invisible()
    },
    
    # C++ signature: void retrieveSwathMaps(libcpp_vector[SwathMap] & maps)
    retrieveSwathMaps = function(maps){
    
        if(!(is_list(maps) && all(sapply(maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg maps wrong type") }
        v0 <- r_to_py(maps)
        private$py_obj$retrieveSwathMaps(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void consumeSpectrum(MSSpectrum & s)
    consumeSpectrum = function(s){
    
        if(!(is.R6(s) && class(s)[1] == "MSSpectrum")){ stop("arg s wrong type") }
    
        private$py_obj$consumeSpectrum(s)
        invisible()
    },
    
    # C++ signature: void consumeChromatogram(MSChromatogram & c)
    consumeChromatogram = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSChromatogram")){ stop("arg c wrong type") }
    
        private$py_obj$consumeChromatogram(c)
        invisible()
    }
)
) 

# R implementation of _Residue
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Residue.html
Residue <- R6Class(classname = "Residue",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Residue()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Residue()
        invisible()
    
    
    },
    
    # C++ signature: void Residue(String name, String three_letter_code, String one_letter_code, EmpiricalFormula formula)
    init_1 = function(name, three_letter_code, one_letter_code, formula){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(three_letter_code) && class(three_letter_code)[1]=="String") || is_scalar_character(three_letter_code))){ stop("arg three_letter_code wrong type") }
        if(!((is.R6(one_letter_code) && class(one_letter_code)[1]=="String") || is_scalar_character(one_letter_code))){ stop("arg one_letter_code wrong type") }
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
    
    
    
    
    
        private$py_obj <- Pymod$Residue(name, three_letter_code, one_letter_code, formula)
        invisible()
    
    
    },
    
    # C++ signature: void Residue()
    # C++ signature: void Residue(String name, String three_letter_code, String one_letter_code, EmpiricalFormula formula)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "EmpiricalFormula")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Residue" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: EmpiricalFormula getInternalToFull()
    getInternalToFull = function(){
    
        py_ans = private$py_obj$getInternalToFull()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToNTerm()
    getInternalToNTerm = function(){
    
        py_ans = private$py_obj$getInternalToNTerm()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToCTerm()
    getInternalToCTerm = function(){
    
        py_ans = private$py_obj$getInternalToCTerm()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToAIon()
    getInternalToAIon = function(){
    
        py_ans = private$py_obj$getInternalToAIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToBIon()
    getInternalToBIon = function(){
    
        py_ans = private$py_obj$getInternalToBIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToCIon()
    getInternalToCIon = function(){
    
        py_ans = private$py_obj$getInternalToCIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToXIon()
    getInternalToXIon = function(){
    
        py_ans = private$py_obj$getInternalToXIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToYIon()
    getInternalToYIon = function(){
    
        py_ans = private$py_obj$getInternalToYIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getInternalToZIon()
    getInternalToZIon = function(){
    
        py_ans = private$py_obj$getInternalToZIon()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getResidueTypeName(ResidueType res_type)
    getResidueTypeName = function(res_type){
    
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
    
        py_ans = private$py_obj$getResidueTypeName(as.integer(res_type))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setShortName(String short_name)
    setShortName = function(short_name){
    
        if(!((is.R6(short_name) && class(short_name)[1]=="String") || is_scalar_character(short_name))){ stop("arg short_name wrong type") }
    
        private$py_obj$setShortName(short_name)
        invisible()
    },
    
    # C++ signature: String getShortName()
    getShortName = function(){
    
        py_ans = private$py_obj$getShortName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSynonyms(libcpp_set[String] synonyms)
    setSynonyms = function(synonyms){
    
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        v0 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
        private$py_obj$setSynonyms(v0)
        invisible()
    },
    
    # C++ signature: void addSynonym(String synonym)
    addSynonym = function(synonym){
    
        if(!((is.R6(synonym) && class(synonym)[1]=="String") || is_scalar_character(synonym))){ stop("arg synonym wrong type") }
    
        private$py_obj$addSynonym(synonym)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getSynonyms()
    getSynonyms = function(){
    
        py_ans = private$py_obj$getSynonyms()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setThreeLetterCode(String three_letter_code)
    setThreeLetterCode = function(three_letter_code){
    
        if(!((is.R6(three_letter_code) && class(three_letter_code)[1]=="String") || is_scalar_character(three_letter_code))){ stop("arg three_letter_code wrong type") }
    
        private$py_obj$setThreeLetterCode(three_letter_code)
        invisible()
    },
    
    # C++ signature: String getThreeLetterCode()
    getThreeLetterCode = function(){
    
        py_ans = private$py_obj$getThreeLetterCode()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOneLetterCode(String one_letter_code)
    setOneLetterCode = function(one_letter_code){
    
        if(!((is.R6(one_letter_code) && class(one_letter_code)[1]=="String") || is_scalar_character(one_letter_code))){ stop("arg one_letter_code wrong type") }
    
        private$py_obj$setOneLetterCode(one_letter_code)
        invisible()
    },
    
    # C++ signature: String getOneLetterCode()
    getOneLetterCode = function(){
    
        py_ans = private$py_obj$getOneLetterCode()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addLossFormula(EmpiricalFormula)
    addLossFormula = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmpiricalFormula")){ stop("arg in_0 wrong type") }
    
        private$py_obj$addLossFormula(in_0)
        invisible()
    },
    
    # C++ signature: void setLossFormulas(libcpp_vector[EmpiricalFormula])
    setLossFormulas = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "EmpiricalFormula")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setLossFormulas(v0)
        
        invisible()
    },
    
    # C++ signature: void addNTermLossFormula(EmpiricalFormula)
    addNTermLossFormula = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "EmpiricalFormula")){ stop("arg in_0 wrong type") }
    
        private$py_obj$addNTermLossFormula(in_0)
        invisible()
    },
    
    # C++ signature: void setNTermLossFormulas(libcpp_vector[EmpiricalFormula])
    setNTermLossFormulas = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "EmpiricalFormula")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setNTermLossFormulas(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[EmpiricalFormula] getLossFormulas()
    getLossFormulas = function(){
    
        py_ans = private$py_obj$getLossFormulas()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[EmpiricalFormula] getNTermLossFormulas()
    getNTermLossFormulas = function(){
    
        py_ans = private$py_obj$getNTermLossFormulas()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setLossNames(libcpp_vector[String] name)
    setLossNames = function(name){
    
        if(!(is_list(name) && all(sapply(name),is_scalar_character))){ stop("arg name wrong type") }
        v0 = r_to_py(modify_depth(name,1,py_builtin$bytes(name,'utf-8')))
        private$py_obj$setLossNames(v0)
        invisible()
    },
    
    # C++ signature: void setNTermLossNames(libcpp_vector[String] name)
    setNTermLossNames = function(name){
    
        if(!(is_list(name) && all(sapply(name),is_scalar_character))){ stop("arg name wrong type") }
        v0 = r_to_py(modify_depth(name,1,py_builtin$bytes(name,'utf-8')))
        private$py_obj$setNTermLossNames(v0)
        invisible()
    },
    
    # C++ signature: void addLossName(String name)
    addLossName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$addLossName(name)
        invisible()
    },
    
    # C++ signature: void addNTermLossName(String name)
    addNTermLossName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$addNTermLossName(name)
        invisible()
    },
    
    # C++ signature: libcpp_vector[String] getLossNames()
    getLossNames = function(){
    
        py_ans = private$py_obj$getLossNames()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getNTermLossNames()
    getNTermLossNames = function(){
    
        py_ans = private$py_obj$getNTermLossNames()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setFormula(EmpiricalFormula formula)
    setFormula = function(formula){
    
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
    
        private$py_obj$setFormula(formula)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getFormula()
    getFormula_0 = function(){
    
        py_ans = private$py_obj$`_getFormula_0`()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula(ResidueType res_type)
    getFormula_1 = function(res_type){
    
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
    
        py_ans = private$py_obj$`_getFormula_1`(as.integer(res_type))
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getFormula()
    # C++ signature: EmpiricalFormula getFormula(ResidueType res_type)
    getFormula = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getFormula_0(...) }
        else if ((length(arg_list)==1) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))) { self$getFormula_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setAverageWeight(double weight)
    setAverageWeight = function(weight){
    
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
    
        private$py_obj$setAverageWeight(weight)
        invisible()
    },
    
    # C++ signature: double getAverageWeight()
    getAverageWeight_0 = function(){
    
        py_ans = private$py_obj$`_getAverageWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight(ResidueType res_type)
    getAverageWeight_1 = function(res_type){
    
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
    
        py_ans = private$py_obj$`_getAverageWeight_1`(as.integer(res_type))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getAverageWeight()
    # C++ signature: double getAverageWeight(ResidueType res_type)
    getAverageWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getAverageWeight_0(...) }
        else if ((length(arg_list)==1) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))) { self$getAverageWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setMonoWeight(double weight)
    setMonoWeight = function(weight){
    
        if(!(is_scalar_double(weight))){ stop("arg weight wrong type") }
    
        private$py_obj$setMonoWeight(weight)
        invisible()
    },
    
    # C++ signature: double getMonoWeight()
    getMonoWeight_0 = function(){
    
        py_ans = private$py_obj$`_getMonoWeight_0`()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight(ResidueType res_type)
    getMonoWeight_1 = function(res_type){
    
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
    
        py_ans = private$py_obj$`_getMonoWeight_1`(as.integer(res_type))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMonoWeight()
    # C++ signature: double getMonoWeight(ResidueType res_type)
    getMonoWeight = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$getMonoWeight_0(...) }
        else if ((length(arg_list)==1) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))) { self$getMonoWeight_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: const ResidueModification * getModification()
    getModification = function(){
    
        py_ans = private$py_obj$getModification() ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = ResidueModification$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setModification(String name)
    setModification = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setModification(name)
        invisible()
    },
    
    # C++ signature: String getModificationName()
    getModificationName = function(){
    
        py_ans = private$py_obj$getModificationName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setLowMassIons(libcpp_vector[EmpiricalFormula] low_mass_ions)
    setLowMassIons = function(low_mass_ions){
    
        if(!(is_list(low_mass_ions) && all(sapply(low_mass_ions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "EmpiricalFormula")))){ stop("arg low_mass_ions wrong type") }
        v0 <- r_to_py(low_mass_ions)
        private$py_obj$setLowMassIons(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[EmpiricalFormula] getLowMassIons()
    getLowMassIons = function(){
    
        py_ans = private$py_obj$getLowMassIons()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setResidueSets(libcpp_set[String] residues_sets)
    setResidueSets = function(residues_sets){
    
        if(!(is_list(residues_sets) && all(sapply(residues_sets),is_scalar_character) && !any(duplicated(residues_sets) == T))){ stop("arg residues_sets wrong type") }
        v0 = py_builtin$set(modify_depth(residues_sets,1,py_builtin$bytes(residues_sets,'utf-8')))
        private$py_obj$setResidueSets(v0)
        invisible()
    },
    
    # C++ signature: void addResidueSet(String residue_sets)
    addResidueSet = function(residue_sets){
    
        if(!((is.R6(residue_sets) && class(residue_sets)[1]=="String") || is_scalar_character(residue_sets))){ stop("arg residue_sets wrong type") }
    
        private$py_obj$addResidueSet(residue_sets)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getResidueSets()
    getResidueSets = function(){
    
        py_ans = private$py_obj$getResidueSets()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: bool hasNeutralLoss()
    hasNeutralLoss = function(){
    
        py_ans = private$py_obj$hasNeutralLoss()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasNTermNeutralLosses()
    hasNTermNeutralLosses = function(){
    
        py_ans = private$py_obj$hasNTermNeutralLosses()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPka()
    getPka = function(){
    
        py_ans = private$py_obj$getPka()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPkb()
    getPkb = function(){
    
        py_ans = private$py_obj$getPkb()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPkc()
    getPkc = function(){
    
        py_ans = private$py_obj$getPkc()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPiValue()
    getPiValue = function(){
    
        py_ans = private$py_obj$getPiValue()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPka(double value)
    setPka = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setPka(value)
        invisible()
    },
    
    # C++ signature: void setPkb(double value)
    setPkb = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setPkb(value)
        invisible()
    },
    
    # C++ signature: void setPkc(double value)
    setPkc = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setPkc(value)
        invisible()
    },
    
    # C++ signature: double getSideChainBasicity()
    getSideChainBasicity = function(){
    
        py_ans = private$py_obj$getSideChainBasicity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSideChainBasicity(double gb_sc)
    setSideChainBasicity = function(gb_sc){
    
        if(!(is_scalar_double(gb_sc))){ stop("arg gb_sc wrong type") }
    
        private$py_obj$setSideChainBasicity(gb_sc)
        invisible()
    },
    
    # C++ signature: double getBackboneBasicityLeft()
    getBackboneBasicityLeft = function(){
    
        py_ans = private$py_obj$getBackboneBasicityLeft()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setBackboneBasicityLeft(double gb_bb_l)
    setBackboneBasicityLeft = function(gb_bb_l){
    
        if(!(is_scalar_double(gb_bb_l))){ stop("arg gb_bb_l wrong type") }
    
        private$py_obj$setBackboneBasicityLeft(gb_bb_l)
        invisible()
    },
    
    # C++ signature: double getBackboneBasicityRight()
    getBackboneBasicityRight = function(){
    
        py_ans = private$py_obj$getBackboneBasicityRight()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setBackboneBasicityRight(double gb_bb_r)
    setBackboneBasicityRight = function(gb_bb_r){
    
        if(!(is_scalar_double(gb_bb_r))){ stop("arg gb_bb_r wrong type") }
    
        private$py_obj$setBackboneBasicityRight(gb_bb_r)
        invisible()
    },
    
    # C++ signature: bool isModified()
    isModified = function(){
    
        py_ans = private$py_obj$isModified()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isInResidueSet(String residue_set)
    isInResidueSet = function(residue_set){
    
        if(!((is.R6(residue_set) && class(residue_set)[1]=="String") || is_scalar_character(residue_set))){ stop("arg residue_set wrong type") }
    
        py_ans = private$py_obj$isInResidueSet(residue_set)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: char residueTypeToIonLetter(ResidueType res_type)
    residueTypeToIonLetter = function(res_type){
    
        if(!(res_type %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg res_type wrong type") }
    
        py_ans = private$py_obj$residueTypeToIonLetter(as.integer(res_type))
        r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _ResidueDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ResidueDB.html
ResidueDB <- R6Class(classname = "ResidueDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: size_t getNumberOfResidues()
    getNumberOfResidues = function(){
    
        py_ans = private$py_obj$getNumberOfResidues()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfModifiedResidues()
    getNumberOfModifiedResidues = function(){
    
        py_ans = private$py_obj$getNumberOfModifiedResidues()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: const Residue * getResidue(const String & name)
    getResidue = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$getResidue(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Residue$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Residue * getModifiedResidue(const String & name)
    getModifiedResidue_0 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$`_getModifiedResidue_0`(name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Residue$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Residue * getModifiedResidue(Residue * residue, const String & name)
    getModifiedResidue_1 = function(residue, name){
    
        if(!(is.R6(residue) && class(residue)[1] == "Residue")){ stop("arg residue wrong type") }
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
    
        py_ans = private$py_obj$`_getModifiedResidue_1`(residue, name) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Residue$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Residue * getModifiedResidue(const String & name)
    # C++ signature: const Residue * getModifiedResidue(Residue * residue, const String & name)
    getModifiedResidue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getModifiedResidue_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Residue") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$getModifiedResidue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: libcpp_set[const Residue *] getResidues(const String & residue_set)
    getResidues = function(residue_set){
    
        if(!((is.R6(residue_set) && class(residue_set)[1]=="String") || is_scalar_character(residue_set))){ stop("arg residue_set wrong type") }
    
        py_ans = private$py_obj$getResidues(residue_set)
        py$res <- py_ans
        r_ans = py_eval("list(res)")
        r_ans <- lapply(r_ans, function(x) Residue$new(x))
        py_run_string("del res;gc.collect()")
        return(r_ans)
    },
    
    # C++ signature: libcpp_set[String] getResidueSets()
    getResidueSets = function(){
    
        py_ans = private$py_obj$getResidueSets()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: bool hasResidue(const String & name)
    hasResidue = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        py_ans = private$py_obj$hasResidue(name)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ResidueModification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ResidueModification.html
ResidueModification <- R6Class(classname = "ResidueModification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ResidueModification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ResidueModification()
        invisible()
    
    
    },
    
    # C++ signature: void ResidueModification(ResidueModification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ResidueModification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ResidueModification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ResidueModification()
    # C++ signature: void ResidueModification(ResidueModification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ResidueModification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ResidueModification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setId(const String & id_)
    setId = function(id_){
    
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
    
        private$py_obj$setId(id_)
        invisible()
    },
    
    # C++ signature: String getId()
    getId = function(){
    
        py_ans = private$py_obj$getId()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFullId(const String & full_id)
    setFullId = function(full_id){
    
        if(!((is.R6(full_id) && class(full_id)[1]=="String") || is_scalar_character(full_id))){ stop("arg full_id wrong type") }
    
        private$py_obj$setFullId(full_id)
        invisible()
    },
    
    # C++ signature: String getFullId()
    getFullId = function(){
    
        py_ans = private$py_obj$getFullId()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getUniModRecordId()
    getUniModRecordId = function(){
    
        py_ans = private$py_obj$getUniModRecordId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniModRecordId(int id_)
    setUniModRecordId = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        private$py_obj$setUniModRecordId(as.integer(id_))
        invisible()
    },
    
    # C++ signature: String getUniModAccession()
    getUniModAccession = function(){
    
        py_ans = private$py_obj$getUniModAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPSIMODAccession(const String & id_)
    setPSIMODAccession = function(id_){
    
        if(!((is.R6(id_) && class(id_)[1]=="String") || is_scalar_character(id_))){ stop("arg id_ wrong type") }
    
        private$py_obj$setPSIMODAccession(id_)
        invisible()
    },
    
    # C++ signature: String getPSIMODAccession()
    getPSIMODAccession = function(){
    
        py_ans = private$py_obj$getPSIMODAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFullName(const String & full_name)
    setFullName = function(full_name){
    
        if(!((is.R6(full_name) && class(full_name)[1]=="String") || is_scalar_character(full_name))){ stop("arg full_name wrong type") }
    
        private$py_obj$setFullName(full_name)
        invisible()
    },
    
    # C++ signature: String getFullName()
    getFullName = function(){
    
        py_ans = private$py_obj$getFullName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String & name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTermSpecificity(TermSpecificity term_spec)
    setTermSpecificity_0 = function(term_spec){
    
        if(!(term_spec %in% c(0, 1, 2, 3, 4, 5))){ stop("arg term_spec wrong type") }
    
        private$py_obj$`_setTermSpecificity_0`(as.integer(term_spec))
        invisible()
    },
    
    # C++ signature: void setTermSpecificity(const String & name)
    setTermSpecificity_1 = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$`_setTermSpecificity_1`(name)
        invisible()
    },
    
    # C++ signature: void setTermSpecificity(TermSpecificity term_spec)
    # C++ signature: void setTermSpecificity(const String & name)
    setTermSpecificity = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5))) { self$setTermSpecificity_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$setTermSpecificity_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: TermSpecificity getTermSpecificity()
    getTermSpecificity = function(){
    
        py_ans = private$py_obj$getTermSpecificity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTermSpecificityName(TermSpecificity)
    getTermSpecificityName = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2, 3, 4, 5))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getTermSpecificityName(as.integer(in_0))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOrigin(char origin)
    setOrigin = function(origin){
    
        if(!(is_scalar_character(origin))){ stop("arg origin wrong type") }
    py_run_string("origin = bytes(origin)")
        private$py_obj$setOrigin(py$origin)
        py_run_string("del origin")
        invisible()
    },
    
    # C++ signature: char getOrigin()
    getOrigin = function(){
    
        py_ans = private$py_obj$getOrigin()
        r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSourceClassification(const String & classification)
    setSourceClassification_0 = function(classification){
    
        if(!((is.R6(classification) && class(classification)[1]=="String") || is_scalar_character(classification))){ stop("arg classification wrong type") }
    
        private$py_obj$`_setSourceClassification_0`(classification)
        invisible()
    },
    
    # C++ signature: void setSourceClassification(SourceClassification classification)
    setSourceClassification_1 = function(classification){
    
        if(!(classification %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))){ stop("arg classification wrong type") }
    
        private$py_obj$`_setSourceClassification_1`(as.integer(classification))
        invisible()
    },
    
    # C++ signature: void setSourceClassification(const String & classification)
    # C++ signature: void setSourceClassification(SourceClassification classification)
    setSourceClassification = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$setSourceClassification_0(...) }
        else if ((length(arg_list)==1) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))) { self$setSourceClassification_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: SourceClassification getSourceClassification()
    getSourceClassification = function(){
    
        py_ans = private$py_obj$getSourceClassification()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getSourceClassificationName(SourceClassification classification)
    getSourceClassificationName = function(classification){
    
        if(!(classification %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))){ stop("arg classification wrong type") }
    
        py_ans = private$py_obj$getSourceClassificationName(as.integer(classification))
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setAverageMass(double mass)
    setAverageMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setAverageMass(mass)
        invisible()
    },
    
    # C++ signature: double getAverageMass()
    getAverageMass = function(){
    
        py_ans = private$py_obj$getAverageMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMonoMass(double mass)
    setMonoMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setMonoMass(mass)
        invisible()
    },
    
    # C++ signature: double getMonoMass()
    getMonoMass = function(){
    
        py_ans = private$py_obj$getMonoMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDiffAverageMass(double mass)
    setDiffAverageMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setDiffAverageMass(mass)
        invisible()
    },
    
    # C++ signature: double getDiffAverageMass()
    getDiffAverageMass = function(){
    
        py_ans = private$py_obj$getDiffAverageMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDiffMonoMass(double mass)
    setDiffMonoMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setDiffMonoMass(mass)
        invisible()
    },
    
    # C++ signature: double getDiffMonoMass()
    getDiffMonoMass = function(){
    
        py_ans = private$py_obj$getDiffMonoMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFormula(const String & composition)
    setFormula = function(composition){
    
        if(!((is.R6(composition) && class(composition)[1]=="String") || is_scalar_character(composition))){ stop("arg composition wrong type") }
    
        private$py_obj$setFormula(composition)
        invisible()
    },
    
    # C++ signature: String getFormula()
    getFormula = function(){
    
        py_ans = private$py_obj$getFormula()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDiffFormula(EmpiricalFormula & diff_formula)
    setDiffFormula = function(diff_formula){
    
        if(!(is.R6(diff_formula) && class(diff_formula)[1] == "EmpiricalFormula")){ stop("arg diff_formula wrong type") }
    
        private$py_obj$setDiffFormula(diff_formula)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getDiffFormula()
    getDiffFormula = function(){
    
        py_ans = private$py_obj$getDiffFormula()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSynonyms(libcpp_set[String] & synonyms)
    setSynonyms = function(synonyms){
    
        if(!(is_list(synonyms) && all(sapply(synonyms),is_scalar_character) && !any(duplicated(synonyms) == T))){ stop("arg synonyms wrong type") }
        v0 = py_builtin$set(modify_depth(synonyms,1,py_builtin$bytes(synonyms,'utf-8')))
        private$py_obj$setSynonyms(v0)
        byref_0 <- modify_depth(py_to_r(py_builtin$list(v0)),1,as.character)
    
        tryCatch({
        eval.parent(substitute(synonyms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addSynonym(const String & synonym)
    addSynonym = function(synonym){
    
        if(!((is.R6(synonym) && class(synonym)[1]=="String") || is_scalar_character(synonym))){ stop("arg synonym wrong type") }
    
        private$py_obj$addSynonym(synonym)
        invisible()
    },
    
    # C++ signature: libcpp_set[String] getSynonyms()
    getSynonyms = function(){
    
        py_ans = private$py_obj$getSynonyms()
        r_ans = modify_depth(py_to_r(py_builtin$list(py_ans)),1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void setNeutralLossDiffFormula(EmpiricalFormula & loss)
    setNeutralLossDiffFormula = function(loss){
    
        if(!(is.R6(loss) && class(loss)[1] == "EmpiricalFormula")){ stop("arg loss wrong type") }
    
        private$py_obj$setNeutralLossDiffFormula(loss)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getNeutralLossDiffFormula()
    getNeutralLossDiffFormula = function(){
    
        py_ans = private$py_obj$getNeutralLossDiffFormula()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setNeutralLossMonoMass(double mono_mass)
    setNeutralLossMonoMass = function(mono_mass){
    
        if(!(is_scalar_double(mono_mass))){ stop("arg mono_mass wrong type") }
    
        private$py_obj$setNeutralLossMonoMass(mono_mass)
        invisible()
    },
    
    # C++ signature: double getNeutralLossMonoMass()
    getNeutralLossMonoMass = function(){
    
        py_ans = private$py_obj$getNeutralLossMonoMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNeutralLossAverageMass(double average_mass)
    setNeutralLossAverageMass = function(average_mass){
    
        if(!(is_scalar_double(average_mass))){ stop("arg average_mass wrong type") }
    
        private$py_obj$setNeutralLossAverageMass(average_mass)
        invisible()
    },
    
    # C++ signature: double getNeutralLossAverageMass()
    getNeutralLossAverageMass = function(){
    
        py_ans = private$py_obj$getNeutralLossAverageMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasNeutralLoss()
    hasNeutralLoss = function(){
    
        py_ans = private$py_obj$hasNeutralLoss()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isUserDefined()
    isUserDefined = function(){
    
        py_ans = private$py_obj$isUserDefined()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _ResolverResult
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ResolverResult.html
ResolverResult <- R6Class(classname = "ResolverResult",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        identifier = function(identifier){
    
        if(!missing(identifier)){
            if(!((is.R6(identifier) && class(identifier)[1]=="String") || is_scalar_character(identifier))){ stop("arg identifier wrong type") }
        
        
            private$py_obj$identifier <- identifier
            } else {
        
                py_ans = private$py_obj$identifier
            r_result = py_ans
                return(r_result)
                }
        },
        isds = function(isds){
    
        if(!missing(isds)){
            if(!(is_list(isds) && all(sapply(isds,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ISDGroup")))){ stop("arg isds wrong type") }
        
            v0 <- r_to_py(isds)
            private$py_obj$isds <- v0
            } else {
            
            if (is.null(private$py_obj$isds)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$isds
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
            }
        },
        msds = function(msds){
    
        if(!missing(msds)){
            if(!(is_list(msds) && all(sapply(msds,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSDGroup")))){ stop("arg msds wrong type") }
        
            v0 <- r_to_py(msds)
            private$py_obj$msds <- v0
            } else {
            
            if (is.null(private$py_obj$msds)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$msds
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
            }
        },
        protein_entries = function(protein_entries){
    
        if(!missing(protein_entries)){
            if(!(is_list(protein_entries) && all(sapply(protein_entries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinEntry")))){ stop("arg protein_entries wrong type") }
        
            v0 <- r_to_py(protein_entries)
            private$py_obj$protein_entries <- v0
            } else {
            
            if (is.null(private$py_obj$protein_entries)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$protein_entries
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
            }
        },
        peptide_entries = function(peptide_entries){
    
        if(!missing(peptide_entries)){
            if(!(is_list(peptide_entries) && all(sapply(peptide_entries,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideEntry")))){ stop("arg peptide_entries wrong type") }
        
            v0 <- r_to_py(peptide_entries)
            private$py_obj$peptide_entries <- v0
            } else {
            
            if (is.null(private$py_obj$peptide_entries)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$peptide_entries
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
            }
        },
        input_type = function(input_type){
    
        if(!missing(input_type)){
            if(!(input_type %in% c(0, 1))){ stop("arg input_type wrong type") }
        
        
            private$py_obj$input_type <- as.integer(input_type)
            } else {
        
                py_ans = private$py_obj$input_type
                r_result = py_ans
                return(r_result)
                }
        },
        peptide_identification = function(peptide_identification){
    
        if(!missing(peptide_identification)){
            if(!(is_list(peptide_identification) && all(sapply(peptide_identification,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_identification wrong type") }
        
            v0 <- r_to_py(peptide_identification)
            private$py_obj$peptide_identification <- v0
            } else {
            
            if (is.null(private$py_obj$peptide_identification)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$peptide_identification
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
            }
        },
        consensus_map = function(consensus_map){
    
        if(!missing(consensus_map)){
            if(!(is.R6(consensus_map) && class(consensus_map)[1] == "ConsensusMap")){ stop("arg consensus_map wrong type") }
        
        
            private$py_obj$consensus_map <- consensus_map
            } else {
        
            if (is.null(private$py_obj$consensus_map)) {
               stop("Cannot access NULL pointer")
            }
            else {
                py_ans = private$py_obj$consensus_map ; if( is.null(py_ans) ) { return(NULL) }
            r_result = ConsensusMap$new(py_ans)
                return(r_result)
                }
            }
        }

    ),
    
    public = list(
    
    # C++ signature: void ResolverResult()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ResolverResult()
        invisible()
    
    
    },
    
    # C++ signature: void ResolverResult(ResolverResult)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ResolverResult")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ResolverResult(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ResolverResult()
    # C++ signature: void ResolverResult(ResolverResult)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ResolverResult")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ResolverResult" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _RetentionTime
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1RetentionTime.html
RetentionTime <- R6Class(classname = "RetentionTime",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        software_ref = function(software_ref){
    
        if(!missing(software_ref)){
            if(!((is.R6(software_ref) && class(software_ref)[1]=="String") || is_scalar_character(software_ref))){ stop("arg software_ref wrong type") }
        
        
            private$py_obj$software_ref <- software_ref
            } else {
        
                py_ans = private$py_obj$software_ref
            r_result = py_ans
                return(r_result)
                }
        },
        retention_time_unit = function(retention_time_unit){
    
        if(!missing(retention_time_unit)){
            if(!(retention_time_unit %in% c(0, 1, 2, 3))){ stop("arg retention_time_unit wrong type") }
        
        
            private$py_obj$retention_time_unit <- as.integer(retention_time_unit)
            } else {
        
                py_ans = private$py_obj$retention_time_unit
                r_result = py_ans
                return(r_result)
                }
        },
        retention_time_type = function(retention_time_type){
    
        if(!missing(retention_time_type)){
            if(!(retention_time_type %in% c(0, 1, 2, 3, 4, 5, 6))){ stop("arg retention_time_type wrong type") }
        
        
            private$py_obj$retention_time_type <- as.integer(retention_time_type)
            } else {
        
                py_ans = private$py_obj$retention_time_type
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void RetentionTime()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$RetentionTime()
        invisible()
    
    
    },
    
    # C++ signature: void RetentionTime(RetentionTime)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "RetentionTime")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$RetentionTime(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void RetentionTime()
    # C++ signature: void RetentionTime(RetentionTime)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "RetentionTime")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "RetentionTime" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isRTset()
    isRTset = function(){
    
        py_ans = private$py_obj$isRTset()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRT(double rt)
    setRT = function(rt){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
    
        private$py_obj$setRT(rt)
        invisible()
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _Ribonucleotide
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Ribonucleotide_1_1Ribonucleotide.html
Ribonucleotide <- R6Class(classname = "Ribonucleotide",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Ribonucleotide()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Ribonucleotide()
        invisible()
    
    
    },
    
    # C++ signature: void Ribonucleotide(String name, String code, String new_code, String html_code, EmpiricalFormula formula, char origin, double mono_mass, double avg_mass, TermSpecificityNuc term_spec, EmpiricalFormula baseloss_formula)
    init_1 = function(name, code, new_code, html_code, formula, origin, mono_mass, avg_mass, term_spec, baseloss_formula){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!((is.R6(code) && class(code)[1]=="String") || is_scalar_character(code))){ stop("arg code wrong type") }
        if(!((is.R6(new_code) && class(new_code)[1]=="String") || is_scalar_character(new_code))){ stop("arg new_code wrong type") }
        if(!((is.R6(html_code) && class(html_code)[1]=="String") || is_scalar_character(html_code))){ stop("arg html_code wrong type") }
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
        if(!(is_scalar_character(origin))){ stop("arg origin wrong type") }
        if(!(is_scalar_double(mono_mass))){ stop("arg mono_mass wrong type") }
        if(!(is_scalar_double(avg_mass))){ stop("arg avg_mass wrong type") }
        if(!(term_spec %in% c(0, 1, 2, 3))){ stop("arg term_spec wrong type") }
        if(!(is.R6(baseloss_formula) && class(baseloss_formula)[1] == "EmpiricalFormula")){ stop("arg baseloss_formula wrong type") }
    
    
    
    
    
    py_run_string("origin = bytes(origin)")
    
    
    
    
    
        private$py_obj <- Pymod$Ribonucleotide(name, code, new_code, html_code, formula, py$origin, mono_mass, avg_mass, as.integer(term_spec), baseloss_formula)
        invisible()
    
        py_run_string("del origin")
    
    },
    
    # C++ signature: void Ribonucleotide()
    # C++ signature: void Ribonucleotide(String name, String code, String new_code, String html_code, EmpiricalFormula formula, char origin, double mono_mass, double avg_mass, TermSpecificityNuc term_spec, EmpiricalFormula baseloss_formula)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==10) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]])) && ((is.R6(arg_list[[4]]) && class(arg_list[[4]])[1]=="String") || is_scalar_character(arg_list[[4]])) && (is.R6(arg_list[[5]]) && class(arg_list[[5]])[1] == "EmpiricalFormula") && (is_scalar_character(arg_list[[6]])) && (is_scalar_double(arg_list[[7]])) && (is_scalar_double(arg_list[[8]])) && (arg_list[[9]] %in% c(0, 1, 2, 3)) && (is.R6(arg_list[[10]]) && class(arg_list[[10]])[1] == "EmpiricalFormula")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Ribonucleotide" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getCode()
    getCode = function(){
    
        py_ans = private$py_obj$getCode()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCode(String code)
    setCode = function(code){
    
        if(!((is.R6(code) && class(code)[1]=="String") || is_scalar_character(code))){ stop("arg code wrong type") }
    
        private$py_obj$setCode(code)
        invisible()
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFormula(EmpiricalFormula formula)
    setFormula = function(formula){
    
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
    
        private$py_obj$setFormula(formula)
        invisible()
    },
    
    # C++ signature: EmpiricalFormula getFormula()
    getFormula = function(){
    
        py_ans = private$py_obj$getFormula()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAvgMass(double avg_mass)
    setAvgMass = function(avg_mass){
    
        if(!(is_scalar_double(avg_mass))){ stop("arg avg_mass wrong type") }
    
        private$py_obj$setAvgMass(avg_mass)
        invisible()
    },
    
    # C++ signature: double getAvgMass()
    getAvgMass = function(){
    
        py_ans = private$py_obj$getAvgMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMonoMass(double mono_mass)
    setMonoMass = function(mono_mass){
    
        if(!(is_scalar_double(mono_mass))){ stop("arg mono_mass wrong type") }
    
        private$py_obj$setMonoMass(mono_mass)
        invisible()
    },
    
    # C++ signature: double getMonoMass()
    getMonoMass = function(){
    
        py_ans = private$py_obj$getMonoMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getNewCode()
    getNewCode = function(){
    
        py_ans = private$py_obj$getNewCode()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNewCode(String code)
    setNewCode = function(code){
    
        if(!((is.R6(code) && class(code)[1]=="String") || is_scalar_character(code))){ stop("arg code wrong type") }
    
        private$py_obj$setNewCode(code)
        invisible()
    },
    
    # C++ signature: char getOrigin()
    getOrigin = function(){
    
        py_ans = private$py_obj$getOrigin()
        r_ans = as.character(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOrigin(char origin)
    setOrigin = function(origin){
    
        if(!(is_scalar_character(origin))){ stop("arg origin wrong type") }
    py_run_string("origin = bytes(origin)")
        private$py_obj$setOrigin(py$origin)
        py_run_string("del origin")
        invisible()
    },
    
    # C++ signature: void setHTMLCode(String html_code)
    setHTMLCode = function(html_code){
    
        if(!((is.R6(html_code) && class(html_code)[1]=="String") || is_scalar_character(html_code))){ stop("arg html_code wrong type") }
    
        private$py_obj$setHTMLCode(html_code)
        invisible()
    },
    
    # C++ signature: String getHTMLCode()
    getHTMLCode = function(){
    
        py_ans = private$py_obj$getHTMLCode()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTermSpecificity(TermSpecificityNuc term_spec)
    setTermSpecificity = function(term_spec){
    
        if(!(term_spec %in% c(0, 1, 2, 3))){ stop("arg term_spec wrong type") }
    
        private$py_obj$setTermSpecificity(as.integer(term_spec))
        invisible()
    },
    
    # C++ signature: TermSpecificityNuc getTermSpecificity()
    getTermSpecificity = function(){
    
        py_ans = private$py_obj$getTermSpecificity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: EmpiricalFormula getBaselossFormula()
    getBaselossFormula = function(){
    
        py_ans = private$py_obj$getBaselossFormula()
        r_ans = EmpiricalFormula$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setBaselossFormula(EmpiricalFormula formula)
    setBaselossFormula = function(formula){
    
        if(!(is.R6(formula) && class(formula)[1] == "EmpiricalFormula")){ stop("arg formula wrong type") }
    
        private$py_obj$setBaselossFormula(formula)
        invisible()
    },
    
    # C++ signature: bool isModified()
    isModified = function(){
    
        py_ans = private$py_obj$isModified()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _RibonucleotideDB
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RibonucleotideDB.html
RibonucleotideDB <- R6Class(classname = "RibonucleotideDB",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: const Ribonucleotide * getRibonucleotide(const libcpp_string & code)
    getRibonucleotide = function(code){
    
        if(!(is_scalar_character(code))){ stop("arg code wrong type") }
    code_0 = py_builtin$bytes(code,'utf-8')
        py_ans = private$py_obj$getRibonucleotide(code) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Ribonucleotide$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: const Ribonucleotide * getRibonucleotidePrefix(const libcpp_string & code)
    getRibonucleotidePrefix = function(code){
    
        if(!(is_scalar_character(code))){ stop("arg code wrong type") }
    code_0 = py_builtin$bytes(code,'utf-8')
        py_ans = private$py_obj$getRibonucleotidePrefix(code) ; if( is.null(py_ans) ) { return(NULL) }
        r_ans = Ribonucleotide$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _RichPeak2D
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1RichPeak2D.html
RichPeak2D <- R6Class(classname = "RichPeak2D",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void RichPeak2D()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$RichPeak2D()
        invisible()
    
    
    },
    
    # C++ signature: void RichPeak2D(RichPeak2D &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "RichPeak2D")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$RichPeak2D(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void RichPeak2D()
    # C++ signature: void RichPeak2D(RichPeak2D &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "RichPeak2D")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "RichPeak2D" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: float getIntensity()
    getIntensity = function(){
    
        py_ans = private$py_obj$getIntensity()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getRT()
    getRT = function(){
    
        py_ans = private$py_obj$getRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZ(double)
    setMZ = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMZ(in_0)
        invisible()
    },
    
    # C++ signature: void setRT(double)
    setRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setRT(in_0)
        invisible()
    },
    
    # C++ signature: void setIntensity(float)
    setIntensity = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setIntensity(in_0)
        invisible()
    },
    
    # C++ signature: size_t getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t clearUniqueId()
    clearUniqueId = function(){
    
        py_ans = private$py_obj$clearUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasValidUniqueId()
    hasValidUniqueId = function(){
    
        py_ans = private$py_obj$hasValidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t hasInvalidUniqueId()
    hasInvalidUniqueId = function(){
    
        py_ans = private$py_obj$hasInvalidUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setUniqueId(unsigned long int rhs)
    setUniqueId = function(rhs){
    
        if(!( (is_scalar_integer(rhs) || is_scalar_double(rhs)) && rhs == as.integer(rhs))){ stop("arg rhs wrong type") }
    
        private$py_obj$setUniqueId(as.integer(rhs))
        invisible()
    },
    
    # C++ signature: size_t ensureUniqueId()
    ensureUniqueId = function(){
    
        py_ans = private$py_obj$ensureUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isValid(unsigned long int unique_id)
    isValid = function(unique_id){
    
        if(!( (is_scalar_integer(unique_id) || is_scalar_double(unique_id)) && unique_id == as.integer(unique_id))){ stop("arg unique_id wrong type") }
    
        py_ans = private$py_obj$isValid(as.integer(unique_id))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _SILACLabeler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SILACLabeler.html
SILACLabeler <- R6Class(classname = "SILACLabeler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SILACLabeler()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SILACLabeler) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SILACLabeler()
        invisible()
    }
    
    },
    
    # C++ signature: void preCheck(Param & param)
    preCheck = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$preCheck(param)
        invisible()
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SVMData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SVMData.html
SVMData <- R6Class(classname = "SVMData",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        labels = function(labels){
    
        if(!missing(labels)){
            if(!(is_list(labels) && all(sapply(labels,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg labels wrong type") }
        
            v0 <- r_to_py(labels)
            private$py_obj$labels <- v0
            } else {
            
                py_ans = private$py_obj$labels
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SVMData()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SVMData) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SVMData()
        invisible()
    }
    
    },
    
    # C++ signature: bool store(const String & filename)
    store = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$store(filename)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool load(const String & filename)
    load = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        py_ans = private$py_obj$load(filename)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SVMPrediction
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SVMPrediction.html
SVMPrediction <- R6Class(classname = "SVMPrediction",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        label = function(label){
    
        if(!missing(label)){
            if(!( (is_scalar_integer(label) || is_scalar_double(label)) && label == as.integer(label))){ stop("arg label wrong type") }
        
        
            private$py_obj$label <- as.integer(label)
            } else {
        
                py_ans = private$py_obj$label
                r_result = py_ans
                return(r_result)
                }
        },
        probabilities = function(probabilities){
    
        if(!missing(probabilities)){
            if(!(
          is.environment(probabilities) && identical(parent.env(probabilities), asNamespace("collections")) && identical(strsplit(capture.output(probabilities$print())," ")[[1]][1], "dict")
          && all(sapply(probabilities$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(probabilities$values(),function(v) is_scalar_double(v)))
          )){ stop("arg probabilities wrong type") }
        
            v0 <- py_dict(modify_depth(probabilities$keys(),1,as.integer),probabilities$values())
            private$py_obj$probabilities <- v0
            } else {
        
                py_ans = private$py_obj$probabilities
            r_result <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),py_to_r(py_builtin$list(py_ans$keys())))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SVMPrediction()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SVMPrediction) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SVMPrediction()
        invisible()
    }
    
    }
)
) 

# R implementation of _SVMWrapper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SVMWrapper.html
SVMWrapper <- R6Class(classname = "SVMWrapper",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SVMWrapper()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SVMWrapper) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SVMWrapper()
        invisible()
    }
    
    },
    
    # C++ signature: void setParameter(SVM_parameter_type type_, int value)
    setParameter_0 = function(type_, value){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type_ wrong type") }
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
    
        private$py_obj$`_setParameter_0`(as.integer(type_), as.integer(value))
        invisible()
    },
    
    # C++ signature: void setParameter(SVM_parameter_type type_, double value)
    setParameter_1 = function(type_, value){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type_ wrong type") }
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
    
        private$py_obj$`_setParameter_1`(as.integer(type_), value)
        invisible()
    },
    
    # C++ signature: void setParameter(SVM_parameter_type type_, int value)
    # C++ signature: void setParameter(SVM_parameter_type type_, double value)
    setParameter = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$setParameter_0(...) }
        else if ((length(arg_list)==2) && (arg_list[[1]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)) && (is_scalar_double(arg_list[[2]]))) { self$setParameter_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: int train(SVMData & problem)
    train = function(problem){
    
        if(!(is.R6(problem) && class(problem)[1] == "SVMData")){ stop("arg problem wrong type") }
    
        py_ans = private$py_obj$train(problem)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void saveModel(String modelFilename)
    saveModel = function(modelFilename){
    
        if(!((is.R6(modelFilename) && class(modelFilename)[1]=="String") || is_scalar_character(modelFilename))){ stop("arg modelFilename wrong type") }
    
        private$py_obj$saveModel(modelFilename)
        invisible()
    },
    
    # C++ signature: void loadModel(String modelFilename)
    loadModel = function(modelFilename){
    
        if(!((is.R6(modelFilename) && class(modelFilename)[1]=="String") || is_scalar_character(modelFilename))){ stop("arg modelFilename wrong type") }
    
        private$py_obj$loadModel(modelFilename)
        invisible()
    },
    
    # C++ signature: void predict(SVMData & problem, libcpp_vector[double] & results)
    predict = function(problem, results){
    
        if(!(is.R6(problem) && class(problem)[1] == "SVMData")){ stop("arg problem wrong type") }
        if(!(is_list(results) && all(sapply(results,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg results wrong type") }
    
        v1 <- r_to_py(results)
        private$py_obj$predict(problem, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(results <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: int getIntParameter(SVM_parameter_type type_)
    getIntParameter = function(type_){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type_ wrong type") }
    
        py_ans = private$py_obj$getIntParameter(as.integer(type_))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getDoubleParameter(SVM_parameter_type type_)
    getDoubleParameter = function(type_){
    
        if(!(type_ %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){ stop("arg type_ wrong type") }
    
        py_ans = private$py_obj$getDoubleParameter(as.integer(type_))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getSVRProbability()
    getSVRProbability = function(){
    
        py_ans = private$py_obj$getSVRProbability()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getSignificanceBorders(SVMData & data, libcpp_pair[double,double] & sigmas, double confidence, size_t number_of_runs, size_t number_of_partitions, double step_size, size_t max_iterations)
    getSignificanceBorders = function(data, sigmas, confidence, number_of_runs, number_of_partitions, step_size, max_iterations){
    
        if(!(is.R6(data) && class(data)[1] == "SVMData")){ stop("arg data wrong type") }
        if(!(is_list(sigmas) && length(sigmas) == 2 && is_scalar_double(sigmas[[1]]) && is_scalar_double(sigmas[[2]]))){ stop("arg sigmas wrong type") }
        if(!(is_scalar_double(confidence))){ stop("arg confidence wrong type") }
        if(!( (is_scalar_integer(number_of_runs) || is_scalar_double(number_of_runs)) && number_of_runs == as.integer(number_of_runs))){ stop("arg number_of_runs wrong type") }
        if(!( (is_scalar_integer(number_of_partitions) || is_scalar_double(number_of_partitions)) && number_of_partitions == as.integer(number_of_partitions))){ stop("arg number_of_partitions wrong type") }
        if(!(is_scalar_double(step_size))){ stop("arg step_size wrong type") }
        if(!( (is_scalar_integer(max_iterations) || is_scalar_double(max_iterations)) && max_iterations == as.integer(max_iterations))){ stop("arg max_iterations wrong type") }
    
        v1 = r_to_py(list(sigmas[[1]],sigmas[[2]]))
    
    
    
    
    
        private$py_obj$getSignificanceBorders(data, v1, confidence, as.integer(number_of_runs), as.integer(number_of_partitions), step_size, as.integer(max_iterations))
        byref_1 = list(py_to_r(v1[0]), py_to_r(v1[1]))
    
        tryCatch({
        eval.parent(substitute(sigmas <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double getPValue(double sigma1, double sigma2, libcpp_pair[double,double] point)
    getPValue = function(sigma1, sigma2, point){
    
        if(!(is_scalar_double(sigma1))){ stop("arg sigma1 wrong type") }
        if(!(is_scalar_double(sigma2))){ stop("arg sigma2 wrong type") }
        if(!(is_list(point) && length(point) == 2 && is_scalar_double(point[[1]]) && is_scalar_double(point[[2]]))){ stop("arg point wrong type") }
    
    
        v2 = r_to_py(list(point[[1]],point[[2]]))
        py_ans = private$py_obj$getPValue(sigma1, sigma2, v2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTrainingSample(SVMData & training_sample)
    setTrainingSample = function(training_sample){
    
        if(!(is.R6(training_sample) && class(training_sample)[1] == "SVMData")){ stop("arg training_sample wrong type") }
    
        private$py_obj$setTrainingSample(training_sample)
        invisible()
    },
    
    # C++ signature: void setWeights(libcpp_vector[int] & weight_labels, libcpp_vector[double] & weights)
    setWeights = function(weight_labels, weights){
    
        if(!(is_list(weight_labels) && all(sapply(weight_labels,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg weight_labels wrong type") }
        if(!(is_list(weights) && all(sapply(weights,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg weights wrong type") }
        v0 <- r_to_py(modify_depth(weight_labels,1,as.integer))
        v1 <- r_to_py(weights)
        private$py_obj$setWeights(v0, v1)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(weight_labels <- byref_0))
        eval.parent(substitute(weights <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void createRandomPartitions(SVMData & problem, size_t number, libcpp_vector[SVMData] & problems)
    createRandomPartitions = function(problem, number, problems){
    
        if(!(is.R6(problem) && class(problem)[1] == "SVMData")){ stop("arg problem wrong type") }
        if(!( (is_scalar_integer(number) || is_scalar_double(number)) && number == as.integer(number))){ stop("arg number wrong type") }
        if(!(is_list(problems) && all(sapply(problems,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SVMData")))){ stop("arg problems wrong type") }
    
    
        v2 <- r_to_py(problems)
        private$py_obj$createRandomPartitions(problem, as.integer(number), v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(problems <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void mergePartitions(libcpp_vector[SVMData] & problems, size_t except_, SVMData & merged_problem)
    mergePartitions = function(problems, except_, merged_problem){
    
        if(!(is_list(problems) && all(sapply(problems,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SVMData")))){ stop("arg problems wrong type") }
        if(!( (is_scalar_integer(except_) || is_scalar_double(except_)) && except_ == as.integer(except_))){ stop("arg except_ wrong type") }
        if(!(is.R6(merged_problem) && class(merged_problem)[1] == "SVMData")){ stop("arg merged_problem wrong type") }
        v0 <- r_to_py(problems)
    
    
        private$py_obj$mergePartitions(v0, as.integer(except_), merged_problem)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(problems <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void calculateGaussTable(size_t border_length, double sigma, libcpp_vector[double] & gauss_table)
    calculateGaussTable = function(border_length, sigma, gauss_table){
    
        if(!( (is_scalar_integer(border_length) || is_scalar_double(border_length)) && border_length == as.integer(border_length))){ stop("arg border_length wrong type") }
        if(!(is_scalar_double(sigma))){ stop("arg sigma wrong type") }
        if(!(is_list(gauss_table) && all(sapply(gauss_table,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg gauss_table wrong type") }
    
    
        v2 <- r_to_py(gauss_table)
        private$py_obj$calculateGaussTable(as.integer(border_length), sigma, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
    
        tryCatch({
        eval.parent(substitute(gauss_table <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _Sample
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Sample.html
Sample <- R6Class(classname = "Sample",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Sample()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Sample) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Sample()
        invisible()
    }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: String getOrganism()
    getOrganism = function(){
    
        py_ans = private$py_obj$getOrganism()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOrganism(String organism)
    setOrganism = function(organism){
    
        if(!((is.R6(organism) && class(organism)[1]=="String") || is_scalar_character(organism))){ stop("arg organism wrong type") }
    
        private$py_obj$setOrganism(organism)
        invisible()
    },
    
    # C++ signature: String getNumber()
    getNumber = function(){
    
        py_ans = private$py_obj$getNumber()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNumber(String number)
    setNumber = function(number){
    
        if(!((is.R6(number) && class(number)[1]=="String") || is_scalar_character(number))){ stop("arg number wrong type") }
    
        private$py_obj$setNumber(number)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String comment)
    setComment = function(comment){
    
        if(!((is.R6(comment) && class(comment)[1]=="String") || is_scalar_character(comment))){ stop("arg comment wrong type") }
    
        private$py_obj$setComment(comment)
        invisible()
    },
    
    # C++ signature: SampleState getState()
    getState = function(){
    
        py_ans = private$py_obj$getState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setState(SampleState state)
    setState = function(state){
    
        if(!(state %in% c(0, 1, 2, 3, 4, 5, 6, 7))){ stop("arg state wrong type") }
    
        private$py_obj$setState(as.integer(state))
        invisible()
    },
    
    # C++ signature: double getMass()
    getMass = function(){
    
        py_ans = private$py_obj$getMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMass(double mass)
    setMass = function(mass){
    
        if(!(is_scalar_double(mass))){ stop("arg mass wrong type") }
    
        private$py_obj$setMass(mass)
        invisible()
    },
    
    # C++ signature: double getVolume()
    getVolume = function(){
    
        py_ans = private$py_obj$getVolume()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setVolume(double volume)
    setVolume = function(volume){
    
        if(!(is_scalar_double(volume))){ stop("arg volume wrong type") }
    
        private$py_obj$setVolume(volume)
        invisible()
    },
    
    # C++ signature: double getConcentration()
    getConcentration = function(){
    
        py_ans = private$py_obj$getConcentration()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setConcentration(double concentration)
    setConcentration = function(concentration){
    
        if(!(is_scalar_double(concentration))){ stop("arg concentration wrong type") }
    
        private$py_obj$setConcentration(concentration)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Sample] getSubsamples()
    getSubsamples = function(){
    
        py_ans = private$py_obj$getSubsamples()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setSubsamples(libcpp_vector[Sample] subsamples)
    setSubsamples = function(subsamples){
    
        if(!(is_list(subsamples) && all(sapply(subsamples,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Sample")))){ stop("arg subsamples wrong type") }
        v0 <- r_to_py(subsamples)
        private$py_obj$setSubsamples(v0)
        
        invisible()
    },
    
    # C++ signature: void removeTreatment(unsigned int position)
    removeTreatment = function(position){
    
        if(!( (is_scalar_integer(position) || is_scalar_double(position)) && position == as.integer(position))){ stop("arg position wrong type") }
    
        private$py_obj$removeTreatment(as.integer(position))
        invisible()
    },
    
    # C++ signature: int countTreatments()
    countTreatments = function(){
    
        py_ans = private$py_obj$countTreatments()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _SavitzkyGolayFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SavitzkyGolayFilter.html
SavitzkyGolayFilter <- R6Class(classname = "SavitzkyGolayFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SavitzkyGolayFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SavitzkyGolayFilter()
        invisible()
    
    
    },
    
    # C++ signature: void SavitzkyGolayFilter(SavitzkyGolayFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SavitzkyGolayFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SavitzkyGolayFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SavitzkyGolayFilter()
    # C++ signature: void SavitzkyGolayFilter(SavitzkyGolayFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SavitzkyGolayFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SavitzkyGolayFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void filter(MSSpectrum & spectrum)
    filter = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$filter(spectrum)
        invisible()
    },
    
    # C++ signature: void filterExperiment(MSExperiment & exp)
    filterExperiment = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterExperiment(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _Scaler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Scaler.html
Scaler <- R6Class(classname = "Scaler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Scaler()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Scaler) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Scaler()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ScanWindow
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ScanWindow.html
ScanWindow <- R6Class(classname = "ScanWindow",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        begin = function(begin){
    
        if(!missing(begin)){
            if(!(is_scalar_double(begin))){ stop("arg begin wrong type") }
        
        
            private$py_obj$begin <- begin
            } else {
        
                py_ans = private$py_obj$begin
                r_result = py_ans
                return(r_result)
                }
        },
        end = function(end){
    
        if(!missing(end)){
            if(!(is_scalar_double(end))){ stop("arg end wrong type") }
        
        
            private$py_obj$end <- end
            } else {
        
                py_ans = private$py_obj$end
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void ScanWindow()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$ScanWindow()
        invisible()
    
    
    },
    
    # C++ signature: void ScanWindow(ScanWindow)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "ScanWindow")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$ScanWindow(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void ScanWindow()
    # C++ signature: void ScanWindow(ScanWindow)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "ScanWindow")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "ScanWindow" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _SearchParameters
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SearchParameters.html
SearchParameters <- R6Class(classname = "SearchParameters",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        db = function(db){
    
        if(!missing(db)){
            if(!((is.R6(db) && class(db)[1]=="String") || is_scalar_character(db))){ stop("arg db wrong type") }
        
        
            private$py_obj$db <- db
            } else {
        
                py_ans = private$py_obj$db
            r_result = py_ans
                return(r_result)
                }
        },
        db_version = function(db_version){
    
        if(!missing(db_version)){
            if(!((is.R6(db_version) && class(db_version)[1]=="String") || is_scalar_character(db_version))){ stop("arg db_version wrong type") }
        
        
            private$py_obj$db_version <- db_version
            } else {
        
                py_ans = private$py_obj$db_version
            r_result = py_ans
                return(r_result)
                }
        },
        taxonomy = function(taxonomy){
    
        if(!missing(taxonomy)){
            if(!((is.R6(taxonomy) && class(taxonomy)[1]=="String") || is_scalar_character(taxonomy))){ stop("arg taxonomy wrong type") }
        
        
            private$py_obj$taxonomy <- taxonomy
            } else {
        
                py_ans = private$py_obj$taxonomy
            r_result = py_ans
                return(r_result)
                }
        },
        charges = function(charges){
    
        if(!missing(charges)){
            if(!((is.R6(charges) && class(charges)[1]=="String") || is_scalar_character(charges))){ stop("arg charges wrong type") }
        
        
            private$py_obj$charges <- charges
            } else {
        
                py_ans = private$py_obj$charges
            r_result = py_ans
                return(r_result)
                }
        },
        mass_type = function(mass_type){
    
        if(!missing(mass_type)){
            if(!(mass_type %in% c(0, 1, 2))){ stop("arg mass_type wrong type") }
        
        
            private$py_obj$mass_type <- as.integer(mass_type)
            } else {
        
                py_ans = private$py_obj$mass_type
                r_result = py_ans
                return(r_result)
                }
        },
        fixed_modifications = function(fixed_modifications){
    
        if(!missing(fixed_modifications)){
            if(!(is_list(fixed_modifications) && all(sapply(fixed_modifications),is_scalar_character))){ stop("arg fixed_modifications wrong type") }
        
            v0 = r_to_py(modify_depth(fixed_modifications,1,py_builtin$bytes(fixed_modifications,'utf-8')))
            private$py_obj$fixed_modifications <- v0
            } else {
        
                py_ans = private$py_obj$fixed_modifications
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        variable_modifications = function(variable_modifications){
    
        if(!missing(variable_modifications)){
            if(!(is_list(variable_modifications) && all(sapply(variable_modifications),is_scalar_character))){ stop("arg variable_modifications wrong type") }
        
            v0 = r_to_py(modify_depth(variable_modifications,1,py_builtin$bytes(variable_modifications,'utf-8')))
            private$py_obj$variable_modifications <- v0
            } else {
        
                py_ans = private$py_obj$variable_modifications
            r_result = modify_depth(py_ans,1,as.character)
                return(r_result)
                }
        },
        missed_cleavages = function(missed_cleavages){
    
        if(!missing(missed_cleavages)){
            if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
        
        
            private$py_obj$missed_cleavages <- as.integer(missed_cleavages)
            } else {
        
                py_ans = private$py_obj$missed_cleavages
                r_result = py_ans
                return(r_result)
                }
        },
        fragment_mass_tolerance = function(fragment_mass_tolerance){
    
        if(!missing(fragment_mass_tolerance)){
            if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        
        
            private$py_obj$fragment_mass_tolerance <- fragment_mass_tolerance
            } else {
        
                py_ans = private$py_obj$fragment_mass_tolerance
                r_result = py_ans
                return(r_result)
                }
        },
        fragment_mass_tolerance_ppm = function(fragment_mass_tolerance_ppm){
    
        if(!missing(fragment_mass_tolerance_ppm)){
            if(!( (is_scalar_integer(fragment_mass_tolerance_ppm) || is_scalar_double(fragment_mass_tolerance_ppm)) && fragment_mass_tolerance_ppm == as.integer(fragment_mass_tolerance_ppm))){ stop("arg fragment_mass_tolerance_ppm wrong type") }
        
        
            private$py_obj$fragment_mass_tolerance_ppm <- as.integer(fragment_mass_tolerance_ppm)
            } else {
        
                py_ans = private$py_obj$fragment_mass_tolerance_ppm
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_mass_tolerance = function(precursor_mass_tolerance){
    
        if(!missing(precursor_mass_tolerance)){
            if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
        
        
            private$py_obj$precursor_mass_tolerance <- precursor_mass_tolerance
            } else {
        
                py_ans = private$py_obj$precursor_mass_tolerance
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_mass_tolerance_ppm = function(precursor_mass_tolerance_ppm){
    
        if(!missing(precursor_mass_tolerance_ppm)){
            if(!( (is_scalar_integer(precursor_mass_tolerance_ppm) || is_scalar_double(precursor_mass_tolerance_ppm)) && precursor_mass_tolerance_ppm == as.integer(precursor_mass_tolerance_ppm))){ stop("arg precursor_mass_tolerance_ppm wrong type") }
        
        
            private$py_obj$precursor_mass_tolerance_ppm <- as.integer(precursor_mass_tolerance_ppm)
            } else {
        
                py_ans = private$py_obj$precursor_mass_tolerance_ppm
                r_result = py_ans
                return(r_result)
                }
        },
        digestion_enzyme = function(digestion_enzyme){
    
        if(!missing(digestion_enzyme)){
            if(!(is.R6(digestion_enzyme) && class(digestion_enzyme)[1] == "DigestionEnzymeProtein")){ stop("arg digestion_enzyme wrong type") }
        
        
            private$py_obj$digestion_enzyme <- digestion_enzyme
            } else {
        
                py_ans = private$py_obj$digestion_enzyme
            r_result = DigestionEnzymeProtein$new(py_ans)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SearchParameters()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SearchParameters()
        invisible()
    
    
    },
    
    # C++ signature: void SearchParameters(SearchParameters)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SearchParameters")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SearchParameters(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SearchParameters()
    # C++ signature: void SearchParameters(SearchParameters)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SearchParameters")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SearchParameters" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _Seed
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::FeatureFinderAlgorithmPickedHelperStructs_1_1Seed.html
Seed <- R6Class(classname = "Seed",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        spectrum = function(spectrum){
    
        if(!missing(spectrum)){
            if(!( (is_scalar_integer(spectrum) || is_scalar_double(spectrum)) && spectrum == as.integer(spectrum))){ stop("arg spectrum wrong type") }
        
        
            private$py_obj$spectrum <- as.integer(spectrum)
            } else {
        
                py_ans = private$py_obj$spectrum
                r_result = py_ans
                return(r_result)
                }
        },
        peak = function(peak){
    
        if(!missing(peak)){
            if(!( (is_scalar_integer(peak) || is_scalar_double(peak)) && peak == as.integer(peak))){ stop("arg peak wrong type") }
        
        
            private$py_obj$peak <- as.integer(peak)
            } else {
        
                py_ans = private$py_obj$peak
                r_result = py_ans
                return(r_result)
                }
        },
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_scalar_double(intensity))){ stop("arg intensity wrong type") }
        
        
            private$py_obj$intensity <- intensity
            } else {
        
                py_ans = private$py_obj$intensity
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
)
) 

# R implementation of _SeedListGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SeedListGenerator.html
SeedListGenerator <- R6Class(classname = "SeedListGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SeedListGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SeedListGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void SeedListGenerator(SeedListGenerator &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SeedListGenerator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SeedListGenerator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SeedListGenerator()
    # C++ signature: void SeedListGenerator(SeedListGenerator &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SeedListGenerator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SeedListGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void generateSeedList(MSExperiment exp, libcpp_vector[DPosition2] & seeds)
    generateSeedList_0 = function(exp, seeds){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!(is.matrix(seeds) && NROW(seeds) == 2 && is_double(seeds[1,]) && is_double(seeds[2,]))){ stop("arg seeds wrong type") }
    
        dp_1 <- r_to_py(seeds)
        private$py_obj$`_generateSeedList_0`(exp, dp_1)
        byref_1 <- py_to_r(dp_1)
    
        tryCatch({
        eval.parent(substitute(seeds <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void generateSeedList(libcpp_vector[PeptideIdentification] & peptides, libcpp_vector[DPosition2] & seeds, bool use_peptide_mass)
    generateSeedList_1 = function(peptides, seeds, use_peptide_mass){
    
        if(!(is_list(peptides) && all(sapply(peptides,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptides wrong type") }
        if(!(is.matrix(seeds) && NROW(seeds) == 2 && is_double(seeds[1,]) && is_double(seeds[2,]))){ stop("arg seeds wrong type") }
        if(!( (is_scalar_integer(use_peptide_mass) || is_scalar_double(use_peptide_mass)) && use_peptide_mass == as.integer(use_peptide_mass))){ stop("arg use_peptide_mass wrong type") }
        v0 <- r_to_py(peptides)
        dp_1 <- r_to_py(seeds)
    
        private$py_obj$`_generateSeedList_1`(v0, dp_1, as.integer(use_peptide_mass))
        byref_1 <- py_to_r(dp_1)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptides <- byref_0))
        eval.parent(substitute(seeds <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void generateSeedList(MSExperiment exp, libcpp_vector[DPosition2] & seeds)
    # C++ signature: void generateSeedList(libcpp_vector[PeptideIdentification] & peptides, libcpp_vector[DPosition2] & seeds, bool use_peptide_mass)
    generateSeedList = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.matrix(arg_list[[2]]) && NROW(arg_list[[2]]) == 2 && is_double(arg_list[[2]][1,]) && is_double(arg_list[[2]][2,]))) { self$generateSeedList_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification"))) && (is.matrix(arg_list[[2]]) && NROW(arg_list[[2]]) == 2 && is_double(arg_list[[2]][1,]) && is_double(arg_list[[2]][2,])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$generateSeedList_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void convertSeedList(libcpp_vector[DPosition2] & seeds, FeatureMap & features)
    convertSeedList_0 = function(seeds, features){
    
        if(!(is.matrix(seeds) && NROW(seeds) == 2 && is_double(seeds[1,]) && is_double(seeds[2,]))){ stop("arg seeds wrong type") }
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        dp_0 <- r_to_py(seeds)
    
        private$py_obj$`_convertSeedList_0`(dp_0, features)
        byref_0 <- py_to_r(dp_0)
    
        tryCatch({
        eval.parent(substitute(seeds <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void convertSeedList(FeatureMap & features, libcpp_vector[DPosition2] & seeds)
    convertSeedList_1 = function(features, seeds){
    
        if(!(is.R6(features) && class(features)[1] == "FeatureMap")){ stop("arg features wrong type") }
        if(!(is.matrix(seeds) && NROW(seeds) == 2 && is_double(seeds[1,]) && is_double(seeds[2,]))){ stop("arg seeds wrong type") }
    
        dp_1 <- r_to_py(seeds)
        private$py_obj$`_convertSeedList_1`(features, dp_1)
        byref_1 <- py_to_r(dp_1)
    
        tryCatch({
        eval.parent(substitute(seeds <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void convertSeedList(libcpp_vector[DPosition2] & seeds, FeatureMap & features)
    # C++ signature: void convertSeedList(FeatureMap & features, libcpp_vector[DPosition2] & seeds)
    convertSeedList = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is.matrix(arg_list[[1]]) && NROW(arg_list[[1]]) == 2 && is_double(arg_list[[1]][1,]) && is_double(arg_list[[1]][2,])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap")) { self$convertSeedList_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "FeatureMap") && (is.matrix(arg_list[[2]]) && NROW(arg_list[[2]]) == 2 && is_double(arg_list[[2]][1,]) && is_double(arg_list[[2]][2,]))) { self$convertSeedList_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _SemanticValidator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1SemanticValidator.html
SemanticValidator <- R6Class(classname = "SemanticValidator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SemanticValidator(CVMappings mapping, ControlledVocabulary cv)
    initialize = function(mapping, cv){
    
    if(missing(cv)){
         if( "python.builtin.object" %in% class(mapping) && class_to_wrap(mapping) == SemanticValidator ) { private$py_obj <- mapping }
         else { stop("arg wrong type") }
      } else {
        if(!(is.R6(mapping) && class(mapping)[1] == "CVMappings")){ stop("arg mapping wrong type") }
        if(!(is.R6(cv) && class(cv)[1] == "ControlledVocabulary")){ stop("arg cv wrong type") }
    
    
    
        private$py_obj <- Pymod$SemanticValidator(mapping, cv)
        invisible()
    }
    
    },
    
    # C++ signature: bool validate(String filename, StringList errors, StringList warnings)
    validate = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$validate(filename, v1, v2)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool locateTerm(String path, SemanticValidator_CVTerm & parsed_term)
    locateTerm = function(path, parsed_term){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
        if(!(is.R6(parsed_term) && class(parsed_term)[1] == "SemanticValidator_CVTerm")){ stop("arg parsed_term wrong type") }
    
    
        py_ans = private$py_obj$locateTerm(path, parsed_term)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTag(String tag)
    setTag = function(tag){
    
        if(!((is.R6(tag) && class(tag)[1]=="String") || is_scalar_character(tag))){ stop("arg tag wrong type") }
    
        private$py_obj$setTag(tag)
        invisible()
    },
    
    # C++ signature: void setAccessionAttribute(String accession)
    setAccessionAttribute = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        private$py_obj$setAccessionAttribute(accession)
        invisible()
    },
    
    # C++ signature: void setNameAttribute(String name)
    setNameAttribute = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setNameAttribute(name)
        invisible()
    },
    
    # C++ signature: void setValueAttribute(String value)
    setValueAttribute = function(value){
    
        if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
    
        private$py_obj$setValueAttribute(value)
        invisible()
    },
    
    # C++ signature: void setCheckTermValueTypes(bool check)
    setCheckTermValueTypes = function(check){
    
        if(!( (is_scalar_integer(check) || is_scalar_double(check)) && check == as.integer(check))){ stop("arg check wrong type") }
    
        private$py_obj$setCheckTermValueTypes(as.integer(check))
        invisible()
    },
    
    # C++ signature: void setCheckUnits(bool check)
    setCheckUnits = function(check){
    
        if(!( (is_scalar_integer(check) || is_scalar_double(check)) && check == as.integer(check))){ stop("arg check wrong type") }
    
        private$py_obj$setCheckUnits(as.integer(check))
        invisible()
    },
    
    # C++ signature: void setUnitAccessionAttribute(String accession)
    setUnitAccessionAttribute = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        private$py_obj$setUnitAccessionAttribute(accession)
        invisible()
    },
    
    # C++ signature: void setUnitNameAttribute(String name)
    setUnitNameAttribute = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setUnitNameAttribute(name)
        invisible()
    }
)
) 

# R implementation of _SemanticValidator_CVTerm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1SemanticValidator_CVTerm.html
SemanticValidator_CVTerm <- R6Class(classname = "SemanticValidator_CVTerm",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        accession = function(accession){
    
        if(!missing(accession)){
            if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        
        
            private$py_obj$accession <- accession
            } else {
        
                py_ans = private$py_obj$accession
            r_result = py_ans
                return(r_result)
                }
        },
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        value = function(value){
    
        if(!missing(value)){
            if(!((is.R6(value) && class(value)[1]=="String") || is_scalar_character(value))){ stop("arg value wrong type") }
        
        
            private$py_obj$value <- value
            } else {
        
                py_ans = private$py_obj$value
            r_result = py_ans
                return(r_result)
                }
        },
        has_value = function(has_value){
    
        if(!missing(has_value)){
            if(!( (is_scalar_integer(has_value) || is_scalar_double(has_value)) && has_value == as.integer(has_value))){ stop("arg has_value wrong type") }
        
        
            private$py_obj$has_value <- as.integer(has_value)
            } else {
        
                py_ans = private$py_obj$has_value
                r_result = py_ans
                return(r_result)
                }
        },
        unit_accession = function(unit_accession){
    
        if(!missing(unit_accession)){
            if(!((is.R6(unit_accession) && class(unit_accession)[1]=="String") || is_scalar_character(unit_accession))){ stop("arg unit_accession wrong type") }
        
        
            private$py_obj$unit_accession <- unit_accession
            } else {
        
                py_ans = private$py_obj$unit_accession
            r_result = py_ans
                return(r_result)
                }
        },
        has_unit_accession = function(has_unit_accession){
    
        if(!missing(has_unit_accession)){
            if(!( (is_scalar_integer(has_unit_accession) || is_scalar_double(has_unit_accession)) && has_unit_accession == as.integer(has_unit_accession))){ stop("arg has_unit_accession wrong type") }
        
        
            private$py_obj$has_unit_accession <- as.integer(has_unit_accession)
            } else {
        
                py_ans = private$py_obj$has_unit_accession
                r_result = py_ans
                return(r_result)
                }
        },
        unit_name = function(unit_name){
    
        if(!missing(unit_name)){
            if(!((is.R6(unit_name) && class(unit_name)[1]=="String") || is_scalar_character(unit_name))){ stop("arg unit_name wrong type") }
        
        
            private$py_obj$unit_name <- unit_name
            } else {
        
                py_ans = private$py_obj$unit_name
            r_result = py_ans
                return(r_result)
                }
        },
        has_unit_name = function(has_unit_name){
    
        if(!missing(has_unit_name)){
            if(!( (is_scalar_integer(has_unit_name) || is_scalar_double(has_unit_name)) && has_unit_name == as.integer(has_unit_name))){ stop("arg has_unit_name wrong type") }
        
        
            private$py_obj$has_unit_name <- as.integer(has_unit_name)
            } else {
        
                py_ans = private$py_obj$has_unit_name
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SemanticValidator_CVTerm()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SemanticValidator_CVTerm()
        invisible()
    
    
    },
    
    # C++ signature: void SemanticValidator_CVTerm(SemanticValidator_CVTerm)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SemanticValidator_CVTerm")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SemanticValidator_CVTerm(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SemanticValidator_CVTerm()
    # C++ signature: void SemanticValidator_CVTerm(SemanticValidator_CVTerm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SemanticValidator_CVTerm")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SemanticValidator_CVTerm" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _SequestInfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SequestInfile.html
SequestInfile <- R6Class(classname = "SequestInfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SequestInfile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SequestInfile()
        invisible()
    
    
    },
    
    # C++ signature: void SequestInfile(SequestInfile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SequestInfile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SequestInfile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SequestInfile()
    # C++ signature: void SequestInfile(SequestInfile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SequestInfile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SequestInfile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void store(const String & filename)
    store = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$store(filename)
        invisible()
    },
    
    # C++ signature: String getEnzymeInfoAsString()
    getEnzymeInfoAsString = function(){
    
        py_ans = private$py_obj$getEnzymeInfoAsString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getDatabase()
    getDatabase = function(){
    
        py_ans = private$py_obj$getDatabase()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDatabase(const String & database)
    setDatabase = function(database){
    
        if(!((is.R6(database) && class(database)[1]=="String") || is_scalar_character(database))){ stop("arg database wrong type") }
    
        private$py_obj$setDatabase(database)
        invisible()
    },
    
    # C++ signature: String getNeutralLossesForIons()
    getNeutralLossesForIons = function(){
    
        py_ans = private$py_obj$getNeutralLossesForIons()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNeutralLossesForIons(const String & neutral_losses_for_ions)
    setNeutralLossesForIons = function(neutral_losses_for_ions){
    
        if(!((is.R6(neutral_losses_for_ions) && class(neutral_losses_for_ions)[1]=="String") || is_scalar_character(neutral_losses_for_ions))){ stop("arg neutral_losses_for_ions wrong type") }
    
        private$py_obj$setNeutralLossesForIons(neutral_losses_for_ions)
        invisible()
    },
    
    # C++ signature: String getIonSeriesWeights()
    getIonSeriesWeights = function(){
    
        py_ans = private$py_obj$getIonSeriesWeights()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIonSeriesWeights(const String & ion_series_weights)
    setIonSeriesWeights = function(ion_series_weights){
    
        if(!((is.R6(ion_series_weights) && class(ion_series_weights)[1]=="String") || is_scalar_character(ion_series_weights))){ stop("arg ion_series_weights wrong type") }
    
        private$py_obj$setIonSeriesWeights(ion_series_weights)
        invisible()
    },
    
    # C++ signature: String getPartialSequence()
    getPartialSequence = function(){
    
        py_ans = private$py_obj$getPartialSequence()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPartialSequence(const String & partial_sequence)
    setPartialSequence = function(partial_sequence){
    
        if(!((is.R6(partial_sequence) && class(partial_sequence)[1]=="String") || is_scalar_character(partial_sequence))){ stop("arg partial_sequence wrong type") }
    
        private$py_obj$setPartialSequence(partial_sequence)
        invisible()
    },
    
    # C++ signature: String getSequenceHeaderFilter()
    getSequenceHeaderFilter = function(){
    
        py_ans = private$py_obj$getSequenceHeaderFilter()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSequenceHeaderFilter(const String & sequence_header_filter)
    setSequenceHeaderFilter = function(sequence_header_filter){
    
        if(!((is.R6(sequence_header_filter) && class(sequence_header_filter)[1]=="String") || is_scalar_character(sequence_header_filter))){ stop("arg sequence_header_filter wrong type") }
    
        private$py_obj$setSequenceHeaderFilter(sequence_header_filter)
        invisible()
    },
    
    # C++ signature: String getProteinMassFilter()
    getProteinMassFilter = function(){
    
        py_ans = private$py_obj$getProteinMassFilter()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setProteinMassFilter(const String & protein_mass_filter)
    setProteinMassFilter = function(protein_mass_filter){
    
        if(!((is.R6(protein_mass_filter) && class(protein_mass_filter)[1]=="String") || is_scalar_character(protein_mass_filter))){ stop("arg protein_mass_filter wrong type") }
    
        private$py_obj$setProteinMassFilter(protein_mass_filter)
        invisible()
    },
    
    # C++ signature: float getPeakMassTolerance()
    getPeakMassTolerance = function(){
    
        py_ans = private$py_obj$getPeakMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPeakMassTolerance(float peak_mass_tolerance)
    setPeakMassTolerance = function(peak_mass_tolerance){
    
        if(!(is_scalar_double(peak_mass_tolerance))){ stop("arg peak_mass_tolerance wrong type") }
    
        private$py_obj$setPeakMassTolerance(peak_mass_tolerance)
        invisible()
    },
    
    # C++ signature: float getPrecursorMassTolerance()
    getPrecursorMassTolerance = function(){
    
        py_ans = private$py_obj$getPrecursorMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassTolerance(float precursor_mass_tolerance)
    setPrecursorMassTolerance = function(precursor_mass_tolerance){
    
        if(!(is_scalar_double(precursor_mass_tolerance))){ stop("arg precursor_mass_tolerance wrong type") }
    
        private$py_obj$setPrecursorMassTolerance(precursor_mass_tolerance)
        invisible()
    },
    
    # C++ signature: float getMatchPeakTolerance()
    getMatchPeakTolerance = function(){
    
        py_ans = private$py_obj$getMatchPeakTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchPeakTolerance(float match_peak_tolerance)
    setMatchPeakTolerance = function(match_peak_tolerance){
    
        if(!(is_scalar_double(match_peak_tolerance))){ stop("arg match_peak_tolerance wrong type") }
    
        private$py_obj$setMatchPeakTolerance(match_peak_tolerance)
        invisible()
    },
    
    # C++ signature: float getIonCutoffPercentage()
    getIonCutoffPercentage = function(){
    
        py_ans = private$py_obj$getIonCutoffPercentage()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setIonCutoffPercentage(float ion_cutoff_percentage)
    setIonCutoffPercentage = function(ion_cutoff_percentage){
    
        if(!(is_scalar_double(ion_cutoff_percentage))){ stop("arg ion_cutoff_percentage wrong type") }
    
        private$py_obj$setIonCutoffPercentage(ion_cutoff_percentage)
        invisible()
    },
    
    # C++ signature: size_t getPeptideMassUnit()
    getPeptideMassUnit = function(){
    
        py_ans = private$py_obj$getPeptideMassUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPeptideMassUnit(size_t peptide_mass_unit)
    setPeptideMassUnit = function(peptide_mass_unit){
    
        if(!( (is_scalar_integer(peptide_mass_unit) || is_scalar_double(peptide_mass_unit)) && peptide_mass_unit == as.integer(peptide_mass_unit))){ stop("arg peptide_mass_unit wrong type") }
    
        private$py_obj$setPeptideMassUnit(as.integer(peptide_mass_unit))
        invisible()
    },
    
    # C++ signature: size_t getOutputLines()
    getOutputLines = function(){
    
        py_ans = private$py_obj$getOutputLines()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOutputLines(size_t output_lines)
    setOutputLines = function(output_lines){
    
        if(!( (is_scalar_integer(output_lines) || is_scalar_double(output_lines)) && output_lines == as.integer(output_lines))){ stop("arg output_lines wrong type") }
    
        private$py_obj$setOutputLines(as.integer(output_lines))
        invisible()
    },
    
    # C++ signature: size_t getEnzymeNumber()
    getEnzymeNumber = function(){
    
        py_ans = private$py_obj$getEnzymeNumber()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getEnzymeName()
    getEnzymeName = function(){
    
        py_ans = private$py_obj$getEnzymeName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t setEnzyme(String enzyme_name)
    setEnzyme = function(enzyme_name){
    
        if(!((is.R6(enzyme_name) && class(enzyme_name)[1]=="String") || is_scalar_character(enzyme_name))){ stop("arg enzyme_name wrong type") }
    
        py_ans = private$py_obj$setEnzyme(enzyme_name)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t getMaxAAPerModPerPeptide()
    getMaxAAPerModPerPeptide = function(){
    
        py_ans = private$py_obj$getMaxAAPerModPerPeptide()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxAAPerModPerPeptide(size_t max_aa_per_mod_per_peptide)
    setMaxAAPerModPerPeptide = function(max_aa_per_mod_per_peptide){
    
        if(!( (is_scalar_integer(max_aa_per_mod_per_peptide) || is_scalar_double(max_aa_per_mod_per_peptide)) && max_aa_per_mod_per_peptide == as.integer(max_aa_per_mod_per_peptide))){ stop("arg max_aa_per_mod_per_peptide wrong type") }
    
        private$py_obj$setMaxAAPerModPerPeptide(as.integer(max_aa_per_mod_per_peptide))
        invisible()
    },
    
    # C++ signature: size_t getMaxModsPerPeptide()
    getMaxModsPerPeptide = function(){
    
        py_ans = private$py_obj$getMaxModsPerPeptide()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxModsPerPeptide(size_t max_mods_per_peptide)
    setMaxModsPerPeptide = function(max_mods_per_peptide){
    
        if(!( (is_scalar_integer(max_mods_per_peptide) || is_scalar_double(max_mods_per_peptide)) && max_mods_per_peptide == as.integer(max_mods_per_peptide))){ stop("arg max_mods_per_peptide wrong type") }
    
        private$py_obj$setMaxModsPerPeptide(as.integer(max_mods_per_peptide))
        invisible()
    },
    
    # C++ signature: size_t getNucleotideReadingFrame()
    getNucleotideReadingFrame = function(){
    
        py_ans = private$py_obj$getNucleotideReadingFrame()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNucleotideReadingFrame(size_t nucleotide_reading_frame)
    setNucleotideReadingFrame = function(nucleotide_reading_frame){
    
        if(!( (is_scalar_integer(nucleotide_reading_frame) || is_scalar_double(nucleotide_reading_frame)) && nucleotide_reading_frame == as.integer(nucleotide_reading_frame))){ stop("arg nucleotide_reading_frame wrong type") }
    
        private$py_obj$setNucleotideReadingFrame(as.integer(nucleotide_reading_frame))
        invisible()
    },
    
    # C++ signature: size_t getMaxInternalCleavageSites()
    getMaxInternalCleavageSites = function(){
    
        py_ans = private$py_obj$getMaxInternalCleavageSites()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxInternalCleavageSites(size_t max_internal_cleavage_sites)
    setMaxInternalCleavageSites = function(max_internal_cleavage_sites){
    
        if(!( (is_scalar_integer(max_internal_cleavage_sites) || is_scalar_double(max_internal_cleavage_sites)) && max_internal_cleavage_sites == as.integer(max_internal_cleavage_sites))){ stop("arg max_internal_cleavage_sites wrong type") }
    
        private$py_obj$setMaxInternalCleavageSites(as.integer(max_internal_cleavage_sites))
        invisible()
    },
    
    # C++ signature: size_t getMatchPeakCount()
    getMatchPeakCount = function(){
    
        py_ans = private$py_obj$getMatchPeakCount()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchPeakCount(size_t match_peak_count)
    setMatchPeakCount = function(match_peak_count){
    
        if(!( (is_scalar_integer(match_peak_count) || is_scalar_double(match_peak_count)) && match_peak_count == as.integer(match_peak_count))){ stop("arg match_peak_count wrong type") }
    
        private$py_obj$setMatchPeakCount(as.integer(match_peak_count))
        invisible()
    },
    
    # C++ signature: size_t getMatchPeakAllowedError()
    getMatchPeakAllowedError = function(){
    
        py_ans = private$py_obj$getMatchPeakAllowedError()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchPeakAllowedError(size_t match_peak_allowed_error)
    setMatchPeakAllowedError = function(match_peak_allowed_error){
    
        if(!( (is_scalar_integer(match_peak_allowed_error) || is_scalar_double(match_peak_allowed_error)) && match_peak_allowed_error == as.integer(match_peak_allowed_error))){ stop("arg match_peak_allowed_error wrong type") }
    
        private$py_obj$setMatchPeakAllowedError(as.integer(match_peak_allowed_error))
        invisible()
    },
    
    # C++ signature: bool getShowFragmentIons()
    getShowFragmentIons = function(){
    
        py_ans = private$py_obj$getShowFragmentIons()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setShowFragmentIons(bool show_fragments)
    setShowFragmentIons = function(show_fragments){
    
        if(!( (is_scalar_integer(show_fragments) || is_scalar_double(show_fragments)) && show_fragments == as.integer(show_fragments))){ stop("arg show_fragments wrong type") }
    
        private$py_obj$setShowFragmentIons(as.integer(show_fragments))
        invisible()
    },
    
    # C++ signature: bool getPrintDuplicateReferences()
    getPrintDuplicateReferences = function(){
    
        py_ans = private$py_obj$getPrintDuplicateReferences()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrintDuplicateReferences(bool print_duplicate_references)
    setPrintDuplicateReferences = function(print_duplicate_references){
    
        if(!( (is_scalar_integer(print_duplicate_references) || is_scalar_double(print_duplicate_references)) && print_duplicate_references == as.integer(print_duplicate_references))){ stop("arg print_duplicate_references wrong type") }
    
        private$py_obj$setPrintDuplicateReferences(as.integer(print_duplicate_references))
        invisible()
    },
    
    # C++ signature: bool getRemovePrecursorNearPeaks()
    getRemovePrecursorNearPeaks = function(){
    
        py_ans = private$py_obj$getRemovePrecursorNearPeaks()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setRemovePrecursorNearPeaks(bool remove_precursor_near_peaks)
    setRemovePrecursorNearPeaks = function(remove_precursor_near_peaks){
    
        if(!( (is_scalar_integer(remove_precursor_near_peaks) || is_scalar_double(remove_precursor_near_peaks)) && remove_precursor_near_peaks == as.integer(remove_precursor_near_peaks))){ stop("arg remove_precursor_near_peaks wrong type") }
    
        private$py_obj$setRemovePrecursorNearPeaks(as.integer(remove_precursor_near_peaks))
        invisible()
    },
    
    # C++ signature: bool getMassTypeParent()
    getMassTypeParent = function(){
    
        py_ans = private$py_obj$getMassTypeParent()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMassTypeParent(bool mass_type_parent)
    setMassTypeParent = function(mass_type_parent){
    
        if(!( (is_scalar_integer(mass_type_parent) || is_scalar_double(mass_type_parent)) && mass_type_parent == as.integer(mass_type_parent))){ stop("arg mass_type_parent wrong type") }
    
        private$py_obj$setMassTypeParent(as.integer(mass_type_parent))
        invisible()
    },
    
    # C++ signature: bool getMassTypeFragment()
    getMassTypeFragment = function(){
    
        py_ans = private$py_obj$getMassTypeFragment()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMassTypeFragment(bool mass_type_fragment)
    setMassTypeFragment = function(mass_type_fragment){
    
        if(!( (is_scalar_integer(mass_type_fragment) || is_scalar_double(mass_type_fragment)) && mass_type_fragment == as.integer(mass_type_fragment))){ stop("arg mass_type_fragment wrong type") }
    
        private$py_obj$setMassTypeFragment(as.integer(mass_type_fragment))
        invisible()
    },
    
    # C++ signature: bool getNormalizeXcorr()
    getNormalizeXcorr = function(){
    
        py_ans = private$py_obj$getNormalizeXcorr()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNormalizeXcorr(bool normalize_xcorr)
    setNormalizeXcorr = function(normalize_xcorr){
    
        if(!( (is_scalar_integer(normalize_xcorr) || is_scalar_double(normalize_xcorr)) && normalize_xcorr == as.integer(normalize_xcorr))){ stop("arg normalize_xcorr wrong type") }
    
        private$py_obj$setNormalizeXcorr(as.integer(normalize_xcorr))
        invisible()
    },
    
    # C++ signature: bool getResiduesInUpperCase()
    getResiduesInUpperCase = function(){
    
        py_ans = private$py_obj$getResiduesInUpperCase()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setResiduesInUpperCase(bool residues_in_upper_case)
    setResiduesInUpperCase = function(residues_in_upper_case){
    
        if(!( (is_scalar_integer(residues_in_upper_case) || is_scalar_double(residues_in_upper_case)) && residues_in_upper_case == as.integer(residues_in_upper_case))){ stop("arg residues_in_upper_case wrong type") }
    
        private$py_obj$setResiduesInUpperCase(as.integer(residues_in_upper_case))
        invisible()
    },
    
    # C++ signature: void addEnzymeInfo(libcpp_vector[String] & enzyme_info)
    addEnzymeInfo = function(enzyme_info){
    
        if(!(is_list(enzyme_info) && all(sapply(enzyme_info),is_scalar_character))){ stop("arg enzyme_info wrong type") }
        v0 = r_to_py(modify_depth(enzyme_info,1,py_builtin$bytes(enzyme_info,'utf-8')))
        private$py_obj$addEnzymeInfo(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(enzyme_info <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void handlePTMs(const String & modification_line, const String & modifications_filename, bool monoisotopic)
    handlePTMs = function(modification_line, modifications_filename, monoisotopic){
    
        if(!((is.R6(modification_line) && class(modification_line)[1]=="String") || is_scalar_character(modification_line))){ stop("arg modification_line wrong type") }
        if(!((is.R6(modifications_filename) && class(modifications_filename)[1]=="String") || is_scalar_character(modifications_filename))){ stop("arg modifications_filename wrong type") }
        if(!( (is_scalar_integer(monoisotopic) || is_scalar_double(monoisotopic)) && monoisotopic == as.integer(monoisotopic))){ stop("arg monoisotopic wrong type") }
    
    
    
        private$py_obj$handlePTMs(modification_line, modifications_filename, as.integer(monoisotopic))
        invisible()
    }
)
) 

# R implementation of _SequestOutfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SequestOutfile.html
SequestOutfile <- R6Class(classname = "SequestOutfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SequestOutfile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SequestOutfile()
        invisible()
    
    
    },
    
    # C++ signature: void SequestOutfile(SequestOutfile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SequestOutfile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SequestOutfile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SequestOutfile()
    # C++ signature: void SequestOutfile(SequestOutfile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SequestOutfile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SequestOutfile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & result_filename, libcpp_vector[PeptideIdentification] & peptide_identifications, ProteinIdentification & protein_identification, double p_value_threshold, libcpp_vector[double] & pvalues, const String & database, bool ignore_proteins_per_peptide)
    load = function(result_filename, peptide_identifications, protein_identification, p_value_threshold, pvalues, database, ignore_proteins_per_peptide){
    
        if(!((is.R6(result_filename) && class(result_filename)[1]=="String") || is_scalar_character(result_filename))){ stop("arg result_filename wrong type") }
        if(!(is_list(peptide_identifications) && all(sapply(peptide_identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_identifications wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_scalar_double(p_value_threshold))){ stop("arg p_value_threshold wrong type") }
        if(!(is_list(pvalues) && all(sapply(pvalues,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg pvalues wrong type") }
        if(!((is.R6(database) && class(database)[1]=="String") || is_scalar_character(database))){ stop("arg database wrong type") }
        if(!( (is_scalar_integer(ignore_proteins_per_peptide) || is_scalar_double(ignore_proteins_per_peptide)) && ignore_proteins_per_peptide == as.integer(ignore_proteins_per_peptide))){ stop("arg ignore_proteins_per_peptide wrong type") }
    
        v1 <- r_to_py(peptide_identifications)
    
    
        v4 <- r_to_py(pvalues)
    
    
        private$py_obj$load(result_filename, v1, protein_identification, p_value_threshold, v4, database, as.integer(ignore_proteins_per_peptide))
        byref_4 <- map_depth(py_to_r(v4),0,as.list)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(peptide_identifications <- byref_1))
        eval.parent(substitute(pvalues <- byref_4))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool getColumns(const String & line, libcpp_vector[String] & substrings, size_t number_of_columns, size_t reference_column)
    getColumns = function(line, substrings, number_of_columns, reference_column){
    
        if(!((is.R6(line) && class(line)[1]=="String") || is_scalar_character(line))){ stop("arg line wrong type") }
        if(!(is_list(substrings) && all(sapply(substrings),is_scalar_character))){ stop("arg substrings wrong type") }
        if(!( (is_scalar_integer(number_of_columns) || is_scalar_double(number_of_columns)) && number_of_columns == as.integer(number_of_columns))){ stop("arg number_of_columns wrong type") }
        if(!( (is_scalar_integer(reference_column) || is_scalar_double(reference_column)) && reference_column == as.integer(reference_column))){ stop("arg reference_column wrong type") }
    
        v1 = r_to_py(modify_depth(substrings,1,py_builtin$bytes(substrings,'utf-8')))
    
    
        py_ans = private$py_obj$getColumns(line, v1, as.integer(number_of_columns), as.integer(reference_column))
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(substrings <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: void getACAndACType(String line, String & accession, String & accession_type)
    getACAndACType = function(line, accession, accession_type){
    
        if(!((is.R6(line) && class(line)[1]=="String") || is_scalar_character(line))){ stop("arg line wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        if(!((is.R6(accession_type) && class(accession_type)[1]=="String") || is_scalar_character(accession_type))){ stop("arg accession_type wrong type") }
    
    
    
        private$py_obj$getACAndACType(line, accession, accession_type)
        invisible()
    }
)
) 

# R implementation of _SignalToNoiseEstimatorMeanIterative[_MSSpectrum]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SignalToNoiseEstimatorMeanIterative[_MSSpectrum].html
SignalToNoiseEstimatorMeanIterative <- R6Class(classname = "SignalToNoiseEstimatorMeanIterative",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SignalToNoiseEstimatorMeanIterative()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SignalToNoiseEstimatorMeanIterative()
        invisible()
    
    
    },
    
    # C++ signature: void SignalToNoiseEstimatorMeanIterative(SignalToNoiseEstimatorMeanIterative)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SignalToNoiseEstimatorMeanIterative")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SignalToNoiseEstimatorMeanIterative(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SignalToNoiseEstimatorMeanIterative()
    # C++ signature: void SignalToNoiseEstimatorMeanIterative(SignalToNoiseEstimatorMeanIterative)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SignalToNoiseEstimatorMeanIterative")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SignalToNoiseEstimatorMeanIterative" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void init(MSSpectrum & c)
    init = function(c){
    
        if(!(is.R6(c) && class(c)[1] == "MSSpectrum")){ stop("arg c wrong type") }
    
        private$py_obj$init(c)
        invisible()
    }
)
) 

# R implementation of _SignalToNoiseEstimatorMedian[_MSSpectrum]
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SignalToNoiseEstimatorMedian[_MSSpectrum].html
SignalToNoiseEstimatorMedian <- R6Class(classname = "SignalToNoiseEstimatorMedian",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SignalToNoiseEstimatorMedian()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SignalToNoiseEstimatorMedian()
        invisible()
    
    
    },
    
    # C++ signature: void SignalToNoiseEstimatorMedian(SignalToNoiseEstimatorMedian)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SignalToNoiseEstimatorMedian")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SignalToNoiseEstimatorMedian(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SignalToNoiseEstimatorMedian()
    # C++ signature: void SignalToNoiseEstimatorMedian(SignalToNoiseEstimatorMedian)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SignalToNoiseEstimatorMedian")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SignalToNoiseEstimatorMedian" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void init(MSSpectrum & spectrum)
    init = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$init(spectrum)
        invisible()
    },
    
    # C++ signature: void getSignalToNoise(Peak1D & data_point)
    getSignalToNoise = function(data_point){
    
        if(!(is.R6(data_point) && class(data_point)[1] == "Peak1D")){ stop("arg data_point wrong type") }
    
        private$py_obj$getSignalToNoise(data_point)
        invisible()
    },
    
    # C++ signature: double getSparseWindowPercent()
    getSparseWindowPercent = function(){
    
        py_ans = private$py_obj$getSparseWindowPercent()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getHistogramRightmostPercent()
    getHistogramRightmostPercent = function(){
    
        py_ans = private$py_obj$getHistogramRightmostPercent()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SignalToNoiseEstimatorMedianRapid
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SignalToNoiseEstimatorMedianRapid.html
SignalToNoiseEstimatorMedianRapid <- R6Class(classname = "SignalToNoiseEstimatorMedianRapid",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SignalToNoiseEstimatorMedianRapid(double window_length)
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SignalToNoiseEstimatorMedianRapid) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
        if(!(is_scalar_double(window_length))){ stop("arg window_length wrong type") }
    
    
        private$py_obj <- Pymod$SignalToNoiseEstimatorMedianRapid(window_length)
        invisible()
    }
    
    },
    
    # C++ signature: NoiseEstimator estimateNoise(shared_ptr[_Interfaces_Spectrum])
    estimateNoise_0 = function(in_0){
    
        if(!(all(class(in_0) == c('Spectrum','R6')))){ stop("arg in_0 wrong type") }
        input_in_0 <- r_to_py(in_0)
        py_ans = private$py_obj$`_estimateNoise_0`(input_in_0)
        r_ans = NoiseEstimator$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: NoiseEstimator estimateNoise(shared_ptr[_Interfaces_Chromatogram])
    estimateNoise_1 = function(in_0){
    
        if(!(all(class(in_0) == c('Chromatogram','R6')))){ stop("arg in_0 wrong type") }
        input_in_0 <- r_to_py(in_0)
        py_ans = private$py_obj$`_estimateNoise_1`(input_in_0)
        r_ans = NoiseEstimator$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: NoiseEstimator estimateNoise(libcpp_vector[double] mz_array, libcpp_vector[double] int_array)
    estimateNoise_2 = function(mz_array, int_array){
    
        if(!(is_list(mz_array) && all(sapply(mz_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz_array wrong type") }
        if(!(is_list(int_array) && all(sapply(int_array,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg int_array wrong type") }
        v0 <- r_to_py(mz_array)
        v1 <- r_to_py(int_array)
        py_ans = private$py_obj$`_estimateNoise_2`(v0, v1)
        
        
        r_ans = NoiseEstimator$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: NoiseEstimator estimateNoise(shared_ptr[_Interfaces_Spectrum])
    # C++ signature: NoiseEstimator estimateNoise(shared_ptr[_Interfaces_Chromatogram])
    # C++ signature: NoiseEstimator estimateNoise(libcpp_vector[double] mz_array, libcpp_vector[double] int_array)
    estimateNoise = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (all(class(arg_list[[1]]) == c('Spectrum','R6')))) { self$estimateNoise_0(...) }
        else if ((length(arg_list)==1) && (all(class(arg_list[[1]]) == c('Chromatogram','R6')))) { self$estimateNoise_1(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec))))) { self$estimateNoise_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _SimProtein
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::SimTypes_1_1SimProtein.html
SimProtein <- R6Class(classname = "SimProtein",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimProtein(FASTAEntry entry, MetaInfoInterface meta)
    initialize = function(entry, meta){
    
    if(missing(meta)){
         if( "python.builtin.object" %in% class(entry) && class_to_wrap(entry) == SimProtein ) { private$py_obj <- entry }
         else { stop("arg wrong type") }
      } else {
        if(!(is.R6(entry) && class(entry)[1] == "FASTAEntry")){ stop("arg entry wrong type") }
        if(!(is.R6(meta) && class(meta)[1] == "MetaInfoInterface")){ stop("arg meta wrong type") }
    
    
    
        private$py_obj <- Pymod$SimProtein(entry, meta)
        invisible()
    }
    
    }
)
) 

# R implementation of _SimRandomNumberGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::SimTypes_1_1SimRandomNumberGenerator.html
SimRandomNumberGenerator <- R6Class(classname = "SimRandomNumberGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimRandomNumberGenerator()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SimRandomNumberGenerator) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SimRandomNumberGenerator()
        invisible()
    }
    
    },
    
    # C++ signature: void initialize(bool biological_random, bool technical_random)
    initialise = function(biological_random, technical_random){
    
        if(!( (is_scalar_integer(biological_random) || is_scalar_double(biological_random)) && biological_random == as.integer(biological_random))){ stop("arg biological_random wrong type") }
        if(!( (is_scalar_integer(technical_random) || is_scalar_double(technical_random)) && technical_random == as.integer(technical_random))){ stop("arg technical_random wrong type") }
    
    
        private$py_obj$initialize(as.integer(biological_random), as.integer(technical_random))
        invisible()
    }
)
) 

# R implementation of _SimplePairFinder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SimplePairFinder.html
SimplePairFinder <- R6Class(classname = "SimplePairFinder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimplePairFinder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SimplePairFinder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SimplePairFinder()
        invisible()
    }
    
    },
    
    # C++ signature: void run(libcpp_vector[ConsensusMap] & input_maps, ConsensusMap & result_map)
    run = function(input_maps, result_map){
    
        if(!(is_list(input_maps) && all(sapply(input_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg input_maps wrong type") }
        if(!(is.R6(result_map) && class(result_map)[1] == "ConsensusMap")){ stop("arg result_map wrong type") }
        v0 <- r_to_py(input_maps)
    
        private$py_obj$run(v0, result_map)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(input_maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _SimplePeak
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SimplePeak.html
SimplePeak <- R6Class(classname = "SimplePeak",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        mz = function(mz){
    
        if(!missing(mz)){
            if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        
        
            private$py_obj$mz <- mz
            } else {
        
                py_ans = private$py_obj$mz
                r_result = py_ans
                return(r_result)
                }
        },
        charge = function(charge){
    
        if(!missing(charge)){
            if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        
        
            private$py_obj$charge <- as.integer(charge)
            } else {
        
                py_ans = private$py_obj$charge
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SimplePeak(SimplePeak)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SimplePeak")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SimplePeak(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SimplePeak()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$SimplePeak()
        invisible()
    
    
    },
    
    # C++ signature: void SimplePeak(double mz, int charge)
    init_2 = function(mz, charge){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
    
    
        private$py_obj <- Pymod$SimplePeak(mz, as.integer(charge))
        invisible()
    
    
    },
    
    # C++ signature: void SimplePeak(SimplePeak)
    # C++ signature: void SimplePeak()
    # C++ signature: void SimplePeak(double mz, int charge)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SimplePeak")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SimplePeak" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _SimpleSVM
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SimpleSVM.html
SimpleSVM <- R6Class(classname = "SimpleSVM",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimpleSVM()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SimpleSVM) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SimpleSVM()
        invisible()
    }
    
    },
    
    # C++ signature: void predict(libcpp_vector[SVMPrediction] & predictions, libcpp_vector[size_t] indexes)
    predict = function(predictions, indexes){
    
        if(!(is_list(predictions) && all(sapply(predictions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SVMPrediction")))){ stop("arg predictions wrong type") }
        if(!(is_list(indexes) && all(sapply(indexes,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indexes wrong type") }
        v0 <- r_to_py(predictions)
        v1 <- r_to_py(indexes)
        private$py_obj$predict(v0, v1)
        
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(predictions <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getFeatureWeights(libcpp_map[String,double] & feature_weights)
    getFeatureWeights = function(feature_weights){
    
        if(!(
          is.environment(feature_weights) && identical(parent.env(feature_weights), asNamespace("collections")) && identical(strsplit(capture.output(feature_weights$print())," ")[[1]][1], "dict")
          && all(sapply(feature_weights$keys(),function(k) (is.R6(k) && class(k)[1]=="String") || is_scalar_character(k)))
          && all(sapply(feature_weights$values(),function(v) is_scalar_double(v)))
          )){ stop("arg feature_weights wrong type") }
        v0 <- py_dict(feature_weights$keys(),feature_weights$values())
        private$py_obj$getFeatureWeights(v0)
        byref_0 <- collections::dict(py_to_r(py_builtin$list(v0$values())),lapply(py_to_r(py_builtin$list(v0$keys())), function(i) String$new(i)))
    
        tryCatch({
        eval.parent(substitute(feature_weights <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void writeXvalResults(const String & path)
    writeXvalResults = function(path){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
    
        private$py_obj$writeXvalResults(path)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SimpleSearchEngineAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SimpleSearchEngineAlgorithm.html
SimpleSearchEngineAlgorithm <- R6Class(classname = "SimpleSearchEngineAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimpleSearchEngineAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SimpleSearchEngineAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SimpleSearchEngineAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: void search(const String & in_mzML, const String & in_db, libcpp_vector[ProteinIdentification] & prot_ids, libcpp_vector[PeptideIdentification] & pep_ids)
    search = function(in_mzML, in_db, prot_ids, pep_ids){
    
        if(!((is.R6(in_mzML) && class(in_mzML)[1]=="String") || is_scalar_character(in_mzML))){ stop("arg in_mzML wrong type") }
        if(!((is.R6(in_db) && class(in_db)[1]=="String") || is_scalar_character(in_db))){ stop("arg in_db wrong type") }
        if(!(is_list(prot_ids) && all(sapply(prot_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg prot_ids wrong type") }
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
    
    
        v2 <- r_to_py(prot_ids)
        v3 <- r_to_py(pep_ids)
        private$py_obj$search(in_mzML, in_db, v2, v3)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(prot_ids <- byref_2))
        eval.parent(substitute(pep_ids <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _SimpleTSGXLMS
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SimpleTSGXLMS.html
SimpleTSGXLMS <- R6Class(classname = "SimpleTSGXLMS",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SimpleTSGXLMS()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SimpleTSGXLMS()
        invisible()
    
    
    },
    
    # C++ signature: void SimpleTSGXLMS(SimpleTSGXLMS)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SimpleTSGXLMS")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SimpleTSGXLMS(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SimpleTSGXLMS()
    # C++ signature: void SimpleTSGXLMS(SimpleTSGXLMS)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SimpleTSGXLMS")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SimpleTSGXLMS" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getLinearIonSpectrum(libcpp_vector[SimplePeak] & spectrum, AASequence peptide, size_t link_pos, int charge, size_t link_pos_2)
    getLinearIonSpectrum = function(spectrum, peptide, link_pos, charge, link_pos_2){
    
        if(!(is_list(spectrum) && all(sapply(spectrum,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak")))){ stop("arg spectrum wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(link_pos) || is_scalar_double(link_pos)) && link_pos == as.integer(link_pos))){ stop("arg link_pos wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!( (is_scalar_integer(link_pos_2) || is_scalar_double(link_pos_2)) && link_pos_2 == as.integer(link_pos_2))){ stop("arg link_pos_2 wrong type") }
        v0 <- r_to_py(spectrum)
    
    
    
    
        private$py_obj$getLinearIonSpectrum(v0, peptide, as.integer(link_pos), as.integer(charge), as.integer(link_pos_2))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(spectrum <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getXLinkIonSpectrum(libcpp_vector[SimplePeak] & spectrum, AASequence peptide, size_t link_pos, double precursor_mass, int mincharge, int maxcharge, size_t link_pos_2)
    getXLinkIonSpectrum_0 = function(spectrum, peptide, link_pos, precursor_mass, mincharge, maxcharge, link_pos_2){
    
        if(!(is_list(spectrum) && all(sapply(spectrum,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak")))){ stop("arg spectrum wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(link_pos) || is_scalar_double(link_pos)) && link_pos == as.integer(link_pos))){ stop("arg link_pos wrong type") }
        if(!(is_scalar_double(precursor_mass))){ stop("arg precursor_mass wrong type") }
        if(!( (is_scalar_integer(mincharge) || is_scalar_double(mincharge)) && mincharge == as.integer(mincharge))){ stop("arg mincharge wrong type") }
        if(!( (is_scalar_integer(maxcharge) || is_scalar_double(maxcharge)) && maxcharge == as.integer(maxcharge))){ stop("arg maxcharge wrong type") }
        if(!( (is_scalar_integer(link_pos_2) || is_scalar_double(link_pos_2)) && link_pos_2 == as.integer(link_pos_2))){ stop("arg link_pos_2 wrong type") }
        v0 <- r_to_py(spectrum)
    
    
    
    
    
    
        private$py_obj$`_getXLinkIonSpectrum_0`(v0, peptide, as.integer(link_pos), precursor_mass, as.integer(mincharge), as.integer(maxcharge), as.integer(link_pos_2))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(spectrum <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getXLinkIonSpectrum(libcpp_vector[SimplePeak] & spectrum, ProteinProteinCrossLink crosslink, bool frag_alpha, int mincharge, int maxcharge)
    getXLinkIonSpectrum_1 = function(spectrum, crosslink, frag_alpha, mincharge, maxcharge){
    
        if(!(is_list(spectrum) && all(sapply(spectrum,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak")))){ stop("arg spectrum wrong type") }
        if(!(is.R6(crosslink) && class(crosslink)[1] == "ProteinProteinCrossLink")){ stop("arg crosslink wrong type") }
        if(!( (is_scalar_integer(frag_alpha) || is_scalar_double(frag_alpha)) && frag_alpha == as.integer(frag_alpha))){ stop("arg frag_alpha wrong type") }
        if(!( (is_scalar_integer(mincharge) || is_scalar_double(mincharge)) && mincharge == as.integer(mincharge))){ stop("arg mincharge wrong type") }
        if(!( (is_scalar_integer(maxcharge) || is_scalar_double(maxcharge)) && maxcharge == as.integer(maxcharge))){ stop("arg maxcharge wrong type") }
        v0 <- r_to_py(spectrum)
    
    
    
    
        private$py_obj$`_getXLinkIonSpectrum_1`(v0, crosslink, as.integer(frag_alpha), as.integer(mincharge), as.integer(maxcharge))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(spectrum <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getXLinkIonSpectrum(libcpp_vector[SimplePeak] & spectrum, AASequence peptide, size_t link_pos, double precursor_mass, int mincharge, int maxcharge, size_t link_pos_2)
    # C++ signature: void getXLinkIonSpectrum(libcpp_vector[SimplePeak] & spectrum, ProteinProteinCrossLink crosslink, bool frag_alpha, int mincharge, int maxcharge)
    getXLinkIonSpectrum = function(...){
        arg_list = list(...)
        if ((length(arg_list)==7) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "AASequence") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && ( (is_scalar_integer(arg_list[[6]]) || is_scalar_double(arg_list[[6]])) && arg_list[[6]] == as.integer(arg_list[[6]])) && ( (is_scalar_integer(arg_list[[7]]) || is_scalar_double(arg_list[[7]])) && arg_list[[7]] == as.integer(arg_list[[7]]))) { self$getXLinkIonSpectrum_0(...) }
        else if ((length(arg_list)==5) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SimplePeak"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ProteinProteinCrossLink") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$getXLinkIonSpectrum_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SiriusAdapterAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusAdapterAlgorithm.html
SiriusAdapterAlgorithm <- R6Class(classname = "SiriusAdapterAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusAdapterAlgorithm()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SiriusAdapterAlgorithm()
        invisible()
    
    
    },
    
    # C++ signature: void SiriusAdapterAlgorithm(SiriusAdapterAlgorithm)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SiriusAdapterAlgorithm")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SiriusAdapterAlgorithm(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SiriusAdapterAlgorithm()
    # C++ signature: void SiriusAdapterAlgorithm(SiriusAdapterAlgorithm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SiriusAdapterAlgorithm")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SiriusAdapterAlgorithm" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getFeatureOnly()
    getFeatureOnly = function(){
    
        py_ans = private$py_obj$getFeatureOnly()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getNoMasstraceInfoIsotopePattern()
    getNoMasstraceInfoIsotopePattern = function(){
    
        py_ans = private$py_obj$getNoMasstraceInfoIsotopePattern()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getIsotopePatternIterations()
    getIsotopePatternIterations = function(){
    
        py_ans = private$py_obj$getIsotopePatternIterations()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getCandidates()
    getCandidates = function(){
    
        py_ans = private$py_obj$getCandidates()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int getTopNHits()
    getTopNHits = function(){
    
        py_ans = private$py_obj$getTopNHits()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void preprocessingSirius(String featureinfo, MSExperiment & spectra, libcpp_vector[FeatureMap] & v_fp, KDTreeFeatureMaps & fp_map_kd, SiriusAdapterAlgorithm sirius_algo, FeatureMapping_FeatureToMs2Indices & feature_mapping)
    preprocessingSirius = function(featureinfo, spectra, v_fp, fp_map_kd, sirius_algo, feature_mapping){
    
        if(!((is.R6(featureinfo) && class(featureinfo)[1]=="String") || is_scalar_character(featureinfo))){ stop("arg featureinfo wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is_list(v_fp) && all(sapply(v_fp,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "FeatureMap")))){ stop("arg v_fp wrong type") }
        if(!(is.R6(fp_map_kd) && class(fp_map_kd)[1] == "KDTreeFeatureMaps")){ stop("arg fp_map_kd wrong type") }
        if(!(is.R6(sirius_algo) && class(sirius_algo)[1] == "SiriusAdapterAlgorithm")){ stop("arg sirius_algo wrong type") }
        if(!(is.R6(feature_mapping) && class(feature_mapping)[1] == "FeatureMapping_FeatureToMs2Indices")){ stop("arg feature_mapping wrong type") }
    
    
        v2 <- r_to_py(v_fp)
    
    
    
        private$py_obj$preprocessingSirius(featureinfo, spectra, v2, fp_map_kd, sirius_algo, feature_mapping)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(v_fp <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void checkFeatureSpectraNumber(String featureinfo, FeatureMapping_FeatureToMs2Indices feature_mapping, MSExperiment spectra, SiriusAdapterAlgorithm sirius_algo)
    checkFeatureSpectraNumber = function(featureinfo, feature_mapping, spectra, sirius_algo){
    
        if(!((is.R6(featureinfo) && class(featureinfo)[1]=="String") || is_scalar_character(featureinfo))){ stop("arg featureinfo wrong type") }
        if(!(is.R6(feature_mapping) && class(feature_mapping)[1] == "FeatureMapping_FeatureToMs2Indices")){ stop("arg feature_mapping wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is.R6(sirius_algo) && class(sirius_algo)[1] == "SiriusAdapterAlgorithm")){ stop("arg sirius_algo wrong type") }
    
    
    
    
        private$py_obj$checkFeatureSpectraNumber(featureinfo, feature_mapping, spectra, sirius_algo)
        invisible()
    },
    
    # C++ signature: libcpp_vector[String] callSiriusQProcess(String tmp_ms_file, String tmp_out_dir, String executable, String out_csifingerid, SiriusAdapterAlgorithm sirius_algo)
    callSiriusQProcess = function(tmp_ms_file, tmp_out_dir, executable, out_csifingerid, sirius_algo){
    
        if(!((is.R6(tmp_ms_file) && class(tmp_ms_file)[1]=="String") || is_scalar_character(tmp_ms_file))){ stop("arg tmp_ms_file wrong type") }
        if(!((is.R6(tmp_out_dir) && class(tmp_out_dir)[1]=="String") || is_scalar_character(tmp_out_dir))){ stop("arg tmp_out_dir wrong type") }
        if(!((is.R6(executable) && class(executable)[1]=="String") || is_scalar_character(executable))){ stop("arg executable wrong type") }
        if(!((is.R6(out_csifingerid) && class(out_csifingerid)[1]=="String") || is_scalar_character(out_csifingerid))){ stop("arg out_csifingerid wrong type") }
        if(!(is.R6(sirius_algo) && class(sirius_algo)[1] == "SiriusAdapterAlgorithm")){ stop("arg sirius_algo wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$callSiriusQProcess(tmp_ms_file, tmp_out_dir, executable, out_csifingerid, sirius_algo)
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    }
)
) 

# R implementation of _SiriusAdapterHit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::SiriusMzTabWriter_1_1SiriusAdapterHit.html
SiriusAdapterHit <- R6Class(classname = "SiriusAdapterHit",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        formula = function(formula){
    
        if(!missing(formula)){
            if(!((is.R6(formula) && class(formula)[1]=="String") || is_scalar_character(formula))){ stop("arg formula wrong type") }
        
        
            private$py_obj$formula <- formula
            } else {
        
                py_ans = private$py_obj$formula
            r_result = py_ans
                return(r_result)
                }
        },
        adduct = function(adduct){
    
        if(!missing(adduct)){
            if(!((is.R6(adduct) && class(adduct)[1]=="String") || is_scalar_character(adduct))){ stop("arg adduct wrong type") }
        
        
            private$py_obj$adduct <- adduct
            } else {
        
                py_ans = private$py_obj$adduct
            r_result = py_ans
                return(r_result)
                }
        },
        rank = function(rank){
    
        if(!missing(rank)){
            if(!( (is_scalar_integer(rank) || is_scalar_double(rank)) && rank == as.integer(rank))){ stop("arg rank wrong type") }
        
        
            private$py_obj$rank <- as.integer(rank)
            } else {
        
                py_ans = private$py_obj$rank
                r_result = py_ans
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        },
        treescore = function(treescore){
    
        if(!missing(treescore)){
            if(!(is_scalar_double(treescore))){ stop("arg treescore wrong type") }
        
        
            private$py_obj$treescore <- treescore
            } else {
        
                py_ans = private$py_obj$treescore
                r_result = py_ans
                return(r_result)
                }
        },
        isoscore = function(isoscore){
    
        if(!missing(isoscore)){
            if(!(is_scalar_double(isoscore))){ stop("arg isoscore wrong type") }
        
        
            private$py_obj$isoscore <- isoscore
            } else {
        
                py_ans = private$py_obj$isoscore
                r_result = py_ans
                return(r_result)
                }
        },
        explainedpeaks = function(explainedpeaks){
    
        if(!missing(explainedpeaks)){
            if(!( (is_scalar_integer(explainedpeaks) || is_scalar_double(explainedpeaks)) && explainedpeaks == as.integer(explainedpeaks))){ stop("arg explainedpeaks wrong type") }
        
        
            private$py_obj$explainedpeaks <- as.integer(explainedpeaks)
            } else {
        
                py_ans = private$py_obj$explainedpeaks
                r_result = py_ans
                return(r_result)
                }
        },
        explainedintensity = function(explainedintensity){
    
        if(!missing(explainedintensity)){
            if(!(is_scalar_double(explainedintensity))){ stop("arg explainedintensity wrong type") }
        
        
            private$py_obj$explainedintensity <- explainedintensity
            } else {
        
                py_ans = private$py_obj$explainedintensity
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SiriusAdapterHit()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusAdapterHit) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusAdapterHit()
        invisible()
    }
    
    }
)
) 

# R implementation of _SiriusAdapterIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusAdapterIdentification.html
SiriusAdapterIdentification <- R6Class(classname = "SiriusAdapterIdentification",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        scan_index = function(scan_index){
    
        if(!missing(scan_index)){
            if(!( (is_scalar_integer(scan_index) || is_scalar_double(scan_index)) && scan_index == as.integer(scan_index))){ stop("arg scan_index wrong type") }
        
        
            private$py_obj$scan_index <- as.integer(scan_index)
            } else {
        
                py_ans = private$py_obj$scan_index
                r_result = py_ans
                return(r_result)
                }
        },
        scan_number = function(scan_number){
    
        if(!missing(scan_number)){
            if(!( (is_scalar_integer(scan_number) || is_scalar_double(scan_number)) && scan_number == as.integer(scan_number))){ stop("arg scan_number wrong type") }
        
        
            private$py_obj$scan_number <- as.integer(scan_number)
            } else {
        
                py_ans = private$py_obj$scan_number
                r_result = py_ans
                return(r_result)
                }
        },
        feature_id = function(feature_id){
    
        if(!missing(feature_id)){
            if(!((is.R6(feature_id) && class(feature_id)[1]=="String") || is_scalar_character(feature_id))){ stop("arg feature_id wrong type") }
        
        
            private$py_obj$feature_id <- feature_id
            } else {
        
                py_ans = private$py_obj$feature_id
            r_result = py_ans
                return(r_result)
                }
        },
        hits = function(hits){
    
        if(!missing(hits)){
            if(!(is_list(hits) && all(sapply(hits,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SiriusAdapterHit")))){ stop("arg hits wrong type") }
        
            v0 <- r_to_py(hits)
            private$py_obj$hits <- v0
            } else {
            
                py_ans = private$py_obj$hits
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SiriusAdapterIdentification()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusAdapterIdentification) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusAdapterIdentification()
        invisible()
    }
    
    }
)
) 

# R implementation of _SiriusAdapterRun
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusAdapterRun.html
SiriusAdapterRun <- R6Class(classname = "SiriusAdapterRun",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        identifications = function(identifications){
    
        if(!missing(identifications)){
            if(!(is_list(identifications) && all(sapply(identifications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SiriusAdapterIdentification")))){ stop("arg identifications wrong type") }
        
            v0 <- r_to_py(identifications)
            private$py_obj$identifications <- v0
            } else {
            
                py_ans = private$py_obj$identifications
            r_result = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SiriusAdapterRun()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusAdapterRun) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusAdapterRun()
        invisible()
    }
    
    }
)
) 

# R implementation of _SiriusFragmentAnnotation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusFragmentAnnotation.html
SiriusFragmentAnnotation <- R6Class(classname = "SiriusFragmentAnnotation",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusFragmentAnnotation()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SiriusFragmentAnnotation()
        invisible()
    
    
    },
    
    # C++ signature: void SiriusFragmentAnnotation(SiriusFragmentAnnotation)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SiriusFragmentAnnotation")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SiriusFragmentAnnotation(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SiriusFragmentAnnotation()
    # C++ signature: void SiriusFragmentAnnotation(SiriusFragmentAnnotation)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SiriusFragmentAnnotation")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SiriusFragmentAnnotation" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void extractSiriusFragmentAnnotationMapping(String & path_to_sirius_workspace, MSSpectrum & msspectrum_to_fill, bool use_exact_mass)
    extractSiriusFragmentAnnotationMapping = function(path_to_sirius_workspace, msspectrum_to_fill, use_exact_mass){
    
        if(!((is.R6(path_to_sirius_workspace) && class(path_to_sirius_workspace)[1]=="String") || is_scalar_character(path_to_sirius_workspace))){ stop("arg path_to_sirius_workspace wrong type") }
        if(!(is.R6(msspectrum_to_fill) && class(msspectrum_to_fill)[1] == "MSSpectrum")){ stop("arg msspectrum_to_fill wrong type") }
        if(!( (is_scalar_integer(use_exact_mass) || is_scalar_double(use_exact_mass)) && use_exact_mass == as.integer(use_exact_mass))){ stop("arg use_exact_mass wrong type") }
    
    
    
        private$py_obj$extractSiriusFragmentAnnotationMapping(path_to_sirius_workspace, msspectrum_to_fill, as.integer(use_exact_mass))
        invisible()
    }
)
) 

# R implementation of _SiriusMSFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusMSFile.html
SiriusMSFile <- R6Class(classname = "SiriusMSFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusMSFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusMSFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusMSFile()
        invisible()
    }
    
    },
    
    # C++ signature: void store(MSExperiment & spectra, String & msfile, FeatureMapping_FeatureToMs2Indices & feature_ms2_spectra_map, bool & feature_only, int & isotope_pattern_iterations, bool no_mt_info, libcpp_vector[SiriusMSFile_CompoundInfo] v_cmpinfo)
    store = function(spectra, msfile, feature_ms2_spectra_map, feature_only, isotope_pattern_iterations, no_mt_info, v_cmpinfo){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!((is.R6(msfile) && class(msfile)[1]=="String") || is_scalar_character(msfile))){ stop("arg msfile wrong type") }
        if(!(is.R6(feature_ms2_spectra_map) && class(feature_ms2_spectra_map)[1] == "FeatureMapping_FeatureToMs2Indices")){ stop("arg feature_ms2_spectra_map wrong type") }
        if(!( (is_scalar_integer(feature_only) || is_scalar_double(feature_only)) && feature_only == as.integer(feature_only))){ stop("arg feature_only wrong type") }
        if(!( (is_scalar_integer(isotope_pattern_iterations) || is_scalar_double(isotope_pattern_iterations)) && isotope_pattern_iterations == as.integer(isotope_pattern_iterations))){ stop("arg isotope_pattern_iterations wrong type") }
        if(!( (is_scalar_integer(no_mt_info) || is_scalar_double(no_mt_info)) && no_mt_info == as.integer(no_mt_info))){ stop("arg no_mt_info wrong type") }
        if(!(is_list(v_cmpinfo) && all(sapply(v_cmpinfo,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SiriusMSFile_CompoundInfo")))){ stop("arg v_cmpinfo wrong type") }
    
    
    
    
    
    
        v6 <- r_to_py(v_cmpinfo)
        private$py_obj$store(spectra, msfile, feature_ms2_spectra_map, as.integer(feature_only), as.integer(isotope_pattern_iterations), as.integer(no_mt_info), v6)
        
        invisible()
    }
)
) 

# R implementation of _SiriusMSFile_AccessionInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusMSFile_AccessionInfo.html
SiriusMSFile_AccessionInfo <- R6Class(classname = "SiriusMSFile_AccessionInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusMSFile_AccessionInfo()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusMSFile_AccessionInfo) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusMSFile_AccessionInfo()
        invisible()
    }
    
    }
)
) 

# R implementation of _SiriusMSFile_CompoundInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusMSFile_CompoundInfo.html
SiriusMSFile_CompoundInfo <- R6Class(classname = "SiriusMSFile_CompoundInfo",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusMSFile_CompoundInfo()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusMSFile_CompoundInfo) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusMSFile_CompoundInfo()
        invisible()
    }
    
    }
)
) 

# R implementation of _SiriusMzTabWriter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusMzTabWriter.html
SiriusMzTabWriter <- R6Class(classname = "SiriusMzTabWriter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusMzTabWriter()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SiriusMzTabWriter) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SiriusMzTabWriter()
        invisible()
    }
    
    },
    
    # C++ signature: String extract_scan_index(const String & path)
    extract_scan_index = function(path){
    
        if(!((is.R6(path) && class(path)[1]=="String") || is_scalar_character(path))){ stop("arg path wrong type") }
    
        py_ans = private$py_obj$extract_scan_index(path)
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void read(libcpp_vector[String] sirius_output_paths, String original_input_mzml, size_t top_n_hits, MzTab & result)
    read = function(sirius_output_paths, original_input_mzml, top_n_hits, result){
    
        if(!(is_list(sirius_output_paths) && all(sapply(sirius_output_paths),is_scalar_character))){ stop("arg sirius_output_paths wrong type") }
        if(!((is.R6(original_input_mzml) && class(original_input_mzml)[1]=="String") || is_scalar_character(original_input_mzml))){ stop("arg original_input_mzml wrong type") }
        if(!( (is_scalar_integer(top_n_hits) || is_scalar_double(top_n_hits)) && top_n_hits == as.integer(top_n_hits))){ stop("arg top_n_hits wrong type") }
        if(!(is.R6(result) && class(result)[1] == "MzTab")){ stop("arg result wrong type") }
        v0 = r_to_py(modify_depth(sirius_output_paths,1,py_builtin$bytes(sirius_output_paths,'utf-8')))
    
    
    
        private$py_obj$read(v0, original_input_mzml, as.integer(top_n_hits), result)
        invisible()
    }
)
) 

# R implementation of _SiriusTemporaryFileSystemObjects
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SiriusTemporaryFileSystemObjects.html
SiriusTemporaryFileSystemObjects <- R6Class(classname = "SiriusTemporaryFileSystemObjects",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SiriusTemporaryFileSystemObjects(int debug_level)
    init_0 = function(debug_level){
    
        if(!( (is_scalar_integer(debug_level) || is_scalar_double(debug_level)) && debug_level == as.integer(debug_level))){ stop("arg debug_level wrong type") }
    
    
        private$py_obj <- Pymod$SiriusTemporaryFileSystemObjects(as.integer(debug_level))
        invisible()
    
    
    },
    
    # C++ signature: void SiriusTemporaryFileSystemObjects(SiriusTemporaryFileSystemObjects)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SiriusTemporaryFileSystemObjects")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SiriusTemporaryFileSystemObjects(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SiriusTemporaryFileSystemObjects(int debug_level)
    # C++ signature: void SiriusTemporaryFileSystemObjects(SiriusTemporaryFileSystemObjects)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SiriusTemporaryFileSystemObjects")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SiriusTemporaryFileSystemObjects" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getTmpDir()
    getTmpDir = function(){
    
        py_ans = private$py_obj$getTmpDir()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTmpOutDir()
    getTmpOutDir = function(){
    
        py_ans = private$py_obj$getTmpOutDir()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getTmpMsFile()
    getTmpMsFile = function(){
    
        py_ans = private$py_obj$getTmpMsFile()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _Software
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Software.html
Software <- R6Class(classname = "Software",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Software()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == Software) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$Software()
        invisible()
    }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setVersion(String)
    setVersion = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setVersion(in_0)
        invisible()
    }
)
) 

# R implementation of _SolverParam
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SolverParam.html
SolverParam <- R6Class(classname = "SolverParam",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        message_level = function(message_level){
    
        if(!missing(message_level)){
            if(!( (is_scalar_integer(message_level) || is_scalar_double(message_level)) && message_level == as.integer(message_level))){ stop("arg message_level wrong type") }
        
        
            private$py_obj$message_level <- as.integer(message_level)
            } else {
        
                py_ans = private$py_obj$message_level
                r_result = py_ans
                return(r_result)
                }
        },
        branching_tech = function(branching_tech){
    
        if(!missing(branching_tech)){
            if(!( (is_scalar_integer(branching_tech) || is_scalar_double(branching_tech)) && branching_tech == as.integer(branching_tech))){ stop("arg branching_tech wrong type") }
        
        
            private$py_obj$branching_tech <- as.integer(branching_tech)
            } else {
        
                py_ans = private$py_obj$branching_tech
                r_result = py_ans
                return(r_result)
                }
        },
        backtrack_tech = function(backtrack_tech){
    
        if(!missing(backtrack_tech)){
            if(!( (is_scalar_integer(backtrack_tech) || is_scalar_double(backtrack_tech)) && backtrack_tech == as.integer(backtrack_tech))){ stop("arg backtrack_tech wrong type") }
        
        
            private$py_obj$backtrack_tech <- as.integer(backtrack_tech)
            } else {
        
                py_ans = private$py_obj$backtrack_tech
                r_result = py_ans
                return(r_result)
                }
        },
        preprocessing_tech = function(preprocessing_tech){
    
        if(!missing(preprocessing_tech)){
            if(!( (is_scalar_integer(preprocessing_tech) || is_scalar_double(preprocessing_tech)) && preprocessing_tech == as.integer(preprocessing_tech))){ stop("arg preprocessing_tech wrong type") }
        
        
            private$py_obj$preprocessing_tech <- as.integer(preprocessing_tech)
            } else {
        
                py_ans = private$py_obj$preprocessing_tech
                r_result = py_ans
                return(r_result)
                }
        },
        enable_feas_pump_heuristic = function(enable_feas_pump_heuristic){
    
        if(!missing(enable_feas_pump_heuristic)){
            if(!( (is_scalar_integer(enable_feas_pump_heuristic) || is_scalar_double(enable_feas_pump_heuristic)) && enable_feas_pump_heuristic == as.integer(enable_feas_pump_heuristic))){ stop("arg enable_feas_pump_heuristic wrong type") }
        
        
            private$py_obj$enable_feas_pump_heuristic <- as.integer(enable_feas_pump_heuristic)
            } else {
        
                py_ans = private$py_obj$enable_feas_pump_heuristic
                r_result = py_ans
                return(r_result)
                }
        },
        enable_gmi_cuts = function(enable_gmi_cuts){
    
        if(!missing(enable_gmi_cuts)){
            if(!( (is_scalar_integer(enable_gmi_cuts) || is_scalar_double(enable_gmi_cuts)) && enable_gmi_cuts == as.integer(enable_gmi_cuts))){ stop("arg enable_gmi_cuts wrong type") }
        
        
            private$py_obj$enable_gmi_cuts <- as.integer(enable_gmi_cuts)
            } else {
        
                py_ans = private$py_obj$enable_gmi_cuts
                r_result = py_ans
                return(r_result)
                }
        },
        enable_mir_cuts = function(enable_mir_cuts){
    
        if(!missing(enable_mir_cuts)){
            if(!( (is_scalar_integer(enable_mir_cuts) || is_scalar_double(enable_mir_cuts)) && enable_mir_cuts == as.integer(enable_mir_cuts))){ stop("arg enable_mir_cuts wrong type") }
        
        
            private$py_obj$enable_mir_cuts <- as.integer(enable_mir_cuts)
            } else {
        
                py_ans = private$py_obj$enable_mir_cuts
                r_result = py_ans
                return(r_result)
                }
        },
        enable_cov_cuts = function(enable_cov_cuts){
    
        if(!missing(enable_cov_cuts)){
            if(!( (is_scalar_integer(enable_cov_cuts) || is_scalar_double(enable_cov_cuts)) && enable_cov_cuts == as.integer(enable_cov_cuts))){ stop("arg enable_cov_cuts wrong type") }
        
        
            private$py_obj$enable_cov_cuts <- as.integer(enable_cov_cuts)
            } else {
        
                py_ans = private$py_obj$enable_cov_cuts
                r_result = py_ans
                return(r_result)
                }
        },
        enable_clq_cuts = function(enable_clq_cuts){
    
        if(!missing(enable_clq_cuts)){
            if(!( (is_scalar_integer(enable_clq_cuts) || is_scalar_double(enable_clq_cuts)) && enable_clq_cuts == as.integer(enable_clq_cuts))){ stop("arg enable_clq_cuts wrong type") }
        
        
            private$py_obj$enable_clq_cuts <- as.integer(enable_clq_cuts)
            } else {
        
                py_ans = private$py_obj$enable_clq_cuts
                r_result = py_ans
                return(r_result)
                }
        },
        mip_gap = function(mip_gap){
    
        if(!missing(mip_gap)){
            if(!(is_scalar_double(mip_gap))){ stop("arg mip_gap wrong type") }
        
        
            private$py_obj$mip_gap <- mip_gap
            } else {
        
                py_ans = private$py_obj$mip_gap
                r_result = py_ans
                return(r_result)
                }
        },
        time_limit = function(time_limit){
    
        if(!missing(time_limit)){
            if(!( (is_scalar_integer(time_limit) || is_scalar_double(time_limit)) && time_limit == as.integer(time_limit))){ stop("arg time_limit wrong type") }
        
        
            private$py_obj$time_limit <- as.integer(time_limit)
            } else {
        
                py_ans = private$py_obj$time_limit
                r_result = py_ans
                return(r_result)
                }
        },
        output_freq = function(output_freq){
    
        if(!missing(output_freq)){
            if(!( (is_scalar_integer(output_freq) || is_scalar_double(output_freq)) && output_freq == as.integer(output_freq))){ stop("arg output_freq wrong type") }
        
        
            private$py_obj$output_freq <- as.integer(output_freq)
            } else {
        
                py_ans = private$py_obj$output_freq
                r_result = py_ans
                return(r_result)
                }
        },
        output_delay = function(output_delay){
    
        if(!missing(output_delay)){
            if(!( (is_scalar_integer(output_delay) || is_scalar_double(output_delay)) && output_delay == as.integer(output_delay))){ stop("arg output_delay wrong type") }
        
        
            private$py_obj$output_delay <- as.integer(output_delay)
            } else {
        
                py_ans = private$py_obj$output_delay
                r_result = py_ans
                return(r_result)
                }
        },
        enable_presolve = function(enable_presolve){
    
        if(!missing(enable_presolve)){
            if(!( (is_scalar_integer(enable_presolve) || is_scalar_double(enable_presolve)) && enable_presolve == as.integer(enable_presolve))){ stop("arg enable_presolve wrong type") }
        
        
            private$py_obj$enable_presolve <- as.integer(enable_presolve)
            } else {
        
                py_ans = private$py_obj$enable_presolve
                r_result = py_ans
                return(r_result)
                }
        },
        enable_binarization = function(enable_binarization){
    
        if(!missing(enable_binarization)){
            if(!( (is_scalar_integer(enable_binarization) || is_scalar_double(enable_binarization)) && enable_binarization == as.integer(enable_binarization))){ stop("arg enable_binarization wrong type") }
        
        
            private$py_obj$enable_binarization <- as.integer(enable_binarization)
            } else {
        
                py_ans = private$py_obj$enable_binarization
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SolverParam()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SolverParam) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SolverParam()
        invisible()
    }
    
    }
)
) 

# R implementation of _SourceFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SourceFile.html
SourceFile <- R6Class(classname = "SourceFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SourceFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SourceFile()
        invisible()
    
    
    },
    
    # C++ signature: void SourceFile(SourceFile)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SourceFile")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SourceFile(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SourceFile()
    # C++ signature: void SourceFile(SourceFile)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SourceFile")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SourceFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getNameOfFile()
    getNameOfFile = function(){
    
        py_ans = private$py_obj$getNameOfFile()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNameOfFile(String)
    setNameOfFile = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setNameOfFile(in_0)
        invisible()
    },
    
    # C++ signature: String getPathToFile()
    getPathToFile = function(){
    
        py_ans = private$py_obj$getPathToFile()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPathToFile(String)
    setPathToFile = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPathToFile(in_0)
        invisible()
    },
    
    # C++ signature: float getFileSize()
    getFileSize = function(){
    
        py_ans = private$py_obj$getFileSize()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFileSize(float)
    setFileSize = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setFileSize(in_0)
        invisible()
    },
    
    # C++ signature: String getFileType()
    getFileType = function(){
    
        py_ans = private$py_obj$getFileType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFileType(String)
    setFileType = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setFileType(in_0)
        invisible()
    },
    
    # C++ signature: String getChecksum()
    getChecksum = function(){
    
        py_ans = private$py_obj$getChecksum()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setChecksum(String, ChecksumType)
    setChecksum = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(in_1 %in% c(0, 1, 2, 3))){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setChecksum(in_0, as.integer(in_1))
        invisible()
    },
    
    # C++ signature: ChecksumType getChecksumType()
    getChecksumType = function(){
    
        py_ans = private$py_obj$getChecksumType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getNativeIDType()
    getNativeIDType = function(){
    
        py_ans = private$py_obj$getNativeIDType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeIDType(String)
    setNativeIDType = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setNativeIDType(in_0)
        invisible()
    },
    
    # C++ signature: String getNativeIDTypeAccession()
    getNativeIDTypeAccession = function(){
    
        py_ans = private$py_obj$getNativeIDTypeAccession()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeIDTypeAccession(const String & accesssion)
    setNativeIDTypeAccession = function(accesssion){
    
        if(!((is.R6(accesssion) && class(accesssion)[1]=="String") || is_scalar_character(accesssion))){ stop("arg accesssion wrong type") }
    
        private$py_obj$setNativeIDTypeAccession(accesssion)
        invisible()
    }
)
) 

# R implementation of _SpectraMerger
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectraMerger.html
SpectraMerger <- R6Class(classname = "SpectraMerger",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectraMerger()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectraMerger) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectraMerger()
        invisible()
    }
    
    },
    
    # C++ signature: void mergeSpectraBlockWise(MSExperiment & exp)
    mergeSpectraBlockWise = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$mergeSpectraBlockWise(exp)
        invisible()
    },
    
    # C++ signature: void mergeSpectraPrecursors(MSExperiment & exp)
    mergeSpectraPrecursors = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$mergeSpectraPrecursors(exp)
        invisible()
    },
    
    # C++ signature: void average(MSExperiment & exp, String average_type)
    average = function(exp, average_type){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
        if(!((is.R6(average_type) && class(average_type)[1]=="String") || is_scalar_character(average_type))){ stop("arg average_type wrong type") }
    
    
        private$py_obj$average(exp, average_type)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectraSTSimilarityScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectraSTSimilarityScore.html
SpectraSTSimilarityScore <- R6Class(classname = "SpectraSTSimilarityScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectraSTSimilarityScore()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SpectraSTSimilarityScore()
        invisible()
    
    
    },
    
    # C++ signature: void SpectraSTSimilarityScore(SpectraSTSimilarityScore)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectraSTSimilarityScore")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectraSTSimilarityScore(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectraSTSimilarityScore()
    # C++ signature: void SpectraSTSimilarityScore(SpectraSTSimilarityScore)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectraSTSimilarityScore")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectraSTSimilarityScore" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: bool preprocess(MSSpectrum & spec, float remove_peak_intensity_threshold, unsigned int cut_peaks_below, size_t min_peak_number, size_t max_peak_number)
    preprocess = function(spec, remove_peak_intensity_threshold, cut_peaks_below, min_peak_number, max_peak_number){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is_scalar_double(remove_peak_intensity_threshold))){ stop("arg remove_peak_intensity_threshold wrong type") }
        if(!( (is_scalar_integer(cut_peaks_below) || is_scalar_double(cut_peaks_below)) && cut_peaks_below == as.integer(cut_peaks_below))){ stop("arg cut_peaks_below wrong type") }
        if(!( (is_scalar_integer(min_peak_number) || is_scalar_double(min_peak_number)) && min_peak_number == as.integer(min_peak_number))){ stop("arg min_peak_number wrong type") }
        if(!( (is_scalar_integer(max_peak_number) || is_scalar_double(max_peak_number)) && max_peak_number == as.integer(max_peak_number))){ stop("arg max_peak_number wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$preprocess(spec, remove_peak_intensity_threshold, as.integer(cut_peaks_below), as.integer(min_peak_number), as.integer(max_peak_number))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: BinnedSpectrum transform(MSSpectrum & spec)
    transform = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        py_ans = private$py_obj$transform(spec)
        r_ans = BinnedSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: double dot_bias(BinnedSpectrum & bin1, BinnedSpectrum & bin2, double dot_product)
    dot_bias = function(bin1, bin2, dot_product){
    
        if(!(is.R6(bin1) && class(bin1)[1] == "BinnedSpectrum")){ stop("arg bin1 wrong type") }
        if(!(is.R6(bin2) && class(bin2)[1] == "BinnedSpectrum")){ stop("arg bin2 wrong type") }
        if(!(is_scalar_double(dot_product))){ stop("arg dot_product wrong type") }
    
    
    
        py_ans = private$py_obj$dot_bias(bin1, bin2, dot_product)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double delta_D(double top_hit, double runner_up)
    delta_D = function(top_hit, runner_up){
    
        if(!(is_scalar_double(top_hit))){ stop("arg top_hit wrong type") }
        if(!(is_scalar_double(runner_up))){ stop("arg runner_up wrong type") }
    
    
        py_ans = private$py_obj$delta_D(top_hit, runner_up)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double compute_F(double dot_product, double delta_D, double dot_bias)
    compute_F = function(dot_product, delta_D, dot_bias){
    
        if(!(is_scalar_double(dot_product))){ stop("arg dot_product wrong type") }
        if(!(is_scalar_double(delta_D))){ stop("arg delta_D wrong type") }
        if(!(is_scalar_double(dot_bias))){ stop("arg dot_bias wrong type") }
    
    
    
        py_ans = private$py_obj$compute_F(dot_product, delta_D, dot_bias)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SpectralMatch
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectralMatch.html
SpectralMatch <- R6Class(classname = "SpectralMatch",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectralMatch()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SpectralMatch()
        invisible()
    
    
    },
    
    # C++ signature: void SpectralMatch(SpectralMatch)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectralMatch")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectralMatch(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectralMatch()
    # C++ signature: void SpectralMatch(SpectralMatch)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectralMatch")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectralMatch" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getObservedPrecursorMass()
    getObservedPrecursorMass = function(){
    
        py_ans = private$py_obj$getObservedPrecursorMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedPrecursorMass(double)
    setObservedPrecursorMass = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setObservedPrecursorMass(in_0)
        invisible()
    },
    
    # C++ signature: double getObservedPrecursorRT()
    getObservedPrecursorRT = function(){
    
        py_ans = private$py_obj$getObservedPrecursorRT()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedPrecursorRT(double)
    setObservedPrecursorRT = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setObservedPrecursorRT(in_0)
        invisible()
    },
    
    # C++ signature: double getFoundPrecursorMass()
    getFoundPrecursorMass = function(){
    
        py_ans = private$py_obj$getFoundPrecursorMass()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFoundPrecursorMass(double)
    setFoundPrecursorMass = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setFoundPrecursorMass(in_0)
        invisible()
    },
    
    # C++ signature: int getFoundPrecursorCharge()
    getFoundPrecursorCharge = function(){
    
        py_ans = private$py_obj$getFoundPrecursorCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFoundPrecursorCharge(int)
    setFoundPrecursorCharge = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setFoundPrecursorCharge(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: double getMatchingScore()
    getMatchingScore = function(){
    
        py_ans = private$py_obj$getMatchingScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchingScore(double)
    setMatchingScore = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMatchingScore(in_0)
        invisible()
    },
    
    # C++ signature: size_t getObservedSpectrumIndex()
    getObservedSpectrumIndex = function(){
    
        py_ans = private$py_obj$getObservedSpectrumIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setObservedSpectrumIndex(size_t)
    setObservedSpectrumIndex = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setObservedSpectrumIndex(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: size_t getMatchingSpectrumIndex()
    getMatchingSpectrumIndex = function(){
    
        py_ans = private$py_obj$getMatchingSpectrumIndex()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMatchingSpectrumIndex(size_t)
    setMatchingSpectrumIndex = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setMatchingSpectrumIndex(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getPrimaryIdentifier()
    getPrimaryIdentifier = function(){
    
        py_ans = private$py_obj$getPrimaryIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrimaryIdentifier(String)
    setPrimaryIdentifier = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPrimaryIdentifier(in_0)
        invisible()
    },
    
    # C++ signature: String getSecondaryIdentifier()
    getSecondaryIdentifier = function(){
    
        py_ans = private$py_obj$getSecondaryIdentifier()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSecondaryIdentifier(String)
    setSecondaryIdentifier = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSecondaryIdentifier(in_0)
        invisible()
    },
    
    # C++ signature: String getCommonName()
    getCommonName = function(){
    
        py_ans = private$py_obj$getCommonName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setCommonName(String)
    setCommonName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setCommonName(in_0)
        invisible()
    },
    
    # C++ signature: String getSumFormula()
    getSumFormula = function(){
    
        py_ans = private$py_obj$getSumFormula()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSumFormula(String)
    setSumFormula = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSumFormula(in_0)
        invisible()
    },
    
    # C++ signature: String getInchiString()
    getInchiString = function(){
    
        py_ans = private$py_obj$getInchiString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInchiString(String)
    setInchiString = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setInchiString(in_0)
        invisible()
    },
    
    # C++ signature: String getSMILESString()
    getSMILESString = function(){
    
        py_ans = private$py_obj$getSMILESString()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSMILESString(String)
    setSMILESString = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSMILESString(in_0)
        invisible()
    },
    
    # C++ signature: String getPrecursorAdduct()
    getPrecursorAdduct = function(){
    
        py_ans = private$py_obj$getPrecursorAdduct()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorAdduct(String)
    setPrecursorAdduct = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setPrecursorAdduct(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectrumAccessOpenMS
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessOpenMS.html
SpectrumAccessOpenMS <- R6Class(classname = "SpectrumAccessOpenMS",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAccessOpenMS()
    init_0 = function(){
    
        stop("Cannot call this constructor!")
    
    },
    
    # C++ signature: void SpectrumAccessOpenMS(SpectrumAccessOpenMS)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessOpenMS")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMS(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMS(shared_ptr[MSExperiment] & ms_experiment)
    init_2 = function(ms_experiment){
    
        if(!(all(class(ms_experiment) == c('MSExperiment','R6')))){ stop("arg ms_experiment wrong type") }
        input_ms_experiment <- r_to_py(ms_experiment)
    
        private$py_obj <- Pymod$SpectrumAccessOpenMS(input_ms_experiment)
        invisible()
    
        byref_0 = MSExperiment$new(input_ms_experiment)
    
    },
    
    # C++ signature: void SpectrumAccessOpenMS()
    # C++ signature: void SpectrumAccessOpenMS(SpectrumAccessOpenMS)
    # C++ signature: void SpectrumAccessOpenMS(shared_ptr[MSExperiment] & ms_experiment)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessOpenMS")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (all(class(arg_list[[1]]) == c('MSExperiment','R6')))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAccessOpenMS" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAccessOpenMSCached
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessOpenMSCached.html
SpectrumAccessOpenMSCached <- R6Class(classname = "SpectrumAccessOpenMSCached",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAccessOpenMSCached()
    init_0 = function(){
    
        stop("Cannot call this constructor!")
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSCached(String filename)
    init_1 = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMSCached(filename)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSCached()
    # C++ signature: void SpectrumAccessOpenMSCached(String filename)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAccessOpenMSCached" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAccessOpenMSInMemory
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessOpenMSInMemory.html
SpectrumAccessOpenMSInMemory <- R6Class(classname = "SpectrumAccessOpenMSInMemory",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAccessOpenMSInMemory()
    init_0 = function(){
    
        stop("Cannot call this constructor!")
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMS)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessOpenMS")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMSInMemory(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMSCached)
    init_2 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessOpenMSCached")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMSInMemory(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMSInMemory)
    init_3 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessOpenMSInMemory")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMSInMemory(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessQuadMZTransforming)
    init_4 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessQuadMZTransforming")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessOpenMSInMemory(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessOpenMSInMemory()
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMS)
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMSCached)
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessOpenMSInMemory)
    # C++ signature: void SpectrumAccessOpenMSInMemory(SpectrumAccessQuadMZTransforming)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessOpenMS")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessOpenMSCached")) { self$init_2(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessOpenMSInMemory")) { self$init_3(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessQuadMZTransforming")) { self$init_4(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAccessOpenMSInMemory" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAccessQuadMZTransforming
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessQuadMZTransforming.html
SpectrumAccessQuadMZTransforming <- R6Class(classname = "SpectrumAccessQuadMZTransforming",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAccessQuadMZTransforming()
    init_0 = function(){
    
        stop("Cannot call this constructor!")
    
    },
    
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMS], double a, double b, double c, bool ppm)
    init_1 = function(in_0, a, b, c, ppm){
    
        if(!(all(class(in_0) == c('SpectrumAccessOpenMS','R6')))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(a))){ stop("arg a wrong type") }
        if(!(is_scalar_double(b))){ stop("arg b wrong type") }
        if(!(is_scalar_double(c))){ stop("arg c wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        input_in_0 <- r_to_py(in_0)
    
    
    
    
    
        private$py_obj <- Pymod$SpectrumAccessQuadMZTransforming(input_in_0, a, b, c, as.integer(ppm))
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMSCached], double a, double b, double c, bool ppm)
    init_2 = function(in_0, a, b, c, ppm){
    
        if(!(all(class(in_0) == c('SpectrumAccessOpenMSCached','R6')))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(a))){ stop("arg a wrong type") }
        if(!(is_scalar_double(b))){ stop("arg b wrong type") }
        if(!(is_scalar_double(c))){ stop("arg c wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        input_in_0 <- r_to_py(in_0)
    
    
    
    
    
        private$py_obj <- Pymod$SpectrumAccessQuadMZTransforming(input_in_0, a, b, c, as.integer(ppm))
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMSInMemory], double a, double b, double c, bool ppm)
    init_3 = function(in_0, a, b, c, ppm){
    
        if(!(all(class(in_0) == c('SpectrumAccessOpenMSInMemory','R6')))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(a))){ stop("arg a wrong type") }
        if(!(is_scalar_double(b))){ stop("arg b wrong type") }
        if(!(is_scalar_double(c))){ stop("arg c wrong type") }
        if(!( (is_scalar_integer(ppm) || is_scalar_double(ppm)) && ppm == as.integer(ppm))){ stop("arg ppm wrong type") }
        input_in_0 <- r_to_py(in_0)
    
    
    
    
    
        private$py_obj <- Pymod$SpectrumAccessQuadMZTransforming(input_in_0, a, b, c, as.integer(ppm))
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessQuadMZTransforming()
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMS], double a, double b, double c, bool ppm)
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMSCached], double a, double b, double c, bool ppm)
    # C++ signature: void SpectrumAccessQuadMZTransforming(shared_ptr[SpectrumAccessOpenMSInMemory], double a, double b, double c, bool ppm)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==5) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMS','R6'))) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$init_1(...) }
        else if ((length(arg_list)==5) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMSCached','R6'))) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$init_2(...) }
        else if ((length(arg_list)==5) && (all(class(arg_list[[1]]) == c('SpectrumAccessOpenMSInMemory','R6'))) && (is_scalar_double(arg_list[[2]])) && (is_scalar_double(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$init_3(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAccessQuadMZTransforming" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAccessSqMass
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessSqMass.html
SpectrumAccessSqMass <- R6Class(classname = "SpectrumAccessSqMass",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAccessSqMass()
    init_0 = function(){
    
        stop("Cannot call this constructor!")
    
    },
    
    # C++ signature: void SpectrumAccessSqMass(SpectrumAccessSqMass)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAccessSqMass")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAccessSqMass(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAccessSqMass(MzMLSqliteHandler, libcpp_vector[int] indices)
    init_2 = function(in_0, indices){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MzMLSqliteHandler")){ stop("arg in_0 wrong type") }
        if(!(is_list(indices) && all(sapply(indices,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg indices wrong type") }
    
        v1 <- r_to_py(modify_depth(indices,1,as.integer))
    
        private$py_obj <- Pymod$SpectrumAccessSqMass(in_0, v1)
        invisible()
    
        
    
    },
    
    # C++ signature: void SpectrumAccessSqMass()
    # C++ signature: void SpectrumAccessSqMass(SpectrumAccessSqMass)
    # C++ signature: void SpectrumAccessSqMass(MzMLSqliteHandler, libcpp_vector[int] indices)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAccessSqMass")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MzMLSqliteHandler") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAccessSqMass" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAccessTransforming
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAccessTransforming.html
SpectrumAccessTransforming <- R6Class(classname = "SpectrumAccessTransforming",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: shared_ptr[OSSpectrum] getSpectrumById(int id_)
    getSpectrumById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getSpectrumById(as.integer(id_))
        r_ans = OSSpectrum$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[size_t] getSpectraByRT(double RT, double deltaRT)
    getSpectraByRT = function(RT, deltaRT){
    
        if(!(is_scalar_double(RT))){ stop("arg RT wrong type") }
        if(!(is_scalar_double(deltaRT))){ stop("arg deltaRT wrong type") }
    
    
        py_ans = private$py_obj$getSpectraByRT(RT, deltaRT)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrSpectra()
    getNrSpectra = function(){
    
        py_ans = private$py_obj$getNrSpectra()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: shared_ptr[OSChromatogram] getChromatogramById(int id_)
    getChromatogramById = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramById(as.integer(id_))
        r_ans = OSChromatogram$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getNrChromatograms()
    getNrChromatograms = function(){
    
        py_ans = private$py_obj$getNrChromatograms()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_string getChromatogramNativeID(int id_)
    getChromatogramNativeID = function(id_){
    
        if(!( (is_scalar_integer(id_) || is_scalar_double(id_)) && id_ == as.integer(id_))){ stop("arg id_ wrong type") }
    
        py_ans = private$py_obj$getChromatogramNativeID(as.integer(id_))
    r_ans = as.character(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumAlignment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAlignment.html
SpectrumAlignment <- R6Class(classname = "SpectrumAlignment",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAlignment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SpectrumAlignment()
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAlignment(SpectrumAlignment)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAlignment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAlignment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAlignment()
    # C++ signature: void SpectrumAlignment(SpectrumAlignment)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAlignment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAlignment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectrumAlignmentScore
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAlignmentScore.html
SpectrumAlignmentScore <- R6Class(classname = "SpectrumAlignmentScore",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAlignmentScore()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SpectrumAlignmentScore()
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAlignmentScore(SpectrumAlignmentScore)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAlignmentScore")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAlignmentScore(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAlignmentScore()
    # C++ signature: void SpectrumAlignmentScore(SpectrumAlignmentScore)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAlignmentScore")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAlignmentScore" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectrumAnnotator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumAnnotator.html
SpectrumAnnotator <- R6Class(classname = "SpectrumAnnotator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumAnnotator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SpectrumAnnotator()
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAnnotator(SpectrumAnnotator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumAnnotator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SpectrumAnnotator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SpectrumAnnotator()
    # C++ signature: void SpectrumAnnotator(SpectrumAnnotator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SpectrumAnnotator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SpectrumAnnotator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void annotateMatches(MSSpectrum & spec, PeptideHit & ph, TheoreticalSpectrumGenerator & tg, SpectrumAlignment & sa)
    annotateMatches = function(spec, ph, tg, sa){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is.R6(ph) && class(ph)[1] == "PeptideHit")){ stop("arg ph wrong type") }
        if(!(is.R6(tg) && class(tg)[1] == "TheoreticalSpectrumGenerator")){ stop("arg tg wrong type") }
        if(!(is.R6(sa) && class(sa)[1] == "SpectrumAlignment")){ stop("arg sa wrong type") }
    
    
    
    
        private$py_obj$annotateMatches(spec, ph, tg, sa)
        invisible()
    },
    
    # C++ signature: void addIonMatchStatistics(PeptideIdentification & pi, MSSpectrum & spec, TheoreticalSpectrumGenerator & tg, SpectrumAlignment & sa)
    addIonMatchStatistics = function(pi, spec, tg, sa){
    
        if(!(is.R6(pi) && class(pi)[1] == "PeptideIdentification")){ stop("arg pi wrong type") }
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is.R6(tg) && class(tg)[1] == "TheoreticalSpectrumGenerator")){ stop("arg tg wrong type") }
        if(!(is.R6(sa) && class(sa)[1] == "SpectrumAlignment")){ stop("arg sa wrong type") }
    
    
    
    
        private$py_obj$addIonMatchStatistics(pi, spec, tg, sa)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectrumHelper
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumHelper.html
SpectrumHelper <- R6Class(classname = "SpectrumHelper",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: void removePeaks(MSChromatogram & p, double pos_start, double pos_end)
    SpectrumHelper$removePeaks = function(p, pos_start, pos_end){
    
        if(!(is.R6(p) && class(p)[1] == "MSChromatogram")){ stop("arg p wrong type") }
        if(!(is_scalar_double(pos_start))){ stop("arg pos_start wrong type") }
        if(!(is_scalar_double(pos_end))){ stop("arg pos_end wrong type") }
    
    
    
        Pymod$SpectrumHelper$removePeaks(p, pos_start, pos_end)
    }
    
    # C++ signature: void removePeaks(MSSpectrum & p, double pos_start, double pos_end)
    SpectrumHelper$removePeaks = function(p, pos_start, pos_end){
    
        if(!(is.R6(p) && class(p)[1] == "MSSpectrum")){ stop("arg p wrong type") }
        if(!(is_scalar_double(pos_start))){ stop("arg pos_start wrong type") }
        if(!(is_scalar_double(pos_end))){ stop("arg pos_end wrong type") }
    
    
    
        Pymod$SpectrumHelper$removePeaks(p, pos_start, pos_end)
    }
    
    # C++ signature: void subtractMinimumIntensity(MSChromatogram & p)
    SpectrumHelper$subtractMinimumIntensity = function(p){
    
        if(!(is.R6(p) && class(p)[1] == "MSChromatogram")){ stop("arg p wrong type") }
    
        Pymod$SpectrumHelper$subtractMinimumIntensity(p)
    }
    
    # C++ signature: void subtractMinimumIntensity(MSSpectrum & p)
    SpectrumHelper$subtractMinimumIntensity = function(p){
    
        if(!(is.R6(p) && class(p)[1] == "MSSpectrum")){ stop("arg p wrong type") }
    
        Pymod$SpectrumHelper$subtractMinimumIntensity(p)
    } 

# R implementation of _SpectrumIdentification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumIdentification.html
SpectrumIdentification <- R6Class(classname = "SpectrumIdentification",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumIdentification()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectrumIdentification) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectrumIdentification()
        invisible()
    }
    
    },
    
    # C++ signature: void setHits(libcpp_vector[IdentificationHit] & hits)
    setHits = function(hits){
    
        if(!(is_list(hits) && all(sapply(hits,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IdentificationHit")))){ stop("arg hits wrong type") }
        v0 <- r_to_py(hits)
        private$py_obj$setHits(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(hits <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void addHit(IdentificationHit & hit)
    addHit = function(hit){
    
        if(!(is.R6(hit) && class(hit)[1] == "IdentificationHit")){ stop("arg hit wrong type") }
    
        private$py_obj$addHit(hit)
        invisible()
    },
    
    # C++ signature: libcpp_vector[IdentificationHit] getHits()
    getHits = function(){
    
        py_ans = private$py_obj$getHits()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _SpectrumLookup
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumLookup.html
SpectrumLookup <- R6Class(classname = "SpectrumLookup",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        rt_tolerance = function(rt_tolerance){
    
        if(!missing(rt_tolerance)){
            if(!(is_scalar_double(rt_tolerance))){ stop("arg rt_tolerance wrong type") }
        
        
            private$py_obj$rt_tolerance <- rt_tolerance
            } else {
        
                py_ans = private$py_obj$rt_tolerance
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SpectrumLookup()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectrumLookup) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectrumLookup()
        invisible()
    }
    
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void readSpectra(MSExperiment spectra, String scan_regexp)
    readSpectra = function(spectra, scan_regexp){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!((is.R6(scan_regexp) && class(scan_regexp)[1]=="String") || is_scalar_character(scan_regexp))){ stop("arg scan_regexp wrong type") }
    
    
        private$py_obj$readSpectra(spectra, scan_regexp)
        invisible()
    },
    
    # C++ signature: size_t findByRT(double rt)
    findByRT = function(rt){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
    
        py_ans = private$py_obj$findByRT(rt)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByNativeID(String native_id)
    findByNativeID = function(native_id){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
    
        py_ans = private$py_obj$findByNativeID(native_id)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByIndex(size_t index, bool count_from_one)
    findByIndex = function(index, count_from_one){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!( (is_scalar_integer(count_from_one) || is_scalar_double(count_from_one)) && count_from_one == as.integer(count_from_one))){ stop("arg count_from_one wrong type") }
    
    
        py_ans = private$py_obj$findByIndex(as.integer(index), as.integer(count_from_one))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByScanNumber(size_t scan_number)
    findByScanNumber = function(scan_number){
    
        if(!( (is_scalar_integer(scan_number) || is_scalar_double(scan_number)) && scan_number == as.integer(scan_number))){ stop("arg scan_number wrong type") }
    
        py_ans = private$py_obj$findByScanNumber(as.integer(scan_number))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByReference(String spectrum_ref)
    findByReference = function(spectrum_ref){
    
        if(!((is.R6(spectrum_ref) && class(spectrum_ref)[1]=="String") || is_scalar_character(spectrum_ref))){ stop("arg spectrum_ref wrong type") }
    
        py_ans = private$py_obj$findByReference(spectrum_ref)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addReferenceFormat(String regexp)
    addReferenceFormat = function(regexp){
    
        if(!((is.R6(regexp) && class(regexp)[1]=="String") || is_scalar_character(regexp))){ stop("arg regexp wrong type") }
    
        private$py_obj$addReferenceFormat(regexp)
        invisible()
    },
    
    # C++ signature: int extractScanNumber(const String & native_id, const String & native_id_type_accession)
    extractScanNumber = function(native_id, native_id_type_accession){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
        if(!((is.R6(native_id_type_accession) && class(native_id_type_accession)[1]=="String") || is_scalar_character(native_id_type_accession))){ stop("arg native_id_type_accession wrong type") }
    
    
        py_ans = private$py_obj$extractScanNumber(native_id, native_id_type_accession)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SpectrumMetaData
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumMetaData.html
SpectrumMetaData <- R6Class(classname = "SpectrumMetaData",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        rt = function(rt){
    
        if(!missing(rt)){
            if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
        
        
            private$py_obj$rt <- rt
            } else {
        
                py_ans = private$py_obj$rt
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_rt = function(precursor_rt){
    
        if(!missing(precursor_rt)){
            if(!(is_scalar_double(precursor_rt))){ stop("arg precursor_rt wrong type") }
        
        
            private$py_obj$precursor_rt <- precursor_rt
            } else {
        
                py_ans = private$py_obj$precursor_rt
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_mz = function(precursor_mz){
    
        if(!missing(precursor_mz)){
            if(!(is_scalar_double(precursor_mz))){ stop("arg precursor_mz wrong type") }
        
        
            private$py_obj$precursor_mz <- precursor_mz
            } else {
        
                py_ans = private$py_obj$precursor_mz
                r_result = py_ans
                return(r_result)
                }
        },
        precursor_charge = function(precursor_charge){
    
        if(!missing(precursor_charge)){
            if(!( (is_scalar_integer(precursor_charge) || is_scalar_double(precursor_charge)) && precursor_charge == as.integer(precursor_charge))){ stop("arg precursor_charge wrong type") }
        
        
            private$py_obj$precursor_charge <- as.integer(precursor_charge)
            } else {
        
                py_ans = private$py_obj$precursor_charge
                r_result = py_ans
                return(r_result)
                }
        },
        ms_level = function(ms_level){
    
        if(!missing(ms_level)){
            if(!( (is_scalar_integer(ms_level) || is_scalar_double(ms_level)) && ms_level == as.integer(ms_level))){ stop("arg ms_level wrong type") }
        
        
            private$py_obj$ms_level <- as.integer(ms_level)
            } else {
        
                py_ans = private$py_obj$ms_level
                r_result = py_ans
                return(r_result)
                }
        },
        scan_number = function(scan_number){
    
        if(!missing(scan_number)){
            if(!( (is_scalar_integer(scan_number) || is_scalar_double(scan_number)) && scan_number == as.integer(scan_number))){ stop("arg scan_number wrong type") }
        
        
            private$py_obj$scan_number <- as.integer(scan_number)
            } else {
        
                py_ans = private$py_obj$scan_number
                r_result = py_ans
                return(r_result)
                }
        },
        native_id = function(native_id){
    
        if(!missing(native_id)){
            if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
        
        
            private$py_obj$native_id <- native_id
            } else {
        
                py_ans = private$py_obj$native_id
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SpectrumMetaData()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectrumMetaData) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectrumMetaData()
        invisible()
    }
    
    }
)
) 

# R implementation of _SpectrumMetaDataLookup
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumMetaDataLookup.html
SpectrumMetaDataLookup <- R6Class(classname = "SpectrumMetaDataLookup",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumMetaDataLookup()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectrumMetaDataLookup) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectrumMetaDataLookup()
        invisible()
    }
    
    },
    
    # C++ signature: void readSpectra(MSExperiment spectra, String scan_regexp, bool get_precursor_rt)
    readSpectra_0 = function(spectra, scan_regexp, get_precursor_rt){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!((is.R6(scan_regexp) && class(scan_regexp)[1]=="String") || is_scalar_character(scan_regexp))){ stop("arg scan_regexp wrong type") }
        if(!( (is_scalar_integer(get_precursor_rt) || is_scalar_double(get_precursor_rt)) && get_precursor_rt == as.integer(get_precursor_rt))){ stop("arg get_precursor_rt wrong type") }
    
    
    
        private$py_obj$`_readSpectra_0`(spectra, scan_regexp, as.integer(get_precursor_rt))
        invisible()
    },
    
    # C++ signature: void readSpectra(MSExperiment spectra, String scan_regexp)
    readSpectra_1 = function(spectra, scan_regexp){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!((is.R6(scan_regexp) && class(scan_regexp)[1]=="String") || is_scalar_character(scan_regexp))){ stop("arg scan_regexp wrong type") }
    
    
        private$py_obj$`_readSpectra_1`(spectra, scan_regexp)
        invisible()
    },
    
    # C++ signature: void readSpectra(MSExperiment spectra, String scan_regexp, bool get_precursor_rt)
    # C++ signature: void readSpectra(MSExperiment spectra, String scan_regexp)
    readSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$readSpectra_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$readSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void getSpectrumMetaData(size_t index, SpectrumMetaData & meta)
    getSpectrumMetaData_0 = function(index, meta){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!(is.R6(meta) && class(meta)[1] == "SpectrumMetaData")){ stop("arg meta wrong type") }
    
    
        private$py_obj$`_getSpectrumMetaData_0`(as.integer(index), meta)
        invisible()
    },
    
    # C++ signature: void getSpectrumMetaData(String spectrum_ref, SpectrumMetaData & meta)
    getSpectrumMetaData_1 = function(spectrum_ref, meta){
    
        if(!((is.R6(spectrum_ref) && class(spectrum_ref)[1]=="String") || is_scalar_character(spectrum_ref))){ stop("arg spectrum_ref wrong type") }
        if(!(is.R6(meta) && class(meta)[1] == "SpectrumMetaData")){ stop("arg meta wrong type") }
    
    
        private$py_obj$`_getSpectrumMetaData_1`(spectrum_ref, meta)
        invisible()
    },
    
    # C++ signature: void getSpectrumMetaData(String spectrum_ref, SpectrumMetaData & meta, unsigned char flags)
    getSpectrumMetaData_2 = function(spectrum_ref, meta, flags){
    
        if(!((is.R6(spectrum_ref) && class(spectrum_ref)[1]=="String") || is_scalar_character(spectrum_ref))){ stop("arg spectrum_ref wrong type") }
        if(!(is.R6(meta) && class(meta)[1] == "SpectrumMetaData")){ stop("arg meta wrong type") }
        if(!(is_scalar_character(flags))){ stop("arg flags wrong type") }
    
    
    py_run_string("flags = bytes(flags)")
        private$py_obj$`_getSpectrumMetaData_2`(spectrum_ref, meta, py$flags)
        py_run_string("del flags")
        invisible()
    },
    
    # C++ signature: void getSpectrumMetaData(size_t index, SpectrumMetaData & meta)
    # C++ signature: void getSpectrumMetaData(String spectrum_ref, SpectrumMetaData & meta)
    # C++ signature: void getSpectrumMetaData(String spectrum_ref, SpectrumMetaData & meta, unsigned char flags)
    getSpectrumMetaData = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "SpectrumMetaData")) { self$getSpectrumMetaData_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "SpectrumMetaData")) { self$getSpectrumMetaData_1(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "SpectrumMetaData") && (is_scalar_character(arg_list[[3]]))) { self$getSpectrumMetaData_2(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setSpectraDataRef(const String & spectra_data)
    setSpectraDataRef = function(spectra_data){
    
        if(!((is.R6(spectra_data) && class(spectra_data)[1]=="String") || is_scalar_character(spectra_data))){ stop("arg spectra_data wrong type") }
    
        private$py_obj$setSpectraDataRef(spectra_data)
        invisible()
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByRT(double rt)
    findByRT = function(rt){
    
        if(!(is_scalar_double(rt))){ stop("arg rt wrong type") }
    
        py_ans = private$py_obj$findByRT(rt)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByNativeID(String native_id)
    findByNativeID = function(native_id){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
    
        py_ans = private$py_obj$findByNativeID(native_id)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByIndex(size_t index, bool count_from_one)
    findByIndex = function(index, count_from_one){
    
        if(!( (is_scalar_integer(index) || is_scalar_double(index)) && index == as.integer(index))){ stop("arg index wrong type") }
        if(!( (is_scalar_integer(count_from_one) || is_scalar_double(count_from_one)) && count_from_one == as.integer(count_from_one))){ stop("arg count_from_one wrong type") }
    
    
        py_ans = private$py_obj$findByIndex(as.integer(index), as.integer(count_from_one))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByScanNumber(size_t scan_number)
    findByScanNumber = function(scan_number){
    
        if(!( (is_scalar_integer(scan_number) || is_scalar_double(scan_number)) && scan_number == as.integer(scan_number))){ stop("arg scan_number wrong type") }
    
        py_ans = private$py_obj$findByScanNumber(as.integer(scan_number))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: size_t findByReference(String spectrum_ref)
    findByReference = function(spectrum_ref){
    
        if(!((is.R6(spectrum_ref) && class(spectrum_ref)[1]=="String") || is_scalar_character(spectrum_ref))){ stop("arg spectrum_ref wrong type") }
    
        py_ans = private$py_obj$findByReference(spectrum_ref)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addReferenceFormat(String regexp)
    addReferenceFormat = function(regexp){
    
        if(!((is.R6(regexp) && class(regexp)[1]=="String") || is_scalar_character(regexp))){ stop("arg regexp wrong type") }
    
        private$py_obj$addReferenceFormat(regexp)
        invisible()
    },
    
    # C++ signature: int extractScanNumber(const String & native_id, const String & native_id_type_accession)
    extractScanNumber = function(native_id, native_id_type_accession){
    
        if(!((is.R6(native_id) && class(native_id)[1]=="String") || is_scalar_character(native_id))){ stop("arg native_id wrong type") }
        if(!((is.R6(native_id_type_accession) && class(native_id_type_accession)[1]=="String") || is_scalar_character(native_id_type_accession))){ stop("arg native_id_type_accession wrong type") }
    
    
        py_ans = private$py_obj$extractScanNumber(native_id, native_id_type_accession)
        r_ans = py_ans
        return(r_ans)
    }
)
)
    
    # C++ signature: bool addMissingRTsToPeptideIDs(libcpp_vector[PeptideIdentification], String filename, bool stop_on_error)
    SpectrumMetaDataLookup$addMissingRTsToPeptideIDs = function(in_0, filename, stop_on_error){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(stop_on_error) || is_scalar_double(stop_on_error)) && stop_on_error == as.integer(stop_on_error))){ stop("arg stop_on_error wrong type") }
        v0 <- r_to_py(in_0)
    
    
        py_ans = Pymod$SpectrumMetaDataLookup$addMissingRTsToPeptideIDs(v0, filename, as.integer(stop_on_error))
        
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: bool addMissingSpectrumReferences(libcpp_vector[PeptideIdentification], String filename, bool stop_on_error, bool override_spectra_data, bool override_spectra_references, libcpp_vector[ProteinIdentification] proteins)
    SpectrumMetaDataLookup$addMissingSpectrumReferences = function(in_0, filename, stop_on_error, override_spectra_data, override_spectra_references, proteins){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(stop_on_error) || is_scalar_double(stop_on_error)) && stop_on_error == as.integer(stop_on_error))){ stop("arg stop_on_error wrong type") }
        if(!( (is_scalar_integer(override_spectra_data) || is_scalar_double(override_spectra_data)) && override_spectra_data == as.integer(override_spectra_data))){ stop("arg override_spectra_data wrong type") }
        if(!( (is_scalar_integer(override_spectra_references) || is_scalar_double(override_spectra_references)) && override_spectra_references == as.integer(override_spectra_references))){ stop("arg override_spectra_references wrong type") }
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg proteins wrong type") }
        v0 <- r_to_py(in_0)
    
    
    
    
        v5 <- r_to_py(proteins)
        py_ans = Pymod$SpectrumMetaDataLookup$addMissingSpectrumReferences(v0, filename, as.integer(stop_on_error), as.integer(override_spectra_data), as.integer(override_spectra_references), v5)
        
        
            r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: void getSpectrumMetaData(MSSpectrum spectrum, SpectrumMetaData & meta)
    SpectrumMetaDataLookup$getSpectrumMetaData = function(spectrum, meta){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is.R6(meta) && class(meta)[1] == "SpectrumMetaData")){ stop("arg meta wrong type") }
    
    
        Pymod$SpectrumMetaDataLookup$getSpectrumMetaData(spectrum, meta)
    } 

# R implementation of _SpectrumSettings
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SpectrumSettings.html
SpectrumSettings <- R6Class(classname = "SpectrumSettings",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SpectrumSettings()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SpectrumSettings) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SpectrumSettings()
        invisible()
    }
    
    },
    
    # C++ signature: void unify(SpectrumSettings)
    unify = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SpectrumSettings")){ stop("arg in_0 wrong type") }
    
        private$py_obj$unify(in_0)
        invisible()
    },
    
    # C++ signature: int getType()
    getType = function(){
    
        py_ans = private$py_obj$getType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setType(SpectrumType)
    setType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2, 3))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: String getNativeID()
    getNativeID = function(){
    
        py_ans = private$py_obj$getNativeID()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNativeID(String)
    setNativeID = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setNativeID(in_0)
        invisible()
    },
    
    # C++ signature: String getComment()
    getComment = function(){
    
        py_ans = private$py_obj$getComment()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setComment(String)
    setComment = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setComment(in_0)
        invisible()
    },
    
    # C++ signature: InstrumentSettings getInstrumentSettings()
    getInstrumentSettings = function(){
    
        py_ans = private$py_obj$getInstrumentSettings()
        r_ans = InstrumentSettings$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setInstrumentSettings(InstrumentSettings)
    setInstrumentSettings = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "InstrumentSettings")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setInstrumentSettings(in_0)
        invisible()
    },
    
    # C++ signature: AcquisitionInfo getAcquisitionInfo()
    getAcquisitionInfo = function(){
    
        py_ans = private$py_obj$getAcquisitionInfo()
        r_ans = AcquisitionInfo$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setAcquisitionInfo(AcquisitionInfo)
    setAcquisitionInfo = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "AcquisitionInfo")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setAcquisitionInfo(in_0)
        invisible()
    },
    
    # C++ signature: SourceFile getSourceFile()
    getSourceFile = function(){
    
        py_ans = private$py_obj$getSourceFile()
        r_ans = SourceFile$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setSourceFile(SourceFile)
    setSourceFile = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SourceFile")){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSourceFile(in_0)
        invisible()
    },
    
    # C++ signature: libcpp_vector[Precursor] getPrecursors()
    getPrecursors = function(){
    
        py_ans = private$py_obj$getPrecursors()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPrecursors(libcpp_vector[Precursor])
    setPrecursors = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Precursor")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPrecursors(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Product] getProducts()
    getProducts = function(){
    
        py_ans = private$py_obj$getProducts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setProducts(libcpp_vector[Product])
    setProducts = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Product")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setProducts(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[PeptideIdentification] getPeptideIdentifications()
    getPeptideIdentifications = function(){
    
        py_ans = private$py_obj$getPeptideIdentifications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setPeptideIdentifications(libcpp_vector[PeptideIdentification])
    setPeptideIdentifications = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setPeptideIdentifications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _SplineInterpolatedPeaks
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SplineInterpolatedPeaks.html
SplineInterpolatedPeaks <- R6Class(classname = "SplineInterpolatedPeaks",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SplineInterpolatedPeaks(libcpp_vector[double] mz, libcpp_vector[double] intensity)
    init_0 = function(mz, intensity){
    
        if(!(is_list(mz) && all(sapply(mz,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mz wrong type") }
        if(!(is_list(intensity) && all(sapply(intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity wrong type") }
        v0 <- r_to_py(mz)
        v1 <- r_to_py(intensity)
    
        private$py_obj <- Pymod$SplineInterpolatedPeaks(v0, v1)
        invisible()
    
        
        
    
    },
    
    # C++ signature: void SplineInterpolatedPeaks(MSSpectrum raw_spectrum)
    init_1 = function(raw_spectrum){
    
        if(!(is.R6(raw_spectrum) && class(raw_spectrum)[1] == "MSSpectrum")){ stop("arg raw_spectrum wrong type") }
    
    
        private$py_obj <- Pymod$SplineInterpolatedPeaks(raw_spectrum)
        invisible()
    
    
    },
    
    # C++ signature: void SplineInterpolatedPeaks(MSChromatogram raw_chromatogram)
    init_2 = function(raw_chromatogram){
    
        if(!(is.R6(raw_chromatogram) && class(raw_chromatogram)[1] == "MSChromatogram")){ stop("arg raw_chromatogram wrong type") }
    
    
        private$py_obj <- Pymod$SplineInterpolatedPeaks(raw_chromatogram)
        invisible()
    
    
    },
    
    # C++ signature: void SplineInterpolatedPeaks(libcpp_vector[double] mz, libcpp_vector[double] intensity)
    # C++ signature: void SplineInterpolatedPeaks(MSSpectrum raw_spectrum)
    # C++ signature: void SplineInterpolatedPeaks(MSChromatogram raw_chromatogram)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_double(elemt_rec))))) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum")) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSChromatogram")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SplineInterpolatedPeaks" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getPosMin()
    getPosMin = function(){
    
        py_ans = private$py_obj$getPosMin()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPosMax()
    getPosMax = function(){
    
        py_ans = private$py_obj$getPosMax()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: int size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: SplineSpectrum_Navigator getNavigator(double scaling)
    getNavigator = function(scaling){
    
        if(!(is_scalar_double(scaling))){ stop("arg scaling wrong type") }
    
        py_ans = private$py_obj$getNavigator(scaling)
        r_ans = SplineSpectrum_Navigator$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SplinePackage
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SplinePackage.html
SplinePackage <- R6Class(classname = "SplinePackage",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SplinePackage(libcpp_vector[double] pos, libcpp_vector[double] intensity)
    initialize = function(pos, intensity){
    
    if(missing(intensity)){
         if( "python.builtin.object" %in% class(pos) && class_to_wrap(pos) == SplinePackage ) { private$py_obj <- pos }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(pos) && all(sapply(pos,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg pos wrong type") }
        if(!(is_list(intensity) && all(sapply(intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity wrong type") }
        v0 <- r_to_py(pos)
        v1 <- r_to_py(intensity)
    
        private$py_obj <- Pymod$SplinePackage(v0, v1)
        invisible()
    }
        
        
    
    },
    
    # C++ signature: double getPosMin()
    getPosMin = function(){
    
        py_ans = private$py_obj$getPosMin()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPosMax()
    getPosMax = function(){
    
        py_ans = private$py_obj$getPosMax()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getPosStepWidth()
    getPosStepWidth = function(){
    
        py_ans = private$py_obj$getPosStepWidth()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isInPackage(double pos)
    isInPackage = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$isInPackage(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double eval(double pos)
    eval = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$eval(pos)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SplineSpectrum_Navigator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SplineSpectrum_Navigator.html
SplineSpectrum_Navigator <- R6Class(classname = "SplineSpectrum_Navigator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SplineSpectrum_Navigator(libcpp_vector[SplinePackage] * packages, double posMin, double posMax, double scaling)
    initialize = function(packages, posMin, posMax, scaling){
    
    if(missing(posMin) && missing(posMax) && missing(scaling)){
         if( "python.builtin.object" %in% class(packages) && class_to_wrap(packages) == SplineSpectrum_Navigator ) { private$py_obj <- packages }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(packages) && all(sapply(packages,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SplinePackage")))){ stop("arg packages wrong type") }
        if(!(is_scalar_double(posMin))){ stop("arg posMin wrong type") }
        if(!(is_scalar_double(posMax))){ stop("arg posMax wrong type") }
        if(!(is_scalar_double(scaling))){ stop("arg scaling wrong type") }
        v0 <- r_to_py(packages)
    
    
    
    
        private$py_obj <- Pymod$SplineSpectrum_Navigator(v0, posMin, posMax, scaling)
        invisible()
    }
        
    
    },
    
    # C++ signature: double eval(double pos)
    eval = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$eval(pos)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getNextPos(double pos)
    getNextPos = function(pos){
    
        if(!(is_scalar_double(pos))){ stop("arg pos wrong type") }
    
        py_ans = private$py_obj$getNextPos(pos)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SqMassConfig
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SqMassConfig.html
SqMassConfig <- R6Class(classname = "SqMassConfig",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        write_full_meta = function(write_full_meta){
    
        if(!missing(write_full_meta)){
            if(!( (is_scalar_integer(write_full_meta) || is_scalar_double(write_full_meta)) && write_full_meta == as.integer(write_full_meta))){ stop("arg write_full_meta wrong type") }
        
        
            private$py_obj$write_full_meta <- as.integer(write_full_meta)
            } else {
        
                py_ans = private$py_obj$write_full_meta
                r_result = py_ans
                return(r_result)
                }
        },
        use_lossy_numpress = function(use_lossy_numpress){
    
        if(!missing(use_lossy_numpress)){
            if(!( (is_scalar_integer(use_lossy_numpress) || is_scalar_double(use_lossy_numpress)) && use_lossy_numpress == as.integer(use_lossy_numpress))){ stop("arg use_lossy_numpress wrong type") }
        
        
            private$py_obj$use_lossy_numpress <- as.integer(use_lossy_numpress)
            } else {
        
                py_ans = private$py_obj$use_lossy_numpress
                r_result = py_ans
                return(r_result)
                }
        },
        linear_fp_mass_acc = function(linear_fp_mass_acc){
    
        if(!missing(linear_fp_mass_acc)){
            if(!(is_scalar_double(linear_fp_mass_acc))){ stop("arg linear_fp_mass_acc wrong type") }
        
        
            private$py_obj$linear_fp_mass_acc <- linear_fp_mass_acc
            } else {
        
                py_ans = private$py_obj$linear_fp_mass_acc
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SqMassConfig()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SqMassConfig) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SqMassConfig()
        invisible()
    }
    
    }
)
) 

# R implementation of _SqMassFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SqMassFile.html
SqMassFile <- R6Class(classname = "SqMassFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SqMassFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SqMassFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SqMassFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, MSExperiment & map_)
    load = function(filename, map_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
    
    
        private$py_obj$load(filename, map_)
        invisible()
    },
    
    # C++ signature: void store(const String & filename, MSExperiment & map_)
    store = function(filename, map_){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(map_) && class(map_)[1] == "MSExperiment")){ stop("arg map_ wrong type") }
    
    
        private$py_obj$store(filename, map_)
        invisible()
    },
    
    # C++ signature: void setConfig(SqMassConfig config)
    setConfig = function(config){
    
        if(!(is.R6(config) && class(config)[1] == "SqMassConfig")){ stop("arg config wrong type") }
    
        private$py_obj$setConfig(config)
        invisible()
    }
)
) 

# R implementation of _SqrtMower
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SqrtMower.html
SqrtMower <- R6Class(classname = "SqrtMower",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SqrtMower()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == SqrtMower) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$SqrtMower()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _StablePairFinder
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1StablePairFinder.html
StablePairFinder <- R6Class(classname = "StablePairFinder",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void StablePairFinder()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == StablePairFinder) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$StablePairFinder()
        invisible()
    }
    
    },
    
    # C++ signature: void run(libcpp_vector[ConsensusMap] & input_maps, ConsensusMap & result_map)
    run = function(input_maps, result_map){
    
        if(!(is_list(input_maps) && all(sapply(input_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ConsensusMap")))){ stop("arg input_maps wrong type") }
        if(!(is.R6(result_map) && class(result_map)[1] == "ConsensusMap")){ stop("arg result_map wrong type") }
        v0 <- r_to_py(input_maps)
    
        private$py_obj$run(v0, result_map)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(input_maps <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _String
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1String.html
String <- R6Class(classname = "String",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void String()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == "String") { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$String()
        invisible()
    }
    
    }
)
) 

# R implementation of _StringDataArray
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::DataArrays_1_1StringDataArray.html

# The representation of extra string data attached to a spectrum or chromatogram.
StringDataArray <- R6Class(classname = "StringDataArray",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void StringDataArray()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == StringDataArray) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$StringDataArray()
        invisible()
    }
    
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void resize(size_t n)
    resize = function(n){
    
        if(!( (is_scalar_integer(n) || is_scalar_double(n)) && n == as.integer(n))){ stop("arg n wrong type") }
    
        private$py_obj$resize(as.integer(n))
        invisible()
    },
    
    # C++ signature: void clear()
    clear = function(){
    
        private$py_obj$clear()
        invisible()
    },
    
    # C++ signature: void push_back(String)
    push_back = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$push_back(in_0)
        invisible()
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(String name)
    setName = function(name){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
    
        private$py_obj$setName(name)
        invisible()
    },
    
    # C++ signature: libcpp_vector[shared_ptr[DataProcessing]] getDataProcessing()
    getDataProcessing = function(){
    
        py_ans = private$py_obj$getDataProcessing()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(DataProcessing,"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataProcessing(libcpp_vector[shared_ptr[DataProcessing]])
    setDataProcessing = function(in_0){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) all(class(elemt_rec) == c('DataProcessing','R6')))))){ stop("arg in_0 wrong type") }
        v0 <- r_to_py(in_0)
        private$py_obj$setDataProcessing(v0)
        
        invisible()
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _StringView
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1StringView.html
StringView <- R6Class(classname = "StringView",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void StringView()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$StringView()
        invisible()
    
    
    },
    
    # C++ signature: void StringView(const String & s)
    init_1 = function(s){
    
        if(!((is.R6(s) && class(s)[1]=="String") || is_scalar_character(s))){ stop("arg s wrong type") }
    
    
        private$py_obj <- Pymod$StringView(s)
        invisible()
    
    
    },
    
    # C++ signature: void StringView(StringView)
    init_2 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "StringView")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$StringView(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void StringView()
    # C++ signature: void StringView(const String & s)
    # C++ signature: void StringView(StringView)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$init_1(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "StringView")) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "StringView" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: StringView substr(size_t start, size_t end)
    substr = function(start, end){
    
        if(!( (is_scalar_integer(start) || is_scalar_double(start)) && start == as.integer(start))){ stop("arg start wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
    
    
        py_ans = private$py_obj$substr(as.integer(start), as.integer(end))
        r_ans = StringView$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getString()
    getString = function(){
    
        py_ans = private$py_obj$getString()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _SvmModelParameterSet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SvmModelParameterSet.html
SvmModelParameterSet <- R6Class(classname = "SvmModelParameterSet",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        number_intensity_levels = function(number_intensity_levels){
    
        if(!missing(number_intensity_levels)){
            if(!( (is_scalar_integer(number_intensity_levels) || is_scalar_double(number_intensity_levels)) && number_intensity_levels == as.integer(number_intensity_levels))){ stop("arg number_intensity_levels wrong type") }
        
        
            private$py_obj$number_intensity_levels <- as.integer(number_intensity_levels)
            } else {
        
                py_ans = private$py_obj$number_intensity_levels
                r_result = py_ans
                return(r_result)
                }
        },
        number_regions = function(number_regions){
    
        if(!missing(number_regions)){
            if(!( (is_scalar_integer(number_regions) || is_scalar_double(number_regions)) && number_regions == as.integer(number_regions))){ stop("arg number_regions wrong type") }
        
        
            private$py_obj$number_regions <- as.integer(number_regions)
            } else {
        
                py_ans = private$py_obj$number_regions
                r_result = py_ans
                return(r_result)
                }
        },
        feature_max = function(feature_max){
    
        if(!missing(feature_max)){
            if(!(is_list(feature_max) && all(sapply(feature_max,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg feature_max wrong type") }
        
            v0 <- r_to_py(feature_max)
            private$py_obj$feature_max <- v0
            } else {
            
                py_ans = private$py_obj$feature_max
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        feature_min = function(feature_min){
    
        if(!missing(feature_min)){
            if(!(is_list(feature_min) && all(sapply(feature_min,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg feature_min wrong type") }
        
            v0 <- r_to_py(feature_min)
            private$py_obj$feature_min <- v0
            } else {
            
                py_ans = private$py_obj$feature_min
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        scaling_lower = function(scaling_lower){
    
        if(!missing(scaling_lower)){
            if(!(is_scalar_double(scaling_lower))){ stop("arg scaling_lower wrong type") }
        
        
            private$py_obj$scaling_lower <- scaling_lower
            } else {
        
                py_ans = private$py_obj$scaling_lower
                r_result = py_ans
                return(r_result)
                }
        },
        scaling_upper = function(scaling_upper){
    
        if(!missing(scaling_upper)){
            if(!(is_scalar_double(scaling_upper))){ stop("arg scaling_upper wrong type") }
        
        
            private$py_obj$scaling_upper <- scaling_upper
            } else {
        
                py_ans = private$py_obj$scaling_upper
                r_result = py_ans
                return(r_result)
                }
        },
        intensity_bin_boarders = function(intensity_bin_boarders){
    
        if(!missing(intensity_bin_boarders)){
            if(!(is_list(intensity_bin_boarders) && all(sapply(intensity_bin_boarders,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity_bin_boarders wrong type") }
        
            v0 <- r_to_py(intensity_bin_boarders)
            private$py_obj$intensity_bin_boarders <- v0
            } else {
            
                py_ans = private$py_obj$intensity_bin_boarders
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        intensity_bin_values = function(intensity_bin_values){
    
        if(!missing(intensity_bin_values)){
            if(!(is_list(intensity_bin_values) && all(sapply(intensity_bin_values,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity_bin_values wrong type") }
        
            v0 <- r_to_py(intensity_bin_values)
            private$py_obj$intensity_bin_values <- v0
            } else {
            
                py_ans = private$py_obj$intensity_bin_values
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    )
) 

# R implementation of _SvmTheoreticalSpectrumGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SvmTheoreticalSpectrumGenerator.html
SvmTheoreticalSpectrumGenerator <- R6Class(classname = "SvmTheoreticalSpectrumGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SvmTheoreticalSpectrumGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGenerator(SvmTheoreticalSpectrumGenerator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SvmTheoreticalSpectrumGenerator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGenerator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGenerator()
    # C++ signature: void SvmTheoreticalSpectrumGenerator(SvmTheoreticalSpectrumGenerator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SvmTheoreticalSpectrumGenerator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SvmTheoreticalSpectrumGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load()
    load = function(){
    
        private$py_obj$load()
        invisible()
    },
    
    # C++ signature: libcpp_vector[IonType] getIonTypes()
    getIonTypes = function(){
    
        py_ans = private$py_obj$getIonTypes()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    }
)
) 

# R implementation of _SvmTheoreticalSpectrumGeneratorSet
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SvmTheoreticalSpectrumGeneratorSet.html
SvmTheoreticalSpectrumGeneratorSet <- R6Class(classname = "SvmTheoreticalSpectrumGeneratorSet",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorSet()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGeneratorSet()
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorSet(SvmTheoreticalSpectrumGeneratorSet)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SvmTheoreticalSpectrumGeneratorSet")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGeneratorSet(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorSet()
    # C++ signature: void SvmTheoreticalSpectrumGeneratorSet(SvmTheoreticalSpectrumGeneratorSet)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SvmTheoreticalSpectrumGeneratorSet")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SvmTheoreticalSpectrumGeneratorSet" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(String)
    load = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$load(in_0)
        invisible()
    },
    
    # C++ signature: void getSupportedCharges(libcpp_set[size_t] & charges)
    getSupportedCharges = function(charges){
    
        if(!(is_list(charges) && all(sapply(charges,function(el)  (is_scalar_integer(el) || is_scalar_double(el)) && el == as.integer(el))) && !(TRUE %in% duplicated(charges)))){ stop("arg charges wrong type") }
        py$v0 <- charges
        py_run_string("v0 = [int(t) for t in v0];v0 = set(v0)")
        private$py_obj$getSupportedCharges(py$v0)
        byref_0 <- as.list(py_eval("list(v0)"))
        py_run_string("del v0; gc.collect()")
    
        tryCatch({
        eval.parent(substitute(charges <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: SvmTheoreticalSpectrumGenerator getSvmModel(size_t)
    getSvmModel = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getSvmModel(as.integer(in_0))
        r_ans = SvmTheoreticalSpectrumGenerator$new(py_ans)
        return(r_ans)
    }
)
) 

# R implementation of _SvmTheoreticalSpectrumGeneratorTrainer
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SvmTheoreticalSpectrumGeneratorTrainer.html
SvmTheoreticalSpectrumGeneratorTrainer <- R6Class(classname = "SvmTheoreticalSpectrumGeneratorTrainer",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorTrainer()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGeneratorTrainer()
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorTrainer(SvmTheoreticalSpectrumGeneratorTrainer)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SvmTheoreticalSpectrumGeneratorTrainer")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SvmTheoreticalSpectrumGeneratorTrainer(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SvmTheoreticalSpectrumGeneratorTrainer()
    # C++ signature: void SvmTheoreticalSpectrumGeneratorTrainer(SvmTheoreticalSpectrumGeneratorTrainer)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SvmTheoreticalSpectrumGeneratorTrainer")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SvmTheoreticalSpectrumGeneratorTrainer" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void trainModel(MSExperiment & spectra, libcpp_vector[AASequence] & annotations, String filename, int precursor_charge)
    trainModel = function(spectra, annotations, filename, precursor_charge){
    
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
        if(!(is_list(annotations) && all(sapply(annotations,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "AASequence")))){ stop("arg annotations wrong type") }
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(precursor_charge) || is_scalar_double(precursor_charge)) && precursor_charge == as.integer(precursor_charge))){ stop("arg precursor_charge wrong type") }
    
        v1 <- r_to_py(annotations)
    
    
        private$py_obj$trainModel(spectra, v1, filename, as.integer(precursor_charge))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(annotations <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void normalizeIntensity(MSSpectrum & S)
    normalizeIntensity = function(S){
    
        if(!(is.R6(S) && class(S)[1] == "MSSpectrum")){ stop("arg S wrong type") }
    
        private$py_obj$normalizeIntensity(S)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _SwathFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SwathFile.html
SwathFile <- R6Class(classname = "SwathFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: libcpp_vector[SwathMap] loadSplit(StringList file_list, String tmp, shared_ptr[ExperimentalSettings] exp_meta, String readoptions)
    loadSplit = function(file_list, tmp, exp_meta, readoptions){
    
        if(!(is_list(file_list) && all(sapply(file_list),is_scalar_character))){ stop("arg file_list wrong type") }
        if(!((is.R6(tmp) && class(tmp)[1]=="String") || is_scalar_character(tmp))){ stop("arg tmp wrong type") }
        if(!(all(class(exp_meta) == c('ExperimentalSettings','R6')))){ stop("arg exp_meta wrong type") }
        if(!((is.R6(readoptions) && class(readoptions)[1]=="String") || is_scalar_character(readoptions))){ stop("arg readoptions wrong type") }
        v0 = r_to_py(modify_depth(file_list,1,py_builtin$bytes(file_list,'utf-8')))
    
        input_exp_meta <- r_to_py(exp_meta)
    
        py_ans = private$py_obj$loadSplit(v0, tmp, input_exp_meta, readoptions)
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[SwathMap] loadMzML(String file_, String tmp, shared_ptr[ExperimentalSettings] exp_meta, String readoptions)
    loadMzML = function(file_, tmp, exp_meta, readoptions){
    
        if(!((is.R6(file_) && class(file_)[1]=="String") || is_scalar_character(file_))){ stop("arg file_ wrong type") }
        if(!((is.R6(tmp) && class(tmp)[1]=="String") || is_scalar_character(tmp))){ stop("arg tmp wrong type") }
        if(!(all(class(exp_meta) == c('ExperimentalSettings','R6')))){ stop("arg exp_meta wrong type") }
        if(!((is.R6(readoptions) && class(readoptions)[1]=="String") || is_scalar_character(readoptions))){ stop("arg readoptions wrong type") }
    
    
        input_exp_meta <- r_to_py(exp_meta)
    
        py_ans = private$py_obj$loadMzML(file_, tmp, input_exp_meta, readoptions)
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[SwathMap] loadMzXML(String file_, String tmp, shared_ptr[ExperimentalSettings] exp_meta, String readoptions)
    loadMzXML = function(file_, tmp, exp_meta, readoptions){
    
        if(!((is.R6(file_) && class(file_)[1]=="String") || is_scalar_character(file_))){ stop("arg file_ wrong type") }
        if(!((is.R6(tmp) && class(tmp)[1]=="String") || is_scalar_character(tmp))){ stop("arg tmp wrong type") }
        if(!(all(class(exp_meta) == c('ExperimentalSettings','R6')))){ stop("arg exp_meta wrong type") }
        if(!((is.R6(readoptions) && class(readoptions)[1]=="String") || is_scalar_character(readoptions))){ stop("arg readoptions wrong type") }
    
    
        input_exp_meta <- r_to_py(exp_meta)
    
        py_ans = private$py_obj$loadMzXML(file_, tmp, input_exp_meta, readoptions)
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _SwathMap
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenSwath_1_1SwathMap.html
SwathMap <- R6Class(classname = "SwathMap",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        lower = function(lower){
    
        if(!missing(lower)){
            if(!(is_scalar_double(lower))){ stop("arg lower wrong type") }
        
        
            private$py_obj$lower <- lower
            } else {
        
                py_ans = private$py_obj$lower
                r_result = py_ans
                return(r_result)
                }
        },
        upper = function(upper){
    
        if(!missing(upper)){
            if(!(is_scalar_double(upper))){ stop("arg upper wrong type") }
        
        
            private$py_obj$upper <- upper
            } else {
        
                py_ans = private$py_obj$upper
                r_result = py_ans
                return(r_result)
                }
        },
        center = function(center){
    
        if(!missing(center)){
            if(!(is_scalar_double(center))){ stop("arg center wrong type") }
        
        
            private$py_obj$center <- center
            } else {
        
                py_ans = private$py_obj$center
                r_result = py_ans
                return(r_result)
                }
        },
        ms1 = function(ms1){
    
        if(!missing(ms1)){
            if(!( (is_scalar_integer(ms1) || is_scalar_double(ms1)) && ms1 == as.integer(ms1))){ stop("arg ms1 wrong type") }
        
        
            private$py_obj$ms1 <- as.integer(ms1)
            } else {
        
                py_ans = private$py_obj$ms1
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void SwathMap()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SwathMap()
        invisible()
    
    
    },
    
    # C++ signature: void SwathMap(SwathMap)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SwathMap")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SwathMap(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SwathMap()
    # C++ signature: void SwathMap(SwathMap)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SwathMap")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SwathMap" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _SwathMapMassCorrection
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SwathMapMassCorrection.html
SwathMapMassCorrection <- R6Class(classname = "SwathMapMassCorrection",cloneable = FALSE,

    private = list(py_obj = NA)

) 

# R implementation of _SwathWindowLoader
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1SwathWindowLoader.html
SwathWindowLoader <- R6Class(classname = "SwathWindowLoader",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void SwathWindowLoader()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$SwathWindowLoader()
        invisible()
    
    
    },
    
    # C++ signature: void SwathWindowLoader(SwathWindowLoader)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "SwathWindowLoader")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$SwathWindowLoader(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void SwathWindowLoader()
    # C++ signature: void SwathWindowLoader(SwathWindowLoader)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "SwathWindowLoader")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "SwathWindowLoader" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void annotateSwathMapsFromFile(String filename, libcpp_vector[SwathMap] & swath_maps, bool do_sort, bool force)
    annotateSwathMapsFromFile = function(filename, swath_maps, do_sort, force){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(swath_maps) && all(sapply(swath_maps,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SwathMap")))){ stop("arg swath_maps wrong type") }
        if(!( (is_scalar_integer(do_sort) || is_scalar_double(do_sort)) && do_sort == as.integer(do_sort))){ stop("arg do_sort wrong type") }
        if(!( (is_scalar_integer(force) || is_scalar_double(force)) && force == as.integer(force))){ stop("arg force wrong type") }
    
        v1 <- r_to_py(swath_maps)
    
    
        private$py_obj$annotateSwathMapsFromFile(filename, v1, as.integer(do_sort), as.integer(force))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(swath_maps <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void readSwathWindows(String filename, libcpp_vector[double] & swath_prec_lower, libcpp_vector[double] & swath_prec_upper)
    readSwathWindows = function(filename, swath_prec_lower, swath_prec_upper){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(swath_prec_lower) && all(sapply(swath_prec_lower,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg swath_prec_lower wrong type") }
        if(!(is_list(swath_prec_upper) && all(sapply(swath_prec_upper,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg swath_prec_upper wrong type") }
    
        v1 <- r_to_py(swath_prec_lower)
        v2 <- r_to_py(swath_prec_upper)
        private$py_obj$readSwathWindows(filename, v1, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
        byref_1 <- map_depth(py_to_r(v1),0,as.list)
    
        tryCatch({
        eval.parent(substitute(swath_prec_lower <- byref_1))
        eval.parent(substitute(swath_prec_upper <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _TICFilter
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TICFilter.html
TICFilter <- R6Class(classname = "TICFilter",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TICFilter()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TICFilter()
        invisible()
    
    
    },
    
    # C++ signature: void TICFilter(TICFilter)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TICFilter")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TICFilter(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TICFilter()
    # C++ signature: void TICFilter(TICFilter)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TICFilter")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TICFilter" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double apply(MSSpectrum &)
    apply = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: String getProductName()
    getProductName = function(){
    
        py_ans = private$py_obj$getProductName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void registerChildren()
    registerChildren = function(){
    
        private$py_obj$registerChildren()
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TMTElevenPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TMTElevenPlexQuantitationMethod.html
TMTElevenPlexQuantitationMethod <- R6Class(classname = "TMTElevenPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TMTElevenPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TMTElevenPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void TMTElevenPlexQuantitationMethod(TMTElevenPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TMTElevenPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TMTElevenPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TMTElevenPlexQuantitationMethod()
    # C++ signature: void TMTElevenPlexQuantitationMethod(TMTElevenPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTElevenPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TMTElevenPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TMTSixPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TMTSixPlexQuantitationMethod.html
TMTSixPlexQuantitationMethod <- R6Class(classname = "TMTSixPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TMTSixPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TMTSixPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void TMTSixPlexQuantitationMethod(TMTSixPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TMTSixPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TMTSixPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TMTSixPlexQuantitationMethod()
    # C++ signature: void TMTSixPlexQuantitationMethod(TMTSixPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTSixPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TMTSixPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TMTSixteenPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TMTSixteenPlexQuantitationMethod.html
TMTSixteenPlexQuantitationMethod <- R6Class(classname = "TMTSixteenPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TMTSixteenPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TMTSixteenPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void TMTSixteenPlexQuantitationMethod(TMTSixteenPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TMTSixteenPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TMTSixteenPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TMTSixteenPlexQuantitationMethod()
    # C++ signature: void TMTSixteenPlexQuantitationMethod(TMTSixteenPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTSixteenPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TMTSixteenPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TMTTenPlexQuantitationMethod
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TMTTenPlexQuantitationMethod.html
TMTTenPlexQuantitationMethod <- R6Class(classname = "TMTTenPlexQuantitationMethod",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TMTTenPlexQuantitationMethod()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TMTTenPlexQuantitationMethod()
        invisible()
    
    
    },
    
    # C++ signature: void TMTTenPlexQuantitationMethod(TMTTenPlexQuantitationMethod)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TMTTenPlexQuantitationMethod")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TMTTenPlexQuantitationMethod(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TMTTenPlexQuantitationMethod()
    # C++ signature: void TMTTenPlexQuantitationMethod(TMTTenPlexQuantitationMethod)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TMTTenPlexQuantitationMethod")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TMTTenPlexQuantitationMethod" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[IsobaricChannelInformation] getChannelInformation()
    getChannelInformation = function(){
    
        py_ans = private$py_obj$getChannelInformation()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: size_t getNumberOfChannels()
    getNumberOfChannels = function(){
    
        py_ans = private$py_obj$getNumberOfChannels()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: MatrixDouble getIsotopeCorrectionMatrix()
    getIsotopeCorrectionMatrix = function(){
    
        py_ans = private$py_obj$getIsotopeCorrectionMatrix()
        r_ans = MatrixDouble$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: size_t getReferenceChannel()
    getReferenceChannel = function(){
    
        py_ans = private$py_obj$getReferenceChannel()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TM_DataPoint
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TM_DataPoint.html
TM_DataPoint <- R6Class(classname = "TM_DataPoint",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        first = function(first){
    
        if(!missing(first)){
            if(!(is_scalar_double(first))){ stop("arg first wrong type") }
        
        
            private$py_obj$first <- first
            } else {
        
                py_ans = private$py_obj$first
                r_result = py_ans
                return(r_result)
                }
        },
        second = function(second){
    
        if(!missing(second)){
            if(!(is_scalar_double(second))){ stop("arg second wrong type") }
        
        
            private$py_obj$second <- second
            } else {
        
                py_ans = private$py_obj$second
                r_result = py_ans
                return(r_result)
                }
        },
        note = function(note){
    
        if(!missing(note)){
            if(!((is.R6(note) && class(note)[1]=="String") || is_scalar_character(note))){ stop("arg note wrong type") }
        
        
            private$py_obj$note <- note
            } else {
        
                py_ans = private$py_obj$note
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TM_DataPoint()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TM_DataPoint()
        invisible()
    
    
    },
    
    # C++ signature: void TM_DataPoint(double, double)
    init_1 = function(in_0, in_1){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
    
    
    
        private$py_obj <- Pymod$TM_DataPoint(in_0, in_1)
        invisible()
    
    
    },
    
    # C++ signature: void TM_DataPoint(double, double, const String &)
    init_2 = function(in_0, in_1, in_2){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
        if(!(is_scalar_double(in_1))){ stop("arg in_1 wrong type") }
        if(!((is.R6(in_2) && class(in_2)[1]=="String") || is_scalar_character(in_2))){ stop("arg in_2 wrong type") }
    
    
    
    
        private$py_obj <- Pymod$TM_DataPoint(in_0, in_1, in_2)
        invisible()
    
    
    },
    
    # C++ signature: void TM_DataPoint()
    # C++ signature: void TM_DataPoint(double, double)
    # C++ signature: void TM_DataPoint(double, double, const String &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==2) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]]))) { self$init_1(...) }
        else if ((length(arg_list)==3) && (is_scalar_double(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TM_DataPoint" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _TOFCalibration
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TOFCalibration.html
TOFCalibration <- R6Class(classname = "TOFCalibration",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TOFCalibration()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TOFCalibration) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TOFCalibration()
        invisible()
    }
    
    },
    
    # C++ signature: void calibrate(MSExperiment & input, MSExperiment & output, libcpp_vector[double] & exp_masses)
    calibrate = function(input, output, exp_masses){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
        if(!(is_list(exp_masses) && all(sapply(exp_masses,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg exp_masses wrong type") }
    
    
        v2 <- r_to_py(exp_masses)
        private$py_obj$calibrate(input, output, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
    
        tryCatch({
        eval.parent(substitute(exp_masses <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void pickAndCalibrate(MSExperiment & input, MSExperiment & output, libcpp_vector[double] & exp_masses)
    pickAndCalibrate = function(input, output, exp_masses){
    
        if(!(is.R6(input) && class(input)[1] == "MSExperiment")){ stop("arg input wrong type") }
        if(!(is.R6(output) && class(output)[1] == "MSExperiment")){ stop("arg output wrong type") }
        if(!(is_list(exp_masses) && all(sapply(exp_masses,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg exp_masses wrong type") }
    
    
        v2 <- r_to_py(exp_masses)
        private$py_obj$pickAndCalibrate(input, output, v2)
        byref_2 <- map_depth(py_to_r(v2),0,as.list)
    
        tryCatch({
        eval.parent(substitute(exp_masses <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] getML1s()
    getML1s = function(){
    
        py_ans = private$py_obj$getML1s()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setML1s(libcpp_vector[double] & ml1s)
    setML1s = function(ml1s){
    
        if(!(is_list(ml1s) && all(sapply(ml1s,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg ml1s wrong type") }
        v0 <- r_to_py(ml1s)
        private$py_obj$setML1s(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(ml1s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] getML2s()
    getML2s = function(){
    
        py_ans = private$py_obj$getML2s()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setML2s(libcpp_vector[double] & ml2s)
    setML2s = function(ml2s){
    
        if(!(is_list(ml2s) && all(sapply(ml2s,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg ml2s wrong type") }
        v0 <- r_to_py(ml2s)
        private$py_obj$setML2s(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(ml2s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] getML3s()
    getML3s = function(){
    
        py_ans = private$py_obj$getML3s()
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: void setML3s(libcpp_vector[double] & ml3s)
    setML3s = function(ml3s){
    
        if(!(is_list(ml3s) && all(sapply(ml3s,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg ml3s wrong type") }
        v0 <- r_to_py(ml3s)
        private$py_obj$setML3s(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(ml3s <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _TSE_Match
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TSE_Match.html
TSE_Match <- R6Class(classname = "TSE_Match",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        spectrum = function(spectrum){
    
        if(!missing(spectrum)){
            if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        
        
            private$py_obj$spectrum <- spectrum
            } else {
        
                py_ans = private$py_obj$spectrum
            r_result = MSSpectrum$new(py_ans)
                return(r_result)
                }
        },
        score = function(score){
    
        if(!missing(score)){
            if(!(is_scalar_double(score))){ stop("arg score wrong type") }
        
        
            private$py_obj$score <- score
            } else {
        
                py_ans = private$py_obj$score
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TSE_Match()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TSE_Match()
        invisible()
    
    
    },
    
    # C++ signature: void TSE_Match(TSE_Match)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TSE_Match")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TSE_Match(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TSE_Match(MSSpectrum & spectrum, double score)
    init_2 = function(spectrum, score){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is_scalar_double(score))){ stop("arg score wrong type") }
    
    
    
        private$py_obj <- Pymod$TSE_Match(spectrum, score)
        invisible()
    
    
    },
    
    # C++ signature: void TSE_Match()
    # C++ signature: void TSE_Match(TSE_Match)
    # C++ signature: void TSE_Match(MSSpectrum & spectrum, double score)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TSE_Match")) { self$init_1(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is_scalar_double(arg_list[[2]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TSE_Match" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _Tagger
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Tagger.html
Tagger <- R6Class(classname = "Tagger",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Tagger(Tagger)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Tagger")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Tagger(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Tagger(size_t min_tag_length, double ppm, size_t max_tag_length, size_t min_charge, size_t max_charge, const StringList & fixed_mods, const StringList & var_mods)
    init_1 = function(min_tag_length, ppm, max_tag_length, min_charge, max_charge, fixed_mods, var_mods){
    
        if(!( (is_scalar_integer(min_tag_length) || is_scalar_double(min_tag_length)) && min_tag_length == as.integer(min_tag_length))){ stop("arg min_tag_length wrong type") }
        if(!(is_scalar_double(ppm))){ stop("arg ppm wrong type") }
        if(!( (is_scalar_integer(max_tag_length) || is_scalar_double(max_tag_length)) && max_tag_length == as.integer(max_tag_length))){ stop("arg max_tag_length wrong type") }
        if(!( (is_scalar_integer(min_charge) || is_scalar_double(min_charge)) && min_charge == as.integer(min_charge))){ stop("arg min_charge wrong type") }
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
        if(!(is_list(fixed_mods) && all(sapply(fixed_mods),is_scalar_character))){ stop("arg fixed_mods wrong type") }
        if(!(is_list(var_mods) && all(sapply(var_mods),is_scalar_character))){ stop("arg var_mods wrong type") }
    
    
    
    
    
        v5 = r_to_py(modify_depth(fixed_mods,1,py_builtin$bytes(fixed_mods,'utf-8')))
        v6 = r_to_py(modify_depth(var_mods,1,py_builtin$bytes(var_mods,'utf-8')))
    
        private$py_obj <- Pymod$Tagger(as.integer(min_tag_length), ppm, as.integer(max_tag_length), as.integer(min_charge), as.integer(max_charge), v5, v6)
        invisible()
    
        byref_6 <- modify_depth(py_to_r(v6),1,as.character)
        byref_5 <- modify_depth(py_to_r(v5),1,as.character)
    
    },
    
    # C++ signature: void Tagger(Tagger)
    # C++ signature: void Tagger(size_t min_tag_length, double ppm, size_t max_tag_length, size_t min_charge, size_t max_charge, const StringList & fixed_mods, const StringList & var_mods)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Tagger")) { self$init_0(...) }
        else if ((length(arg_list)==7) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is_scalar_double(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && (is_list(arg_list[[6]]) && all(sapply(arg_list[[6]]),is_scalar_character)) && (is_list(arg_list[[7]]) && all(sapply(arg_list[[7]]),is_scalar_character))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Tagger" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getTag(const libcpp_vector[double] & mzs, libcpp_vector[libcpp_string] & tags)
    getTag_0 = function(mzs, tags){
    
        if(!(is_list(mzs) && all(sapply(mzs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg mzs wrong type") }
        if(!(is_list(tags) && all(sapply(tags,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg tags wrong type") }
        v0 <- r_to_py(mzs)
        v1 <- r_to_py(modify_depth(tags,1, function(a) py_builtin$bytes(a, 'utf-8')))
        private$py_obj$`_getTag_0`(v0, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        
    
        tryCatch({
        eval.parent(substitute(tags <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getTag(const MSSpectrum & spec, libcpp_vector[libcpp_string] & tags)
    getTag_1 = function(spec, tags){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is_list(tags) && all(sapply(tags,function(elemt_rec) is_scalar_character(elemt_rec))))){ stop("arg tags wrong type") }
    
        v1 <- r_to_py(modify_depth(tags,1, function(a) py_builtin$bytes(a, 'utf-8')))
        private$py_obj$`_getTag_1`(spec, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
    
        tryCatch({
        eval.parent(substitute(tags <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getTag(const libcpp_vector[double] & mzs, libcpp_vector[libcpp_string] & tags)
    # C++ signature: void getTag(const MSSpectrum & spec, libcpp_vector[libcpp_string] & tags)
    getTag = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_scalar_double(elemt_rec)))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_character(elemt_rec))))) { self$getTag_0(...) }
        else if ((length(arg_list)==2) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is_scalar_character(elemt_rec))))) { self$getTag_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setMaxCharge(size_t max_charge)
    setMaxCharge = function(max_charge){
    
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
    
        private$py_obj$setMaxCharge(as.integer(max_charge))
        invisible()
    }
)
) 

# R implementation of _Tagging
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Tagging.html
Tagging <- R6Class(classname = "Tagging",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void Tagging()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Tagging()
        invisible()
    
    
    },
    
    # C++ signature: void Tagging(Tagging)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Tagging")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Tagging(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Tagging()
    # C++ signature: void Tagging(Tagging)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Tagging")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Tagging" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMassShift()
    getMassShift = function(){
    
        py_ans = private$py_obj$getMassShift()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMassShift(double mass_shift)
    setMassShift = function(mass_shift){
    
        if(!(is_scalar_double(mass_shift))){ stop("arg mass_shift wrong type") }
    
        private$py_obj$setMassShift(mass_shift)
        invisible()
    },
    
    # C++ signature: IsotopeVariant getVariant()
    getVariant = function(){
    
        py_ans = private$py_obj$getVariant()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setVariant(IsotopeVariant variant)
    setVariant = function(variant){
    
        if(!(variant %in% c(0, 1, 2))){ stop("arg variant wrong type") }
    
        private$py_obj$setVariant(as.integer(variant))
        invisible()
    }
)
) 

# R implementation of _TargetedExperiment
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TargetedExperiment.html
TargetedExperiment <- R6Class(classname = "TargetedExperiment",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TargetedExperiment()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TargetedExperiment()
        invisible()
    
    
    },
    
    # C++ signature: void TargetedExperiment(TargetedExperiment &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TargetedExperiment")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TargetedExperiment(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TargetedExperiment()
    # C++ signature: void TargetedExperiment(TargetedExperiment &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TargetedExperiment")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TargetedExperiment" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void clear(bool clear_meta_data)
    clear = function(clear_meta_data){
    
        if(!( (is_scalar_integer(clear_meta_data) || is_scalar_double(clear_meta_data)) && clear_meta_data == as.integer(clear_meta_data))){ stop("arg clear_meta_data wrong type") }
    
        private$py_obj$clear(as.integer(clear_meta_data))
        invisible()
    },
    
    # C++ signature: void sortTransitionsByProductMZ()
    sortTransitionsByProductMZ = function(){
    
        private$py_obj$sortTransitionsByProductMZ()
        invisible()
    },
    
    # C++ signature: void setCVs(libcpp_vector[CV] cvs)
    setCVs = function(cvs){
    
        if(!(is_list(cvs) && all(sapply(cvs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CV")))){ stop("arg cvs wrong type") }
        v0 <- r_to_py(cvs)
        private$py_obj$setCVs(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[CV] getCVs()
    getCVs = function(){
    
        py_ans = private$py_obj$getCVs()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addCV(CV cv)
    addCV = function(cv){
    
        if(!(is.R6(cv) && class(cv)[1] == "CV")){ stop("arg cv wrong type") }
    
        private$py_obj$addCV(cv)
        invisible()
    },
    
    # C++ signature: void setContacts(libcpp_vector[Contact] contacts)
    setContacts = function(contacts){
    
        if(!(is_list(contacts) && all(sapply(contacts,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Contact")))){ stop("arg contacts wrong type") }
        v0 <- r_to_py(contacts)
        private$py_obj$setContacts(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Contact] getContacts()
    getContacts = function(){
    
        py_ans = private$py_obj$getContacts()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addContact(Contact contact)
    addContact = function(contact){
    
        if(!(is.R6(contact) && class(contact)[1] == "Contact")){ stop("arg contact wrong type") }
    
        private$py_obj$addContact(contact)
        invisible()
    },
    
    # C++ signature: void setPublications(libcpp_vector[Publication] publications)
    setPublications = function(publications){
    
        if(!(is_list(publications) && all(sapply(publications,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Publication")))){ stop("arg publications wrong type") }
        v0 <- r_to_py(publications)
        private$py_obj$setPublications(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Publication] getPublications()
    getPublications = function(){
    
        py_ans = private$py_obj$getPublications()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addPublication(Publication publication)
    addPublication = function(publication){
    
        if(!(is.R6(publication) && class(publication)[1] == "Publication")){ stop("arg publication wrong type") }
    
        private$py_obj$addPublication(publication)
        invisible()
    },
    
    # C++ signature: void setTargetCVTerms(CVTermList cv_terms)
    setTargetCVTerms = function(cv_terms){
    
        if(!(is.R6(cv_terms) && class(cv_terms)[1] == "CVTermList")){ stop("arg cv_terms wrong type") }
    
        private$py_obj$setTargetCVTerms(cv_terms)
        invisible()
    },
    
    # C++ signature: CVTermList getTargetCVTerms()
    getTargetCVTerms = function(){
    
        py_ans = private$py_obj$getTargetCVTerms()
        r_ans = CVTermList$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addTargetCVTerm(CVTerm cv_term)
    addTargetCVTerm = function(cv_term){
    
        if(!(is.R6(cv_term) && class(cv_term)[1] == "CVTerm")){ stop("arg cv_term wrong type") }
    
        private$py_obj$addTargetCVTerm(cv_term)
        invisible()
    },
    
    # C++ signature: void setTargetMetaValue(String name, DataValue value)
    setTargetMetaValue = function(name, value){
    
        if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        if(!(is.R6(value) && class(value)[1] == "DataValue")){ stop("arg value wrong type") }
    
    
        private$py_obj$setTargetMetaValue(name, value)
        invisible()
    },
    
    # C++ signature: void setInstruments(libcpp_vector[TargetedExperiment_Instrument] instruments)
    setInstruments = function(instruments){
    
        if(!(is_list(instruments) && all(sapply(instruments,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TargetedExperiment_Instrument")))){ stop("arg instruments wrong type") }
        v0 <- r_to_py(instruments)
        private$py_obj$setInstruments(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[TargetedExperiment_Instrument] getInstruments()
    getInstruments = function(){
    
        py_ans = private$py_obj$getInstruments()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addInstrument(TargetedExperiment_Instrument instrument)
    addInstrument = function(instrument){
    
        if(!(is.R6(instrument) && class(instrument)[1] == "TargetedExperiment_Instrument")){ stop("arg instrument wrong type") }
    
        private$py_obj$addInstrument(instrument)
        invisible()
    },
    
    # C++ signature: void setSoftware(libcpp_vector[Software] software)
    setSoftware = function(software){
    
        if(!(is_list(software) && all(sapply(software,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Software")))){ stop("arg software wrong type") }
        v0 <- r_to_py(software)
        private$py_obj$setSoftware(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Software] getSoftware()
    getSoftware = function(){
    
        py_ans = private$py_obj$getSoftware()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addSoftware(Software software)
    addSoftware = function(software){
    
        if(!(is.R6(software) && class(software)[1] == "Software")){ stop("arg software wrong type") }
    
        private$py_obj$addSoftware(software)
        invisible()
    },
    
    # C++ signature: void setProteins(libcpp_vector[Protein] proteins)
    setProteins = function(proteins){
    
        if(!(is_list(proteins) && all(sapply(proteins,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Protein")))){ stop("arg proteins wrong type") }
        v0 <- r_to_py(proteins)
        private$py_obj$setProteins(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Protein] getProteins()
    getProteins = function(){
    
        py_ans = private$py_obj$getProteins()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: Protein getProteinByRef(String ref)
    getProteinByRef = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$getProteinByRef(ref)
        r_ans = Protein$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: bool hasProtein(String ref)
    hasProtein = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$hasProtein(ref)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void addProtein(Protein protein)
    addProtein = function(protein){
    
        if(!(is.R6(protein) && class(protein)[1] == "Protein")){ stop("arg protein wrong type") }
    
        private$py_obj$addProtein(protein)
        invisible()
    },
    
    # C++ signature: void setCompounds(libcpp_vector[Compound] rhs)
    setCompounds = function(rhs){
    
        if(!(is_list(rhs) && all(sapply(rhs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Compound")))){ stop("arg rhs wrong type") }
        v0 <- r_to_py(rhs)
        private$py_obj$setCompounds(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Compound] getCompounds()
    getCompounds = function(){
    
        py_ans = private$py_obj$getCompounds()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addCompound(Compound rhs)
    addCompound = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "Compound")){ stop("arg rhs wrong type") }
    
        private$py_obj$addCompound(rhs)
        invisible()
    },
    
    # C++ signature: bool hasCompound(String ref)
    hasCompound = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$hasCompound(ref)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Compound getCompoundByRef(String ref)
    getCompoundByRef = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$getCompoundByRef(ref)
        r_ans = Compound$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setPeptides(libcpp_vector[Peptide] rhs)
    setPeptides = function(rhs){
    
        if(!(is_list(rhs) && all(sapply(rhs,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "Peptide")))){ stop("arg rhs wrong type") }
        v0 <- r_to_py(rhs)
        private$py_obj$setPeptides(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[Peptide] getPeptides()
    getPeptides = function(){
    
        py_ans = private$py_obj$getPeptides()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: bool hasPeptide(String ref)
    hasPeptide = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$hasPeptide(ref)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Peptide getPeptideByRef(String ref)
    getPeptideByRef = function(ref){
    
        if(!((is.R6(ref) && class(ref)[1]=="String") || is_scalar_character(ref))){ stop("arg ref wrong type") }
    
        py_ans = private$py_obj$getPeptideByRef(ref)
        r_ans = Peptide$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void addPeptide(Peptide rhs)
    addPeptide = function(rhs){
    
        if(!(is.R6(rhs) && class(rhs)[1] == "Peptide")){ stop("arg rhs wrong type") }
    
        private$py_obj$addPeptide(rhs)
        invisible()
    },
    
    # C++ signature: void setTransitions(libcpp_vector[ReactionMonitoringTransition] transitions)
    setTransitions = function(transitions){
    
        if(!(is_list(transitions) && all(sapply(transitions,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ReactionMonitoringTransition")))){ stop("arg transitions wrong type") }
        v0 <- r_to_py(transitions)
        private$py_obj$setTransitions(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[ReactionMonitoringTransition] getTransitions()
    getTransitions = function(){
    
        py_ans = private$py_obj$getTransitions()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addTransition(ReactionMonitoringTransition transition)
    addTransition = function(transition){
    
        if(!(is.R6(transition) && class(transition)[1] == "ReactionMonitoringTransition")){ stop("arg transition wrong type") }
    
        private$py_obj$addTransition(transition)
        invisible()
    },
    
    # C++ signature: void setIncludeTargets(libcpp_vector[IncludeExcludeTarget] targets)
    setIncludeTargets = function(targets){
    
        if(!(is_list(targets) && all(sapply(targets,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IncludeExcludeTarget")))){ stop("arg targets wrong type") }
        v0 <- r_to_py(targets)
        private$py_obj$setIncludeTargets(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[IncludeExcludeTarget] getIncludeTargets()
    getIncludeTargets = function(){
    
        py_ans = private$py_obj$getIncludeTargets()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addIncludeTarget(IncludeExcludeTarget target)
    addIncludeTarget = function(target){
    
        if(!(is.R6(target) && class(target)[1] == "IncludeExcludeTarget")){ stop("arg target wrong type") }
    
        private$py_obj$addIncludeTarget(target)
        invisible()
    },
    
    # C++ signature: void setExcludeTargets(libcpp_vector[IncludeExcludeTarget] targets)
    setExcludeTargets = function(targets){
    
        if(!(is_list(targets) && all(sapply(targets,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "IncludeExcludeTarget")))){ stop("arg targets wrong type") }
        v0 <- r_to_py(targets)
        private$py_obj$setExcludeTargets(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[IncludeExcludeTarget] getExcludeTargets()
    getExcludeTargets = function(){
    
        py_ans = private$py_obj$getExcludeTargets()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addExcludeTarget(IncludeExcludeTarget target)
    addExcludeTarget = function(target){
    
        if(!(is.R6(target) && class(target)[1] == "IncludeExcludeTarget")){ stop("arg target wrong type") }
    
        private$py_obj$addExcludeTarget(target)
        invisible()
    },
    
    # C++ signature: void setSourceFiles(libcpp_vector[SourceFile] source_files)
    setSourceFiles = function(source_files){
    
        if(!(is_list(source_files) && all(sapply(source_files,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "SourceFile")))){ stop("arg source_files wrong type") }
        v0 <- r_to_py(source_files)
        private$py_obj$setSourceFiles(v0)
        
        invisible()
    },
    
    # C++ signature: libcpp_vector[SourceFile] getSourceFiles()
    getSourceFiles = function(){
    
        py_ans = private$py_obj$getSourceFiles()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addSourceFile(SourceFile source_file)
    addSourceFile = function(source_file){
    
        if(!(is.R6(source_file) && class(source_file)[1] == "SourceFile")){ stop("arg source_file wrong type") }
    
        private$py_obj$addSourceFile(source_file)
        invisible()
    },
    
    # C++ signature: bool containsInvalidReferences()
    containsInvalidReferences = function(){
    
        py_ans = private$py_obj$containsInvalidReferences()
        r_ans = py_ans
        return(r_ans)
    }
)
)
    #' @export
    `+.TargetedExperiment` <- function(e1, e2){
       added <- e1$.__enclos_env__$private$py_obj + e2$.__enclos_env__$private$py_obj
       result <- TargetedExperiment$new(added)
       return(result)
    } 

# R implementation of _TargetedExperiment_Instrument
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1TargetedExperiment_Instrument.html
TargetedExperiment_Instrument <- R6Class(classname = "TargetedExperiment_Instrument",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        id = function(id){
    
        if(!missing(id)){
            if(!((is.R6(id) && class(id)[1]=="String") || is_scalar_character(id))){ stop("arg id wrong type") }
        
        
            private$py_obj$id <- id
            } else {
        
                py_ans = private$py_obj$id
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TargetedExperiment_Instrument()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TargetedExperiment_Instrument) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TargetedExperiment_Instrument()
        invisible()
    }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms_0 = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$`_replaceCVTerms_0`(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms_1 = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$`_replaceCVTerms_1`(map_0)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$replaceCVTerms_0(...) }
        else if ((length(arg_list)==1) && (
          is.environment(arg_list[[1]]) && identical(parent.env(arg_list[[1]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[1]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[1]]$keys(),is_scalar_character))
          && all(sapply(arg_list[[1]]$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )) { self$replaceCVTerms_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getKeysAsIntegers(libcpp_vector[unsigned int] & keys)
    getKeysAsIntegers = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg keys wrong type") }
        v0 <- r_to_py(modify_depth(keys,1,as.integer))
        private$py_obj$getKeysAsIntegers(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(unsigned int)
    getMetaValue_0 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getMetaValue_0`(as.integer(in_0))
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue_1 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getMetaValue_1`(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getMetaValue(unsigned int)
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getMetaValue_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setMetaValue(unsigned int, DataValue)
    setMetaValue_0 = function(in_0, in_1){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_setMetaValue_0`(as.integer(in_0), in_1)
        invisible()
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue_1 = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_setMetaValue_1`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void setMetaValue(unsigned int, DataValue)
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setMetaValue_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists_0 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_metaValueExists_0`(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool metaValueExists(unsigned int)
    metaValueExists_1 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_metaValueExists_1`(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool metaValueExists(String)
    # C++ signature: bool metaValueExists(unsigned int)
    metaValueExists = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$metaValueExists_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$metaValueExists_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue_0 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_removeMetaValue_0`(in_0)
        invisible()
    },
    
    # C++ signature: void removeMetaValue(unsigned int)
    removeMetaValue_1 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_removeMetaValue_1`(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: void removeMetaValue(String)
    # C++ signature: void removeMetaValue(unsigned int)
    removeMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$removeMetaValue_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$removeMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _TargetedExperiment_Interpretation
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1TargetedExperiment_Interpretation.html
TargetedExperiment_Interpretation <- R6Class(classname = "TargetedExperiment_Interpretation",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        ordinal = function(ordinal){
    
        if(!missing(ordinal)){
            if(!(is_scalar_character(ordinal))){ stop("arg ordinal wrong type") }
        
        py_run_string("ordinal = bytes(ordinal)")
            private$py_obj$ordinal <- py$ordinal
            } else {
            py_run_string("del ordinal")
                py_ans = private$py_obj$ordinal
                r_result = as.character(py_ans)
                return(r_result)
                }
        },
        rank = function(rank){
    
        if(!missing(rank)){
            if(!(is_scalar_character(rank))){ stop("arg rank wrong type") }
        
        py_run_string("rank = bytes(rank)")
            private$py_obj$rank <- py$rank
            } else {
            py_run_string("del rank")
                py_ans = private$py_obj$rank
                r_result = as.character(py_ans)
                return(r_result)
                }
        },
        iontype = function(iontype){
    
        if(!missing(iontype)){
            if(!(iontype %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))){ stop("arg iontype wrong type") }
        
        
            private$py_obj$iontype <- as.integer(iontype)
            } else {
        
                py_ans = private$py_obj$iontype
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TargetedExperiment_Interpretation()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TargetedExperiment_Interpretation) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TargetedExperiment_Interpretation()
        invisible()
    }
    
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms_0 = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$`_replaceCVTerms_0`(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms_1 = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$`_replaceCVTerms_1`(map_0)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    # C++ signature: void replaceCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    replaceCVTerms = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm"))) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$replaceCVTerms_0(...) }
        else if ((length(arg_list)==1) && (
          is.environment(arg_list[[1]]) && identical(parent.env(arg_list[[1]]), asNamespace("collections")) && identical(strsplit(capture.output(arg_list[[1]]$print())," ")[[1]][1], "dict")
          && all(sapply(arg_list[[1]]$keys(),is_scalar_character))
          && all(sapply(arg_list[[1]]$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )) { self$replaceCVTerms_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void getKeysAsIntegers(libcpp_vector[unsigned int] & keys)
    getKeysAsIntegers = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys,function(elemt_rec)  (is_scalar_integer(elemt_rec) || is_scalar_double(elemt_rec)) && elemt_rec == as.integer(elemt_rec))))){ stop("arg keys wrong type") }
        v0 <- r_to_py(modify_depth(keys,1,as.integer))
        private$py_obj$getKeysAsIntegers(v0)
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(unsigned int)
    getMetaValue_0 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getMetaValue_0`(as.integer(in_0))
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue_1 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_getMetaValue_1`(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: DataValue getMetaValue(unsigned int)
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$getMetaValue_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$getMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setMetaValue(unsigned int, DataValue)
    setMetaValue_0 = function(in_0, in_1){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_setMetaValue_0`(as.integer(in_0), in_1)
        invisible()
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue_1 = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$`_setMetaValue_1`(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void setMetaValue(unsigned int, DataValue)
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setMetaValue_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "DataValue")) { self$setMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists_0 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_metaValueExists_0`(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool metaValueExists(unsigned int)
    metaValueExists_1 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$`_metaValueExists_1`(as.integer(in_0))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool metaValueExists(String)
    # C++ signature: bool metaValueExists(unsigned int)
    metaValueExists = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$metaValueExists_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$metaValueExists_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue_0 = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_removeMetaValue_0`(in_0)
        invisible()
    },
    
    # C++ signature: void removeMetaValue(unsigned int)
    removeMetaValue_1 = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$`_removeMetaValue_1`(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: void removeMetaValue(String)
    # C++ signature: void removeMetaValue(unsigned int)
    removeMetaValue = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$removeMetaValue_0(...) }
        else if ((length(arg_list)==1) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]]))) { self$removeMetaValue_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    }
)
) 

# R implementation of _TargetedExperiment_Modification
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1TargetedExperiment_Modification.html
TargetedExperiment_Modification <- R6Class(classname = "TargetedExperiment_Modification",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        avg_mass_delta = function(avg_mass_delta){
    
        if(!missing(avg_mass_delta)){
            if(!(is_scalar_double(avg_mass_delta))){ stop("arg avg_mass_delta wrong type") }
        
        
            private$py_obj$avg_mass_delta <- avg_mass_delta
            } else {
        
                py_ans = private$py_obj$avg_mass_delta
                r_result = py_ans
                return(r_result)
                }
        },
        mono_mass_delta = function(mono_mass_delta){
    
        if(!missing(mono_mass_delta)){
            if(!(is_scalar_double(mono_mass_delta))){ stop("arg mono_mass_delta wrong type") }
        
        
            private$py_obj$mono_mass_delta <- mono_mass_delta
            } else {
        
                py_ans = private$py_obj$mono_mass_delta
                r_result = py_ans
                return(r_result)
                }
        },
        location = function(location){
    
        if(!missing(location)){
            if(!( (is_scalar_integer(location) || is_scalar_double(location)) && location == as.integer(location))){ stop("arg location wrong type") }
        
        
            private$py_obj$location <- as.integer(location)
            } else {
        
                py_ans = private$py_obj$location
                r_result = py_ans
                return(r_result)
                }
        },
        unimod_id = function(unimod_id){
    
        if(!missing(unimod_id)){
            if(!( (is_scalar_integer(unimod_id) || is_scalar_double(unimod_id)) && unimod_id == as.integer(unimod_id))){ stop("arg unimod_id wrong type") }
        
        
            private$py_obj$unimod_id <- as.integer(unimod_id)
            } else {
        
                py_ans = private$py_obj$unimod_id
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TargetedExperiment_Modification()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TargetedExperiment_Modification()
        invisible()
    
    
    },
    
    # C++ signature: void TargetedExperiment_Modification(TargetedExperiment_Modification)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TargetedExperiment_Modification")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TargetedExperiment_Modification(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TargetedExperiment_Modification()
    # C++ signature: void TargetedExperiment_Modification(TargetedExperiment_Modification)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TargetedExperiment_Modification")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TargetedExperiment_Modification" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _TargetedSpectraExtractor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TargetedSpectraExtractor.html
TargetedSpectraExtractor <- R6Class(classname = "TargetedSpectraExtractor",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TargetedSpectraExtractor()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TargetedSpectraExtractor()
        invisible()
    
    
    },
    
    # C++ signature: void TargetedSpectraExtractor(TargetedSpectraExtractor)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TargetedSpectraExtractor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TargetedSpectraExtractor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TargetedSpectraExtractor()
    # C++ signature: void TargetedSpectraExtractor(TargetedSpectraExtractor)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TargetedSpectraExtractor")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TargetedSpectraExtractor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getDefaultParameters(Param &)
    getDefaultParameters = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
        private$py_obj$getDefaultParameters(in_0)
        invisible()
    },
    
    # C++ signature: void annotateSpectra(libcpp_vector[MSSpectrum] &, TargetedExperiment &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    annotateSpectra_0 = function(in_0, in_1, in_2, in_3){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TargetedExperiment")){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
        if(!(is.R6(in_3) && class(in_3)[1] == "FeatureMap")){ stop("arg in_3 wrong type") }
        v0 <- r_to_py(in_0)
    
        v2 <- r_to_py(in_2)
    
        private$py_obj$`_annotateSpectra_0`(v0, in_1, v2, in_3)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void annotateSpectra(libcpp_vector[MSSpectrum] &, TargetedExperiment &, libcpp_vector[MSSpectrum] &)
    annotateSpectra_1 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TargetedExperiment")){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
    
        v2 <- r_to_py(in_2)
        private$py_obj$`_annotateSpectra_1`(v0, in_1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void annotateSpectra(libcpp_vector[MSSpectrum] &, TargetedExperiment &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    # C++ signature: void annotateSpectra(libcpp_vector[MSSpectrum] &, TargetedExperiment &, libcpp_vector[MSSpectrum] &)
    annotateSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TargetedExperiment") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "FeatureMap")) { self$annotateSpectra_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TargetedExperiment") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))) { self$annotateSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void pickSpectrum(MSSpectrum &, MSSpectrum &)
    pickSpectrum = function(in_0, in_1){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSSpectrum")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "MSSpectrum")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$pickSpectrum(in_0, in_1)
        invisible()
    },
    
    # C++ signature: void scoreSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &, FeatureMap &, libcpp_vector[MSSpectrum] &)
    scoreSpectra_0 = function(in_0, in_1, in_2, in_3){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_1 wrong type") }
        if(!(is.R6(in_2) && class(in_2)[1] == "FeatureMap")){ stop("arg in_2 wrong type") }
        if(!(is_list(in_3) && all(sapply(in_3,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_3 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
    
        v3 <- r_to_py(in_3)
        private$py_obj$`_scoreSpectra_0`(v0, v1, in_2, v3)
        byref_3 <- map(py_to_r(v3),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        eval.parent(substitute(in_3 <- byref_3))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void scoreSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &)
    scoreSpectra_1 = function(in_0, in_1, in_2){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
        v2 <- r_to_py(in_2)
        private$py_obj$`_scoreSpectra_1`(v0, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void scoreSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &, FeatureMap &, libcpp_vector[MSSpectrum] &)
    # C++ signature: void scoreSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &)
    scoreSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "FeatureMap") && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))) { self$scoreSpectra_0(...) }
        else if ((length(arg_list)==3) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))) { self$scoreSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void selectSpectra(libcpp_vector[MSSpectrum] &, FeatureMap &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    selectSpectra_0 = function(in_0, in_1, in_2, in_3){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "FeatureMap")){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
        if(!(is.R6(in_3) && class(in_3)[1] == "FeatureMap")){ stop("arg in_3 wrong type") }
        v0 <- r_to_py(in_0)
    
        v2 <- r_to_py(in_2)
    
        private$py_obj$`_selectSpectra_0`(v0, in_1, v2, in_3)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void selectSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &)
    selectSpectra_1 = function(in_0, in_1){
    
        if(!(is_list(in_0) && all(sapply(in_0,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_0 wrong type") }
        if(!(is_list(in_1) && all(sapply(in_1,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_1 wrong type") }
        v0 <- r_to_py(in_0)
        v1 <- r_to_py(in_1)
        private$py_obj$`_selectSpectra_1`(v0, v1)
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_0 <- byref_0))
        eval.parent(substitute(in_1 <- byref_1))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void selectSpectra(libcpp_vector[MSSpectrum] &, FeatureMap &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    # C++ signature: void selectSpectra(libcpp_vector[MSSpectrum] &, libcpp_vector[MSSpectrum] &)
    selectSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "FeatureMap") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "FeatureMap")) { self$selectSpectra_0(...) }
        else if ((length(arg_list)==2) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is_list(arg_list[[2]]) && all(sapply(arg_list[[2]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))) { self$selectSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void extractSpectra(MSExperiment &, TargetedExperiment &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    extractSpectra_0 = function(in_0, in_1, in_2, in_3){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TargetedExperiment")){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
        if(!(is.R6(in_3) && class(in_3)[1] == "FeatureMap")){ stop("arg in_3 wrong type") }
    
    
        v2 <- r_to_py(in_2)
    
        private$py_obj$`_extractSpectra_0`(in_0, in_1, v2, in_3)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractSpectra(MSExperiment &, TargetedExperiment &, libcpp_vector[MSSpectrum] &)
    extractSpectra_1 = function(in_0, in_1, in_2){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "MSExperiment")){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TargetedExperiment")){ stop("arg in_1 wrong type") }
        if(!(is_list(in_2) && all(sapply(in_2,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))){ stop("arg in_2 wrong type") }
    
    
        v2 <- r_to_py(in_2)
        private$py_obj$`_extractSpectra_1`(in_0, in_1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(in_2 <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void extractSpectra(MSExperiment &, TargetedExperiment &, libcpp_vector[MSSpectrum] &, FeatureMap &)
    # C++ signature: void extractSpectra(MSExperiment &, TargetedExperiment &, libcpp_vector[MSSpectrum] &)
    extractSpectra = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TargetedExperiment") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum"))) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "FeatureMap")) { self$extractSpectra_0(...) }
        else if ((length(arg_list)==3) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSExperiment") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TargetedExperiment") && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "MSSpectrum")))) { self$extractSpectra_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TextFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TextFile.html
TextFile <- R6Class(classname = "TextFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TextFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TextFile()
        invisible()
    
    
    },
    
    # C++ signature: void TextFile(const String & filename, bool trim_linesalse, int first_n1)
    init_1 = function(filename, trim_linesalse, first_n1){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(trim_linesalse) || is_scalar_double(trim_linesalse)) && trim_linesalse == as.integer(trim_linesalse))){ stop("arg trim_linesalse wrong type") }
        if(!( (is_scalar_integer(first_n1) || is_scalar_double(first_n1)) && first_n1 == as.integer(first_n1))){ stop("arg first_n1 wrong type") }
    
    
    
    
        private$py_obj <- Pymod$TextFile(filename, as.integer(trim_linesalse), as.integer(first_n1))
        invisible()
    
    
    },
    
    # C++ signature: void TextFile()
    # C++ signature: void TextFile(const String & filename, bool trim_linesalse, int first_n1)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TextFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void load(const String & filename, bool trim_linesalse, int first_n1)
    load = function(filename, trim_linesalse, first_n1){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(trim_linesalse) || is_scalar_double(trim_linesalse)) && trim_linesalse == as.integer(trim_linesalse))){ stop("arg trim_linesalse wrong type") }
        if(!( (is_scalar_integer(first_n1) || is_scalar_double(first_n1)) && first_n1 == as.integer(first_n1))){ stop("arg first_n1 wrong type") }
    
    
    
        private$py_obj$load(filename, as.integer(trim_linesalse), as.integer(first_n1))
        invisible()
    },
    
    # C++ signature: void store(const String & filename)
    store = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$store(filename)
        invisible()
    },
    
    # C++ signature: void addLine(const String line)
    addLine = function(line){
    
        if(!((is.R6(line) && class(line)[1]=="String") || is_scalar_character(line))){ stop("arg line wrong type") }
    
        private$py_obj$addLine(line)
        invisible()
    }
)
) 

# R implementation of _TheoreticalIsotopePattern
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::FeatureFinderAlgorithmPickedHelperStructs_1_1TheoreticalIsotopePattern.html
TheoreticalIsotopePattern <- R6Class(classname = "TheoreticalIsotopePattern",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        intensity = function(intensity){
    
        if(!missing(intensity)){
            if(!(is_list(intensity) && all(sapply(intensity,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg intensity wrong type") }
        
            v0 <- r_to_py(intensity)
            private$py_obj$intensity <- v0
            } else {
            
                py_ans = private$py_obj$intensity
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        },
        optional_begin = function(optional_begin){
    
        if(!missing(optional_begin)){
            if(!( (is_scalar_integer(optional_begin) || is_scalar_double(optional_begin)) && optional_begin == as.integer(optional_begin))){ stop("arg optional_begin wrong type") }
        
        
            private$py_obj$optional_begin <- as.integer(optional_begin)
            } else {
        
                py_ans = private$py_obj$optional_begin
                r_result = py_ans
                return(r_result)
                }
        },
        optional_end = function(optional_end){
    
        if(!missing(optional_end)){
            if(!( (is_scalar_integer(optional_end) || is_scalar_double(optional_end)) && optional_end == as.integer(optional_end))){ stop("arg optional_end wrong type") }
        
        
            private$py_obj$optional_end <- as.integer(optional_end)
            } else {
        
                py_ans = private$py_obj$optional_end
                r_result = py_ans
                return(r_result)
                }
        },
        max = function(max){
    
        if(!missing(max)){
            if(!(is_scalar_double(max))){ stop("arg max wrong type") }
        
        
            private$py_obj$max <- max
            } else {
        
                py_ans = private$py_obj$max
                r_result = py_ans
                return(r_result)
                }
        },
        trimmed_left = function(trimmed_left){
    
        if(!missing(trimmed_left)){
            if(!( (is_scalar_integer(trimmed_left) || is_scalar_double(trimmed_left)) && trimmed_left == as.integer(trimmed_left))){ stop("arg trimmed_left wrong type") }
        
        
            private$py_obj$trimmed_left <- as.integer(trimmed_left)
            } else {
        
                py_ans = private$py_obj$trimmed_left
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: size_t size()
    size = function(){
    
        py_ans = private$py_obj$size()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _TheoreticalSpectrumGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TheoreticalSpectrumGenerator.html
TheoreticalSpectrumGenerator <- R6Class(classname = "TheoreticalSpectrumGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TheoreticalSpectrumGenerator()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TheoreticalSpectrumGenerator()
        invisible()
    
    
    },
    
    # C++ signature: void TheoreticalSpectrumGenerator(TheoreticalSpectrumGenerator)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TheoreticalSpectrumGenerator")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TheoreticalSpectrumGenerator(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TheoreticalSpectrumGenerator()
    # C++ signature: void TheoreticalSpectrumGenerator(TheoreticalSpectrumGenerator)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TheoreticalSpectrumGenerator")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TheoreticalSpectrumGenerator" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getSpectrum(MSSpectrum & spec, AASequence & peptide, int min_charge, int max_charge)
    getSpectrum = function(spec, peptide, min_charge, max_charge){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(min_charge) || is_scalar_double(min_charge)) && min_charge == as.integer(min_charge))){ stop("arg min_charge wrong type") }
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
    
    
    
    
        private$py_obj$getSpectrum(spec, peptide, as.integer(min_charge), as.integer(max_charge))
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TheoreticalSpectrumGeneratorXLMS
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TheoreticalSpectrumGeneratorXLMS.html
TheoreticalSpectrumGeneratorXLMS <- R6Class(classname = "TheoreticalSpectrumGeneratorXLMS",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TheoreticalSpectrumGeneratorXLMS()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TheoreticalSpectrumGeneratorXLMS()
        invisible()
    
    
    },
    
    # C++ signature: void TheoreticalSpectrumGeneratorXLMS(TheoreticalSpectrumGeneratorXLMS)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TheoreticalSpectrumGeneratorXLMS")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TheoreticalSpectrumGeneratorXLMS(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TheoreticalSpectrumGeneratorXLMS()
    # C++ signature: void TheoreticalSpectrumGeneratorXLMS(TheoreticalSpectrumGeneratorXLMS)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TheoreticalSpectrumGeneratorXLMS")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TheoreticalSpectrumGeneratorXLMS" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: void getLinearIonSpectrum(MSSpectrum & spectrum, AASequence peptide, size_t link_pos, bool frag_alpha, int charge, size_t link_pos_2)
    getLinearIonSpectrum = function(spectrum, peptide, link_pos, frag_alpha, charge, link_pos_2){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(link_pos) || is_scalar_double(link_pos)) && link_pos == as.integer(link_pos))){ stop("arg link_pos wrong type") }
        if(!( (is_scalar_integer(frag_alpha) || is_scalar_double(frag_alpha)) && frag_alpha == as.integer(frag_alpha))){ stop("arg frag_alpha wrong type") }
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
        if(!( (is_scalar_integer(link_pos_2) || is_scalar_double(link_pos_2)) && link_pos_2 == as.integer(link_pos_2))){ stop("arg link_pos_2 wrong type") }
    
    
    
    
    
    
        private$py_obj$getLinearIonSpectrum(spectrum, peptide, as.integer(link_pos), as.integer(frag_alpha), as.integer(charge), as.integer(link_pos_2))
        invisible()
    },
    
    # C++ signature: void getXLinkIonSpectrum(MSSpectrum & spectrum, AASequence peptide, size_t link_pos, double precursor_mass, bool frag_alpha, int mincharge, int maxcharge, size_t link_pos_2)
    getXLinkIonSpectrum_0 = function(spectrum, peptide, link_pos, precursor_mass, frag_alpha, mincharge, maxcharge, link_pos_2){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is.R6(peptide) && class(peptide)[1] == "AASequence")){ stop("arg peptide wrong type") }
        if(!( (is_scalar_integer(link_pos) || is_scalar_double(link_pos)) && link_pos == as.integer(link_pos))){ stop("arg link_pos wrong type") }
        if(!(is_scalar_double(precursor_mass))){ stop("arg precursor_mass wrong type") }
        if(!( (is_scalar_integer(frag_alpha) || is_scalar_double(frag_alpha)) && frag_alpha == as.integer(frag_alpha))){ stop("arg frag_alpha wrong type") }
        if(!( (is_scalar_integer(mincharge) || is_scalar_double(mincharge)) && mincharge == as.integer(mincharge))){ stop("arg mincharge wrong type") }
        if(!( (is_scalar_integer(maxcharge) || is_scalar_double(maxcharge)) && maxcharge == as.integer(maxcharge))){ stop("arg maxcharge wrong type") }
        if(!( (is_scalar_integer(link_pos_2) || is_scalar_double(link_pos_2)) && link_pos_2 == as.integer(link_pos_2))){ stop("arg link_pos_2 wrong type") }
    
    
    
    
    
    
    
    
        private$py_obj$`_getXLinkIonSpectrum_0`(spectrum, peptide, as.integer(link_pos), precursor_mass, as.integer(frag_alpha), as.integer(mincharge), as.integer(maxcharge), as.integer(link_pos_2))
        invisible()
    },
    
    # C++ signature: void getXLinkIonSpectrum(MSSpectrum & spectrum, ProteinProteinCrossLink crosslink, bool frag_alpha, int mincharge, int maxcharge)
    getXLinkIonSpectrum_1 = function(spectrum, crosslink, frag_alpha, mincharge, maxcharge){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
        if(!(is.R6(crosslink) && class(crosslink)[1] == "ProteinProteinCrossLink")){ stop("arg crosslink wrong type") }
        if(!( (is_scalar_integer(frag_alpha) || is_scalar_double(frag_alpha)) && frag_alpha == as.integer(frag_alpha))){ stop("arg frag_alpha wrong type") }
        if(!( (is_scalar_integer(mincharge) || is_scalar_double(mincharge)) && mincharge == as.integer(mincharge))){ stop("arg mincharge wrong type") }
        if(!( (is_scalar_integer(maxcharge) || is_scalar_double(maxcharge)) && maxcharge == as.integer(maxcharge))){ stop("arg maxcharge wrong type") }
    
    
    
    
    
        private$py_obj$`_getXLinkIonSpectrum_1`(spectrum, crosslink, as.integer(frag_alpha), as.integer(mincharge), as.integer(maxcharge))
        invisible()
    },
    
    # C++ signature: void getXLinkIonSpectrum(MSSpectrum & spectrum, AASequence peptide, size_t link_pos, double precursor_mass, bool frag_alpha, int mincharge, int maxcharge, size_t link_pos_2)
    # C++ signature: void getXLinkIonSpectrum(MSSpectrum & spectrum, ProteinProteinCrossLink crosslink, bool frag_alpha, int mincharge, int maxcharge)
    getXLinkIonSpectrum = function(...){
        arg_list = list(...)
        if ((length(arg_list)==8) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "AASequence") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && (is_scalar_double(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]])) && ( (is_scalar_integer(arg_list[[6]]) || is_scalar_double(arg_list[[6]])) && arg_list[[6]] == as.integer(arg_list[[6]])) && ( (is_scalar_integer(arg_list[[7]]) || is_scalar_double(arg_list[[7]])) && arg_list[[7]] == as.integer(arg_list[[7]])) && ( (is_scalar_integer(arg_list[[8]]) || is_scalar_double(arg_list[[8]])) && arg_list[[8]] == as.integer(arg_list[[8]]))) { self$getXLinkIonSpectrum_0(...) }
        else if ((length(arg_list)==5) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "MSSpectrum") && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "ProteinProteinCrossLink") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]])) && ( (is_scalar_integer(arg_list[[5]]) || is_scalar_double(arg_list[[5]])) && arg_list[[5]] == as.integer(arg_list[[5]]))) { self$getXLinkIonSpectrum_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _ThresholdMower
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1ThresholdMower.html
ThresholdMower <- R6Class(classname = "ThresholdMower",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void ThresholdMower()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == ThresholdMower) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$ThresholdMower()
        invisible()
    }
    
    },
    
    # C++ signature: void filterSpectrum(MSSpectrum & spec)
    filterSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _TraMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TraMLFile.html
TraMLFile <- R6Class(classname = "TraMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TraMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TraMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TraMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, TargetedExperiment & id)
    load = function(filename, id){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(id) && class(id)[1] == "TargetedExperiment")){ stop("arg id wrong type") }
    
    
        private$py_obj$load(filename, id)
        invisible()
    },
    
    # C++ signature: void store(String filename, TargetedExperiment & id)
    store = function(filename, id){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(id) && class(id)[1] == "TargetedExperiment")){ stop("arg id wrong type") }
    
    
        private$py_obj$store(filename, id)
        invisible()
    },
    
    # C++ signature: bool isSemanticallyValid(String filename, StringList & errors, StringList & warnings)
    isSemanticallyValid = function(filename, errors, warnings){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(errors) && all(sapply(errors),is_scalar_character))){ stop("arg errors wrong type") }
        if(!(is_list(warnings) && all(sapply(warnings),is_scalar_character))){ stop("arg warnings wrong type") }
    
        v1 = r_to_py(modify_depth(errors,1,py_builtin$bytes(errors,'utf-8')))
        v2 = r_to_py(modify_depth(warnings,1,py_builtin$bytes(warnings,'utf-8')))
        py_ans = private$py_obj$isSemanticallyValid(filename, v1, v2)
        byref_2 <- modify_depth(py_to_r(v2),1,as.character)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(errors <- byref_1))
        eval.parent(substitute(warnings <- byref_2))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    }
)
) 

# R implementation of _TraMLProduct
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TargetedExperimentHelper::RetentionTime::RTUnit_1_1TraMLProduct.html
TraMLProduct <- R6Class(classname = "TraMLProduct",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TraMLProduct()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TraMLProduct) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TraMLProduct()
        invisible()
    }
    
    },
    
    # C++ signature: void setMZ(double mz)
    setMZ = function(mz){
    
        if(!(is_scalar_double(mz))){ stop("arg mz wrong type") }
    
        private$py_obj$setMZ(mz)
        invisible()
    },
    
    # C++ signature: double getMZ()
    getMZ = function(){
    
        py_ans = private$py_obj$getMZ()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setChargeState(int charge)
    setChargeState = function(charge){
    
        if(!( (is_scalar_integer(charge) || is_scalar_double(charge)) && charge == as.integer(charge))){ stop("arg charge wrong type") }
    
        private$py_obj$setChargeState(as.integer(charge))
        invisible()
    },
    
    # C++ signature: int getChargeState()
    getChargeState = function(){
    
        py_ans = private$py_obj$getChargeState()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool hasCharge()
    hasCharge = function(){
    
        py_ans = private$py_obj$hasCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[Configuration] getConfigurationList()
    getConfigurationList = function(){
    
        py_ans = private$py_obj$getConfigurationList()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addConfiguration(Configuration configuration)
    addConfiguration = function(configuration){
    
        if(!(is.R6(configuration) && class(configuration)[1] == "Configuration")){ stop("arg configuration wrong type") }
    
        private$py_obj$addConfiguration(configuration)
        invisible()
    },
    
    # C++ signature: libcpp_vector[TargetedExperiment_Interpretation] getInterpretationList()
    getInterpretationList = function(){
    
        py_ans = private$py_obj$getInterpretationList()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void addInterpretation(TargetedExperiment_Interpretation interpretation)
    addInterpretation = function(interpretation){
    
        if(!(is.R6(interpretation) && class(interpretation)[1] == "TargetedExperiment_Interpretation")){ stop("arg interpretation wrong type") }
    
        private$py_obj$addInterpretation(interpretation)
        invisible()
    },
    
    # C++ signature: void resetInterpretations()
    resetInterpretations = function(){
    
        private$py_obj$resetInterpretations()
        invisible()
    },
    
    # C++ signature: void setCVTerms(libcpp_vector[CVTerm] & terms)
    setCVTerms = function(terms){
    
        if(!(is_list(terms) && all(sapply(terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg terms wrong type") }
        v0 <- r_to_py(terms)
        private$py_obj$setCVTerms(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(terms <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void replaceCVTerm(CVTerm & term)
    replaceCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$replaceCVTerm(term)
        invisible()
    },
    
    # C++ signature: void replaceCVTerms(libcpp_vector[CVTerm] cv_terms, String accession)
    replaceCVTerms = function(cv_terms, accession){
    
        if(!(is_list(cv_terms) && all(sapply(cv_terms,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "CVTerm")))){ stop("arg cv_terms wrong type") }
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        v0 <- r_to_py(cv_terms)
    
        private$py_obj$replaceCVTerms(v0, accession)
        
        invisible()
    },
    
    # C++ signature: void consumeCVTerms(Map[String,libcpp_vector[CVTerm]] cv_term_map)
    consumeCVTerms = function(cv_term_map){
    
        if(!(
          is.environment(cv_term_map) && identical(parent.env(cv_term_map), asNamespace("collections")) && identical(strsplit(capture.output(cv_term_map$print())," ")[[1]][1], "dict")
          && all(sapply(cv_term_map$keys(),is_scalar_character))
          && all(sapply(cv_term_map$values(), function(v) is_list(v) && sapply(v, function(v1) is.R6(v1) && class(v1)[1] == "CVTerm")))
          )){ stop("arg cv_term_map wrong type") }
        map_0 <- py_dict(cv_term_map$values(),modify_depth(cv_term_map$keys(),1,function(i) py_builtin$bytes(i,'utf-8')))
        private$py_obj$consumeCVTerms(map_0)
        invisible()
    },
    
    # C++ signature: Map[String,libcpp_vector[CVTerm]] getCVTerms()
    getCVTerms = function(){
    
        py_ans = py_call(private$py_obj$getCVTerms,)
        r_ans <- collections::dict(lapply(py_to_r(py_builtin$list(py_ans$values())),function(v) CVTerm$new(v)), lapply(py_to_r(py_builtin$list(py_ans$keys())),as.character))
        return(r_ans)
    },
    
    # C++ signature: void addCVTerm(CVTerm & term)
    addCVTerm = function(term){
    
        if(!(is.R6(term) && class(term)[1] == "CVTerm")){ stop("arg term wrong type") }
    
        private$py_obj$addCVTerm(term)
        invisible()
    },
    
    # C++ signature: bool hasCVTerm(String accession)
    hasCVTerm = function(accession){
    
        if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
    
        py_ans = private$py_obj$hasCVTerm(accession)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool empty()
    empty = function(){
    
        py_ans = private$py_obj$empty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: bool isMetaEmpty()
    isMetaEmpty = function(){
    
        py_ans = private$py_obj$isMetaEmpty()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void clearMetaInfo()
    clearMetaInfo = function(){
    
        private$py_obj$clearMetaInfo()
        invisible()
    },
    
    # C++ signature: MetaInfoRegistry metaRegistry()
    metaRegistry = function(){
    
        py_ans = private$py_obj$metaRegistry()
        r_ans = MetaInfoRegistry$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void getKeys(libcpp_vector[String] & keys)
    getKeys = function(keys){
    
        if(!(is_list(keys) && all(sapply(keys),is_scalar_character))){ stop("arg keys wrong type") }
        v0 = r_to_py(modify_depth(keys,1,py_builtin$bytes(keys,'utf-8')))
        private$py_obj$getKeys(v0)
        byref_0 <- modify_depth(py_to_r(v0),1,as.character)
    
        tryCatch({
        eval.parent(substitute(keys <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: DataValue getMetaValue(String)
    getMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$getMetaValue(in_0)
        dtype = DataType$new()
        type = py_ans$valueType()
        if( type == dtype$STRING_VALUE ){
           r_ans = py_ans$toString()
        } else if ( type == dtype$INT_VALUE ){
           r_ans = py_ans$toInt()
        } else if ( type == dtype$DOUBLE_VALUE ){
            r_ans = py_ans$toDouble()
        } else if ( type == dtype$INT_LIST ){
           r_ans = py_ans$toIntList()
        } else if ( type == dtype$DOUBLE_LIST ){
           r_ans = py_ans$toDoubleList()
        } else if ( type == dtype$STRING_LIST ){
           r_ans = py_ans$toStringList()
        } else if ( type == dtype$EMPTY_VALUE ){
           r_ans = NULL
        } else {
            stop(paste0("DataValue instance has invalid value",type))
        }
        return(r_ans)
    },
    
    # C++ signature: void setMetaValue(String, DataValue)
    setMetaValue = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "DataValue")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$setMetaValue(in_0, in_1)
        invisible()
    },
    
    # C++ signature: bool metaValueExists(String)
    metaValueExists = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$metaValueExists(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void removeMetaValue(String)
    removeMetaValue = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$removeMetaValue(in_0)
        invisible()
    }
)
) 

# R implementation of _TraceInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TraceInfo.html
TraceInfo <- R6Class(classname = "TraceInfo",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        description = function(description){
    
        if(!missing(description)){
            if(!((is.R6(description) && class(description)[1]=="String") || is_scalar_character(description))){ stop("arg description wrong type") }
        
        
            private$py_obj$description <- description
            } else {
        
                py_ans = private$py_obj$description
            r_result = py_ans
                return(r_result)
                }
        },
        opened = function(opened){
    
        if(!missing(opened)){
            if(!( (is_scalar_integer(opened) || is_scalar_double(opened)) && opened == as.integer(opened))){ stop("arg opened wrong type") }
        
        
            private$py_obj$opened <- as.integer(opened)
            } else {
        
                py_ans = private$py_obj$opened
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TraceInfo(String n, String d, bool o)
    init_0 = function(n, d, o){
    
        if(!((is.R6(n) && class(n)[1]=="String") || is_scalar_character(n))){ stop("arg n wrong type") }
        if(!((is.R6(d) && class(d)[1]=="String") || is_scalar_character(d))){ stop("arg d wrong type") }
        if(!( (is_scalar_integer(o) || is_scalar_double(o)) && o == as.integer(o))){ stop("arg o wrong type") }
    
    
    
    
        private$py_obj <- Pymod$TraceInfo(n, d, as.integer(o))
        invisible()
    
    
    },
    
    # C++ signature: void TraceInfo(TraceInfo)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TraceInfo")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TraceInfo(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TraceInfo(String n, String d, bool o)
    # C++ signature: void TraceInfo(TraceInfo)
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TraceInfo")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TraceInfo" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _TransformationDescription
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TransformationDescription_1_1TransformationDescription.html
TransformationDescription <- R6Class(classname = "TransformationDescription",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationDescription()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TransformationDescription) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TransformationDescription()
        invisible()
    }
    
    },
    
    # C++ signature: libcpp_vector[TM_DataPoint] getDataPoints()
    getDataPoints = function(){
    
        py_ans = private$py_obj$getDataPoints()
        r_ans = map(py_ans,function(i) eval(parse(text = paste0(class_to_wrap(i),"$","new(i)"))))
        return(r_ans)
    },
    
    # C++ signature: void setDataPoints(libcpp_vector[TM_DataPoint] & data)
    setDataPoints_0 = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$`_setDataPoints_0`(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setDataPoints(libcpp_vector[libcpp_pair[double,double]] & data)
    setDataPoints_1 = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$`_setDataPoints_1`(v0)
        byref_0 <- py_to_r(v0)
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void setDataPoints(libcpp_vector[TM_DataPoint] & data)
    # C++ signature: void setDataPoints(libcpp_vector[libcpp_pair[double,double]] & data)
    setDataPoints = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))) { self$setDataPoints_0(...) }
        else if ((length(arg_list)==1) && (is_list(arg_list[[1]]) && all(sapply(arg_list[[1]],function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 && is_scalar_double(elemt_rec[[1]]) && is_scalar_double(elemt_rec[[2]]))))) { self$setDataPoints_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double apply(double)
    apply = function(in_0){
    
        if(!(is_scalar_double(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = private$py_obj$apply(in_0)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void fitModel(String model_type, Param params)
    fitModel_0 = function(model_type, params){
    
        if(!((is.R6(model_type) && class(model_type)[1]=="String") || is_scalar_character(model_type))){ stop("arg model_type wrong type") }
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
    
    
        private$py_obj$`_fitModel_0`(model_type, params)
        invisible()
    },
    
    # C++ signature: void fitModel(String model_type)
    fitModel_1 = function(model_type){
    
        if(!((is.R6(model_type) && class(model_type)[1]=="String") || is_scalar_character(model_type))){ stop("arg model_type wrong type") }
    
        private$py_obj$`_fitModel_1`(model_type)
        invisible()
    },
    
    # C++ signature: void fitModel(String model_type, Param params)
    # C++ signature: void fitModel(String model_type)
    fitModel = function(...){
        arg_list = list(...)
        if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "Param")) { self$fitModel_0(...) }
        else if ((length(arg_list)==1) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]]))) { self$fitModel_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getModelType()
    getModelType = function(){
    
        py_ans = private$py_obj$getModelType()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param getModelParameters()
    getModelParameters = function(){
    
        py_ans = private$py_obj$getModelParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void invert()
    invert = function(){
    
        private$py_obj$invert()
        invisible()
    },
    
    # C++ signature: void getDeviations(libcpp_vector[double] & diffs, bool do_apply, bool do_sort)
    getDeviations = function(diffs, do_apply, do_sort){
    
        if(!(is_list(diffs) && all(sapply(diffs,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg diffs wrong type") }
        if(!( (is_scalar_integer(do_apply) || is_scalar_double(do_apply)) && do_apply == as.integer(do_apply))){ stop("arg do_apply wrong type") }
        if(!( (is_scalar_integer(do_sort) || is_scalar_double(do_sort)) && do_sort == as.integer(do_sort))){ stop("arg do_sort wrong type") }
        v0 <- r_to_py(diffs)
    
    
        private$py_obj$getDeviations(v0, as.integer(do_apply), as.integer(do_sort))
        byref_0 <- map_depth(py_to_r(v0),0,as.list)
    
        tryCatch({
        eval.parent(substitute(diffs <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: TransformationStatistics getStatistics()
    getStatistics = function(){
    
        py_ans = private$py_obj$getStatistics()
        r_ans = TransformationStatistics$new(py_ans)
        return(r_ans)
    }
)
)
    
    # C++ signature: void getModelTypes(StringList result)
    TransformationDescription$getModelTypes = function(result){
    
        if(!(is_list(result) && all(sapply(result),is_scalar_character))){ stop("arg result wrong type") }
        v0 = r_to_py(modify_depth(result,1,py_builtin$bytes(result,'utf-8')))
        Pymod$TransformationDescription$getModelTypes(v0)
    } 

# R implementation of _TransformationModelBSpline
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransformationModelBSpline.html
TransformationModelBSpline <- R6Class(classname = "TransformationModelBSpline",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationModelBSpline(libcpp_vector[TM_DataPoint] & data, Param & params)
    initialize = function(data, params){
    
    if(missing(params)){
         if( "python.builtin.object" %in% class(data) && class_to_wrap(data) == TransformationModelBSpline ) { private$py_obj <- data }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        v0 <- r_to_py(data)
    
    
        private$py_obj <- Pymod$TransformationModelBSpline(v0, params)
        invisible()
    }
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: double evaluate(double value)
    evaluate = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$evaluate(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void weightData(libcpp_vector[TM_DataPoint] & data)
    weightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$weightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool checkValidWeight(const String & weight, libcpp_vector[String] & valid_weights)
    checkValidWeight = function(weight, valid_weights){
    
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
        if(!(is_list(valid_weights) && all(sapply(valid_weights),is_scalar_character))){ stop("arg valid_weights wrong type") }
    
        v1 = r_to_py(modify_depth(valid_weights,1,py_builtin$bytes(valid_weights,'utf-8')))
        py_ans = private$py_obj$checkValidWeight(weight, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(valid_weights <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double weightDatum(double & datum, const String & weight)
    weightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$weightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double unWeightDatum(double & datum, const String & weight)
    unWeightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$unWeightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidXWeights()
    getValidXWeights = function(){
    
        py_ans = private$py_obj$getValidXWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidYWeights()
    getValidYWeights = function(){
    
        py_ans = private$py_obj$getValidYWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void unWeightData(libcpp_vector[TM_DataPoint] & data)
    unWeightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$unWeightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double checkDatumRange(const double & datum, const double & datum_min, const double & datum_max)
    checkDatumRange = function(datum, datum_min, datum_max){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!(is_scalar_double(datum_min))){ stop("arg datum_min wrong type") }
        if(!(is_scalar_double(datum_max))){ stop("arg datum_max wrong type") }
    
    
    
        py_ans = private$py_obj$checkDatumRange(datum, datum_min, datum_max)
        r_ans = py_ans
        return(r_ans)
    }
)
)
    
    # C++ signature: void getDefaultParameters(Param & params)
    TransformationModelBSpline$getDefaultParameters = function(params){
    
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
    
        Pymod$TransformationModelBSpline$getDefaultParameters(params)
    } 

# R implementation of _TransformationModelInterpolated
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransformationModelInterpolated.html
TransformationModelInterpolated <- R6Class(classname = "TransformationModelInterpolated",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationModelInterpolated(libcpp_vector[TM_DataPoint] & data, Param & params)
    initialize = function(data, params){
    
    if(missing(params)){
         if( "python.builtin.object" %in% class(data) && class_to_wrap(data) == TransformationModelInterpolated ) { private$py_obj <- data }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        v0 <- r_to_py(data)
    
    
        private$py_obj <- Pymod$TransformationModelInterpolated(v0, params)
        invisible()
    }
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void getDefaultParameters(Param &)
    getDefaultParameters = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
        private$py_obj$getDefaultParameters(in_0)
        invisible()
    },
    
    # C++ signature: double evaluate(double value)
    evaluate = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$evaluate(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void weightData(libcpp_vector[TM_DataPoint] & data)
    weightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$weightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool checkValidWeight(const String & weight, libcpp_vector[String] & valid_weights)
    checkValidWeight = function(weight, valid_weights){
    
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
        if(!(is_list(valid_weights) && all(sapply(valid_weights),is_scalar_character))){ stop("arg valid_weights wrong type") }
    
        v1 = r_to_py(modify_depth(valid_weights,1,py_builtin$bytes(valid_weights,'utf-8')))
        py_ans = private$py_obj$checkValidWeight(weight, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(valid_weights <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double weightDatum(double & datum, const String & weight)
    weightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$weightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double unWeightDatum(double & datum, const String & weight)
    unWeightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$unWeightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidXWeights()
    getValidXWeights = function(){
    
        py_ans = private$py_obj$getValidXWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidYWeights()
    getValidYWeights = function(){
    
        py_ans = private$py_obj$getValidYWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void unWeightData(libcpp_vector[TM_DataPoint] & data)
    unWeightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$unWeightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double checkDatumRange(const double & datum, const double & datum_min, const double & datum_max)
    checkDatumRange = function(datum, datum_min, datum_max){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!(is_scalar_double(datum_min))){ stop("arg datum_min wrong type") }
        if(!(is_scalar_double(datum_max))){ stop("arg datum_max wrong type") }
    
    
    
        py_ans = private$py_obj$checkDatumRange(datum, datum_min, datum_max)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _TransformationModelLinear
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransformationModelLinear.html
TransformationModelLinear <- R6Class(classname = "TransformationModelLinear",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationModelLinear(libcpp_vector[TM_DataPoint] & data, Param & params)
    initialize = function(data, params){
    
    if(missing(params)){
         if( "python.builtin.object" %in% class(data) && class_to_wrap(data) == TransformationModelLinear ) { private$py_obj <- data }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        v0 <- r_to_py(data)
    
    
        private$py_obj <- Pymod$TransformationModelLinear(v0, params)
        invisible()
    }
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: void getDefaultParameters(Param &)
    getDefaultParameters = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Param")){ stop("arg in_0 wrong type") }
    
        private$py_obj$getDefaultParameters(in_0)
        invisible()
    },
    
    # C++ signature: double evaluate(double value)
    evaluate = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$evaluate(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void invert()
    invert = function(){
    
        private$py_obj$invert()
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void weightData(libcpp_vector[TM_DataPoint] & data)
    weightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$weightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool checkValidWeight(const String & weight, libcpp_vector[String] & valid_weights)
    checkValidWeight = function(weight, valid_weights){
    
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
        if(!(is_list(valid_weights) && all(sapply(valid_weights),is_scalar_character))){ stop("arg valid_weights wrong type") }
    
        v1 = r_to_py(modify_depth(valid_weights,1,py_builtin$bytes(valid_weights,'utf-8')))
        py_ans = private$py_obj$checkValidWeight(weight, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(valid_weights <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double weightDatum(double & datum, const String & weight)
    weightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$weightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double unWeightDatum(double & datum, const String & weight)
    unWeightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$unWeightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidXWeights()
    getValidXWeights = function(){
    
        py_ans = private$py_obj$getValidXWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidYWeights()
    getValidYWeights = function(){
    
        py_ans = private$py_obj$getValidYWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void unWeightData(libcpp_vector[TM_DataPoint] & data)
    unWeightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$unWeightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double checkDatumRange(const double & datum, const double & datum_min, const double & datum_max)
    checkDatumRange = function(datum, datum_min, datum_max){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!(is_scalar_double(datum_min))){ stop("arg datum_min wrong type") }
        if(!(is_scalar_double(datum_max))){ stop("arg datum_max wrong type") }
    
    
    
        py_ans = private$py_obj$checkDatumRange(datum, datum_min, datum_max)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _TransformationModelLowess
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransformationModelLowess.html
TransformationModelLowess <- R6Class(classname = "TransformationModelLowess",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationModelLowess(libcpp_vector[TM_DataPoint] & data, Param & params)
    initialize = function(data, params){
    
    if(missing(params)){
         if( "python.builtin.object" %in% class(data) && class_to_wrap(data) == TransformationModelLowess ) { private$py_obj <- data }
         else { stop("arg wrong type") }
      } else {
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
        v0 <- r_to_py(data)
    
    
        private$py_obj <- Pymod$TransformationModelLowess(v0, params)
        invisible()
    }
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
    },
    
    # C++ signature: double evaluate(double value)
    evaluate = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        py_ans = private$py_obj$evaluate(value)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void weightData(libcpp_vector[TM_DataPoint] & data)
    weightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$weightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: bool checkValidWeight(const String & weight, libcpp_vector[String] & valid_weights)
    checkValidWeight = function(weight, valid_weights){
    
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
        if(!(is_list(valid_weights) && all(sapply(valid_weights),is_scalar_character))){ stop("arg valid_weights wrong type") }
    
        v1 = r_to_py(modify_depth(valid_weights,1,py_builtin$bytes(valid_weights,'utf-8')))
        py_ans = private$py_obj$checkValidWeight(weight, v1)
        byref_1 <- modify_depth(py_to_r(v1),1,as.character)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(valid_weights <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double weightDatum(double & datum, const String & weight)
    weightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$weightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double unWeightDatum(double & datum, const String & weight)
    unWeightDatum = function(datum, weight){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!((is.R6(weight) && class(weight)[1]=="String") || is_scalar_character(weight))){ stop("arg weight wrong type") }
    
    
        py_ans = private$py_obj$unWeightDatum(datum, weight)
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidXWeights()
    getValidXWeights = function(){
    
        py_ans = private$py_obj$getValidXWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: libcpp_vector[String] getValidYWeights()
    getValidYWeights = function(){
    
        py_ans = private$py_obj$getValidYWeights()
        r_ans = modify_depth(py_ans,1,as.character)
        return(r_ans)
    },
    
    # C++ signature: void unWeightData(libcpp_vector[TM_DataPoint] & data)
    unWeightData = function(data){
    
        if(!(is_list(data) && all(sapply(data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "TM_DataPoint")))){ stop("arg data wrong type") }
        v0 <- r_to_py(data)
        private$py_obj$unWeightData(v0)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(data <- byref_0))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: double checkDatumRange(const double & datum, const double & datum_min, const double & datum_max)
    checkDatumRange = function(datum, datum_min, datum_max){
    
        if(!(is_scalar_double(datum))){ stop("arg datum wrong type") }
        if(!(is_scalar_double(datum_min))){ stop("arg datum_min wrong type") }
        if(!(is_scalar_double(datum_max))){ stop("arg datum_max wrong type") }
    
    
    
        py_ans = private$py_obj$checkDatumRange(datum, datum_min, datum_max)
        r_ans = py_ans
        return(r_ans)
    }
)
)
    
    # C++ signature: void getDefaultParameters(Param & params)
    TransformationModelLowess$getDefaultParameters = function(params){
    
        if(!(is.R6(params) && class(params)[1] == "Param")){ stop("arg params wrong type") }
    
        Pymod$TransformationModelLowess$getDefaultParameters(params)
    } 

# R implementation of _TransformationStatistics
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::TransformationDescription_1_1TransformationStatistics.html
TransformationStatistics <- R6Class(classname = "TransformationStatistics",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        xmin = function(xmin){
    
        if(!missing(xmin)){
            if(!(is_scalar_double(xmin))){ stop("arg xmin wrong type") }
        
        
            private$py_obj$xmin <- xmin
            } else {
        
                py_ans = private$py_obj$xmin
                r_result = py_ans
                return(r_result)
                }
        },
        xmax = function(xmax){
    
        if(!missing(xmax)){
            if(!(is_scalar_double(xmax))){ stop("arg xmax wrong type") }
        
        
            private$py_obj$xmax <- xmax
            } else {
        
                py_ans = private$py_obj$xmax
                r_result = py_ans
                return(r_result)
                }
        },
        ymin = function(ymin){
    
        if(!missing(ymin)){
            if(!(is_scalar_double(ymin))){ stop("arg ymin wrong type") }
        
        
            private$py_obj$ymin <- ymin
            } else {
        
                py_ans = private$py_obj$ymin
                r_result = py_ans
                return(r_result)
                }
        },
        ymax = function(ymax){
    
        if(!missing(ymax)){
            if(!(is_scalar_double(ymax))){ stop("arg ymax wrong type") }
        
        
            private$py_obj$ymax <- ymax
            } else {
        
                py_ans = private$py_obj$ymax
                r_result = py_ans
                return(r_result)
                }
        },
        percentiles_before = function(percentiles_before){
    
        if(!missing(percentiles_before)){
            if(!(
          is.environment(percentiles_before) && identical(parent.env(percentiles_before), asNamespace("collections")) && identical(strsplit(capture.output(percentiles_before$print())," ")[[1]][1], "dict")
          && all(sapply(percentiles_before$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(percentiles_before$values(),function(v) is_scalar_double(v)))
          )){ stop("arg percentiles_before wrong type") }
        
            v0 <- py_dict(as.integer(percentiles_before$keys()),percentiles_before$values())
            private$py_obj$percentiles_before <- v0
            } else {
        
                py_ans = private$py_obj$percentiles_before
            r_result <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),py_to_r(py_builtin$list(py_ans$keys())))
                return(r_result)
                }
        },
        percentiles_after = function(percentiles_after){
    
        if(!missing(percentiles_after)){
            if(!(
          is.environment(percentiles_after) && identical(parent.env(percentiles_after), asNamespace("collections")) && identical(strsplit(capture.output(percentiles_after$print())," ")[[1]][1], "dict")
          && all(sapply(percentiles_after$keys(),function(k)  (is_scalar_integer(k) || is_scalar_double(k)) && k == as.integer(k)))
          && all(sapply(percentiles_after$values(),function(v) is_scalar_double(v)))
          )){ stop("arg percentiles_after wrong type") }
        
            v0 <- py_dict(as.integer(percentiles_after$keys()),percentiles_after$values())
            private$py_obj$percentiles_after <- v0
            } else {
        
                py_ans = private$py_obj$percentiles_after
            r_result <- collections::dict(py_to_r(py_builtin$list(py_ans$values())),py_to_r(py_builtin$list(py_ans$keys())))
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void TransformationStatistics()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TransformationStatistics()
        invisible()
    
    
    },
    
    # C++ signature: void TransformationStatistics(TransformationStatistics)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TransformationStatistics")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TransformationStatistics(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TransformationStatistics()
    # C++ signature: void TransformationStatistics(TransformationStatistics)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TransformationStatistics")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TransformationStatistics" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _TransformationXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransformationXMLFile.html
TransformationXMLFile <- R6Class(classname = "TransformationXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransformationXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TransformationXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TransformationXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String, TransformationDescription &, bool fit_model)
    load = function(in_0, in_1, fit_model){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
        if(!( (is_scalar_integer(fit_model) || is_scalar_double(fit_model)) && fit_model == as.integer(fit_model))){ stop("arg fit_model wrong type") }
    
    
    
        private$py_obj$load(in_0, in_1, as.integer(fit_model))
        invisible()
    },
    
    # C++ signature: void store(String, TransformationDescription)
    store = function(in_0, in_1){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
        if(!(is.R6(in_1) && class(in_1)[1] == "TransformationDescription")){ stop("arg in_1 wrong type") }
    
    
        private$py_obj$store(in_0, in_1)
        invisible()
    }
)
) 

# R implementation of _TransitionPQPFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransitionPQPFile.html
TransitionPQPFile <- R6Class(classname = "TransitionPQPFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransitionPQPFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TransitionPQPFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TransitionPQPFile()
        invisible()
    }
    
    },
    
    # C++ signature: void convertTargetedExperimentToPQP(char * filename, TargetedExperiment & targeted_exp)
    convertTargetedExperimentToPQP = function(filename, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
        private$py_obj$convertTargetedExperimentToPQP(filename, targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertPQPToTargetedExperiment(char * filename, TargetedExperiment & targeted_exp, bool legacy_traml_id)
    convertPQPToTargetedExperiment_0 = function(filename, targeted_exp, legacy_traml_id){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
        if(!( (is_scalar_integer(legacy_traml_id) || is_scalar_double(legacy_traml_id)) && legacy_traml_id == as.integer(legacy_traml_id))){ stop("arg legacy_traml_id wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertPQPToTargetedExperiment_0`(filename, targeted_exp, as.integer(legacy_traml_id))
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertPQPToTargetedExperiment(char * filename, LightTargetedExperiment & targeted_exp, bool legacy_traml_id)
    convertPQPToTargetedExperiment_1 = function(filename, targeted_exp, legacy_traml_id){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "LightTargetedExperiment")){ stop("arg targeted_exp wrong type") }
        if(!( (is_scalar_integer(legacy_traml_id) || is_scalar_double(legacy_traml_id)) && legacy_traml_id == as.integer(legacy_traml_id))){ stop("arg legacy_traml_id wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertPQPToTargetedExperiment_1`(filename, targeted_exp, as.integer(legacy_traml_id))
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertPQPToTargetedExperiment(char * filename, TargetedExperiment & targeted_exp, bool legacy_traml_id)
    # C++ signature: void convertPQPToTargetedExperiment(char * filename, LightTargetedExperiment & targeted_exp, bool legacy_traml_id)
    convertPQPToTargetedExperiment = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "TargetedExperiment") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$convertPQPToTargetedExperiment_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (is.R6(arg_list[[2]]) && class(arg_list[[2]])[1] == "LightTargetedExperiment") && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]]))) { self$convertPQPToTargetedExperiment_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void convertTargetedExperimentToTSV(char * filename, TargetedExperiment & targeted_exp)
    convertTargetedExperimentToTSV = function(filename, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
        private$py_obj$convertTargetedExperimentToTSV(filename, targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, TargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment_0 = function(filename, filetype, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(filetype %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg filetype wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertTSVToTargetedExperiment_0`(filename, as.integer(filetype), targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, LightTargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment_1 = function(filename, filetype, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(filetype %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg filetype wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "LightTargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertTSVToTargetedExperiment_1`(filename, as.integer(filetype), targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, TargetedExperiment & targeted_exp)
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, LightTargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (arg_list[[2]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "TargetedExperiment")) { self$convertTSVToTargetedExperiment_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (arg_list[[2]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "LightTargetedExperiment")) { self$convertTSVToTargetedExperiment_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void validateTargetedExperiment(TargetedExperiment targeted_exp)
    validateTargetedExperiment = function(targeted_exp){
    
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    
        private$py_obj$validateTargetedExperiment(targeted_exp)
        invisible()
    }
)
) 

# R implementation of _TransitionTSVFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TransitionTSVFile.html
TransitionTSVFile <- R6Class(classname = "TransitionTSVFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TransitionTSVFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == TransitionTSVFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$TransitionTSVFile()
        invisible()
    }
    
    },
    
    # C++ signature: void convertTargetedExperimentToTSV(char * filename, TargetedExperiment & targeted_exp)
    convertTargetedExperimentToTSV = function(filename, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
        private$py_obj$convertTargetedExperimentToTSV(filename, targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, TargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment_0 = function(filename, filetype, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(filetype %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg filetype wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertTSVToTargetedExperiment_0`(filename, as.integer(filetype), targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, LightTargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment_1 = function(filename, filetype, targeted_exp){
    
        if(!(is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(filetype %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))){ stop("arg filetype wrong type") }
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "LightTargetedExperiment")){ stop("arg targeted_exp wrong type") }
    py_run_string("filename = bytes(filename)")
    
    
        private$py_obj$`_convertTSVToTargetedExperiment_1`(filename, as.integer(filetype), targeted_exp)
        py_run_string("del filename")
        invisible()
    },
    
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, TargetedExperiment & targeted_exp)
    # C++ signature: void convertTSVToTargetedExperiment(char * filename, FileType filetype, LightTargetedExperiment & targeted_exp)
    convertTSVToTargetedExperiment = function(...){
        arg_list = list(...)
        if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (arg_list[[2]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "TargetedExperiment")) { self$convertTSVToTargetedExperiment_0(...) }
        else if ((length(arg_list)==3) && (is_scalar_character(arg_list[[1]])) && (arg_list[[2]] %in% c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "LightTargetedExperiment")) { self$convertTSVToTargetedExperiment_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: void validateTargetedExperiment(TargetedExperiment targeted_exp)
    validateTargetedExperiment = function(targeted_exp){
    
        if(!(is.R6(targeted_exp) && class(targeted_exp)[1] == "TargetedExperiment")){ stop("arg targeted_exp wrong type") }
    
        private$py_obj$validateTargetedExperiment(targeted_exp)
        invisible()
    },
    
    # C++ signature: void setLogType(LogType)
    setLogType = function(in_0){
    
        if(!(in_0 %in% c(0, 1, 2))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setLogType(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: LogType getLogType()
    getLogType = function(){
    
        py_ans = private$py_obj$getLogType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void startProgress(ptrdiff_t begin, ptrdiff_t end, String label)
    startProgress = function(begin, end, label){
    
        if(!( (is_scalar_integer(begin) || is_scalar_double(begin)) && begin == as.integer(begin))){ stop("arg begin wrong type") }
        if(!( (is_scalar_integer(end) || is_scalar_double(end)) && end == as.integer(end))){ stop("arg end wrong type") }
        if(!((is.R6(label) && class(label)[1]=="String") || is_scalar_character(label))){ stop("arg label wrong type") }
    
    
    
        private$py_obj$startProgress(as.integer(begin), as.integer(end), label)
        invisible()
    },
    
    # C++ signature: void setProgress(ptrdiff_t value)
    setProgress = function(value){
    
        if(!( (is_scalar_integer(value) || is_scalar_double(value)) && value == as.integer(value))){ stop("arg value wrong type") }
    
        private$py_obj$setProgress(as.integer(value))
        invisible()
    },
    
    # C++ signature: void endProgress()
    endProgress = function(){
    
        private$py_obj$endProgress()
        invisible()
    },
    
    # C++ signature: void nextProgress()
    nextProgress = function(){
    
        private$py_obj$nextProgress()
        invisible()
    }
)
) 

# R implementation of _TwoDOptimization
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1TwoDOptimization.html
TwoDOptimization <- R6Class(classname = "TwoDOptimization",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void TwoDOptimization()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$TwoDOptimization()
        invisible()
    
    
    },
    
    # C++ signature: void TwoDOptimization(TwoDOptimization)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "TwoDOptimization")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$TwoDOptimization(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void TwoDOptimization()
    # C++ signature: void TwoDOptimization(TwoDOptimization)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "TwoDOptimization")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "TwoDOptimization" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: double getMZTolerance()
    getMZTolerance = function(){
    
        py_ans = private$py_obj$getMZTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMZTolerance(double tolerance_mz)
    setMZTolerance = function(tolerance_mz){
    
        if(!(is_scalar_double(tolerance_mz))){ stop("arg tolerance_mz wrong type") }
    
        private$py_obj$setMZTolerance(tolerance_mz)
        invisible()
    },
    
    # C++ signature: double getMaxPeakDistance()
    getMaxPeakDistance = function(){
    
        py_ans = private$py_obj$getMaxPeakDistance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxPeakDistance(double max_peak_distance)
    setMaxPeakDistance = function(max_peak_distance){
    
        if(!(is_scalar_double(max_peak_distance))){ stop("arg max_peak_distance wrong type") }
    
        private$py_obj$setMaxPeakDistance(max_peak_distance)
        invisible()
    },
    
    # C++ signature: unsigned int getMaxIterations()
    getMaxIterations = function(){
    
        py_ans = private$py_obj$getMaxIterations()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxIterations(unsigned int max_iteration)
    setMaxIterations = function(max_iteration){
    
        if(!( (is_scalar_integer(max_iteration) || is_scalar_double(max_iteration)) && max_iteration == as.integer(max_iteration))){ stop("arg max_iteration wrong type") }
    
        private$py_obj$setMaxIterations(as.integer(max_iteration))
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _UnimodXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1UnimodXMLFile.html
UnimodXMLFile <- R6Class(classname = "UnimodXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void UnimodXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == UnimodXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$UnimodXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _UniqueIdGenerator
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1UniqueIdGenerator.html
UniqueIdGenerator <- R6Class(classname = "UniqueIdGenerator",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: unsigned long int getUniqueId()
    getUniqueId = function(){
    
        py_ans = private$py_obj$getUniqueId()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSeed(unsigned long int)
    setSeed = function(in_0){
    
        if(!( (is_scalar_integer(in_0) || is_scalar_double(in_0)) && in_0 == as.integer(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setSeed(as.integer(in_0))
        invisible()
    },
    
    # C++ signature: unsigned long int getSeed()
    getSeed = function(){
    
        py_ans = private$py_obj$getSeed()
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _Unit
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1Unit.html
Unit <- R6Class(classname = "Unit",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        accession = function(accession){
    
        if(!missing(accession)){
            if(!((is.R6(accession) && class(accession)[1]=="String") || is_scalar_character(accession))){ stop("arg accession wrong type") }
        
        
            private$py_obj$accession <- accession
            } else {
        
                py_ans = private$py_obj$accession
            r_result = py_ans
                return(r_result)
                }
        },
        name = function(name){
    
        if(!missing(name)){
            if(!((is.R6(name) && class(name)[1]=="String") || is_scalar_character(name))){ stop("arg name wrong type") }
        
        
            private$py_obj$name <- name
            } else {
        
                py_ans = private$py_obj$name
            r_result = py_ans
                return(r_result)
                }
        },
        cv_ref = function(cv_ref){
    
        if(!missing(cv_ref)){
            if(!((is.R6(cv_ref) && class(cv_ref)[1]=="String") || is_scalar_character(cv_ref))){ stop("arg cv_ref wrong type") }
        
        
            private$py_obj$cv_ref <- cv_ref
            } else {
        
                py_ans = private$py_obj$cv_ref
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void Unit()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Unit()
        invisible()
    
    
    },
    
    # C++ signature: void Unit(Unit)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Unit")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Unit(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void Unit(const String & p_accession, const String & p_name, const String & p_cv_ref)
    init_2 = function(p_accession, p_name, p_cv_ref){
    
        if(!((is.R6(p_accession) && class(p_accession)[1]=="String") || is_scalar_character(p_accession))){ stop("arg p_accession wrong type") }
        if(!((is.R6(p_name) && class(p_name)[1]=="String") || is_scalar_character(p_name))){ stop("arg p_name wrong type") }
        if(!((is.R6(p_cv_ref) && class(p_cv_ref)[1]=="String") || is_scalar_character(p_cv_ref))){ stop("arg p_cv_ref wrong type") }
    
    
    
    
        private$py_obj <- Pymod$Unit(p_accession, p_name, p_cv_ref)
        invisible()
    
    
    },
    
    # C++ signature: void Unit()
    # C++ signature: void Unit(Unit)
    # C++ signature: void Unit(const String & p_accession, const String & p_name, const String & p_cv_ref)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Unit")) { self$init_1(...) }
        else if ((length(arg_list)==3) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && ((is.R6(arg_list[[3]]) && class(arg_list[[3]])[1]=="String") || is_scalar_character(arg_list[[3]]))) { self$init_2(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Unit" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _VersionDetails
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1VersionDetails.html
VersionDetails <- R6Class(classname = "VersionDetails",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        version_major = function(version_major){
    
        if(!missing(version_major)){
            if(!( (is_scalar_integer(version_major) || is_scalar_double(version_major)) && version_major == as.integer(version_major))){ stop("arg version_major wrong type") }
        
        
            private$py_obj$version_major <- as.integer(version_major)
            } else {
        
                py_ans = private$py_obj$version_major
                r_result = py_ans
                return(r_result)
                }
        },
        version_minor = function(version_minor){
    
        if(!missing(version_minor)){
            if(!( (is_scalar_integer(version_minor) || is_scalar_double(version_minor)) && version_minor == as.integer(version_minor))){ stop("arg version_minor wrong type") }
        
        
            private$py_obj$version_minor <- as.integer(version_minor)
            } else {
        
                py_ans = private$py_obj$version_minor
                r_result = py_ans
                return(r_result)
                }
        },
        version_patch = function(version_patch){
    
        if(!missing(version_patch)){
            if(!( (is_scalar_integer(version_patch) || is_scalar_double(version_patch)) && version_patch == as.integer(version_patch))){ stop("arg version_patch wrong type") }
        
        
            private$py_obj$version_patch <- as.integer(version_patch)
            } else {
        
                py_ans = private$py_obj$version_patch
                r_result = py_ans
                return(r_result)
                }
        },
        pre_release_identifier = function(pre_release_identifier){
    
        if(!missing(pre_release_identifier)){
            if(!((is.R6(pre_release_identifier) && class(pre_release_identifier)[1]=="String") || is_scalar_character(pre_release_identifier))){ stop("arg pre_release_identifier wrong type") }
        
        
            private$py_obj$pre_release_identifier <- pre_release_identifier
            } else {
        
                py_ans = private$py_obj$pre_release_identifier
            r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void VersionDetails()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == VersionDetails) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$VersionDetails()
        invisible()
    }
    
    }
)
)
    
    # C++ signature: VersionDetails create(String)
    VersionDetails$create = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        py_ans = Pymod$VersionDetails$create(in_0)
        r_ans = VersionDetails$new(py_ans)
        return(r_ans)
    } 

# R implementation of _VersionInfo
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1VersionInfo.html
VersionInfo <- R6Class(classname = "VersionInfo",cloneable = FALSE,

    private = list(py_obj = NA)

)
    
    # C++ signature: String getBranch()
    VersionInfo$getBranch = function(){
    
        py_ans = Pymod$VersionInfo$getBranch()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getRevision()
    VersionInfo$getRevision = function(){
    
        py_ans = Pymod$VersionInfo$getRevision()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getTime()
    VersionInfo$getTime = function(){
    
        py_ans = Pymod$VersionInfo$getTime()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: String getVersion()
    VersionInfo$getVersion = function(){
    
        py_ans = Pymod$VersionInfo$getVersion()
        r_ans = py_ans
        return(r_ans)
    }
    
    # C++ signature: VersionDetails getVersionStruct()
    VersionInfo$getVersionStruct = function(){
    
        py_ans = Pymod$VersionInfo$getVersionStruct()
        r_ans = VersionDetails$new(py_ans)
        return(r_ans)
    } 

# R implementation of _WindowMower
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1WindowMower.html
WindowMower <- R6Class(classname = "WindowMower",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void WindowMower()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == WindowMower) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$WindowMower()
        invisible()
    }
    
    },
    
    # C++ signature: void filterPeakSpectrumForTopNInSlidingWindow(MSSpectrum & spectrum)
# sliding window version (slower)
    filterPeakSpectrumForTopNInSlidingWindow = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$filterPeakSpectrumForTopNInSlidingWindow(spectrum)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrumForTopNInJumpingWindow(MSSpectrum & spectrum)
# jumping window version (faster)
    filterPeakSpectrumForTopNInJumpingWindow = function(spectrum){
    
        if(!(is.R6(spectrum) && class(spectrum)[1] == "MSSpectrum")){ stop("arg spectrum wrong type") }
    
        private$py_obj$filterPeakSpectrumForTopNInJumpingWindow(spectrum)
        invisible()
    },
    
    # C++ signature: void filterPeakSpectrum(MSSpectrum & spec)
    filterPeakSpectrum = function(spec){
    
        if(!(is.R6(spec) && class(spec)[1] == "MSSpectrum")){ stop("arg spec wrong type") }
    
        private$py_obj$filterPeakSpectrum(spec)
        invisible()
    },
    
    # C++ signature: void filterPeakMap(MSExperiment & exp)
    filterPeakMap = function(exp){
    
        if(!(is.R6(exp) && class(exp)[1] == "MSExperiment")){ stop("arg exp wrong type") }
    
        private$py_obj$filterPeakMap(exp)
        invisible()
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _XFDRAlgorithm
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XFDRAlgorithm.html
XFDRAlgorithm <- R6Class(classname = "XFDRAlgorithm",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XFDRAlgorithm()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == XFDRAlgorithm) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$XFDRAlgorithm()
        invisible()
    }
    
    },
    
    # C++ signature: XFDRAlgorithm_ExitCodes run(libcpp_vector[PeptideIdentification] & peptide_ids, ProteinIdentification & protein_id)
    run = function(peptide_ids, protein_id){
    
        if(!(is_list(peptide_ids) && all(sapply(peptide_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peptide_ids wrong type") }
        if(!(is.R6(protein_id) && class(protein_id)[1] == "ProteinIdentification")){ stop("arg protein_id wrong type") }
        v0 <- r_to_py(peptide_ids)
    
        py_ans = private$py_obj$run(v0, protein_id)
        byref_0 <- map(py_to_r(v0),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(peptide_ids <- byref_0))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: XFDRAlgorithm_ExitCodes validateClassArguments()
    validateClassArguments = function(){
    
        py_ans = private$py_obj$validateClassArguments()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setParameters(Param & param)
    setParameters = function(param){
    
        if(!(is.R6(param) && class(param)[1] == "Param")){ stop("arg param wrong type") }
    
        private$py_obj$setParameters(param)
        invisible()
    },
    
    # C++ signature: Param getParameters()
    getParameters = function(){
    
        py_ans = private$py_obj$getParameters()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: Param getDefaults()
    getDefaults = function(){
    
        py_ans = private$py_obj$getDefaults()
        r_ans = Param$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: String getName()
    getName = function(){
    
        py_ans = private$py_obj$getName()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setName(const String &)
    setName = function(in_0){
    
        if(!((is.R6(in_0) && class(in_0)[1]=="String") || is_scalar_character(in_0))){ stop("arg in_0 wrong type") }
    
        private$py_obj$setName(in_0)
        invisible()
    }
)
) 

# R implementation of _XLPrecursor
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XLPrecursor.html
XLPrecursor <- R6Class(classname = "XLPrecursor",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        precursor_mass = function(precursor_mass){
    
        if(!missing(precursor_mass)){
            if(!(is_scalar_double(precursor_mass))){ stop("arg precursor_mass wrong type") }
        
        
            private$py_obj$precursor_mass <- precursor_mass
            } else {
        
                py_ans = private$py_obj$precursor_mass
                r_result = py_ans
                return(r_result)
                }
        },
        alpha_index = function(alpha_index){
    
        if(!missing(alpha_index)){
            if(!( (is_scalar_integer(alpha_index) || is_scalar_double(alpha_index)) && alpha_index == as.integer(alpha_index))){ stop("arg alpha_index wrong type") }
        
        
            private$py_obj$alpha_index <- as.integer(alpha_index)
            } else {
        
                py_ans = private$py_obj$alpha_index
                r_result = py_ans
                return(r_result)
                }
        },
        beta_index = function(beta_index){
    
        if(!missing(beta_index)){
            if(!( (is_scalar_integer(beta_index) || is_scalar_double(beta_index)) && beta_index == as.integer(beta_index))){ stop("arg beta_index wrong type") }
        
        
            private$py_obj$beta_index <- as.integer(beta_index)
            } else {
        
                py_ans = private$py_obj$beta_index
                r_result = py_ans
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void XLPrecursor(XLPrecursor)
    init_0 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "XLPrecursor")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$XLPrecursor(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void XLPrecursor()
    init_1 = function(){
    
    
        private$py_obj <- Pymod$XLPrecursor()
        invisible()
    
    
    },
    
    # C++ signature: void XLPrecursor(XLPrecursor)
    # C++ signature: void XLPrecursor()
    initialize = function(...){
        arg_list = list(...)
        if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "XLPrecursor")) { self$init_0(...) }
        else if (length(arg_list)==0) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "XLPrecursor" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _XMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1XMLFile.html
XMLFile <- R6Class(classname = "XMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XMLFile()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$XMLFile()
        invisible()
    
    
    },
    
    # C++ signature: void XMLFile(const String & schema_location, const String & version)
    init_1 = function(schema_location, version){
    
        if(!((is.R6(schema_location) && class(schema_location)[1]=="String") || is_scalar_character(schema_location))){ stop("arg schema_location wrong type") }
        if(!((is.R6(version) && class(version)[1]=="String") || is_scalar_character(version))){ stop("arg version wrong type") }
    
    
    
        private$py_obj <- Pymod$XMLFile(schema_location, version)
        invisible()
    
    
    },
    
    # C++ signature: void XMLFile()
    # C++ signature: void XMLFile(const String & schema_location, const String & version)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==2) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]]))) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "XMLFile" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _XMLHandler
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Internal_1_1XMLHandler.html
XMLHandler <- R6Class(classname = "XMLHandler",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XMLHandler(const String & filename, const String & version)
    initialize = function(filename, version){
    
    if(missing(version)){
         if( "python.builtin.object" %in% class(filename) && class_to_wrap(filename) == XMLHandler ) { private$py_obj <- filename }
         else { stop("arg wrong type") }
      } else {
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!((is.R6(version) && class(version)[1]=="String") || is_scalar_character(version))){ stop("arg version wrong type") }
    
    
    
        private$py_obj <- Pymod$XMLHandler(filename, version)
        invisible()
    }
    
    },
    
    # C++ signature: void reset()
    reset = function(){
    
        private$py_obj$reset()
        invisible()
    },
    
    # C++ signature: void error(ActionMode mode, const String & msg, unsigned int line, unsigned int column)
    error = function(mode, msg, line, column){
    
        if(!(mode %in% c(0, 1))){ stop("arg mode wrong type") }
        if(!((is.R6(msg) && class(msg)[1]=="String") || is_scalar_character(msg))){ stop("arg msg wrong type") }
        if(!( (is_scalar_integer(line) || is_scalar_double(line)) && line == as.integer(line))){ stop("arg line wrong type") }
        if(!( (is_scalar_integer(column) || is_scalar_double(column)) && column == as.integer(column))){ stop("arg column wrong type") }
    
    
    
    
        private$py_obj$error(as.integer(mode), msg, as.integer(line), as.integer(column))
        invisible()
    },
    
    # C++ signature: void warning(ActionMode mode, const String & msg, unsigned int line, unsigned int column)
    warning = function(mode, msg, line, column){
    
        if(!(mode %in% c(0, 1))){ stop("arg mode wrong type") }
        if(!((is.R6(msg) && class(msg)[1]=="String") || is_scalar_character(msg))){ stop("arg msg wrong type") }
        if(!( (is_scalar_integer(line) || is_scalar_double(line)) && line == as.integer(line))){ stop("arg line wrong type") }
        if(!( (is_scalar_integer(column) || is_scalar_double(column)) && column == as.integer(column))){ stop("arg column wrong type") }
    
    
    
    
        private$py_obj$warning(as.integer(mode), msg, as.integer(line), as.integer(column))
        invisible()
    },
    
    # C++ signature: String errorString()
    errorString = function(){
    
        py_ans = private$py_obj$errorString()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _XQuestResultXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XQuestResultXMLFile.html
XQuestResultXMLFile <- R6Class(classname = "XQuestResultXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XQuestResultXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == XQuestResultXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$XQuestResultXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(const String & filename, libcpp_vector[PeptideIdentification] & pep_ids, libcpp_vector[ProteinIdentification] & prot_ids)
    load = function(filename, pep_ids, prot_ids){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(pep_ids) && all(sapply(pep_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg pep_ids wrong type") }
        if(!(is_list(prot_ids) && all(sapply(prot_ids,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg prot_ids wrong type") }
    
        v1 <- r_to_py(pep_ids)
        v2 <- r_to_py(prot_ids)
        private$py_obj$load(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(pep_ids <- byref_1))
        eval.parent(substitute(prot_ids <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: void store(const String & filename, libcpp_vector[ProteinIdentification] & poid, libcpp_vector[PeptideIdentification] & peid)
    store = function(filename, poid, peid){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is_list(poid) && all(sapply(poid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "ProteinIdentification")))){ stop("arg poid wrong type") }
        if(!(is_list(peid) && all(sapply(peid,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg peid wrong type") }
    
        v1 <- r_to_py(poid)
        v2 <- r_to_py(peid)
        private$py_obj$store(filename, v1, v2)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
        byref_1 <- map(py_to_r(v1),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(poid <- byref_1))
        eval.parent(substitute(peid <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    },
    
    # C++ signature: int getNumberOfHits()
    getNumberOfHits = function(){
    
        py_ans = private$py_obj$getNumberOfHits()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMinScore()
    getMinScore = function(){
    
        py_ans = private$py_obj$getMinScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double getMaxScore()
    getMaxScore = function(){
    
        py_ans = private$py_obj$getMaxScore()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void writeXQuestXMLSpec(const String & out_file, const String & base_name, OPXL_PreprocessedPairSpectra preprocessed_pair_spectra, libcpp_vector[libcpp_pair[size_t,size_t]] spectrum_pairs, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] all_top_csms, MSExperiment spectra)
    writeXQuestXMLSpec_0 = function(out_file, base_name, preprocessed_pair_spectra, spectrum_pairs, all_top_csms, spectra){
    
        if(!((is.R6(out_file) && class(out_file)[1]=="String") || is_scalar_character(out_file))){ stop("arg out_file wrong type") }
        if(!((is.R6(base_name) && class(base_name)[1]=="String") || is_scalar_character(base_name))){ stop("arg base_name wrong type") }
        if(!(is.R6(preprocessed_pair_spectra) && class(preprocessed_pair_spectra)[1] == "OPXL_PreprocessedPairSpectra")){ stop("arg preprocessed_pair_spectra wrong type") }
        if(!(is_list(spectrum_pairs) && all(sapply(spectrum_pairs,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg spectrum_pairs wrong type") }
        if(!(is_list(all_top_csms) && all(sapply(all_top_csms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch")))))){ stop("arg all_top_csms wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
    
    
        v3 <- r_to_py(spectrum_pairs)
        v4 <- r_to_py(all_top_csms)
    
        private$py_obj$`_writeXQuestXMLSpec_0`(out_file, base_name, preprocessed_pair_spectra, v3, v4, spectra)
        
        
        invisible()
    },
    
    # C++ signature: void writeXQuestXMLSpec(const String & out_file, const String & base_name, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] all_top_csms, MSExperiment spectra)
    writeXQuestXMLSpec_1 = function(out_file, base_name, all_top_csms, spectra){
    
        if(!((is.R6(out_file) && class(out_file)[1]=="String") || is_scalar_character(out_file))){ stop("arg out_file wrong type") }
        if(!((is.R6(base_name) && class(base_name)[1]=="String") || is_scalar_character(base_name))){ stop("arg base_name wrong type") }
        if(!(is_list(all_top_csms) && all(sapply(all_top_csms,function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch")))))){ stop("arg all_top_csms wrong type") }
        if(!(is.R6(spectra) && class(spectra)[1] == "MSExperiment")){ stop("arg spectra wrong type") }
    
    
        v2 <- r_to_py(all_top_csms)
    
        private$py_obj$`_writeXQuestXMLSpec_1`(out_file, base_name, v2, spectra)
        
        invisible()
    },
    
    # C++ signature: void writeXQuestXMLSpec(const String & out_file, const String & base_name, OPXL_PreprocessedPairSpectra preprocessed_pair_spectra, libcpp_vector[libcpp_pair[size_t,size_t]] spectrum_pairs, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] all_top_csms, MSExperiment spectra)
    # C++ signature: void writeXQuestXMLSpec(const String & out_file, const String & base_name, libcpp_vector[libcpp_vector[CrossLinkSpectrumMatch]] all_top_csms, MSExperiment spectra)
    writeXQuestXMLSpec = function(...){
        arg_list = list(...)
        if ((length(arg_list)==6) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (is.R6(arg_list[[3]]) && class(arg_list[[3]])[1] == "OPXL_PreprocessedPairSpectra") && (is_list(arg_list[[4]]) && all(sapply(arg_list[[4]],function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]])))) && (is_list(arg_list[[5]]) && all(sapply(arg_list[[5]],function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch"))))) && (is.R6(arg_list[[6]]) && class(arg_list[[6]])[1] == "MSExperiment")) { self$writeXQuestXMLSpec_0(...) }
        else if ((length(arg_list)==4) && ((is.R6(arg_list[[1]]) && class(arg_list[[1]])[1]=="String") || is_scalar_character(arg_list[[1]])) && ((is.R6(arg_list[[2]]) && class(arg_list[[2]])[1]=="String") || is_scalar_character(arg_list[[2]])) && (is_list(arg_list[[3]]) && all(sapply(arg_list[[3]],function(elemt_rec) is_list(elemt_rec) && all(sapply(elemt_rec,function(elemt_rec_rec) is.R6(elemt_rec_rec) && class(elemt_rec_rec)[1] == "CrossLinkSpectrumMatch"))))) && (is.R6(arg_list[[4]]) && class(arg_list[[4]])[1] == "MSExperiment")) { self$writeXQuestXMLSpec_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: String getVersion()
    getVersion = function(){
    
        py_ans = private$py_obj$getVersion()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _XQuestScores
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XQuestScores.html
XQuestScores <- R6Class(classname = "XQuestScores",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: float preScore(size_t matched_alpha, size_t ions_alpha, size_t matched_beta, size_t ions_beta)
    preScore_0 = function(matched_alpha, ions_alpha, matched_beta, ions_beta){
    
        if(!( (is_scalar_integer(matched_alpha) || is_scalar_double(matched_alpha)) && matched_alpha == as.integer(matched_alpha))){ stop("arg matched_alpha wrong type") }
        if(!( (is_scalar_integer(ions_alpha) || is_scalar_double(ions_alpha)) && ions_alpha == as.integer(ions_alpha))){ stop("arg ions_alpha wrong type") }
        if(!( (is_scalar_integer(matched_beta) || is_scalar_double(matched_beta)) && matched_beta == as.integer(matched_beta))){ stop("arg matched_beta wrong type") }
        if(!( (is_scalar_integer(ions_beta) || is_scalar_double(ions_beta)) && ions_beta == as.integer(ions_beta))){ stop("arg ions_beta wrong type") }
    
    
    
    
        py_ans = private$py_obj$`_preScore_0`(as.integer(matched_alpha), as.integer(ions_alpha), as.integer(matched_beta), as.integer(ions_beta))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float preScore(size_t matched_alpha, size_t ions_alpha)
    preScore_1 = function(matched_alpha, ions_alpha){
    
        if(!( (is_scalar_integer(matched_alpha) || is_scalar_double(matched_alpha)) && matched_alpha == as.integer(matched_alpha))){ stop("arg matched_alpha wrong type") }
        if(!( (is_scalar_integer(ions_alpha) || is_scalar_double(ions_alpha)) && ions_alpha == as.integer(ions_alpha))){ stop("arg ions_alpha wrong type") }
    
    
        py_ans = private$py_obj$`_preScore_1`(as.integer(matched_alpha), as.integer(ions_alpha))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: float preScore(size_t matched_alpha, size_t ions_alpha, size_t matched_beta, size_t ions_beta)
    # C++ signature: float preScore(size_t matched_alpha, size_t ions_alpha)
    preScore = function(...){
        arg_list = list(...)
        if ((length(arg_list)==4) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]])) && ( (is_scalar_integer(arg_list[[3]]) || is_scalar_double(arg_list[[3]])) && arg_list[[3]] == as.integer(arg_list[[3]])) && ( (is_scalar_integer(arg_list[[4]]) || is_scalar_double(arg_list[[4]])) && arg_list[[4]] == as.integer(arg_list[[4]]))) { self$preScore_0(...) }
        else if ((length(arg_list)==2) && ( (is_scalar_integer(arg_list[[1]]) || is_scalar_double(arg_list[[1]])) && arg_list[[1]] == as.integer(arg_list[[1]])) && ( (is_scalar_integer(arg_list[[2]]) || is_scalar_double(arg_list[[2]])) && arg_list[[2]] == as.integer(arg_list[[2]]))) { self$preScore_1(...) }
        else {
              stop("wrong arguments provided")
        }
    
    },
    
    # C++ signature: double matchOddsScore(MSSpectrum & theoretical_spec, double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm, bool is_xlink_spectrum, size_t n_charges)
    matchOddsScore = function(theoretical_spec, fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm, is_xlink_spectrum, n_charges){
    
        if(!(is.R6(theoretical_spec) && class(theoretical_spec)[1] == "MSSpectrum")){ stop("arg theoretical_spec wrong type") }
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
        if(!( (is_scalar_integer(is_xlink_spectrum) || is_scalar_double(is_xlink_spectrum)) && is_xlink_spectrum == as.integer(is_xlink_spectrum))){ stop("arg is_xlink_spectrum wrong type") }
        if(!( (is_scalar_integer(n_charges) || is_scalar_double(n_charges)) && n_charges == as.integer(n_charges))){ stop("arg n_charges wrong type") }
    
    
    
    
    
        py_ans = private$py_obj$matchOddsScore(theoretical_spec, fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm), as.integer(is_xlink_spectrum), as.integer(n_charges))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double logOccupancyProb(MSSpectrum theoretical_spec, size_t matched_size, double fragment_mass_tolerance, bool fragment_mass_tolerance_unit_ppm)
    logOccupancyProb = function(theoretical_spec, matched_size, fragment_mass_tolerance, fragment_mass_tolerance_unit_ppm){
    
        if(!(is.R6(theoretical_spec) && class(theoretical_spec)[1] == "MSSpectrum")){ stop("arg theoretical_spec wrong type") }
        if(!( (is_scalar_integer(matched_size) || is_scalar_double(matched_size)) && matched_size == as.integer(matched_size))){ stop("arg matched_size wrong type") }
        if(!(is_scalar_double(fragment_mass_tolerance))){ stop("arg fragment_mass_tolerance wrong type") }
        if(!( (is_scalar_integer(fragment_mass_tolerance_unit_ppm) || is_scalar_double(fragment_mass_tolerance_unit_ppm)) && fragment_mass_tolerance_unit_ppm == as.integer(fragment_mass_tolerance_unit_ppm))){ stop("arg fragment_mass_tolerance_unit_ppm wrong type") }
    
    
    
    
        py_ans = private$py_obj$logOccupancyProb(theoretical_spec, as.integer(matched_size), fragment_mass_tolerance, as.integer(fragment_mass_tolerance_unit_ppm))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double weightedTICScoreXQuest(size_t alpha_size, size_t beta_size, double intsum_alpha, double intsum_beta, double total_current, bool type_is_cross_link)
    weightedTICScoreXQuest = function(alpha_size, beta_size, intsum_alpha, intsum_beta, total_current, type_is_cross_link){
    
        if(!( (is_scalar_integer(alpha_size) || is_scalar_double(alpha_size)) && alpha_size == as.integer(alpha_size))){ stop("arg alpha_size wrong type") }
        if(!( (is_scalar_integer(beta_size) || is_scalar_double(beta_size)) && beta_size == as.integer(beta_size))){ stop("arg beta_size wrong type") }
        if(!(is_scalar_double(intsum_alpha))){ stop("arg intsum_alpha wrong type") }
        if(!(is_scalar_double(intsum_beta))){ stop("arg intsum_beta wrong type") }
        if(!(is_scalar_double(total_current))){ stop("arg total_current wrong type") }
        if(!( (is_scalar_integer(type_is_cross_link) || is_scalar_double(type_is_cross_link)) && type_is_cross_link == as.integer(type_is_cross_link))){ stop("arg type_is_cross_link wrong type") }
    
    
    
    
    
    
        py_ans = private$py_obj$weightedTICScoreXQuest(as.integer(alpha_size), as.integer(beta_size), intsum_alpha, intsum_beta, total_current, as.integer(type_is_cross_link))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double weightedTICScore(size_t alpha_size, size_t beta_size, double intsum_alpha, double intsum_beta, double total_current, bool type_is_cross_link)
    weightedTICScore = function(alpha_size, beta_size, intsum_alpha, intsum_beta, total_current, type_is_cross_link){
    
        if(!( (is_scalar_integer(alpha_size) || is_scalar_double(alpha_size)) && alpha_size == as.integer(alpha_size))){ stop("arg alpha_size wrong type") }
        if(!( (is_scalar_integer(beta_size) || is_scalar_double(beta_size)) && beta_size == as.integer(beta_size))){ stop("arg beta_size wrong type") }
        if(!(is_scalar_double(intsum_alpha))){ stop("arg intsum_alpha wrong type") }
        if(!(is_scalar_double(intsum_beta))){ stop("arg intsum_beta wrong type") }
        if(!(is_scalar_double(total_current))){ stop("arg total_current wrong type") }
        if(!( (is_scalar_integer(type_is_cross_link) || is_scalar_double(type_is_cross_link)) && type_is_cross_link == as.integer(type_is_cross_link))){ stop("arg type_is_cross_link wrong type") }
    
    
    
    
    
    
        py_ans = private$py_obj$weightedTICScore(as.integer(alpha_size), as.integer(beta_size), intsum_alpha, intsum_beta, total_current, as.integer(type_is_cross_link))
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: double matchedCurrentChain(libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_common, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_xlinks, MSSpectrum & spectrum_common_peaks, MSSpectrum & spectrum_xlink_peaks)
    matchedCurrentChain = function(matched_spec_common, matched_spec_xlinks, spectrum_common_peaks, spectrum_xlink_peaks){
    
        if(!(is_list(matched_spec_common) && all(sapply(matched_spec_common,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_common wrong type") }
        if(!(is_list(matched_spec_xlinks) && all(sapply(matched_spec_xlinks,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_xlinks wrong type") }
        if(!(is.R6(spectrum_common_peaks) && class(spectrum_common_peaks)[1] == "MSSpectrum")){ stop("arg spectrum_common_peaks wrong type") }
        if(!(is.R6(spectrum_xlink_peaks) && class(spectrum_xlink_peaks)[1] == "MSSpectrum")){ stop("arg spectrum_xlink_peaks wrong type") }
        v0 <- r_to_py(matched_spec_common)
        v1 <- r_to_py(matched_spec_xlinks)
    
    
        py_ans = private$py_obj$matchedCurrentChain(v0, v1, spectrum_common_peaks, spectrum_xlink_peaks)
        byref_1 <- py_to_r(v1)
        byref_0 <- py_to_r(v0)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(matched_spec_common <- byref_0))
        eval.parent(substitute(matched_spec_xlinks <- byref_1))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: double totalMatchedCurrent(libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_common_alpha, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_common_beta, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_xlinks_alpha, libcpp_vector[libcpp_pair[size_t,size_t]] & matched_spec_xlinks_beta, MSSpectrum & spectrum_common_peaks, MSSpectrum & spectrum_xlink_peaks)
    totalMatchedCurrent = function(matched_spec_common_alpha, matched_spec_common_beta, matched_spec_xlinks_alpha, matched_spec_xlinks_beta, spectrum_common_peaks, spectrum_xlink_peaks){
    
        if(!(is_list(matched_spec_common_alpha) && all(sapply(matched_spec_common_alpha,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_common_alpha wrong type") }
        if(!(is_list(matched_spec_common_beta) && all(sapply(matched_spec_common_beta,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_common_beta wrong type") }
        if(!(is_list(matched_spec_xlinks_alpha) && all(sapply(matched_spec_xlinks_alpha,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_xlinks_alpha wrong type") }
        if(!(is_list(matched_spec_xlinks_beta) && all(sapply(matched_spec_xlinks_beta,function(elemt_rec) is_list(elemt_rec) && length(elemt_rec) == 2 &&  (is_scalar_integer(elemt_rec[[1]]) || is_scalar_double(elemt_rec[[1]])) && elemt_rec[[1]] == as.integer(elemt_rec[[1]]) &&  (is_scalar_integer(elemt_rec[[2]]) || is_scalar_double(elemt_rec[[2]])) && elemt_rec[[2]] == as.integer(elemt_rec[[2]]))))){ stop("arg matched_spec_xlinks_beta wrong type") }
        if(!(is.R6(spectrum_common_peaks) && class(spectrum_common_peaks)[1] == "MSSpectrum")){ stop("arg spectrum_common_peaks wrong type") }
        if(!(is.R6(spectrum_xlink_peaks) && class(spectrum_xlink_peaks)[1] == "MSSpectrum")){ stop("arg spectrum_xlink_peaks wrong type") }
        v0 <- r_to_py(matched_spec_common_alpha)
        v1 <- r_to_py(matched_spec_common_beta)
        v2 <- r_to_py(matched_spec_xlinks_alpha)
        v3 <- r_to_py(matched_spec_xlinks_beta)
    
    
        py_ans = private$py_obj$totalMatchedCurrent(v0, v1, v2, v3, spectrum_common_peaks, spectrum_xlink_peaks)
        byref_3 <- py_to_r(v3)
        byref_2 <- py_to_r(v2)
        byref_1 <- py_to_r(v1)
        byref_0 <- py_to_r(v0)
        r_ans = py_ans
    
        tryCatch({
        eval.parent(substitute(matched_spec_common_alpha <- byref_0))
        eval.parent(substitute(matched_spec_common_beta <- byref_1))
        eval.parent(substitute(matched_spec_xlinks_alpha <- byref_2))
        eval.parent(substitute(matched_spec_xlinks_beta <- byref_3))
        return(r_ans)
        }, error = function(c) {return(r_ans)}
        )
    
    },
    
    # C++ signature: libcpp_vector[double] xCorrelation(MSSpectrum & spec1, MSSpectrum & spec2, int maxshift, double tolerance)
    xCorrelation = function(spec1, spec2, maxshift, tolerance){
    
        if(!(is.R6(spec1) && class(spec1)[1] == "MSSpectrum")){ stop("arg spec1 wrong type") }
        if(!(is.R6(spec2) && class(spec2)[1] == "MSSpectrum")){ stop("arg spec2 wrong type") }
        if(!( (is_scalar_integer(maxshift) || is_scalar_double(maxshift)) && maxshift == as.integer(maxshift))){ stop("arg maxshift wrong type") }
        if(!(is_scalar_double(tolerance))){ stop("arg tolerance wrong type") }
    
    
    
    
        py_ans = private$py_obj$xCorrelation(spec1, spec2, as.integer(maxshift), tolerance)
        r_ans <- modify_depth(py_ans,0,as.list)
        return(r_ans)
    },
    
    # C++ signature: double xCorrelationPrescore(MSSpectrum & spec1, MSSpectrum & spec2, double tolerance)
    xCorrelationPrescore = function(spec1, spec2, tolerance){
    
        if(!(is.R6(spec1) && class(spec1)[1] == "MSSpectrum")){ stop("arg spec1 wrong type") }
        if(!(is.R6(spec2) && class(spec2)[1] == "MSSpectrum")){ stop("arg spec2 wrong type") }
        if(!(is_scalar_double(tolerance))){ stop("arg tolerance wrong type") }
    
    
    
        py_ans = private$py_obj$xCorrelationPrescore(spec1, spec2, tolerance)
        r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _XTandemInfile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XTandemInfile.html
XTandemInfile <- R6Class(classname = "XTandemInfile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XTandemInfile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == XTandemInfile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$XTandemInfile()
        invisible()
    }
    
    },
    
    # C++ signature: void setFragmentMassTolerance(double tolerance)
    setFragmentMassTolerance = function(tolerance){
    
        if(!(is_scalar_double(tolerance))){ stop("arg tolerance wrong type") }
    
        private$py_obj$setFragmentMassTolerance(tolerance)
        invisible()
    },
    
    # C++ signature: double getFragmentMassTolerance()
    getFragmentMassTolerance = function(){
    
        py_ans = private$py_obj$getFragmentMassTolerance()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassTolerancePlus(double tol)
    setPrecursorMassTolerancePlus = function(tol){
    
        if(!(is_scalar_double(tol))){ stop("arg tol wrong type") }
    
        private$py_obj$setPrecursorMassTolerancePlus(tol)
        invisible()
    },
    
    # C++ signature: double getPrecursorMassTolerancePlus()
    getPrecursorMassTolerancePlus = function(){
    
        py_ans = private$py_obj$getPrecursorMassTolerancePlus()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassToleranceMinus(double tol)
    setPrecursorMassToleranceMinus = function(tol){
    
        if(!(is_scalar_double(tol))){ stop("arg tol wrong type") }
    
        private$py_obj$setPrecursorMassToleranceMinus(tol)
        invisible()
    },
    
    # C++ signature: double getPrecursorMassToleranceMinus()
    getPrecursorMassToleranceMinus = function(){
    
        py_ans = private$py_obj$getPrecursorMassToleranceMinus()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorErrorType(MassType mono_isotopic)
    setPrecursorErrorType = function(mono_isotopic){
    
        if(!(mono_isotopic %in% c(0, 1))){ stop("arg mono_isotopic wrong type") }
    
        private$py_obj$setPrecursorErrorType(as.integer(mono_isotopic))
        invisible()
    },
    
    # C++ signature: MassType getPrecursorErrorType()
    getPrecursorErrorType = function(){
    
        py_ans = private$py_obj$getPrecursorErrorType()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setFragmentMassErrorUnit(ErrorUnit unit)
    setFragmentMassErrorUnit = function(unit){
    
        if(!(unit %in% c(0, 1))){ stop("arg unit wrong type") }
    
        private$py_obj$setFragmentMassErrorUnit(as.integer(unit))
        invisible()
    },
    
    # C++ signature: ErrorUnit getFragmentMassErrorUnit()
    getFragmentMassErrorUnit = function(){
    
        py_ans = private$py_obj$getFragmentMassErrorUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setPrecursorMassErrorUnit(ErrorUnit unit)
    setPrecursorMassErrorUnit = function(unit){
    
        if(!(unit %in% c(0, 1))){ stop("arg unit wrong type") }
    
        private$py_obj$setPrecursorMassErrorUnit(as.integer(unit))
        invisible()
    },
    
    # C++ signature: ErrorUnit getPrecursorMassErrorUnit()
    getPrecursorMassErrorUnit = function(){
    
        py_ans = private$py_obj$getPrecursorMassErrorUnit()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNumberOfThreads(unsigned int threads)
    setNumberOfThreads = function(threads){
    
        if(!( (is_scalar_integer(threads) || is_scalar_double(threads)) && threads == as.integer(threads))){ stop("arg threads wrong type") }
    
        private$py_obj$setNumberOfThreads(as.integer(threads))
        invisible()
    },
    
    # C++ signature: unsigned int getNumberOfThreads()
    getNumberOfThreads = function(){
    
        py_ans = private$py_obj$getNumberOfThreads()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setModifications(ModificationDefinitionsSet & mods)
    setModifications = function(mods){
    
        if(!(is.R6(mods) && class(mods)[1] == "ModificationDefinitionsSet")){ stop("arg mods wrong type") }
    
        private$py_obj$setModifications(mods)
        invisible()
    },
    
    # C++ signature: ModificationDefinitionsSet getModifications()
    getModifications = function(){
    
        py_ans = private$py_obj$getModifications()
        r_ans = ModificationDefinitionsSet$new(py_ans)
        return(r_ans)
    },
    
    # C++ signature: void setOutputFilename(const String & output)
    setOutputFilename = function(output){
    
        if(!((is.R6(output) && class(output)[1]=="String") || is_scalar_character(output))){ stop("arg output wrong type") }
    
        private$py_obj$setOutputFilename(output)
        invisible()
    },
    
    # C++ signature: String getOutputFilename()
    getOutputFilename = function(){
    
        py_ans = private$py_obj$getOutputFilename()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setInputFilename(const String & input_file)
    setInputFilename = function(input_file){
    
        if(!((is.R6(input_file) && class(input_file)[1]=="String") || is_scalar_character(input_file))){ stop("arg input_file wrong type") }
    
        private$py_obj$setInputFilename(input_file)
        invisible()
    },
    
    # C++ signature: String getInputFilename()
    getInputFilename = function(){
    
        py_ans = private$py_obj$getInputFilename()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTaxonomyFilename(const String & filename)
    setTaxonomyFilename = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$setTaxonomyFilename(filename)
        invisible()
    },
    
    # C++ signature: String getTaxonomyFilename()
    getTaxonomyFilename = function(){
    
        py_ans = private$py_obj$getTaxonomyFilename()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setDefaultParametersFilename(const String & filename)
    setDefaultParametersFilename = function(filename){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
    
        private$py_obj$setDefaultParametersFilename(filename)
        invisible()
    },
    
    # C++ signature: String getDefaultParametersFilename()
    getDefaultParametersFilename = function(){
    
        py_ans = private$py_obj$getDefaultParametersFilename()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setTaxon(const String & taxon)
    setTaxon = function(taxon){
    
        if(!((is.R6(taxon) && class(taxon)[1]=="String") || is_scalar_character(taxon))){ stop("arg taxon wrong type") }
    
        private$py_obj$setTaxon(taxon)
        invisible()
    },
    
    # C++ signature: String getTaxon()
    getTaxon = function(){
    
        py_ans = private$py_obj$getTaxon()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxPrecursorCharge(int max_charge)
    setMaxPrecursorCharge = function(max_charge){
    
        if(!( (is_scalar_integer(max_charge) || is_scalar_double(max_charge)) && max_charge == as.integer(max_charge))){ stop("arg max_charge wrong type") }
    
        private$py_obj$setMaxPrecursorCharge(as.integer(max_charge))
        invisible()
    },
    
    # C++ signature: int getMaxPrecursorCharge()
    getMaxPrecursorCharge = function(){
    
        py_ans = private$py_obj$getMaxPrecursorCharge()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setNumberOfMissedCleavages(unsigned int missed_cleavages)
    setNumberOfMissedCleavages = function(missed_cleavages){
    
        if(!( (is_scalar_integer(missed_cleavages) || is_scalar_double(missed_cleavages)) && missed_cleavages == as.integer(missed_cleavages))){ stop("arg missed_cleavages wrong type") }
    
        private$py_obj$setNumberOfMissedCleavages(as.integer(missed_cleavages))
        invisible()
    },
    
    # C++ signature: unsigned int getNumberOfMissedCleavages()
    getNumberOfMissedCleavages = function(){
    
        py_ans = private$py_obj$getNumberOfMissedCleavages()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setOutputResults(String result)
    setOutputResults = function(result){
    
        if(!((is.R6(result) && class(result)[1]=="String") || is_scalar_character(result))){ stop("arg result wrong type") }
    
        private$py_obj$setOutputResults(result)
        invisible()
    },
    
    # C++ signature: String getOutputResults()
    getOutputResults = function(){
    
        py_ans = private$py_obj$getOutputResults()
    r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setMaxValidEValue(double value)
    setMaxValidEValue = function(value){
    
        if(!(is_scalar_double(value))){ stop("arg value wrong type") }
    
        private$py_obj$setMaxValidEValue(value)
        invisible()
    },
    
    # C++ signature: double getMaxValidEValue()
    getMaxValidEValue = function(){
    
        py_ans = private$py_obj$getMaxValidEValue()
        r_ans = py_ans
        return(r_ans)
    },
    
    # C++ signature: void setSemiCleavage(bool semi_cleavage)
    setSemiCleavage = function(semi_cleavage){
    
        if(!( (is_scalar_integer(semi_cleavage) || is_scalar_double(semi_cleavage)) && semi_cleavage == as.integer(semi_cleavage))){ stop("arg semi_cleavage wrong type") }
    
        private$py_obj$setSemiCleavage(as.integer(semi_cleavage))
        invisible()
    },
    
    # C++ signature: void setAllowIsotopeError(bool allow_isotope_error)
    setAllowIsotopeError = function(allow_isotope_error){
    
        if(!( (is_scalar_integer(allow_isotope_error) || is_scalar_double(allow_isotope_error)) && allow_isotope_error == as.integer(allow_isotope_error))){ stop("arg allow_isotope_error wrong type") }
    
        private$py_obj$setAllowIsotopeError(as.integer(allow_isotope_error))
        invisible()
    },
    
    # C++ signature: void write(String filename, bool ignore_member_parameters, bool force_default_mods)
    write = function(filename, ignore_member_parameters, force_default_mods){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!( (is_scalar_integer(ignore_member_parameters) || is_scalar_double(ignore_member_parameters)) && ignore_member_parameters == as.integer(ignore_member_parameters))){ stop("arg ignore_member_parameters wrong type") }
        if(!( (is_scalar_integer(force_default_mods) || is_scalar_double(force_default_mods)) && force_default_mods == as.integer(force_default_mods))){ stop("arg force_default_mods wrong type") }
    
    
    
        private$py_obj$write(filename, as.integer(ignore_member_parameters), as.integer(force_default_mods))
        invisible()
    },
    
    # C++ signature: void setCleavageSite(String cleavage_site)
    setCleavageSite = function(cleavage_site){
    
        if(!((is.R6(cleavage_site) && class(cleavage_site)[1]=="String") || is_scalar_character(cleavage_site))){ stop("arg cleavage_site wrong type") }
    
        private$py_obj$setCleavageSite(cleavage_site)
        invisible()
    },
    
    # C++ signature: String getCleavageSite()
    getCleavageSite = function(){
    
        py_ans = private$py_obj$getCleavageSite()
    r_ans = py_ans
        return(r_ans)
    }
)
) 

# R implementation of _XTandemXMLFile
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS_1_1XTandemXMLFile.html
XTandemXMLFile <- R6Class(classname = "XTandemXMLFile",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void XTandemXMLFile()
    initialize = function(...){
        par <- list(...)
    if (!length(par) %in% c(0,1)) { stop("arg wrong type")}
    if (length(par)==1) {
        if ("python.builtin.object" %in% class(par[[1]]) && class_to_wrap(par[[1]]) == XTandemXMLFile) { private$py_obj <- par[[1]] }
        else { stop("arg wrong type") }
    } else if (length(par)==0) {
    
        private$py_obj <- Pymod$XTandemXMLFile()
        invisible()
    }
    
    },
    
    # C++ signature: void load(String filename, ProteinIdentification & protein_identification, libcpp_vector[PeptideIdentification] & id_data, ModificationDefinitionsSet & mod_def_set)
    load = function(filename, protein_identification, id_data, mod_def_set){
    
        if(!((is.R6(filename) && class(filename)[1]=="String") || is_scalar_character(filename))){ stop("arg filename wrong type") }
        if(!(is.R6(protein_identification) && class(protein_identification)[1] == "ProteinIdentification")){ stop("arg protein_identification wrong type") }
        if(!(is_list(id_data) && all(sapply(id_data,function(elemt_rec) is.R6(elemt_rec) && class(elemt_rec)[1] == "PeptideIdentification")))){ stop("arg id_data wrong type") }
        if(!(is.R6(mod_def_set) && class(mod_def_set)[1] == "ModificationDefinitionsSet")){ stop("arg mod_def_set wrong type") }
    
    
        v2 <- r_to_py(id_data)
    
        private$py_obj$load(filename, protein_identification, v2, mod_def_set)
        byref_2 <- map(py_to_r(v2),function(t) eval(parse(text = paste0(class_to_wrap(t),"$","new(t)"))))
    
        tryCatch({
        eval.parent(substitute(id_data <- byref_2))
        invisible()
        }, error = function(c) {invisible()}
        )
    
    }
)
) 

# R implementation of _BinaryDataArray
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Interfaces_1_1BinaryDataArray.html
BinaryDataArray <- R6Class(classname = "BinaryDataArray",cloneable = FALSE,

    private = list(py_obj = NA),


    active = list(
        data = function(data){
    
        if(!missing(data)){
            if(!(is_list(data) && all(sapply(data,function(elemt_rec) is_scalar_double(elemt_rec))))){ stop("arg data wrong type") }
        
            v0 <- r_to_py(data)
            private$py_obj$data <- v0
            } else {
            
                py_ans = private$py_obj$data
            r_result <- modify_depth(py_ans,0,as.list)
                return(r_result)
                }
        }

    ),
    
    public = list(
    
    # C++ signature: void _Interfaces_BinaryDataArray()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Interfaces$BinaryDataArray()
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_BinaryDataArray(_Interfaces_BinaryDataArray)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "BinaryDataArray")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Interfaces$BinaryDataArray(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_BinaryDataArray()
    # C++ signature: void _Interfaces_BinaryDataArray(_Interfaces_BinaryDataArray)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "BinaryDataArray")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "BinaryDataArray" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _Chromatogram
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Interfaces_1_1Chromatogram.html
Chromatogram <- R6Class(classname = "Chromatogram",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void _Interfaces_Chromatogram()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Interfaces$Chromatogram()
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_Chromatogram(_Interfaces_Chromatogram)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Chromatogram")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Interfaces$Chromatogram(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_Chromatogram()
    # C++ signature: void _Interfaces_Chromatogram(_Interfaces_Chromatogram)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Chromatogram")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Chromatogram" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _Spectrum
# Documentation is available at http://www.openms.de/current_doxygen/html/classOpenMS::Interfaces_1_1Spectrum.html
Spectrum <- R6Class(classname = "Spectrum",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void _Interfaces_Spectrum()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$Interfaces$Spectrum()
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_Spectrum(_Interfaces_Spectrum)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "Spectrum")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$Interfaces$Spectrum(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void _Interfaces_Spectrum()
    # C++ signature: void _Interfaces_Spectrum(_Interfaces_Spectrum)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "Spectrum")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "Spectrum" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

# R implementation of _streampos
# Documentation is available at http://www.openms.de/current_doxygen/html/classstd_1_1streampos.html
streampos <- R6Class(classname = "streampos",cloneable = FALSE,

    private = list(py_obj = NA),

    
    public = list(
    
    # C++ signature: void streampos()
    init_0 = function(){
    
    
        private$py_obj <- Pymod$streampos()
        invisible()
    
    
    },
    
    # C++ signature: void streampos(streampos &)
    init_1 = function(in_0){
    
        if(!(is.R6(in_0) && class(in_0)[1] == "streampos")){ stop("arg in_0 wrong type") }
    
    
        private$py_obj <- Pymod$streampos(in_0)
        invisible()
    
    
    },
    
    # C++ signature: void streampos()
    # C++ signature: void streampos(streampos &)
    initialize = function(...){
        arg_list = list(...)
        if (length(arg_list)==0) { self$init_0(...) }
        else if ((length(arg_list)==1) && (is.R6(arg_list[[1]]) && class(arg_list[[1]])[1] == "streampos")) { self$init_1(...) }
        else{
               # to create a new R object and set its underlying python object as the one supplied in the constructor.
               # this helps avoid use of set_py_object(), s.t., the user is not able to manipulate the python object in a direct fashion.
               if( length(arg_list)==1 && ( "python.builtin.object" %in% class(arg_list[[1]]) && class_to_wrap(arg_list[[1]]) == "streampos" ) )
               { private$py_obj <- arg_list[[1]]  }
               else {
                    stop("wrong arguments provided")
               }
           }
    
    }
)
) 

AcquisitionMode = R6Class(classname = "AcquisitionMode", cloneable = FALSE,

        public = list(

        ACQMODENULL = 0L,
        PULSECOUNTING = 1L,
        ADC = 2L,
        TDC = 3L,
        TRANSIENTRECORDER = 4L,
        SIZE_OF_ACQUISITIONMODE = 5L,
        initialize = function(){
            lockBinding("ACQMODENULL",self)
            lockBinding("PULSECOUNTING",self)
            lockBinding("ADC",self)
            lockBinding("TDC",self)
            lockBinding("TRANSIENTRECORDER",self)
            lockBinding("SIZE_OF_ACQUISITIONMODE",self)
        },
        getMapping = function() {
            return( Pymod$AcquisitionMode()$getMapping() )
        }
    )
) 

ActionMode = R6Class(classname = "ActionMode", cloneable = FALSE,

        public = list(

        LOAD = 0L,
        STORE = 1L,
        initialize = function(){
            lockBinding("LOAD",self)
            lockBinding("STORE",self)
        },
        getMapping = function() {
            return( Pymod$ActionMode()$getMapping() )
        }
    )
) 

ActivationMethod = R6Class(classname = "ActivationMethod", cloneable = FALSE,

        public = list(

        CID = 0L,
        PSD = 1L,
        PD = 2L,
        SID = 3L,
        BIRD = 4L,
        ECD = 5L,
        IMD = 6L,
        SORI = 7L,
        HCID = 8L,
        LCID = 9L,
        PHD = 10L,
        ETD = 11L,
        PQD = 12L,
        SIZE_OF_ACTIVATIONMETHOD = 13L,
        initialize = function(){
            lockBinding("CID",self)
            lockBinding("PSD",self)
            lockBinding("PD",self)
            lockBinding("SID",self)
            lockBinding("BIRD",self)
            lockBinding("ECD",self)
            lockBinding("IMD",self)
            lockBinding("SORI",self)
            lockBinding("HCID",self)
            lockBinding("LCID",self)
            lockBinding("PHD",self)
            lockBinding("ETD",self)
            lockBinding("PQD",self)
            lockBinding("SIZE_OF_ACTIVATIONMETHOD",self)
        },
        getMapping = function() {
            return( Pymod$ActivationMethod()$getMapping() )
        }
    )
) 

AnalyzerType = R6Class(classname = "AnalyzerType", cloneable = FALSE,

        public = list(

        ANALYZERNULL = 0L,
        QUADRUPOLE = 1L,
        PAULIONTRAP = 2L,
        RADIALEJECTIONLINEARIONTRAP = 3L,
        AXIALEJECTIONLINEARIONTRAP = 4L,
        TOF = 5L,
        SECTOR = 6L,
        FOURIERTRANSFORM = 7L,
        IONSTORAGE = 8L,
        ESA = 9L,
        IT = 10L,
        SWIFT = 11L,
        CYCLOTRON = 12L,
        ORBITRAP = 13L,
        LIT = 14L,
        SIZE_OF_ANALYZERTYPE = 15L,
        initialize = function(){
            lockBinding("ANALYZERNULL",self)
            lockBinding("QUADRUPOLE",self)
            lockBinding("PAULIONTRAP",self)
            lockBinding("RADIALEJECTIONLINEARIONTRAP",self)
            lockBinding("AXIALEJECTIONLINEARIONTRAP",self)
            lockBinding("TOF",self)
            lockBinding("SECTOR",self)
            lockBinding("FOURIERTRANSFORM",self)
            lockBinding("IONSTORAGE",self)
            lockBinding("ESA",self)
            lockBinding("IT",self)
            lockBinding("SWIFT",self)
            lockBinding("CYCLOTRON",self)
            lockBinding("ORBITRAP",self)
            lockBinding("LIT",self)
            lockBinding("SIZE_OF_ANALYZERTYPE",self)
        },
        getMapping = function() {
            return( Pymod$AnalyzerType()$getMapping() )
        }
    )
) 

AnnotationState = R6Class(classname = "AnnotationState", cloneable = FALSE,

        public = list(

        FEATURE_ID_NONE = 0L,
        FEATURE_ID_SINGLE = 1L,
        FEATURE_ID_MULTIPLE_SAME = 2L,
        FEATURE_ID_MULTIPLE_DIVERGENT = 3L,
        SIZE_OF_ANNOTATIONSTATE = 4L,
        initialize = function(){
            lockBinding("FEATURE_ID_NONE",self)
            lockBinding("FEATURE_ID_SINGLE",self)
            lockBinding("FEATURE_ID_MULTIPLE_SAME",self)
            lockBinding("FEATURE_ID_MULTIPLE_DIVERGENT",self)
            lockBinding("SIZE_OF_ANNOTATIONSTATE",self)
        },
        getMapping = function() {
            return( Pymod$AnnotationState()$getMapping() )
        }
    )
) 

Averagines = R6Class(classname = "Averagines", cloneable = FALSE,

        public = list(

        C = 0L,
        H = 1L,
        N = 2L,
        O = 3L,
        S = 4L,
        AVERAGINE_NUM = 5L,
        initialize = function(){
            lockBinding("C",self)
            lockBinding("H",self)
            lockBinding("N",self)
            lockBinding("O",self)
            lockBinding("S",self)
            lockBinding("AVERAGINE_NUM",self)
        },
        getMapping = function() {
            return( Pymod$Averagines()$getMapping() )
        }
    )
) 

BoundaryCondition = R6Class(classname = "BoundaryCondition", cloneable = FALSE,

        public = list(

        BC_ZERO_ENDPOINTS = 0L,
        BC_ZERO_FIRST = 1L,
        BC_ZERO_SECOND = 2L,
        initialize = function(){
            lockBinding("BC_ZERO_ENDPOINTS",self)
            lockBinding("BC_ZERO_FIRST",self)
            lockBinding("BC_ZERO_SECOND",self)
        },
        getMapping = function() {
            return( Pymod$BoundaryCondition()$getMapping() )
        }
    )
) 

ByteOrder = R6Class(classname = "ByteOrder", cloneable = FALSE,

        public = list(

        BYTEORDER_BIGENDIAN = 0L,
        BYTEORDER_LITTLEENDIAN = 1L,
        initialize = function(){
            lockBinding("BYTEORDER_BIGENDIAN",self)
            lockBinding("BYTEORDER_LITTLEENDIAN",self)
        },
        getMapping = function() {
            return( Pymod$ByteOrder()$getMapping() )
        }
    )
) 

CHARGEMODE_FD = R6Class(classname = "CHARGEMODE_FD", cloneable = FALSE,

        public = list(

        QFROMFEATURE = 0L,
        QHEURISTIC = 1L,
        QALL = 2L,
        initialize = function(){
            lockBinding("QFROMFEATURE",self)
            lockBinding("QHEURISTIC",self)
            lockBinding("QALL",self)
        },
        getMapping = function() {
            return( Pymod$CHARGEMODE_FD()$getMapping() )
        }
    )
) 

CHARGEMODE_MFD = R6Class(classname = "CHARGEMODE_MFD", cloneable = FALSE,

        public = list(

        QFROMFEATURE = 0L,
        QHEURISTIC = 1L,
        QALL = 2L,
        initialize = function(){
            lockBinding("QFROMFEATURE",self)
            lockBinding("QHEURISTIC",self)
            lockBinding("QALL",self)
        },
        getMapping = function() {
            return( Pymod$CHARGEMODE_MFD()$getMapping() )
        }
    )
) 

ChecksumType = R6Class(classname = "ChecksumType", cloneable = FALSE,

        public = list(

        UNKNOWN_CHECKSUM = 0L,
        SHA1 = 1L,
        MD5 = 2L,
        SIZE_OF_CHECKSUMTYPE = 3L,
        initialize = function(){
            lockBinding("UNKNOWN_CHECKSUM",self)
            lockBinding("SHA1",self)
            lockBinding("MD5",self)
            lockBinding("SIZE_OF_CHECKSUMTYPE",self)
        },
        getMapping = function() {
            return( Pymod$ChecksumType()$getMapping() )
        }
    )
) 

ChromatogramType = R6Class(classname = "ChromatogramType", cloneable = FALSE,

        public = list(

        MASS_CHROMATOGRAM = 0L,
        TOTAL_ION_CURRENT_CHROMATOGRAM = 1L,
        SELECTED_ION_CURRENT_CHROMATOGRAM = 2L,
        BASEPEAK_CHROMATOGRAM = 3L,
        SELECTED_ION_MONITORING_CHROMATOGRAM = 4L,
        SELECTED_REACTION_MONITORING_CHROMATOGRAM = 5L,
        ELECTROMAGNETIC_RADIATION_CHROMATOGRAM = 6L,
        ABSORPTION_CHROMATOGRAM = 7L,
        EMISSION_CHROMATOGRAM = 8L,
        SIZE_OF_CHROMATOGRAM_TYPE = 9L,
        initialize = function(){
            lockBinding("MASS_CHROMATOGRAM",self)
            lockBinding("TOTAL_ION_CURRENT_CHROMATOGRAM",self)
            lockBinding("SELECTED_ION_CURRENT_CHROMATOGRAM",self)
            lockBinding("BASEPEAK_CHROMATOGRAM",self)
            lockBinding("SELECTED_ION_MONITORING_CHROMATOGRAM",self)
            lockBinding("SELECTED_REACTION_MONITORING_CHROMATOGRAM",self)
            lockBinding("ELECTROMAGNETIC_RADIATION_CHROMATOGRAM",self)
            lockBinding("ABSORPTION_CHROMATOGRAM",self)
            lockBinding("EMISSION_CHROMATOGRAM",self)
            lockBinding("SIZE_OF_CHROMATOGRAM_TYPE",self)
        },
        getMapping = function() {
            return( Pymod$ChromatogramType()$getMapping() )
        }
    )
) 

CombinationsLogic = R6Class(classname = "CombinationsLogic", cloneable = FALSE,

        public = list(

        OR = 0L,
        AND = 1L,
        XOR = 2L,
        initialize = function(){
            lockBinding("OR",self)
            lockBinding("AND",self)
            lockBinding("XOR",self)
        },
        getMapping = function() {
            return( Pymod$CombinationsLogic()$getMapping() )
        }
    )
) 

DRangeIntersection = R6Class(classname = "DRangeIntersection", cloneable = FALSE,

        public = list(

        Disjoint = 0L,
        Intersects = 1L,
        Inside = 2L,
        initialize = function(){
            lockBinding("Disjoint",self)
            lockBinding("Intersects",self)
            lockBinding("Inside",self)
        },
        getMapping = function() {
            return( Pymod$DRangeIntersection()$getMapping() )
        }
    )
) 

DataType = R6Class(classname = "DataType", cloneable = FALSE,

        public = list(

        STRING_VALUE = 0L,
        INT_VALUE = 1L,
        DOUBLE_VALUE = 2L,
        STRING_LIST = 3L,
        INT_LIST = 4L,
        DOUBLE_LIST = 5L,
        EMPTY_VALUE = 6L,
        initialize = function(){
            lockBinding("STRING_VALUE",self)
            lockBinding("INT_VALUE",self)
            lockBinding("DOUBLE_VALUE",self)
            lockBinding("STRING_LIST",self)
            lockBinding("INT_LIST",self)
            lockBinding("DOUBLE_LIST",self)
            lockBinding("EMPTY_VALUE",self)
        },
        getMapping = function() {
            return( Pymod$DataType()$getMapping() )
        }
    )
) 

DecoyTransitionType = R6Class(classname = "DecoyTransitionType", cloneable = FALSE,

        public = list(

        UNKNOWN = 0L,
        TARGET = 1L,
        DECOY = 2L,
        initialize = function(){
            lockBinding("UNKNOWN",self)
            lockBinding("TARGET",self)
            lockBinding("DECOY",self)
        },
        getMapping = function() {
            return( Pymod$DecoyTransitionType()$getMapping() )
        }
    )
) 

DimensionDescription = R6Class(classname = "DimensionDescription", cloneable = FALSE,

        public = list(

        RT = 0L,
        MZ = 1L,
        DIMENSION = 2L,
        initialize = function(){
            lockBinding("RT",self)
            lockBinding("MZ",self)
            lockBinding("DIMENSION",self)
        },
        getMapping = function() {
            return( Pymod$DimensionDescription()$getMapping() )
        }
    )
) 

ErrorUnit = R6Class(classname = "ErrorUnit", cloneable = FALSE,

        public = list(

        DALTONS = 0L,
        PPM = 1L,
        initialize = function(){
            lockBinding("DALTONS",self)
            lockBinding("PPM",self)
        },
        getMapping = function() {
            return( Pymod$ErrorUnit()$getMapping() )
        }
    )
) 

FileType = R6Class(classname = "FileType", cloneable = FALSE,

        public = list(

        UNKNOWN = 0L,
        DTA = 1L,
        DTA2D = 2L,
        MZDATA = 3L,
        MZXML = 4L,
        FEATUREXML = 5L,
        IDXML = 6L,
        CONSENSUSXML = 7L,
        MGF = 8L,
        INI = 9L,
        TOPPAS = 10L,
        TRANSFORMATIONXML = 11L,
        MZML = 12L,
        CACHEDMZML = 13L,
        MS2 = 14L,
        PEPXML = 15L,
        PROTXML = 16L,
        MZIDENTML = 17L,
        MZQUANTML = 18L,
        QCML = 19L,
        GELML = 20L,
        TRAML = 21L,
        MSP = 22L,
        OMSSAXML = 23L,
        MASCOTXML = 24L,
        PNG = 25L,
        XMASS = 26L,
        TSV = 27L,
        PEPLIST = 28L,
        HARDKLOER = 29L,
        KROENIK = 30L,
        FASTA = 31L,
        EDTA = 32L,
        CSV = 33L,
        TXT = 34L,
        OBO = 35L,
        HTML = 36L,
        XML = 37L,
        ANALYSISXML = 38L,
        XSD = 39L,
        PSQ = 40L,
        MRM = 41L,
        SQMASS = 42L,
        PQP = 43L,
        OSW = 44L,
        PSMS = 45L,
        PARAMXML = 46L,
        SIZE_OF_TYPE = 47L,
        initialize = function(){
            lockBinding("UNKNOWN",self)
            lockBinding("DTA",self)
            lockBinding("DTA2D",self)
            lockBinding("MZDATA",self)
            lockBinding("MZXML",self)
            lockBinding("FEATUREXML",self)
            lockBinding("IDXML",self)
            lockBinding("CONSENSUSXML",self)
            lockBinding("MGF",self)
            lockBinding("INI",self)
            lockBinding("TOPPAS",self)
            lockBinding("TRANSFORMATIONXML",self)
            lockBinding("MZML",self)
            lockBinding("CACHEDMZML",self)
            lockBinding("MS2",self)
            lockBinding("PEPXML",self)
            lockBinding("PROTXML",self)
            lockBinding("MZIDENTML",self)
            lockBinding("MZQUANTML",self)
            lockBinding("QCML",self)
            lockBinding("GELML",self)
            lockBinding("TRAML",self)
            lockBinding("MSP",self)
            lockBinding("OMSSAXML",self)
            lockBinding("MASCOTXML",self)
            lockBinding("PNG",self)
            lockBinding("XMASS",self)
            lockBinding("TSV",self)
            lockBinding("PEPLIST",self)
            lockBinding("HARDKLOER",self)
            lockBinding("KROENIK",self)
            lockBinding("FASTA",self)
            lockBinding("EDTA",self)
            lockBinding("CSV",self)
            lockBinding("TXT",self)
            lockBinding("OBO",self)
            lockBinding("HTML",self)
            lockBinding("XML",self)
            lockBinding("ANALYSISXML",self)
            lockBinding("XSD",self)
            lockBinding("PSQ",self)
            lockBinding("MRM",self)
            lockBinding("SQMASS",self)
            lockBinding("PQP",self)
            lockBinding("OSW",self)
            lockBinding("PSMS",self)
            lockBinding("PARAMXML",self)
            lockBinding("SIZE_OF_TYPE",self)
        },
        getMapping = function() {
            return( Pymod$FileType()$getMapping() )
        }
    )
) 

FilterOperation = R6Class(classname = "FilterOperation", cloneable = FALSE,

        public = list(

        GREATER_EQUAL = 0L,
        EQUAL = 1L,
        LESS_EQUAL = 2L,
        EXISTS = 3L,
        initialize = function(){
            lockBinding("GREATER_EQUAL",self)
            lockBinding("EQUAL",self)
            lockBinding("LESS_EQUAL",self)
            lockBinding("EXISTS",self)
        },
        getMapping = function() {
            return( Pymod$FilterOperation()$getMapping() )
        }
    )
) 

FilterType = R6Class(classname = "FilterType", cloneable = FALSE,

        public = list(

        INTENSITY = 0L,
        QUALITY = 1L,
        CHARGE = 2L,
        SIZE = 3L,
        META_DATA = 4L,
        initialize = function(){
            lockBinding("INTENSITY",self)
            lockBinding("QUALITY",self)
            lockBinding("CHARGE",self)
            lockBinding("SIZE",self)
            lockBinding("META_DATA",self)
        },
        getMapping = function() {
            return( Pymod$FilterType()$getMapping() )
        }
    )
) 

FragmentationType = R6Class(classname = "FragmentationType", cloneable = FALSE,

        public = list(

        ChargeDirected = 0L,
        ChargeRemote = 1L,
        SideChain = 2L,
        initialize = function(){
            lockBinding("ChargeDirected",self)
            lockBinding("ChargeRemote",self)
            lockBinding("SideChain",self)
        },
        getMapping = function() {
            return( Pymod$FragmentationType()$getMapping() )
        }
    )
) 

ITRAQ_TYPES = R6Class(classname = "ITRAQ_TYPES", cloneable = FALSE,

        public = list(

        FOURPLEX = 0L,
        EIGHTPLEX = 1L,
        TMT_SIXPLEX = 2L,
        SIZE_OF_ITRAQ_TYPES = 3L,
        initialize = function(){
            lockBinding("FOURPLEX",self)
            lockBinding("EIGHTPLEX",self)
            lockBinding("TMT_SIXPLEX",self)
            lockBinding("SIZE_OF_ITRAQ_TYPES",self)
        },
        getMapping = function() {
            return( Pymod$ITRAQ_TYPES()$getMapping() )
        }
    )
) 

InletType = R6Class(classname = "InletType", cloneable = FALSE,

        public = list(

        INLETNULL = 0L,
        DIRECT = 1L,
        BATCH = 2L,
        CHROMATOGRAPHY = 3L,
        PARTICLEBEAM = 4L,
        MEMBRANESEPARATOR = 5L,
        OPENSPLIT = 6L,
        JETSEPARATOR = 7L,
        SEPTUM = 8L,
        RESERVOIR = 9L,
        MOVINGBELT = 10L,
        MOVINGWIRE = 11L,
        FLOWINJECTIONANALYSIS = 12L,
        ELECTROSPRAYINLET = 13L,
        THERMOSPRAYINLET = 14L,
        INFUSION = 15L,
        CONTINUOUSFLOWFASTATOMBOMBARDMENT = 16L,
        INDUCTIVELYCOUPLEDPLASMA = 17L,
        MEMBRANE = 18L,
        NANOSPRAY = 19L,
        SIZE_OF_INLETTYPE = 20L,
        initialize = function(){
            lockBinding("INLETNULL",self)
            lockBinding("DIRECT",self)
            lockBinding("BATCH",self)
            lockBinding("CHROMATOGRAPHY",self)
            lockBinding("PARTICLEBEAM",self)
            lockBinding("MEMBRANESEPARATOR",self)
            lockBinding("OPENSPLIT",self)
            lockBinding("JETSEPARATOR",self)
            lockBinding("SEPTUM",self)
            lockBinding("RESERVOIR",self)
            lockBinding("MOVINGBELT",self)
            lockBinding("MOVINGWIRE",self)
            lockBinding("FLOWINJECTIONANALYSIS",self)
            lockBinding("ELECTROSPRAYINLET",self)
            lockBinding("THERMOSPRAYINLET",self)
            lockBinding("INFUSION",self)
            lockBinding("CONTINUOUSFLOWFASTATOMBOMBARDMENT",self)
            lockBinding("INDUCTIVELYCOUPLEDPLASMA",self)
            lockBinding("MEMBRANE",self)
            lockBinding("NANOSPRAY",self)
            lockBinding("SIZE_OF_INLETTYPE",self)
        },
        getMapping = function() {
            return( Pymod$InletType()$getMapping() )
        }
    )
) 

IntensityThresholdCalculation = R6Class(classname = "IntensityThresholdCalculation", cloneable = FALSE,

        public = list(

        MANUAL = 0L,
        AUTOMAXBYSTDEV = 1L,
        AUTOMAXBYPERCENT = 2L,
        initialize = function(){
            lockBinding("MANUAL",self)
            lockBinding("AUTOMAXBYSTDEV",self)
            lockBinding("AUTOMAXBYPERCENT",self)
        },
        getMapping = function() {
            return( Pymod$IntensityThresholdCalculation()$getMapping() )
        }
    )
) 

IonOpticsType = R6Class(classname = "IonOpticsType", cloneable = FALSE,

        public = list(

        UNKNOWN = 0L,
        MAGNETIC_DEFLECTION = 1L,
        DELAYED_EXTRACTION = 2L,
        COLLISION_QUADRUPOLE = 3L,
        SELECTED_ION_FLOW_TUBE = 4L,
        TIME_LAG_FOCUSING = 5L,
        REFLECTRON = 6L,
        EINZEL_LENS = 7L,
        FIRST_STABILITY_REGION = 8L,
        FRINGING_FIELD = 9L,
        KINETIC_ENERGY_ANALYZER = 10L,
        STATIC_FIELD = 11L,
        SIZE_OF_IONOPTICSTYPE = 12L,
        initialize = function(){
            lockBinding("UNKNOWN",self)
            lockBinding("MAGNETIC_DEFLECTION",self)
            lockBinding("DELAYED_EXTRACTION",self)
            lockBinding("COLLISION_QUADRUPOLE",self)
            lockBinding("SELECTED_ION_FLOW_TUBE",self)
            lockBinding("TIME_LAG_FOCUSING",self)
            lockBinding("REFLECTRON",self)
            lockBinding("EINZEL_LENS",self)
            lockBinding("FIRST_STABILITY_REGION",self)
            lockBinding("FRINGING_FIELD",self)
            lockBinding("KINETIC_ENERGY_ANALYZER",self)
            lockBinding("STATIC_FIELD",self)
            lockBinding("SIZE_OF_IONOPTICSTYPE",self)
        },
        getMapping = function() {
            return( Pymod$IonOpticsType()$getMapping() )
        }
    )
) 

IonizationMethod = R6Class(classname = "IonizationMethod", cloneable = FALSE,

        public = list(

        IONMETHODNULL = 0L,
        ESI = 1L,
        EI = 2L,
        CI = 3L,
        FAB = 4L,
        TSP = 5L,
        LD = 6L,
        FD = 7L,
        FI = 8L,
        PD = 9L,
        SI = 10L,
        TI = 11L,
        API = 12L,
        ISI = 13L,
        CID = 14L,
        CAD = 15L,
        HN = 16L,
        APCI = 17L,
        APPI = 18L,
        ICP = 19L,
        NESI = 20L,
        MESI = 21L,
        SELDI = 22L,
        SEND = 23L,
        FIB = 24L,
        MALDI = 25L,
        MPI = 26L,
        DI = 27L,
        FA = 28L,
        FII = 29L,
        GD_MS = 30L,
        NICI = 31L,
        NRMS = 32L,
        PI = 33L,
        PYMS = 34L,
        REMPI = 35L,
        AI = 36L,
        ASI = 37L,
        AD = 38L,
        AUI = 39L,
        CEI = 40L,
        CHEMI = 41L,
        DISSI = 42L,
        LSI = 43L,
        PEI = 44L,
        SOI = 45L,
        SPI = 46L,
        SUI = 47L,
        VI = 48L,
        AP_MALDI = 49L,
        SILI = 50L,
        SALDI = 51L,
        SIZE_OF_IONIZATIONMETHOD = 52L,
        initialize = function(){
            lockBinding("IONMETHODNULL",self)
            lockBinding("ESI",self)
            lockBinding("EI",self)
            lockBinding("CI",self)
            lockBinding("FAB",self)
            lockBinding("TSP",self)
            lockBinding("LD",self)
            lockBinding("FD",self)
            lockBinding("FI",self)
            lockBinding("PD",self)
            lockBinding("SI",self)
            lockBinding("TI",self)
            lockBinding("API",self)
            lockBinding("ISI",self)
            lockBinding("CID",self)
            lockBinding("CAD",self)
            lockBinding("HN",self)
            lockBinding("APCI",self)
            lockBinding("APPI",self)
            lockBinding("ICP",self)
            lockBinding("NESI",self)
            lockBinding("MESI",self)
            lockBinding("SELDI",self)
            lockBinding("SEND",self)
            lockBinding("FIB",self)
            lockBinding("MALDI",self)
            lockBinding("MPI",self)
            lockBinding("DI",self)
            lockBinding("FA",self)
            lockBinding("FII",self)
            lockBinding("GD_MS",self)
            lockBinding("NICI",self)
            lockBinding("NRMS",self)
            lockBinding("PI",self)
            lockBinding("PYMS",self)
            lockBinding("REMPI",self)
            lockBinding("AI",self)
            lockBinding("ASI",self)
            lockBinding("AD",self)
            lockBinding("AUI",self)
            lockBinding("CEI",self)
            lockBinding("CHEMI",self)
            lockBinding("DISSI",self)
            lockBinding("LSI",self)
            lockBinding("PEI",self)
            lockBinding("SOI",self)
            lockBinding("SPI",self)
            lockBinding("SUI",self)
            lockBinding("VI",self)
            lockBinding("AP_MALDI",self)
            lockBinding("SILI",self)
            lockBinding("SALDI",self)
            lockBinding("SIZE_OF_IONIZATIONMETHOD",self)
        },
        getMapping = function() {
            return( Pymod$IonizationMethod()$getMapping() )
        }
    )
) 

IsotopeVariant = R6Class(classname = "IsotopeVariant", cloneable = FALSE,

        public = list(

        LIGHT = 0L,
        HEAVY = 1L,
        SIZE_OF_ISOTOPEVARIANT = 2L,
        initialize = function(){
            lockBinding("LIGHT",self)
            lockBinding("HEAVY",self)
            lockBinding("SIZE_OF_ISOTOPEVARIANT",self)
        },
        getMapping = function() {
            return( Pymod$IsotopeVariant()$getMapping() )
        }
    )
) 

LPWrapper_Type = R6Class(classname = "LPWrapper_Type", cloneable = FALSE,

        public = list(

        UNBOUNDED = 0L,
        LOWER_BOUND_ONLY = 1L,
        UPPER_BOUND_ONLY = 2L,
        DOUBLE_BOUNDED = 3L,
        FIXED = 4L,
        initialize = function(){
            lockBinding("UNBOUNDED",self)
            lockBinding("LOWER_BOUND_ONLY",self)
            lockBinding("UPPER_BOUND_ONLY",self)
            lockBinding("DOUBLE_BOUNDED",self)
            lockBinding("FIXED",self)
        },
        getMapping = function() {
            return( Pymod$LPWrapper_Type()$getMapping() )
        }
    )
) 

LogType = R6Class(classname = "LogType", cloneable = FALSE,

        public = list(

        CMD = 0L,
        GUI = 1L,
        NONE = 2L,
        initialize = function(){
            lockBinding("CMD",self)
            lockBinding("GUI",self)
            lockBinding("NONE",self)
        },
        getMapping = function() {
            return( Pymod$LogType()$getMapping() )
        }
    )
) 

MT_QUANTMETHOD = R6Class(classname = "MT_QUANTMETHOD", cloneable = FALSE,

        public = list(

        MT_QUANT_AREA = 0L,
        MT_QUANT_MEDIAN = 1L,
        SIZE_OF_MT_QUANTMETHOD = 2L,
        initialize = function(){
            lockBinding("MT_QUANT_AREA",self)
            lockBinding("MT_QUANT_MEDIAN",self)
            lockBinding("SIZE_OF_MT_QUANTMETHOD",self)
        },
        getMapping = function() {
            return( Pymod$MT_QUANTMETHOD()$getMapping() )
        }
    )
) 

MZTrafoModel_MODELTYPE = R6Class(classname = "MZTrafoModel_MODELTYPE", cloneable = FALSE,

        public = list(

        LINEAR = 0L,
        LINEAR_WEIGHTED = 1L,
        QUADRATIC = 2L,
        QUADRATIC_WEIGHTED = 3L,
        SIZE_OF_MODELTYPE = 4L,
        initialize = function(){
            lockBinding("LINEAR",self)
            lockBinding("LINEAR_WEIGHTED",self)
            lockBinding("QUADRATIC",self)
            lockBinding("QUADRATIC_WEIGHTED",self)
            lockBinding("SIZE_OF_MODELTYPE",self)
        },
        getMapping = function() {
            return( Pymod$MZTrafoModel_MODELTYPE()$getMapping() )
        }
    )
) 

MassType = R6Class(classname = "MassType", cloneable = FALSE,

        public = list(

        MONOISOTOPIC = 0L,
        AVERAGE = 1L,
        initialize = function(){
            lockBinding("MONOISOTOPIC",self)
            lockBinding("AVERAGE",self)
        },
        getMapping = function() {
            return( Pymod$MassType()$getMapping() )
        }
    )
) 

Measure = R6Class(classname = "Measure", cloneable = FALSE,

        public = list(

        MEASURE_PPM = 0L,
        MEASURE_DA = 1L,
        initialize = function(){
            lockBinding("MEASURE_PPM",self)
            lockBinding("MEASURE_DA",self)
        },
        getMapping = function() {
            return( Pymod$Measure()$getMapping() )
        }
    )
) 

Modification_SpecificityType = R6Class(classname = "Modification_SpecificityType", cloneable = FALSE,

        public = list(

        AA = 0L,
        AA_AT_CTERM = 1L,
        AA_AT_NTERM = 2L,
        CTERM = 3L,
        NTERM = 4L,
        SIZE_OF_SPECIFICITYTYPE = 5L,
        initialize = function(){
            lockBinding("AA",self)
            lockBinding("AA_AT_CTERM",self)
            lockBinding("AA_AT_NTERM",self)
            lockBinding("CTERM",self)
            lockBinding("NTERM",self)
            lockBinding("SIZE_OF_SPECIFICITYTYPE",self)
        },
        getMapping = function() {
            return( Pymod$Modification_SpecificityType()$getMapping() )
        }
    )
) 

NASFragmentType = R6Class(classname = "NASFragmentType", cloneable = FALSE,

        public = list(

        Full = 0L,
        Internal = 1L,
        FivePrime = 2L,
        ThreePrime = 3L,
        AIon = 4L,
        BIon = 5L,
        CIon = 6L,
        XIon = 7L,
        YIon = 8L,
        ZIon = 9L,
        Precursor = 10L,
        BIonMinusH20 = 11L,
        YIonMinusH20 = 12L,
        BIonMinusNH3 = 13L,
        YIonMinusNH3 = 14L,
        NonIdentified = 15L,
        Unannotated = 16L,
        WIon = 17L,
        AminusB = 18L,
        DIon = 19L,
        SizeOfNASFragmentType = 20L,
        initialize = function(){
            lockBinding("Full",self)
            lockBinding("Internal",self)
            lockBinding("FivePrime",self)
            lockBinding("ThreePrime",self)
            lockBinding("AIon",self)
            lockBinding("BIon",self)
            lockBinding("CIon",self)
            lockBinding("XIon",self)
            lockBinding("YIon",self)
            lockBinding("ZIon",self)
            lockBinding("Precursor",self)
            lockBinding("BIonMinusH20",self)
            lockBinding("YIonMinusH20",self)
            lockBinding("BIonMinusNH3",self)
            lockBinding("YIonMinusNH3",self)
            lockBinding("NonIdentified",self)
            lockBinding("Unannotated",self)
            lockBinding("WIon",self)
            lockBinding("AminusB",self)
            lockBinding("DIon",self)
            lockBinding("SizeOfNASFragmentType",self)
        },
        getMapping = function() {
            return( Pymod$NASFragmentType()$getMapping() )
        }
    )
) 

NormalizationMethod = R6Class(classname = "NormalizationMethod", cloneable = FALSE,

        public = list(

        NM_SCALE = 0L,
        NM_SHIFT = 1L,
        initialize = function(){
            lockBinding("NM_SCALE",self)
            lockBinding("NM_SHIFT",self)
        },
        getMapping = function() {
            return( Pymod$NormalizationMethod()$getMapping() )
        }
    )
) 

NumpressCompression = R6Class(classname = "NumpressCompression", cloneable = FALSE,

        public = list(

        NONE = 0L,
        LINEAR = 1L,
        PIC = 2L,
        SLOF = 3L,
        SIZE_OF_NUMPRESSCOMPRESSION = 4L,
        initialize = function(){
            lockBinding("NONE",self)
            lockBinding("LINEAR",self)
            lockBinding("PIC",self)
            lockBinding("SLOF",self)
            lockBinding("SIZE_OF_NUMPRESSCOMPRESSION",self)
        },
        getMapping = function() {
            return( Pymod$NumpressCompression()$getMapping() )
        }
    )
) 

OpenPepXLAlgorithm_ExitCodes = R6Class(classname = "OpenPepXLAlgorithm_ExitCodes", cloneable = FALSE,

        public = list(

        EXECUTION_OK = 0L,
        ILLEGAL_PARAMETERS = 1L,
        UNEXPECTED_RESULT = 2L,
        INCOMPATIBLE_INPUT_DATA = 3L,
        initialize = function(){
            lockBinding("EXECUTION_OK",self)
            lockBinding("ILLEGAL_PARAMETERS",self)
            lockBinding("UNEXPECTED_RESULT",self)
            lockBinding("INCOMPATIBLE_INPUT_DATA",self)
        },
        getMapping = function() {
            return( Pymod$OpenPepXLAlgorithm_ExitCodes()$getMapping() )
        }
    )
) 

OpenPepXLLFAlgorithm_ExitCodes = R6Class(classname = "OpenPepXLLFAlgorithm_ExitCodes", cloneable = FALSE,

        public = list(

        EXECUTION_OK = 0L,
        ILLEGAL_PARAMETERS = 1L,
        UNEXPECTED_RESULT = 2L,
        INCOMPATIBLE_INPUT_DATA = 3L,
        initialize = function(){
            lockBinding("EXECUTION_OK",self)
            lockBinding("ILLEGAL_PARAMETERS",self)
            lockBinding("UNEXPECTED_RESULT",self)
            lockBinding("INCOMPATIBLE_INPUT_DATA",self)
        },
        getMapping = function() {
            return( Pymod$OpenPepXLLFAlgorithm_ExitCodes()$getMapping() )
        }
    )
) 

PeakMassType = R6Class(classname = "PeakMassType", cloneable = FALSE,

        public = list(

        MONOISOTOPIC = 0L,
        AVERAGE = 1L,
        SIZE_OF_PEAKMASSTYPE = 2L,
        initialize = function(){
            lockBinding("MONOISOTOPIC",self)
            lockBinding("AVERAGE",self)
            lockBinding("SIZE_OF_PEAKMASSTYPE",self)
        },
        getMapping = function() {
            return( Pymod$PeakMassType()$getMapping() )
        }
    )
) 

PeakShape_Type = R6Class(classname = "PeakShape_Type", cloneable = FALSE,

        public = list(

        LORENTZ_PEAK = 0L,
        SECH_PEAK = 1L,
        UNDEFINED = 2L,
        initialize = function(){
            lockBinding("LORENTZ_PEAK",self)
            lockBinding("SECH_PEAK",self)
            lockBinding("UNDEFINED",self)
        },
        getMapping = function() {
            return( Pymod$PeakShape_Type()$getMapping() )
        }
    )
) 

PeptideIndexing_ExitCodes = R6Class(classname = "PeptideIndexing_ExitCodes", cloneable = FALSE,

        public = list(

        EXECUTION_OK = 0L,
        DATABASE_EMPTY = 1L,
        PEPTIDE_IDS_EMPTY = 2L,
        ILLEGAL_PARAMETERS = 3L,
        UNEXPECTED_RESULT = 4L,
        DECOYSTRING_EMPTY = 5L,
        initialize = function(){
            lockBinding("EXECUTION_OK",self)
            lockBinding("DATABASE_EMPTY",self)
            lockBinding("PEPTIDE_IDS_EMPTY",self)
            lockBinding("ILLEGAL_PARAMETERS",self)
            lockBinding("UNEXPECTED_RESULT",self)
            lockBinding("DECOYSTRING_EMPTY",self)
        },
        getMapping = function() {
            return( Pymod$PeptideIndexing_ExitCodes()$getMapping() )
        }
    )
) 

PeptidePosition = R6Class(classname = "PeptidePosition", cloneable = FALSE,

        public = list(

        INTERNAL = 0L,
        C_TERM = 1L,
        N_TERM = 2L,
        initialize = function(){
            lockBinding("INTERNAL",self)
            lockBinding("C_TERM",self)
            lockBinding("N_TERM",self)
        },
        getMapping = function() {
            return( Pymod$PeptidePosition()$getMapping() )
        }
    )
) 

PercolatorOutfile_ScoreType = R6Class(classname = "PercolatorOutfile_ScoreType", cloneable = FALSE,

        public = list(

        QVALUE = 0L,
        POSTERRPROB = 1L,
        SCORE = 2L,
        SIZE_OF_SCORETYPE = 3L,
        initialize = function(){
            lockBinding("QVALUE",self)
            lockBinding("POSTERRPROB",self)
            lockBinding("SCORE",self)
            lockBinding("SIZE_OF_SCORETYPE",self)
        },
        getMapping = function() {
            return( Pymod$PercolatorOutfile_ScoreType()$getMapping() )
        }
    )
) 

Polarity = R6Class(classname = "Polarity", cloneable = FALSE,

        public = list(

        POLNULL = 0L,
        POSITIVE = 1L,
        NEGATIVE = 2L,
        SIZE_OF_POLARITY = 3L,
        initialize = function(){
            lockBinding("POLNULL",self)
            lockBinding("POSITIVE",self)
            lockBinding("NEGATIVE",self)
            lockBinding("SIZE_OF_POLARITY",self)
        },
        getMapping = function() {
            return( Pymod$Polarity()$getMapping() )
        }
    )
) 

PrecursorIonSelection_Type = R6Class(classname = "PrecursorIonSelection_Type", cloneable = FALSE,

        public = list(

        IPS = 0L,
        ILP_IPS = 1L,
        SPS = 2L,
        UPSHIFT = 3L,
        DOWNSHIFT = 4L,
        DEX = 5L,
        initialize = function(){
            lockBinding("IPS",self)
            lockBinding("ILP_IPS",self)
            lockBinding("SPS",self)
            lockBinding("UPSHIFT",self)
            lockBinding("DOWNSHIFT",self)
            lockBinding("DEX",self)
        },
        getMapping = function() {
            return( Pymod$PrecursorIonSelection_Type()$getMapping() )
        }
    )
) 

ProcessingAction = R6Class(classname = "ProcessingAction", cloneable = FALSE,

        public = list(

        DATA_PROCESSING = 0L,
        CHARGE_DECONVOLUTION = 1L,
        DEISOTOPING = 2L,
        SMOOTHING = 3L,
        CHARGE_CALCULATION = 4L,
        PRECURSOR_RECALCULATION = 5L,
        BASELINE_REDUCTION = 6L,
        PEAK_PICKING = 7L,
        ALIGNMENT = 8L,
        CALIBRATION = 9L,
        NORMALIZATION = 10L,
        FILTERING = 11L,
        QUANTITATION = 12L,
        FEATURE_GROUPING = 13L,
        IDENTIFICATION_MAPPING = 14L,
        FORMAT_CONVERSION = 15L,
        CONVERSION_MZDATA = 16L,
        CONVERSION_MZML = 17L,
        CONVERSION_MZXML = 18L,
        CONVERSION_DTA = 19L,
        SIZE_OF_PROCESSINGACTION = 20L,
        initialize = function(){
            lockBinding("DATA_PROCESSING",self)
            lockBinding("CHARGE_DECONVOLUTION",self)
            lockBinding("DEISOTOPING",self)
            lockBinding("SMOOTHING",self)
            lockBinding("CHARGE_CALCULATION",self)
            lockBinding("PRECURSOR_RECALCULATION",self)
            lockBinding("BASELINE_REDUCTION",self)
            lockBinding("PEAK_PICKING",self)
            lockBinding("ALIGNMENT",self)
            lockBinding("CALIBRATION",self)
            lockBinding("NORMALIZATION",self)
            lockBinding("FILTERING",self)
            lockBinding("QUANTITATION",self)
            lockBinding("FEATURE_GROUPING",self)
            lockBinding("IDENTIFICATION_MAPPING",self)
            lockBinding("FORMAT_CONVERSION",self)
            lockBinding("CONVERSION_MZDATA",self)
            lockBinding("CONVERSION_MZML",self)
            lockBinding("CONVERSION_MZXML",self)
            lockBinding("CONVERSION_DTA",self)
            lockBinding("SIZE_OF_PROCESSINGACTION",self)
        },
        getMapping = function() {
            return( Pymod$ProcessingAction()$getMapping() )
        }
    )
) 

ProteinEntry_type = R6Class(classname = "ProteinEntry_type", cloneable = FALSE,

        public = list(

        primary = 0L,
        secondary = 1L,
        primary_indistinguishable = 2L,
        secondary_indistinguishable = 3L,
        initialize = function(){
            lockBinding("primary",self)
            lockBinding("secondary",self)
            lockBinding("primary_indistinguishable",self)
            lockBinding("secondary_indistinguishable",self)
        },
        getMapping = function() {
            return( Pymod$ProteinEntry_type()$getMapping() )
        }
    )
) 

ProteinProteinCrossLinkType = R6Class(classname = "ProteinProteinCrossLinkType", cloneable = FALSE,

        public = list(

        CROSS = 0L,
        MONO = 1L,
        LOOP = 2L,
        NUMBER_OF_CROSS_LINK_TYPES = 3L,
        initialize = function(){
            lockBinding("CROSS",self)
            lockBinding("MONO",self)
            lockBinding("LOOP",self)
            lockBinding("NUMBER_OF_CROSS_LINK_TYPES",self)
        },
        getMapping = function() {
            return( Pymod$ProteinProteinCrossLinkType()$getMapping() )
        }
    )
) 

ProteinResolverResult_Type = R6Class(classname = "ProteinResolverResult_Type", cloneable = FALSE,

        public = list(

        PeptideIdent = 0L,
        Consensus = 1L,
        initialize = function(){
            lockBinding("PeptideIdent",self)
            lockBinding("Consensus",self)
        },
        getMapping = function() {
            return( Pymod$ProteinResolverResult_Type()$getMapping() )
        }
    )
) 

QUANT_TYPES = R6Class(classname = "QUANT_TYPES", cloneable = FALSE,

        public = list(

        MS1LABEL = 0L,
        MS2LABEL = 1L,
        LABELFREE = 2L,
        SIZE_OF_QUANT_TYPES = 3L,
        initialize = function(){
            lockBinding("MS1LABEL",self)
            lockBinding("MS2LABEL",self)
            lockBinding("LABELFREE",self)
            lockBinding("SIZE_OF_QUANT_TYPES",self)
        },
        getMapping = function() {
            return( Pymod$QUANT_TYPES()$getMapping() )
        }
    )
) 

QuotingMethod = R6Class(classname = "QuotingMethod", cloneable = FALSE,

        public = list(

        NONE = 0L,
        ESCAPE = 1L,
        DOUBLE = 2L,
        initialize = function(){
            lockBinding("NONE",self)
            lockBinding("ESCAPE",self)
            lockBinding("DOUBLE",self)
        },
        getMapping = function() {
            return( Pymod$QuotingMethod()$getMapping() )
        }
    )
) 

RETURN_STATUS = R6Class(classname = "RETURN_STATUS", cloneable = FALSE,

        public = list(

        SOLVED = 0L,
        ITERATION_EXCEEDED = 1L,
        initialize = function(){
            lockBinding("SOLVED",self)
            lockBinding("ITERATION_EXCEEDED",self)
        },
        getMapping = function() {
            return( Pymod$RETURN_STATUS()$getMapping() )
        }
    )
) 

RTType = R6Class(classname = "RTType", cloneable = FALSE,

        public = list(

        LOCAL = 0L,
        NORMALIZED = 1L,
        PREDICTED = 2L,
        HPINS = 3L,
        IRT = 4L,
        UNKNOWN = 5L,
        SIZE_OF_RTTYPE = 6L,
        initialize = function(){
            lockBinding("LOCAL",self)
            lockBinding("NORMALIZED",self)
            lockBinding("PREDICTED",self)
            lockBinding("HPINS",self)
            lockBinding("IRT",self)
            lockBinding("UNKNOWN",self)
            lockBinding("SIZE_OF_RTTYPE",self)
        },
        getMapping = function() {
            return( Pymod$RTType()$getMapping() )
        }
    )
) 

RTUnit = R6Class(classname = "RTUnit", cloneable = FALSE,

        public = list(

        SECOND = 0L,
        MINUTE = 1L,
        UNKNOWN = 2L,
        SIZE_OF_RTUNIT = 3L,
        initialize = function(){
            lockBinding("SECOND",self)
            lockBinding("MINUTE",self)
            lockBinding("UNKNOWN",self)
            lockBinding("SIZE_OF_RTUNIT",self)
        },
        getMapping = function() {
            return( Pymod$RTUnit()$getMapping() )
        }
    )
) 

ReflectronState = R6Class(classname = "ReflectronState", cloneable = FALSE,

        public = list(

        REFLSTATENULL = 0L,
        ON = 1L,
        OFF = 2L,
        NONE = 3L,
        SIZE_OF_REFLECTRONSTATE = 4L,
        initialize = function(){
            lockBinding("REFLSTATENULL",self)
            lockBinding("ON",self)
            lockBinding("OFF",self)
            lockBinding("NONE",self)
            lockBinding("SIZE_OF_REFLECTRONSTATE",self)
        },
        getMapping = function() {
            return( Pymod$ReflectronState()$getMapping() )
        }
    )
) 

RequirementLevel = R6Class(classname = "RequirementLevel", cloneable = FALSE,

        public = list(

        MUST = 0L,
        SHOULD = 1L,
        MAY = 2L,
        initialize = function(){
            lockBinding("MUST",self)
            lockBinding("SHOULD",self)
            lockBinding("MAY",self)
        },
        getMapping = function() {
            return( Pymod$RequirementLevel()$getMapping() )
        }
    )
) 

ResidueType = R6Class(classname = "ResidueType", cloneable = FALSE,

        public = list(

        Full = 0L,
        Internal = 1L,
        NTerminal = 2L,
        CTerminal = 3L,
        AIon = 4L,
        BIon = 5L,
        CIon = 6L,
        XIon = 7L,
        YIon = 8L,
        ZIon = 9L,
        Precursor_ion = 10L,
        BIonMinusH20 = 11L,
        YIonMinusH20 = 12L,
        BIonMinusNH3 = 13L,
        YIonMinusNH3 = 14L,
        NonIdentified = 15L,
        Unannotated = 16L,
        SizeOfResidueType = 17L,
        initialize = function(){
            lockBinding("Full",self)
            lockBinding("Internal",self)
            lockBinding("NTerminal",self)
            lockBinding("CTerminal",self)
            lockBinding("AIon",self)
            lockBinding("BIon",self)
            lockBinding("CIon",self)
            lockBinding("XIon",self)
            lockBinding("YIon",self)
            lockBinding("ZIon",self)
            lockBinding("Precursor_ion",self)
            lockBinding("BIonMinusH20",self)
            lockBinding("YIonMinusH20",self)
            lockBinding("BIonMinusNH3",self)
            lockBinding("YIonMinusNH3",self)
            lockBinding("NonIdentified",self)
            lockBinding("Unannotated",self)
            lockBinding("SizeOfResidueType",self)
        },
        getMapping = function() {
            return( Pymod$ResidueType()$getMapping() )
        }
    )
) 

ResolutionMethod = R6Class(classname = "ResolutionMethod", cloneable = FALSE,

        public = list(

        RESMETHNULL = 0L,
        FWHM = 1L,
        TENPERCENTVALLEY = 2L,
        BASELINE = 3L,
        SIZE_OF_RESOLUTIONMETHOD = 4L,
        initialize = function(){
            lockBinding("RESMETHNULL",self)
            lockBinding("FWHM",self)
            lockBinding("TENPERCENTVALLEY",self)
            lockBinding("BASELINE",self)
            lockBinding("SIZE_OF_RESOLUTIONMETHOD",self)
        },
        getMapping = function() {
            return( Pymod$ResolutionMethod()$getMapping() )
        }
    )
) 

ResolutionType = R6Class(classname = "ResolutionType", cloneable = FALSE,

        public = list(

        RESTYPENULL = 0L,
        CONSTANT = 1L,
        PROPORTIONAL = 2L,
        SIZE_OF_RESOLUTIONTYPE = 3L,
        initialize = function(){
            lockBinding("RESTYPENULL",self)
            lockBinding("CONSTANT",self)
            lockBinding("PROPORTIONAL",self)
            lockBinding("SIZE_OF_RESOLUTIONTYPE",self)
        },
        getMapping = function() {
            return( Pymod$ResolutionType()$getMapping() )
        }
    )
) 

SIDE = R6Class(classname = "SIDE", cloneable = FALSE,

        public = list(

        LEFT = 0L,
        RIGHT = 1L,
        BOTH = 2L,
        initialize = function(){
            lockBinding("LEFT",self)
            lockBinding("RIGHT",self)
            lockBinding("BOTH",self)
        },
        getMapping = function() {
            return( Pymod$SIDE()$getMapping() )
        }
    )
) 

SOLVER = R6Class(classname = "SOLVER", cloneable = FALSE,

        public = list(

        SOLVER_GLPK = 0L,
        initialize = function(){
            lockBinding("SOLVER_GLPK",self)
        },
        getMapping = function() {
            return( Pymod$SOLVER()$getMapping() )
        }
    )
) 

SVM_kernel_type = R6Class(classname = "SVM_kernel_type", cloneable = FALSE,

        public = list(

        OLIGO = 0L,
        OLIGO_COMBINED = 1L,
        initialize = function(){
            lockBinding("OLIGO",self)
            lockBinding("OLIGO_COMBINED",self)
        },
        getMapping = function() {
            return( Pymod$SVM_kernel_type()$getMapping() )
        }
    )
) 

SVM_parameter_type = R6Class(classname = "SVM_parameter_type", cloneable = FALSE,

        public = list(

        SVM_TYPE = 0L,
        KERNEL_TYPE = 1L,
        DEGREE = 2L,
        C = 3L,
        NU = 4L,
        P = 5L,
        GAMMA = 6L,
        PROBABILITY = 7L,
        SIGMA = 8L,
        BORDER_LENGTH = 9L,
        initialize = function(){
            lockBinding("SVM_TYPE",self)
            lockBinding("KERNEL_TYPE",self)
            lockBinding("DEGREE",self)
            lockBinding("C",self)
            lockBinding("NU",self)
            lockBinding("P",self)
            lockBinding("GAMMA",self)
            lockBinding("PROBABILITY",self)
            lockBinding("SIGMA",self)
            lockBinding("BORDER_LENGTH",self)
        },
        getMapping = function() {
            return( Pymod$SVM_parameter_type()$getMapping() )
        }
    )
) 

SampleState = R6Class(classname = "SampleState", cloneable = FALSE,

        public = list(

        SAMPLENULL = 0L,
        SOLID = 1L,
        LIQUID = 2L,
        GAS = 3L,
        SOLUTION = 4L,
        EMULSION = 5L,
        SUSPENSION = 6L,
        SIZE_OF_SAMPLESTATE = 7L,
        initialize = function(){
            lockBinding("SAMPLENULL",self)
            lockBinding("SOLID",self)
            lockBinding("LIQUID",self)
            lockBinding("GAS",self)
            lockBinding("SOLUTION",self)
            lockBinding("EMULSION",self)
            lockBinding("SUSPENSION",self)
            lockBinding("SIZE_OF_SAMPLESTATE",self)
        },
        getMapping = function() {
            return( Pymod$SampleState()$getMapping() )
        }
    )
) 

ScanDirection = R6Class(classname = "ScanDirection", cloneable = FALSE,

        public = list(

        SCANDIRNULL = 0L,
        UP = 1L,
        DOWN = 2L,
        SIZE_OF_SCANDIRECTION = 3L,
        initialize = function(){
            lockBinding("SCANDIRNULL",self)
            lockBinding("UP",self)
            lockBinding("DOWN",self)
            lockBinding("SIZE_OF_SCANDIRECTION",self)
        },
        getMapping = function() {
            return( Pymod$ScanDirection()$getMapping() )
        }
    )
) 

ScanLaw = R6Class(classname = "ScanLaw", cloneable = FALSE,

        public = list(

        SCANLAWNULL = 0L,
        EXPONENTIAL = 1L,
        LINEAR = 2L,
        QUADRATIC = 3L,
        SIZE_OF_SCANLAW = 4L,
        initialize = function(){
            lockBinding("SCANLAWNULL",self)
            lockBinding("EXPONENTIAL",self)
            lockBinding("LINEAR",self)
            lockBinding("QUADRATIC",self)
            lockBinding("SIZE_OF_SCANLAW",self)
        },
        getMapping = function() {
            return( Pymod$ScanLaw()$getMapping() )
        }
    )
) 

ScanMode = R6Class(classname = "ScanMode", cloneable = FALSE,

        public = list(

        UNKNOWN = 0L,
        MASSSPECTRUM = 1L,
        MS1SPECTRUM = 2L,
        MSNSPECTRUM = 3L,
        SIM = 4L,
        SRM = 5L,
        CRM = 6L,
        CNG = 7L,
        CNL = 8L,
        PRECURSOR = 9L,
        EMC = 10L,
        TDF = 11L,
        EMR = 12L,
        EMISSION = 13L,
        ABSORPTION = 14L,
        SIZE_OF_SCANMODE = 15L,
        initialize = function(){
            lockBinding("UNKNOWN",self)
            lockBinding("MASSSPECTRUM",self)
            lockBinding("MS1SPECTRUM",self)
            lockBinding("MSNSPECTRUM",self)
            lockBinding("SIM",self)
            lockBinding("SRM",self)
            lockBinding("CRM",self)
            lockBinding("CNG",self)
            lockBinding("CNL",self)
            lockBinding("PRECURSOR",self)
            lockBinding("EMC",self)
            lockBinding("TDF",self)
            lockBinding("EMR",self)
            lockBinding("EMISSION",self)
            lockBinding("ABSORPTION",self)
            lockBinding("SIZE_OF_SCANMODE",self)
        },
        getMapping = function() {
            return( Pymod$ScanMode()$getMapping() )
        }
    )
) 

Sense = R6Class(classname = "Sense", cloneable = FALSE,

        public = list(

        MIN = 0L,
        MAX = 1L,
        initialize = function(){
            lockBinding("MIN",self)
            lockBinding("MAX",self)
        },
        getMapping = function() {
            return( Pymod$Sense()$getMapping() )
        }
    )
) 

SolverStatus = R6Class(classname = "SolverStatus", cloneable = FALSE,

        public = list(

        UNDEFINED = 0L,
        OPTIMAL = 1L,
        FEASIBLE = 2L,
        NO_FEASIBLE_SOL = 3L,
        initialize = function(){
            lockBinding("UNDEFINED",self)
            lockBinding("OPTIMAL",self)
            lockBinding("FEASIBLE",self)
            lockBinding("NO_FEASIBLE_SOL",self)
        },
        getMapping = function() {
            return( Pymod$SolverStatus()$getMapping() )
        }
    )
) 

Sorted = R6Class(classname = "Sorted", cloneable = FALSE,

        public = list(

        INTENSITY = 0L,
        MASS = 1L,
        UNDEFINED = 2L,
        initialize = function(){
            lockBinding("INTENSITY",self)
            lockBinding("MASS",self)
            lockBinding("UNDEFINED",self)
        },
        getMapping = function() {
            return( Pymod$Sorted()$getMapping() )
        }
    )
) 

SourceClassification = R6Class(classname = "SourceClassification", cloneable = FALSE,

        public = list(

        ARTIFACT = 0L,
        HYPOTHETICAL = 1L,
        NATURAL = 2L,
        POSTTRANSLATIONAL = 3L,
        MULTIPLE = 4L,
        CHEMICAL_DERIVATIVE = 5L,
        ISOTOPIC_LABEL = 6L,
        PRETRANSLATIONAL = 7L,
        OTHER_GLYCOSYLATION = 8L,
        NLINKED_GLYCOSYLATION = 9L,
        AA_SUBSTITUTION = 10L,
        OTHER = 11L,
        NONSTANDARD_RESIDUE = 12L,
        COTRANSLATIONAL = 13L,
        OLINKED_GLYCOSYLATION = 14L,
        UNKNOWN = 15L,
        NUMBER_OF_SOURCE_CLASSIFICATIONS = 16L,
        initialize = function(){
            lockBinding("ARTIFACT",self)
            lockBinding("HYPOTHETICAL",self)
            lockBinding("NATURAL",self)
            lockBinding("POSTTRANSLATIONAL",self)
            lockBinding("MULTIPLE",self)
            lockBinding("CHEMICAL_DERIVATIVE",self)
            lockBinding("ISOTOPIC_LABEL",self)
            lockBinding("PRETRANSLATIONAL",self)
            lockBinding("OTHER_GLYCOSYLATION",self)
            lockBinding("NLINKED_GLYCOSYLATION",self)
            lockBinding("AA_SUBSTITUTION",self)
            lockBinding("OTHER",self)
            lockBinding("NONSTANDARD_RESIDUE",self)
            lockBinding("COTRANSLATIONAL",self)
            lockBinding("OLINKED_GLYCOSYLATION",self)
            lockBinding("UNKNOWN",self)
            lockBinding("NUMBER_OF_SOURCE_CLASSIFICATIONS",self)
        },
        getMapping = function() {
            return( Pymod$SourceClassification()$getMapping() )
        }
    )
) 

Specificity = R6Class(classname = "Specificity", cloneable = FALSE,

        public = list(

        SPEC_NONE = 0L,
        SPEC_SEMI = 1L,
        SPEC_FULL = 2L,
        SPEC_UNKNOWN = 3L,
        SPEC_NOCTERM = 8L,
        SPEC_NONTERM = 9L,
        SIZE_OF_SPECIFICITY = 10L,
        initialize = function(){
            lockBinding("SPEC_NONE",self)
            lockBinding("SPEC_SEMI",self)
            lockBinding("SPEC_FULL",self)
            lockBinding("SPEC_UNKNOWN",self)
            lockBinding("SPEC_NOCTERM",self)
            lockBinding("SPEC_NONTERM",self)
            lockBinding("SIZE_OF_SPECIFICITY",self)
        },
        getMapping = function() {
            return( Pymod$Specificity()$getMapping() )
        }
    )
) 

SpectrumType = R6Class(classname = "SpectrumType", cloneable = FALSE,

        public = list(

        UNKNOWN = 0L,
        PEAKS = 1L,
        RAWDATA = 2L,
        SIZE_OF_SPECTRUMTYPE = 3L,
        initialize = function(){
            lockBinding("UNKNOWN",self)
            lockBinding("PEAKS",self)
            lockBinding("RAWDATA",self)
            lockBinding("SIZE_OF_SPECTRUMTYPE",self)
        },
        getMapping = function() {
            return( Pymod$SpectrumType()$getMapping() )
        }
    )
) 

TermSpecificity = R6Class(classname = "TermSpecificity", cloneable = FALSE,

        public = list(

        ANYWHERE = 0L,
        C_TERM = 1L,
        N_TERM = 2L,
        PROTEIN_C_TERM = 3L,
        PROTEIN_N_TERM = 4L,
        NUMBER_OF_TERM_SPECIFICITY = 5L,
        initialize = function(){
            lockBinding("ANYWHERE",self)
            lockBinding("C_TERM",self)
            lockBinding("N_TERM",self)
            lockBinding("PROTEIN_C_TERM",self)
            lockBinding("PROTEIN_N_TERM",self)
            lockBinding("NUMBER_OF_TERM_SPECIFICITY",self)
        },
        getMapping = function() {
            return( Pymod$TermSpecificity()$getMapping() )
        }
    )
) 

TermSpecificityNuc = R6Class(classname = "TermSpecificityNuc", cloneable = FALSE,

        public = list(

        ANYWHERE = 0L,
        FIVE_PRIME = 1L,
        THREE_PRIME = 2L,
        NUMBER_OF_TERM_SPECIFICITY = 3L,
        initialize = function(){
            lockBinding("ANYWHERE",self)
            lockBinding("FIVE_PRIME",self)
            lockBinding("THREE_PRIME",self)
            lockBinding("NUMBER_OF_TERM_SPECIFICITY",self)
        },
        getMapping = function() {
            return( Pymod$TermSpecificityNuc()$getMapping() )
        }
    )
) 

Type_IonDetector = R6Class(classname = "Type_IonDetector", cloneable = FALSE,

        public = list(

        TYPENULL = 0L,
        ELECTRONMULTIPLIER = 1L,
        PHOTOMULTIPLIER = 2L,
        FOCALPLANEARRAY = 3L,
        FARADAYCUP = 4L,
        CONVERSIONDYNODEELECTRONMULTIPLIER = 5L,
        CONVERSIONDYNODEPHOTOMULTIPLIER = 6L,
        MULTICOLLECTOR = 7L,
        CHANNELELECTRONMULTIPLIER = 8L,
        CHANNELTRON = 9L,
        DALYDETECTOR = 10L,
        MICROCHANNELPLATEDETECTOR = 11L,
        ARRAYDETECTOR = 12L,
        CONVERSIONDYNODE = 13L,
        DYNODE = 14L,
        FOCALPLANECOLLECTOR = 15L,
        IONTOPHOTONDETECTOR = 16L,
        POINTCOLLECTOR = 17L,
        POSTACCELERATIONDETECTOR = 18L,
        PHOTODIODEARRAYDETECTOR = 19L,
        INDUCTIVEDETECTOR = 20L,
        ELECTRONMULTIPLIERTUBE = 21L,
        SIZE_OF_TYPE = 22L,
        initialize = function(){
            lockBinding("TYPENULL",self)
            lockBinding("ELECTRONMULTIPLIER",self)
            lockBinding("PHOTOMULTIPLIER",self)
            lockBinding("FOCALPLANEARRAY",self)
            lockBinding("FARADAYCUP",self)
            lockBinding("CONVERSIONDYNODEELECTRONMULTIPLIER",self)
            lockBinding("CONVERSIONDYNODEPHOTOMULTIPLIER",self)
            lockBinding("MULTICOLLECTOR",self)
            lockBinding("CHANNELELECTRONMULTIPLIER",self)
            lockBinding("CHANNELTRON",self)
            lockBinding("DALYDETECTOR",self)
            lockBinding("MICROCHANNELPLATEDETECTOR",self)
            lockBinding("ARRAYDETECTOR",self)
            lockBinding("CONVERSIONDYNODE",self)
            lockBinding("DYNODE",self)
            lockBinding("FOCALPLANECOLLECTOR",self)
            lockBinding("IONTOPHOTONDETECTOR",self)
            lockBinding("POINTCOLLECTOR",self)
            lockBinding("POSTACCELERATIONDETECTOR",self)
            lockBinding("PHOTODIODEARRAYDETECTOR",self)
            lockBinding("INDUCTIVEDETECTOR",self)
            lockBinding("ELECTRONMULTIPLIERTUBE",self)
            lockBinding("SIZE_OF_TYPE",self)
        },
        getMapping = function() {
            return( Pymod$Type_IonDetector()$getMapping() )
        }
    )
) 

UnitType = R6Class(classname = "UnitType", cloneable = FALSE,

        public = list(

        UNIT_ONTOLOGY = 0L,
        MS_ONTOLOGY = 1L,
        OTHER = 2L,
        initialize = function(){
            lockBinding("UNIT_ONTOLOGY",self)
            lockBinding("MS_ONTOLOGY",self)
            lockBinding("OTHER",self)
        },
        getMapping = function() {
            return( Pymod$UnitType()$getMapping() )
        }
    )
) 

VariableType = R6Class(classname = "VariableType", cloneable = FALSE,

        public = list(

        CONTINUOUS = 0L,
        INTEGER = 1L,
        BINARY = 2L,
        initialize = function(){
            lockBinding("CONTINUOUS",self)
            lockBinding("INTEGER",self)
            lockBinding("BINARY",self)
        },
        getMapping = function() {
            return( Pymod$VariableType()$getMapping() )
        }
    )
) 

WriteFormat = R6Class(classname = "WriteFormat", cloneable = FALSE,

        public = list(

        FORMAT_LP = 0L,
        FORMAT_MPS = 1L,
        FORMAT_GLPK = 2L,
        initialize = function(){
            lockBinding("FORMAT_LP",self)
            lockBinding("FORMAT_MPS",self)
            lockBinding("FORMAT_GLPK",self)
        },
        getMapping = function() {
            return( Pymod$WriteFormat()$getMapping() )
        }
    )
) 

XFDRAlgorithm_ExitCodes = R6Class(classname = "XFDRAlgorithm_ExitCodes", cloneable = FALSE,

        public = list(

        EXECUTION_OK = 0L,
        ILLEGAL_PARAMETERS = 1L,
        UNEXPECTED_RESULT = 2L,
        initialize = function(){
            lockBinding("EXECUTION_OK",self)
            lockBinding("ILLEGAL_PARAMETERS",self)
            lockBinding("UNEXPECTED_RESULT",self)
        },
        getMapping = function() {
            return( Pymod$XFDRAlgorithm_ExitCodes()$getMapping() )
        }
    )
) 

XRefType_CVTerm_ControlledVocabulary = R6Class(classname = "XRefType_CVTerm_ControlledVocabulary", cloneable = FALSE,

        public = list(

        XSD_STRING = 0L,
        XSD_INTEGER = 1L,
        XSD_DECIMAL = 2L,
        XSD_NEGATIVE_INTEGER = 3L,
        XSD_POSITIVE_INTEGER = 4L,
        XSD_NON_NEGATIVE_INTEGER = 5L,
        XSD_NON_POSITIVE_INTEGER = 6L,
        XSD_BOOLEAN = 7L,
        XSD_DATE = 8L,
        XSD_ANYURI = 9L,
        NONE = 10L,
        initialize = function(){
            lockBinding("XSD_STRING",self)
            lockBinding("XSD_INTEGER",self)
            lockBinding("XSD_DECIMAL",self)
            lockBinding("XSD_NEGATIVE_INTEGER",self)
            lockBinding("XSD_POSITIVE_INTEGER",self)
            lockBinding("XSD_NON_NEGATIVE_INTEGER",self)
            lockBinding("XSD_NON_POSITIVE_INTEGER",self)
            lockBinding("XSD_BOOLEAN",self)
            lockBinding("XSD_DATE",self)
            lockBinding("XSD_ANYURI",self)
            lockBinding("NONE",self)
        },
        getMapping = function() {
            return( Pymod$XRefType_CVTerm_ControlledVocabulary()$getMapping() )
        }
    )
) 
