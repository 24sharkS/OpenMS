// --------------------------------------------------------------------------
//                   %OpenMS -- Open-Source Mass Spectrometry
// --------------------------------------------------------------------------
// Copyright The %OpenMS Team -- Eberhard Karls University Tuebingen,
// ETH Zurich, and Freie Universitaet Berlin 2002-2017.
//
// This software is released under a three-clause BSD license:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of any author or any participating institution
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// For a full list of authors, refer to the file AUTHORS.
// --------------------------------------------------------------------------
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL ANY OF THE AUTHORS OR THE CONTRIBUTING
// INSTITUTIONS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// --------------------------------------------------------------------------
// $Maintainer:  $
// $Authors: Timo Sachsenberg, Oliver Alka$
// --------------------------------------------------------------------------

//########################### Please read this carefully! ###########################

// Sections:
// - to add new pages you have to add them to:
//    - doc/OpenMS_tutorial/refman_overwrite.tex.in (pdf output)
//    - doc/doxygen/public/OpenMS_Tutorial_html.doxygen (html output)

// Conventions:
// - Please write a short introduction for each chapter that explains
//   what classes are described and where these classes can be found (folder)
// - Use @a to visually highlight class names, namespaces, etc
// - When using example code, put it in the %OpenMS/doc/code_examples folder
//   to make sure it can be compiled. The name of the file should be in the text
//   to make the file easy to find for the user.
// - When talking about %OpenMS in general, prefix it with a '%'. Otherwise a
//   link to the %OpenMS namespace is generated automatically

//####################################### INTRODUCTION  #######################################

/**

@page tutorial_introduction Introduction

Mass spectrometry (MS) is an essential analytical technique for high-throughput analysis in proteomics and metabolomics. The development of new separation techniques, precise mass analyzers and experimental protocols is a very active field of research. This leads to more complex experimental setups yielding ever increasing amounts of data. Consequently, analysis of the data is currently often the bottleneck for experimental studies. Although software tools for many data analysis tasks are available today, they are often hard to combine with each other or not flexible enough to allow for rapid prototyping of a new analysis workflow. <br>

<b>%OpenMS</b>, a software framework for rapid <b>application and method development</b> in mass spectrometry has been designed to be portable, easy-to-use, and robust while offering a rich functionality ranging from basic data structures to sophisticated algorithms for data analysis. (see https://www.nature.com/nmeth/journal/v13/n9/abs/nmeth.3959.html). <br>

<b>Ease of use:</b>
%OpenMS follows the <b>object-oriented</b> programming paradigm, which aims at mapping real-world entities to comprehensible data structures and interfaces. %OpenMS enforces a <b>coding style</b> that ensures consistent names of classes, methods and member variables which increases the usability as a software library. Another important feature of a software framework is documentation. We decided to use <b>doxygen</b> [15] to generate the class documentation from the <b>source code</b>, which ensures consistency of code and documentation. The documentation is generated in HTML format making it easy to read with a web browser. <br>

<b>Robustness:</b>
Robustness of algorithms is essential if a new method will be applied routinely to large scale datasets. Typically, there is a trade-off between performance and robustness. %OpenMS tries to address both issues equally. In general, we try to tolerate recoverable errors, e.g. files that do not entirely fulfill the format specifications. On the other hand, <b>exceptions</b> are used to handle fatal errors. To check for correctness, more than 1000 <b>unit tests</b> are implemented in total, covering public methods of classes. These tests check the behavior for both valid and invalid use. Additionally, <b>preprocessor macros</b> are used to enable additional consistency checks in debug mode, enforce <b>pre- and post-conditions</b>, and are then disabled in productive mode for performance reasons. <br>

<b>Extensibility:</b>
Since %OpenMS is based on several <b>external libraries</b> it is designed for the integration of external code. All classes are encapsulated in the %OpenMS namespace to avoid symbol clashes with other libraries. Through the use of <b>C++ templates</b>, many data structures are adaptable to specific use cases. Also, %OpenMS supports <b>standard formats</b> and is itself open-source software. The use of standard formats ensures that applications developed with %OpenMS can be easily integrated into existing analysis pipelines. %OpenMS source code is released under the permissive <b>BSD 3 license</b> and located on <b>GitHub</b>, a repository for open-source software. This allows users to participate in the project and to contribute to the code base. <br>

<b>Scriptable:</b>
%OpenMS allows exposing its functionality through python bindings (<b>%pyOpenMS</b>). This eases the rapid development of algorithms in Python that later can be translated to C++. <br>

<b>Portability:</b>
%OpenMS supports <b>Windows</b>, <b>Linux</b>, and <b>OS X</b> platforms. <br>
*/

//####################################### STRUCTURE #######################################

/**

@page tutorial_structure The structure of the %OpenMS Framework

The following image shows the overall structure of %OpenMS:

@image html Structure.png "Overall design of %OpenMS."
@image latex Structure.png "Overall design of %OpenMS." width=14cm

The structure of the OpenMS framework. <br>

The %OpenMS software framework consists of three main layers:
- <b>%OpenMS Library:</b> the object-oriented %OpenMS core library contains over 1,300 classes and is built on modern C++ infrastructure with native compiler support on Windows, Linux and OS X. The classes are representing core concepts in mass spectrometry as well as the corresponding ontologies defined by the Human Proteome Organization Proteomics Standard Initiative (HUPO-PSI). <br>
- <b>Scripting:</b> a well-defined Python API offers scripting for rapid software prototyping and interactive data exploration by researchers with advanced scripting skills. The pyOpenMS interactive Python interface, providing easy integration of the %OpenMS library with other scientific Python libraries.
- <b>TOPP tools:</b>  a set of pre-built tools covering most core tasks in computational mass spectrometry. These tools are created using the %OpenMS library. These tools form the building blocks that can be chained together to form complex workflows. <br>
- <b>Workflow:</b> a set of over 185 different tools for common mass spectrometric tasks can be accessed by routine users through the KNIME, and Galaxy workflow systems. <br>
Each level of increasing abstraction provides better usability, but limits the extensibility as the Python and workflow levels only have access to the exposed Python API or the available set of TOPP tools respectively. Increasing abstraction, however, makes it easier to design and execute complex analyses, even across multiple omics types. By following a layered design the different needs of bioinformaticians and life scientists are addressed. <br>

*/

//####################################### Developing with OpenMS #######################################

/**

@page tutorial_developing Developing with OpenMS

Before we get started developing with %OpenMS, we would like to point to some information on the development model and conventions we follow to maintain a coherent code base.

<b>Development model</b>
%OpenMS follows the Gitflow development workflow which is excellently describedI <a href="http://nvie.com/posts/a-successful-git-branching-model/">here</a>. Additionally we encourage every developer (even if he is eligible to push directly to OpenMS) to create his own fork (e.g. @username). The GitHub people provide superb documentation on <a href="https://help.github.com/articles/fork-a-repo">forking</a> and how to keep your fork <a href="https://help.github.com/articles/syncing-a-fork">up-to-date</a>. With your own fork you can follow the Gitflow development model directly, but instead of merging into "develop" in your own fork you can open a <a href="https://help.github.com/articles/using-pull-requests">pull request</a>. Before opening the pull request, please check the <a href="https://github.com/OpenMS/OpenMS/wiki/Pull-Request-Checklist">checklist</a>.
<br>
Some more details and tips are collected here.
<br>
<b>Conventions</b>
See the manual for proper coding style: <a href="https://github.com/OpenMS/OpenMS/wiki/Coding-conventions">Coding conventions</a> also see: <a href="https://github.com/OpenMS/OpenMS/wiki/C&%2343;&%2343;-Guide">C++ Guide</a>.
We automatically test for common coding convention violations using a modified version of cpplint. Style testing can be enabled using CMake options. We also provide a configuration file for Uncrustify for automated style corrections (see "tools/uncrustify.cfg").
<br>
<b>Commit Messages</b>
In order to ease the creation of a CHANGELOG we use a defined format for our commit messages.
See the manual for proper commit messages: <a href="https://github.com/OpenMS/OpenMS/wiki/HowTo---Write-Commit-Messages">How to write commit messages</a>.
<br>
<b>Automated Unit Tests</b>
Pull requests are automatically tested using our continuous integration platform. In addition we perform nightly test runs covering different platforms. Even if everything compiled well on your machine and all tests passed, please check if you broke another platform on the next day.
Nightly tests: <a href="http://cdash.openms.de/index.php?project=OpenMS">CDASH</a>
<br>
<b>Experimental Installers</b>
We automatically build installers for different platforms. These usually contain unstable or partially untested code - so use them at your own risk.
The nightly (unstable) installers are available <a href="http://ftp.mi.fu-berlin.de/OpenMS/nightly_binaries/">here</a>.
<br>
<b>Technical Documentation</b>
Documentation of classes and tools is automatically generated using doxygen:
See the documentation for <a href="http://www.openms.de/current_doxygen/html/">HEAD</a>
See the documentation for the latest <a href="https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/index.html">release branch</a>
<br>
<b>Building %OpenMS</b>
Before you get started coding with OpenMS you need to build it for your operating system. Please follow the <b>build instructions</b> from the documentation.
<br>
<a href="http://ftp.mi.fu-berlin.de/pub/OpenMS/release-documentation/html/install_linux.html"><b>Building %OpenMS on GNU/Linux</b></a>
<br>
<a href="http://ftp.mi.fu-berlin.de/pub/OpenMS/release-documentation/html/install_mac_bin.html"><b>Building %OpenMS on Mac OS X</b></a>
<br>
<a href="http://ftp.mi.fu-berlin.de/pub/OpenMS/release-documentation/html/install_win_bin.html"><b>Building %OpenMS on Windows</b></a>
<br>
Note that for development purposes, you might want to set the variable <i>CMAKE_BUILD_TYPE</i> to <i>Debug</i>. Otherwise, the default <i>Release</i> will be applied and disables pre-condition and post-condition checks, and assertions.
<br>
<b>Choice of an IDE</b> <br>
You are, of course, free to choose your favorite (or even no) IDE for %OpenMS development but given the size of %OpenMS, not all IDEs perform equally well. We have good experiences with Qt Creator on Linux and Mac, because it can directly import CMake Projects and is rather fast in indexing all files. On Windows, Visual Studio is currently the preferred solution. Additionally, you may want to try JetBrains CLion (it’s free for students, teachers and open source projects). Another option is Eclipse with C++ support, which can also import CMake projects directly with the respective CMake generator.

*/

//####################################### TERMS #######################################

/**

@page tutorial_terms Mass spectrometry terms

 The following terms for MS-related data are used in this tutorial and the %%OpenMS class documentation:
 - <b>Raw or profile peak</b>: a typically Gaussian shaped mass peak measured by the instrument. <br>
 - <b>Centroid or picked peak</b>: a single m/z, intensity pair as obtained after using a peak picking (also: peak centroiding) algorithm. <br>
 - <b>Spectrum / Scan</b>: a mass spectrum containing profile or centroided peaks (profile spectrum) or centroided peaks (peak spectrum). E.g. a low resolution profile (blue) and a centroided peak spectrum (pink) are shown in the figure below. <br>

TODO: update images

  @image html Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)"
  @image latex Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" width=12cm

 - <b>(Peak or Raw) Map</b>: a collection of spectra of a single LC-MS run. If spectra are recorded in profile mode, we usually use the term raw map. If spectra are already centroided we usually refer to them as peak map. <br>
 - <b>Feature</b>: a signal from a chemical entity detected in an HPLC-MS experiment, typically a peptide. <br>

The image below shows a peak map and the red circle highlights a feature. 

TODO: Update Image 

  @image html Terms_Map.png "Peak map with a marked feature (red)"
  @image latex Terms_Map.png "Peak map with a marked feature (red)" width=14cm

*/

//####################################### OpenMS Library #######################################

/**

@page tutorial_library %OpenMS Library

The extensible %OpenMS library implements common mass spectrometric data processing tasks through a well defined API in C++ and Python using standardized open data formats.

@section tutorial_library_overview Overview on Central Algorithms and Methods

%OpenMS provides algorithms in many fields of computational metabolomics and proteomics. <b>The following list is intended to algorithm and tool developers a starting point to tools and classes relevant to their scientific question at hand</b>. This list does not include third-party tools but only tools that were implemented in %OpenMS. 
<br>

- Proteomics:
    - Signal processing:
        - Conversion from profile to centroided spectra (Tool PeakPickerHiRes)
        - Precursor mass correction (Tool HiResPrecursorMassCorrector)
    - Filtering:
        - Large number of basic filters applicable to different types of data (e.g., remove identified spectra, filter MS2, extract m/z ranges, … in Tool FileFilter and IDFilter)
    - Identification:
        - Database search:
            - Peptides (Tool %SimpleSearchEngine and its classes - started simple but is, by now, rather complete peptide identification engine)
            - Protein-RNA cross-links (Tool %RNPxlSearch and its classes)
            - Protein-Protein cross-links (Tool OpenPepXL)
        - Spectral library search:
            - Tool SpecLibSearcher and its classes
        - DeNovo:
            - Tool CompNovoCID and its classes
    - Quantification:
        - Peptide Feature Detection:
            - Untargeted, label-free (Tools FeatureFinderCentroided, FeatureFinderMultiplex, and its classes)
            - ID-based label-free (Tool FeatureFinderIdentification “new”)
            - SILAC-labeling (Tool FeatureFinderMultiplex)
            - iTRAQ/TMT (Tool IsobaricAnalyzer)
            - Dynamically labeled (SIP) peptides (Tool MetaProSIP)
        - Retention Time Alignment:
            - Linear map alignment (Tool MapAlignerPoseClustering)
            - (Non-)linear map alignment (Tool MapAlignerIdentification “new”)
        - Peptide Feature linking (matching of features between runs):
            - fast, KD-tree based linking (Tool FeatureLinkerUnlabeledKD)
            - QT based clustering and linking (Tool FeatureLinkerUnlabeledQT)
        - Protein inference:
            - WIP (currently via third-party tool FIDO and Wrapper FidoAdapter)
        - Protein Quantification:
            - Tool ProteinQuantifier
        - Targeted data extraction: 
            - Analysis of data-independent acquisition or SWATH-MS data (Tool OpenSWATH)
        - Misc:
            - Theoretical spectra generators
<br>

- Metabolomics:
    - Quantification:
        - Small molecule feature detection:
            - Untargeted, label-free (Tool FeatureFinderMetabo)
        - Retention Time Alignment:
            - Linear map alignment (Tool MagAlignerPoseClustering)
        - Small molecule feature linking:
            - QT based clustering and linking (Tool FeatureLinkerUnlabeledQT)
            - fast, KD-tree based linking (Tool FeatureLinkerUnlabeledKD)
        - Adduct decharing:
            - Linear programming based determination of small molecule ion adducts and charges (Tool MetboliteAdductDecharger)
        - Targeted data extraction: 
            - Analysis of data-independent acquisition or SWATH-MS data (Tool OpenSWATH)
    - Identification:
        - Spectral library search:
            - Tool MetaboliteSpectralMatcher
        - Accurate mass search: 
            - Tool AccurateMassSearch 
<br>
General:
    - Mass decomposition algorithms
    - Isotope pattern generators
    - Quality control (Tools QCCalculator, QCExtractor) metrics and file format (QcML)

<br>
<table>
<caption id="multi_row">Directory structure of src folder (/src)</caption>
 <tr><th>Folder        <th>Description
 <tr><td>openms</td><td>Source code of core library</td></tr>
 <tr><td>openms_gui</td><td>Source code of GUI applications (e.g.: TOPPView)</td></tr>
 <tr><td>topp</td><td>Source code of (stable) OpenMS Tools</td></tr>
 <tr><td>util</td><td>Source code of (experimental) OpenMS Tools</td></tr>
 <tr><td>pyOpenMS</td><td>Source files providing the python bindings</td></tr>
 <tr><td>tests</td><td>Source code of class and tool tests</td></tr>
</table >
<br>
<table>
<caption id="multi_row">Directory strucrture of core library (/src/openms)</caption>
 <tr><th>Folder        <th>Description
 <tr><td>ANALYSIS</td><td>Source code of high-level analysis like PeakPicking, Quantitation, Identification, MapAlignment</td></tr>
 <tr><td>APPLICATIONS</td><td>Source code for tool base and handling</td></tr>
 <tr><td>CHEMISTRY</td><td>Source code dealing with Elements, Enzymes, Residues, Modifications, Isotope distibutions and amino acid sequences</td></tr>
 <tr><td>COMPARISON</td><td>Different scoring functions for clustering and spectra comparison</td></tr>
 <tr><td>CONCEPT</td><td>OpenMS concepts (types, macros, ...)</td></tr>
 <tr><td>DATASTRUCTURES</td><td>Auxiliary datastructures</td></tr>
 <tr><td>FILTERING</td><td>Filter</td></tr>
 <tr><td>FORMAT</td><td>Source code for I/O classes and file formats</td></tr>
 <tr><td>INTERFACES_IMPL</td><td>Interfaces (WIP)</td></tr>
 <tr><td>KERNEL</td<td>Core data structures</td></tr>
 <tr><td>MATH</td><td>Source code for math functions and classes</td></tr>
 <tr><td>METADATA</td><td>Source code for classes that capture metadata about a MS or HPLC-MS experiment</td></tr>
 <tr><td>SIMULATION</td><td>Source code of MS simulator</td></tr>
 <tr><td>SYSTEM</td><td>Source code for basic functionality (file system, stopwatch)</td></tr>
 <tr><td>TEST</td><td>Unit tests</td></tr>
 <tr><td>TRANSFORMATIONS</td><td>Feature detection</td></tr>
</table>
<br>

For the sake of completeness you will find a short list of the THIRDPARTY tools, which are integrated via wrappers into the OpenMS framework (usually called -Adapter e.g. SiriusAdapter)

Wrapper to thid-party tools:
    - Search Engines (MSGFPLUS, XTandem, OMSSA, Comet, MyriMatch)
    - Protein Inference (Fido)
    - Spectral Library Search (SpectraST)
    - Metabolite Identification (Sirius)
    - Score calibration and FDR calculation (Percolator)

@section tutorial_library_kernelclasses Kernel Classes

The %OpenMS kernel contains the data structures that store the actual MS data.

For storing the basic MS data (spectra, chromatograms, and full runs) %OpenMS uses
- Peaks (Peak1D and ChromatogramPeak) stored in
- MSSpectrum and MSChromatogram, which in turn can both be stored in an
- MSExperiment

For storing quantified peptides or analytes in single MS runs, %OpenMS uses so called feature maps.

The main data structures for quantitative information are
- Features (for quantitative information in MS1 maps)
- MRMFeatures (for quantitative information in XIC traces on MS1 and MS2 level)
    - which are both stored in a FeatureMap

To store quantified peptides or analytes over several MS runs, %OpenMS uses so called consensus maps.
- ConsensusFeatures are stored in a
- ConsensusMap

To store identified peptides %OpenMS has classes
- PeptideHit, which corresponds to a Peptide-Spectrum-Matching stored in a
- PeptideIdentification object (which is associated with a single spectrum)

<br>
<table>
<caption id="multi_row">Directory strucrture of core library (/src/openms)</caption>
 <tr><th>Stored Entity        <th>Class Name 
 <tr><td>Mass Peak (m/z + intensity)</td><td>Peak1D</td></tr>
 <tr><td>Elution Peak (rt + intensity)</td><td>ChromatogramPeak</td></tr>
 <tr><td>Spectrum of Mass Peaks</td><td>MSSpectrum</td></tr>
 <tr><td>Chromatogram of Elution Peaks</td><td>MSChromatogram</td></tr>
 <tr><td>Mass trace for small molecule detection</td><td>MassTrace</td></tr>
 <tr><td>Full MS run, containing both spectra and chromatograms</td><td>MSExperiment (alias PeakMap)</td></tr>
 <tr><td>Feature (isotopic pattern of eluting analyte)</td><td>Feature</td></tr>
 <tr><td>All features detected in an MS Run</td><td>FeatureMap</td></tr>
 <tr><td>Linked / Grouped feature (e.g., same Peptide quantified in several MS runs) </td><td>ConsensusFeature</td></tr>
 <tr><td>All grouped ConsensusFeatures of a multi-run experiment</td><td>ConsensusMap</td></tr>
 <tr><td>Peptide Spectrum Match</td><td>PeptideHit</td></tr>
 <tr><td>Identified Spectrum with one or several PSMs</td><td>PeptideIdentification</td></tr>
 <tr><td>Identified Protein</td><td>ProteinHit</td></tr>
</table>
<br>

@section tutorial_library_kernelclasses_peaks Peaks
%OpenMS provides one-, two- and d-dimensional data points, either with or without metadata attached to them.

TODO: Insert picture

One-dimensional data points:
One-dimensional data points (Peak1D) are the most important ones and used throughout %OpenMS. The two-dimensional and d-dimensional data points are needed rarely and used for special purposes only. 
Peak1D provides getter and setter methods to store the mass-to-charge ratio and intensity. 

Two-dimensional data points:
The two-dimensional data points store mass-to-charge, retention time and intensity. The most prominent example we will later take a closer look at is the Feature class, which stores a two-dimensional position (m/z and RT) and intensity of the eluting peptide or analyte. 

The base class of the two-dimensional data points is Peak2D. It provides the same interface as Peak1D and additional getter and setter methods for the retention time. RichPeak2D is derived from Peak2D and adds an interface for metadata. The Feature is derived from RichPeak2D and adds information about the convex hull of the feature, quality and so on.

For information on d-dimensional data points see the appendix.

@section tutorial_library_kernelclasses_spectra Spectra
The most important container for raw/profile data and centroided peaks is MSSpectrum. The elements of a MSSpectrum are peaks (Peak1D). In fact it is so common that it has its own typedef PeakSpectrum. MSSpectrum is derived from SpectrumSettings, a container for the metadata of a spectrum (e.g. precursor information). Here, only MS data handling is explained, SpectrumSettings is described in section meta data of a spectrum. In the following example (Tutorial_MSSpectrum.cpp) program, a MSSpectrum is filled with peaks, sorted according to mass-to-charge ratio and a selection of peak positions is displaOne-dimensional data points:
One-dimensional data points (Peak1D) are the most important ones and used throughout %OpenMS. The two-dimensional and d-dimensional data points are needed rarely and used for special purposes only. 
Peak1D provides getter and setter methods to store the mass-to-charge ratio and intensity. 

Two-dimensional data points:
The two-dimensional data points store mass-to-charge, retention time and intensity. The most prominent example we will later take a closer look at is the Feature class, which stores a two-dimensional position (m/z and RT) and intensity of the eluting peptide or analyte. 

The base class of the two-dimensional data points is Peak2D. It provides the same interface as Peak1D and additional getter and setter methods for the retention time. RichPeak2D is derived from Peak2D and adds an interface for metadata. The Feature is derived from RichPeak2D and adds information about the convex hull of the feature, quality and so on.

For information on d-dimensional data points see the appendix.

TODO: right code example

@example code_examples/Tutorial_MapAlignment.cpp 
In this example, we create MS1 spectrum at 1 minute and insert peaks with descending mass-to-charge ratios (for educational reasons). We sort the peaks according to ascending mass-to-charge ratio. Finally we print the peak positions of those peaks between 800 and 1000 Thomson. For printing all the peaks in the spectrum, we simply would have used the STL-conform methods begin() and end(). In addition to the iterator access, we can also directly access the peaks via vector indices (e.g. spectrum[0] is the first Peak1D object of the MSSpectrum). 

@section tutorial_library_kernelclasses_chrom  Chromatograms
The most important container for targeted analysis / XIC data is MSChromatogram. The elements of a MSChromatogram are chromatogram peaks (Peak1D). MSChromatogram is derived from ChromatogramSettings, a container for the metadata of a chromatogram (e.g. containing precursor and product information), similarly to SpectrumSettings. In the following example (Tutorial_MSChromatogram.cpp) program, a MSChromatogram is filled with chromatographic peaks, sorted according to retention time and a selection of peak positions is displayed. 

TODO: MSChromatogram.cpp

Since much of the functionality is shared between MSChromatogram and MSSpectrum, further examples can be gathered from the MSSpectrum section.

@section tutorial_library_kernelclasses_precursor  Precursor
The precursor data stored along with MS/MS spectra contains invaluable information for MS/MS analysis (e.g, m/z, charge, activation mode, collision energy). This information is stored in Precursor objects that can be retrieved from each spectrum. For a complete list of functions please see the Precursor class documentation.

TODO: Precursor.cpp

<br>
@section tutorial_library_kernelclasses_mrm MRMTransitionGroup
The targeted analysis of SRM or DIA (SWATH-MS) type of data requires a set of targeted assays as well as raw data chromatograms. The MRMTransitionGroup class allows users to map these two types of information and store them together with identified features conveniently in a single object. 

TODO: MRMTransitionGroup.cpp (?)

Note how the identifiers of the chromatograms and the assay information (ReactionMonitoringTransition) are matched so that downstream algorithms can utilize the meta-information stored in the assays for data analysis.

@section tutorial_library_kernelclasses_map   Maps
Although raw data maps, peak maps and feature maps are conceptually very similar they are stored in different data types. For raw data and peak maps, the default container is MSExperiment, which is an array of MSSpectrum instances. 
In contrast to raw data and peak maps, feature maps are not a collection of one-dimensional spectra, but an array of two-dimensional feature instances. The main data structure for feature maps is called FeatureMap.

Although MSExperiment and FeatureMap differ in the data they store, they also have things in common. Both store metadata that is valid for the whole map, i.e. sample description and instrument description. This data is stored in the common base class ExperimentalSettings.

@section tutorial_library_kernelclasses_mse  MSExperiment
MSExperiment contains ExperimentalSettings (metadata of the MS run) and a vector<MSSpectrum>. The one-dimensional spectrum MSSpectrum is derived from SpectrumSettings (metadata of a spectrum).

TODO: MSExperiment.cpp

@section tutorial_library_kernelclasses_fmap FeatureMap
FeatureMap, the container for features, is simply a vector<Feature>. Additionally, it is derived from ExperimentalSettings, to store the meta information. All peak and feature containers (MSSpectrum, MSExperiment, FeatureMap) are also derived from RangeManager. This class facilitates the handling of MS data ranges. It allows to calculate and store both the position range and the intensity range of the container.

TODO: FeautreMap.cpp






*/
